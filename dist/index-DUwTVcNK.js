var zs = Object.defineProperty;
var qs = ($, ee, te) => ee in $ ? zs($, ee, { enumerable: !0, configurable: !0, writable: !0, value: te }) : $[ee] = te;
var On = ($, ee, te) => (qs($, typeof ee != "symbol" ? ee + "" : ee, te), te), Er = ($, ee, te) => {
  if (!ee.has($))
    throw TypeError("Cannot " + te);
};
var Oe = ($, ee, te) => (Er($, ee, "read from private field"), te ? te.call($) : ee.get($)), Rt = ($, ee, te) => {
  if (ee.has($))
    throw TypeError("Cannot add the same private member more than once");
  ee instanceof WeakSet ? ee.add($) : ee.set($, te);
}, zt = ($, ee, te, ne) => (Er($, ee, "write to private field"), ne ? ne.call($, te) : ee.set($, te), te);
var Xn = ($, ee, te, ne) => ({
  set _(re) {
    zt($, ee, re, te);
  },
  get _() {
    return Oe($, ee, ne);
  }
}), Nt = ($, ee, te) => (Er($, ee, "access private method"), te);
import "./index.css";
import * as React from "react";
import React__default, { useState, useEffect, createContext, useReducer, forwardRef, useRef, useImperativeHandle, useCallback, useMemo, useContext, useLayoutEffect, Component, Children, isValidElement, cloneElement, memo } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default from "react-dom";
function _mergeNamespaces($, ee) {
  for (var te = 0; te < ee.length; te++) {
    const ne = ee[te];
    if (typeof ne != "string" && !Array.isArray(ne)) {
      for (const re in ne)
        if (re !== "default" && !(re in $)) {
          const se = Object.getOwnPropertyDescriptor(ne, re);
          se && Object.defineProperty($, re, se.get ? se : {
            enumerable: !0,
            get: () => ne[re]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty($, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs($) {
  return $ && $.__esModule && Object.prototype.hasOwnProperty.call($, "default") ? $.default : $;
}
function getAugmentedNamespace($) {
  if ($.__esModule)
    return $;
  var ee = $.default;
  if (typeof ee == "function") {
    var te = function ne() {
      return this instanceof ne ? Reflect.construct(ee, arguments, this.constructor) : ee.apply(this, arguments);
    };
    te.prototype = ee.prototype;
  } else
    te = {};
  return Object.defineProperty(te, "__esModule", { value: !0 }), Object.keys($).forEach(function(ne) {
    var re = Object.getOwnPropertyDescriptor($, ne);
    Object.defineProperty(te, ne, re.get ? re : {
      enumerable: !0,
      get: function() {
        return $[ne];
      }
    });
  }), te;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var $ = React__default, ee = Symbol.for("react.element"), te = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, re = $.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, se = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ie(oe, le, ue) {
    var de, fe = {}, pe = null, ye = null;
    ue !== void 0 && (pe = "" + ue), le.key !== void 0 && (pe = "" + le.key), le.ref !== void 0 && (ye = le.ref);
    for (de in le)
      ne.call(le, de) && !se.hasOwnProperty(de) && (fe[de] = le[de]);
    if (oe && oe.defaultProps)
      for (de in le = oe.defaultProps, le)
        fe[de] === void 0 && (fe[de] = le[de]);
    return { $$typeof: ee, type: oe, key: pe, ref: ye, props: fe, _owner: re.current };
  }
  return reactJsxRuntime_production_min.Fragment = te, reactJsxRuntime_production_min.jsx = ie, reactJsxRuntime_production_min.jsxs = ie, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var $ = React__default, ee = Symbol.for("react.element"), te = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), re = Symbol.for("react.strict_mode"), se = Symbol.for("react.profiler"), ie = Symbol.for("react.provider"), oe = Symbol.for("react.context"), le = Symbol.for("react.forward_ref"), ue = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), pe = Symbol.for("react.lazy"), ye = Symbol.for("react.offscreen"), me = Symbol.iterator, ve = "@@iterator";
    function ge(Ve) {
      if (Ve === null || typeof Ve != "object")
        return null;
      var Dt = me && Ve[me] || Ve[ve];
      return typeof Dt == "function" ? Dt : null;
    }
    var xe = $.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Ee(Ve) {
      {
        for (var Dt = arguments.length, Wt = new Array(Dt > 1 ? Dt - 1 : 0), Xt = 1; Xt < Dt; Xt++)
          Wt[Xt - 1] = arguments[Xt];
        Te("error", Ve, Wt);
      }
    }
    function Te(Ve, Dt, Wt) {
      {
        var Xt = xe.ReactDebugCurrentFrame, hn = Xt.getStackAddendum();
        hn !== "" && (Dt += "%s", Wt = Wt.concat([hn]));
        var rn = Wt.map(function(tn) {
          return String(tn);
        });
        rn.unshift("Warning: " + Dt), Function.prototype.apply.call(console[Ve], console, rn);
      }
    }
    var Se = !1, he = !1, Pe = !1, Ie = !1, De = !1, Ce;
    Ce = Symbol.for("react.module.reference");
    function Ne(Ve) {
      return !!(typeof Ve == "string" || typeof Ve == "function" || Ve === ne || Ve === se || De || Ve === re || Ve === ue || Ve === de || Ie || Ve === ye || Se || he || Pe || typeof Ve == "object" && Ve !== null && (Ve.$$typeof === pe || Ve.$$typeof === fe || Ve.$$typeof === ie || Ve.$$typeof === oe || Ve.$$typeof === le || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ve.$$typeof === Ce || Ve.getModuleId !== void 0));
    }
    function Me(Ve, Dt, Wt) {
      var Xt = Ve.displayName;
      if (Xt)
        return Xt;
      var hn = Dt.displayName || Dt.name || "";
      return hn !== "" ? Wt + "(" + hn + ")" : Wt;
    }
    function Be(Ve) {
      return Ve.displayName || "Context";
    }
    function We(Ve) {
      if (Ve == null)
        return null;
      if (typeof Ve.tag == "number" && Ee("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Ve == "function")
        return Ve.displayName || Ve.name || null;
      if (typeof Ve == "string")
        return Ve;
      switch (Ve) {
        case ne:
          return "Fragment";
        case te:
          return "Portal";
        case se:
          return "Profiler";
        case re:
          return "StrictMode";
        case ue:
          return "Suspense";
        case de:
          return "SuspenseList";
      }
      if (typeof Ve == "object")
        switch (Ve.$$typeof) {
          case oe:
            var Dt = Ve;
            return Be(Dt) + ".Consumer";
          case ie:
            var Wt = Ve;
            return Be(Wt._context) + ".Provider";
          case le:
            return Me(Ve, Ve.render, "ForwardRef");
          case fe:
            var Xt = Ve.displayName || null;
            return Xt !== null ? Xt : We(Ve.type) || "Memo";
          case pe: {
            var hn = Ve, rn = hn._payload, tn = hn._init;
            try {
              return We(tn(rn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Le = Object.assign, He = 0, Ge, Ze, Ue, Qe, Je, Ot, At;
    function ze() {
    }
    ze.__reactDisabledLog = !0;
    function we() {
      {
        if (He === 0) {
          Ge = console.log, Ze = console.info, Ue = console.warn, Qe = console.error, Je = console.group, Ot = console.groupCollapsed, At = console.groupEnd;
          var Ve = {
            configurable: !0,
            enumerable: !0,
            value: ze,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Ve,
            log: Ve,
            warn: Ve,
            error: Ve,
            group: Ve,
            groupCollapsed: Ve,
            groupEnd: Ve
          });
        }
        He++;
      }
    }
    function Ae() {
      {
        if (He--, He === 0) {
          var Ve = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Le({}, Ve, {
              value: Ge
            }),
            info: Le({}, Ve, {
              value: Ze
            }),
            warn: Le({}, Ve, {
              value: Ue
            }),
            error: Le({}, Ve, {
              value: Qe
            }),
            group: Le({}, Ve, {
              value: Je
            }),
            groupCollapsed: Le({}, Ve, {
              value: Ot
            }),
            groupEnd: Le({}, Ve, {
              value: At
            })
          });
        }
        He < 0 && Ee("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Re = xe.ReactCurrentDispatcher, je;
    function Fe(Ve, Dt, Wt) {
      {
        if (je === void 0)
          try {
            throw Error();
          } catch (hn) {
            var Xt = hn.stack.trim().match(/\n( *(at )?)/);
            je = Xt && Xt[1] || "";
          }
        return `
` + je + Ve;
      }
    }
    var $e = !1, qe;
    {
      var Ye = typeof WeakMap == "function" ? WeakMap : Map;
      qe = new Ye();
    }
    function Ke(Ve, Dt) {
      if (!Ve || $e)
        return "";
      {
        var Wt = qe.get(Ve);
        if (Wt !== void 0)
          return Wt;
      }
      var Xt;
      $e = !0;
      var hn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var rn;
      rn = Re.current, Re.current = null, we();
      try {
        if (Dt) {
          var tn = function() {
            throw Error();
          };
          if (Object.defineProperty(tn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(tn, []);
            } catch (jn) {
              Xt = jn;
            }
            Reflect.construct(Ve, [], tn);
          } else {
            try {
              tn.call();
            } catch (jn) {
              Xt = jn;
            }
            Ve.call(tn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (jn) {
            Xt = jn;
          }
          Ve();
        }
      } catch (jn) {
        if (jn && Xt && typeof jn.stack == "string") {
          for (var fn = jn.stack.split(`
`), Sn = Xt.stack.split(`
`), Cn = fn.length - 1, An = Sn.length - 1; Cn >= 1 && An >= 0 && fn[Cn] !== Sn[An]; )
            An--;
          for (; Cn >= 1 && An >= 0; Cn--, An--)
            if (fn[Cn] !== Sn[An]) {
              if (Cn !== 1 || An !== 1)
                do
                  if (Cn--, An--, An < 0 || fn[Cn] !== Sn[An]) {
                    var Nn = `
` + fn[Cn].replace(" at new ", " at ");
                    return Ve.displayName && Nn.includes("<anonymous>") && (Nn = Nn.replace("<anonymous>", Ve.displayName)), typeof Ve == "function" && qe.set(Ve, Nn), Nn;
                  }
                while (Cn >= 1 && An >= 0);
              break;
            }
        }
      } finally {
        $e = !1, Re.current = rn, Ae(), Error.prepareStackTrace = hn;
      }
      var Ln = Ve ? Ve.displayName || Ve.name : "", Fn = Ln ? Fe(Ln) : "";
      return typeof Ve == "function" && qe.set(Ve, Fn), Fn;
    }
    function Tt(Ve, Dt, Wt) {
      return Ke(Ve, !1);
    }
    function pt(Ve) {
      var Dt = Ve.prototype;
      return !!(Dt && Dt.isReactComponent);
    }
    function Bt(Ve, Dt, Wt) {
      if (Ve == null)
        return "";
      if (typeof Ve == "function")
        return Ke(Ve, pt(Ve));
      if (typeof Ve == "string")
        return Fe(Ve);
      switch (Ve) {
        case ue:
          return Fe("Suspense");
        case de:
          return Fe("SuspenseList");
      }
      if (typeof Ve == "object")
        switch (Ve.$$typeof) {
          case le:
            return Tt(Ve.render);
          case fe:
            return Bt(Ve.type, Dt, Wt);
          case pe: {
            var Xt = Ve, hn = Xt._payload, rn = Xt._init;
            try {
              return Bt(rn(hn), Dt, Wt);
            } catch {
            }
          }
        }
      return "";
    }
    var Vt = Object.prototype.hasOwnProperty, qt = {}, nn = xe.ReactDebugCurrentFrame;
    function mn(Ve) {
      if (Ve) {
        var Dt = Ve._owner, Wt = Bt(Ve.type, Ve._source, Dt ? Dt.type : null);
        nn.setExtraStackFrame(Wt);
      } else
        nn.setExtraStackFrame(null);
    }
    function en(Ve, Dt, Wt, Xt, hn) {
      {
        var rn = Function.call.bind(Vt);
        for (var tn in Ve)
          if (rn(Ve, tn)) {
            var fn = void 0;
            try {
              if (typeof Ve[tn] != "function") {
                var Sn = Error((Xt || "React class") + ": " + Wt + " type `" + tn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Ve[tn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Sn.name = "Invariant Violation", Sn;
              }
              fn = Ve[tn](Dt, tn, Xt, Wt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Cn) {
              fn = Cn;
            }
            fn && !(fn instanceof Error) && (mn(hn), Ee("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Xt || "React class", Wt, tn, typeof fn), mn(null)), fn instanceof Error && !(fn.message in qt) && (qt[fn.message] = !0, mn(hn), Ee("Failed %s type: %s", Wt, fn.message), mn(null));
          }
      }
    }
    var pn = Array.isArray;
    function Yt(Ve) {
      return pn(Ve);
    }
    function Ut(Ve) {
      {
        var Dt = typeof Symbol == "function" && Symbol.toStringTag, Wt = Dt && Ve[Symbol.toStringTag] || Ve.constructor.name || "Object";
        return Wt;
      }
    }
    function jt(Ve) {
      try {
        return Gt(Ve), !1;
      } catch {
        return !0;
      }
    }
    function Gt(Ve) {
      return "" + Ve;
    }
    function ln(Ve) {
      if (jt(Ve))
        return Ee("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ut(Ve)), Gt(Ve);
    }
    var sn = xe.ReactCurrentOwner, _n = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, un, En, wn;
    wn = {};
    function Tn(Ve) {
      if (Vt.call(Ve, "ref")) {
        var Dt = Object.getOwnPropertyDescriptor(Ve, "ref").get;
        if (Dt && Dt.isReactWarning)
          return !1;
      }
      return Ve.ref !== void 0;
    }
    function Pn(Ve) {
      if (Vt.call(Ve, "key")) {
        var Dt = Object.getOwnPropertyDescriptor(Ve, "key").get;
        if (Dt && Dt.isReactWarning)
          return !1;
      }
      return Ve.key !== void 0;
    }
    function Rn(Ve, Dt) {
      if (typeof Ve.ref == "string" && sn.current && Dt && sn.current.stateNode !== Dt) {
        var Wt = We(sn.current.type);
        wn[Wt] || (Ee('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', We(sn.current.type), Ve.ref), wn[Wt] = !0);
      }
    }
    function Kt(Ve, Dt) {
      {
        var Wt = function() {
          un || (un = !0, Ee("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Dt));
        };
        Wt.isReactWarning = !0, Object.defineProperty(Ve, "key", {
          get: Wt,
          configurable: !0
        });
      }
    }
    function Ht(Ve, Dt) {
      {
        var Wt = function() {
          En || (En = !0, Ee("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Dt));
        };
        Wt.isReactWarning = !0, Object.defineProperty(Ve, "ref", {
          get: Wt,
          configurable: !0
        });
      }
    }
    var Lt = function(Ve, Dt, Wt, Xt, hn, rn, tn) {
      var fn = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: ee,
        // Built-in properties that belong on the element
        type: Ve,
        key: Dt,
        ref: Wt,
        props: tn,
        // Record the component responsible for creating this element.
        _owner: rn
      };
      return fn._store = {}, Object.defineProperty(fn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(fn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Xt
      }), Object.defineProperty(fn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: hn
      }), Object.freeze && (Object.freeze(fn.props), Object.freeze(fn)), fn;
    };
    function Zt(Ve, Dt, Wt, Xt, hn) {
      {
        var rn, tn = {}, fn = null, Sn = null;
        Wt !== void 0 && (ln(Wt), fn = "" + Wt), Pn(Dt) && (ln(Dt.key), fn = "" + Dt.key), Tn(Dt) && (Sn = Dt.ref, Rn(Dt, hn));
        for (rn in Dt)
          Vt.call(Dt, rn) && !_n.hasOwnProperty(rn) && (tn[rn] = Dt[rn]);
        if (Ve && Ve.defaultProps) {
          var Cn = Ve.defaultProps;
          for (rn in Cn)
            tn[rn] === void 0 && (tn[rn] = Cn[rn]);
        }
        if (fn || Sn) {
          var An = typeof Ve == "function" ? Ve.displayName || Ve.name || "Unknown" : Ve;
          fn && Kt(tn, An), Sn && Ht(tn, An);
        }
        return Lt(Ve, fn, Sn, hn, Xt, sn.current, tn);
      }
    }
    var Jt = xe.ReactCurrentOwner, Dn = xe.ReactDebugCurrentFrame;
    function kn(Ve) {
      if (Ve) {
        var Dt = Ve._owner, Wt = Bt(Ve.type, Ve._source, Dt ? Dt.type : null);
        Dn.setExtraStackFrame(Wt);
      } else
        Dn.setExtraStackFrame(null);
    }
    var $t;
    $t = !1;
    function on(Ve) {
      return typeof Ve == "object" && Ve !== null && Ve.$$typeof === ee;
    }
    function gn() {
      {
        if (Jt.current) {
          var Ve = We(Jt.current.type);
          if (Ve)
            return `

Check the render method of \`` + Ve + "`.";
        }
        return "";
      }
    }
    function dn(Ve) {
      {
        if (Ve !== void 0) {
          var Dt = Ve.fileName.replace(/^.*[\\\/]/, ""), Wt = Ve.lineNumber;
          return `

Check your code at ` + Dt + ":" + Wt + ".";
        }
        return "";
      }
    }
    var vn = {};
    function xn(Ve) {
      {
        var Dt = gn();
        if (!Dt) {
          var Wt = typeof Ve == "string" ? Ve : Ve.displayName || Ve.name;
          Wt && (Dt = `

Check the top-level render call using <` + Wt + ">.");
        }
        return Dt;
      }
    }
    function In(Ve, Dt) {
      {
        if (!Ve._store || Ve._store.validated || Ve.key != null)
          return;
        Ve._store.validated = !0;
        var Wt = xn(Dt);
        if (vn[Wt])
          return;
        vn[Wt] = !0;
        var Xt = "";
        Ve && Ve._owner && Ve._owner !== Jt.current && (Xt = " It was passed a child from " + We(Ve._owner.type) + "."), kn(Ve), Ee('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Wt, Xt), kn(null);
      }
    }
    function Qt(Ve, Dt) {
      {
        if (typeof Ve != "object")
          return;
        if (Yt(Ve))
          for (var Wt = 0; Wt < Ve.length; Wt++) {
            var Xt = Ve[Wt];
            on(Xt) && In(Xt, Dt);
          }
        else if (on(Ve))
          Ve._store && (Ve._store.validated = !0);
        else if (Ve) {
          var hn = ge(Ve);
          if (typeof hn == "function" && hn !== Ve.entries)
            for (var rn = hn.call(Ve), tn; !(tn = rn.next()).done; )
              on(tn.value) && In(tn.value, Dt);
        }
      }
    }
    function Mn(Ve) {
      {
        var Dt = Ve.type;
        if (Dt == null || typeof Dt == "string")
          return;
        var Wt;
        if (typeof Dt == "function")
          Wt = Dt.propTypes;
        else if (typeof Dt == "object" && (Dt.$$typeof === le || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Dt.$$typeof === fe))
          Wt = Dt.propTypes;
        else
          return;
        if (Wt) {
          var Xt = We(Dt);
          en(Wt, Ve.props, "prop", Xt, Ve);
        } else if (Dt.PropTypes !== void 0 && !$t) {
          $t = !0;
          var hn = We(Dt);
          Ee("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", hn || "Unknown");
        }
        typeof Dt.getDefaultProps == "function" && !Dt.getDefaultProps.isReactClassApproved && Ee("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yn(Ve) {
      {
        for (var Dt = Object.keys(Ve.props), Wt = 0; Wt < Dt.length; Wt++) {
          var Xt = Dt[Wt];
          if (Xt !== "children" && Xt !== "key") {
            kn(Ve), Ee("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Xt), kn(null);
            break;
          }
        }
        Ve.ref !== null && (kn(Ve), Ee("Invalid attribute `ref` supplied to `React.Fragment`."), kn(null));
      }
    }
    var xt = {};
    function ke(Ve, Dt, Wt, Xt, hn, rn) {
      {
        var tn = Ne(Ve);
        if (!tn) {
          var fn = "";
          (Ve === void 0 || typeof Ve == "object" && Ve !== null && Object.keys(Ve).length === 0) && (fn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Sn = dn(hn);
          Sn ? fn += Sn : fn += gn();
          var Cn;
          Ve === null ? Cn = "null" : Yt(Ve) ? Cn = "array" : Ve !== void 0 && Ve.$$typeof === ee ? (Cn = "<" + (We(Ve.type) || "Unknown") + " />", fn = " Did you accidentally export a JSX literal instead of a component?") : Cn = typeof Ve, Ee("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Cn, fn);
        }
        var An = Zt(Ve, Dt, Wt, hn, rn);
        if (An == null)
          return An;
        if (tn) {
          var Nn = Dt.children;
          if (Nn !== void 0)
            if (Xt)
              if (Yt(Nn)) {
                for (var Ln = 0; Ln < Nn.length; Ln++)
                  Qt(Nn[Ln], Ve);
                Object.freeze && Object.freeze(Nn);
              } else
                Ee("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Qt(Nn, Ve);
        }
        if (Vt.call(Dt, "key")) {
          var Fn = We(Ve), jn = Object.keys(Dt).filter(function(Hs) {
            return Hs !== "key";
          }), $n = jn.length > 0 ? "{key: someKey, " + jn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!xt[Fn + $n]) {
            var rr = jn.length > 0 ? "{" + jn.join(": ..., ") + ": ...}" : "{}";
            Ee(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, $n, Fn, rr, Fn), xt[Fn + $n] = !0;
          }
        }
        return Ve === ne ? yn(An) : Mn(An), An;
      }
    }
    function Xe(Ve, Dt, Wt) {
      return ke(Ve, Dt, Wt, !0);
    }
    function Et(Ve, Dt, Wt) {
      return ke(Ve, Dt, Wt, !1);
    }
    var Mt = Et, Ft = Xe;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = Mt, reactJsxRuntime_development.jsxs = Ft;
  }()), reactJsxRuntime_development;
}
process.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
const GlobalClientProviderContext = React__default.createContext({
  lmFeedclient: null
}), UserProviderContext = React__default.createContext({
  currentUser: null,
  logoutUser: null,
  currentCommunity: null
});
var axios$1 = { exports: {} }, bind$2 = function(ee, te) {
  return function() {
    for (var re = new Array(arguments.length), se = 0; se < re.length; se++)
      re[se] = arguments[se];
    return ee.apply(te, re);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray($) {
  return toString.call($) === "[object Array]";
}
function isUndefined($) {
  return typeof $ > "u";
}
function isBuffer($) {
  return $ !== null && !isUndefined($) && $.constructor !== null && !isUndefined($.constructor) && typeof $.constructor.isBuffer == "function" && $.constructor.isBuffer($);
}
function isArrayBuffer$2($) {
  return toString.call($) === "[object ArrayBuffer]";
}
function isFormData($) {
  return typeof FormData < "u" && $ instanceof FormData;
}
function isArrayBufferView($) {
  var ee;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ee = ArrayBuffer.isView($) : ee = $ && $.buffer && $.buffer instanceof ArrayBuffer, ee;
}
function isString$1($) {
  return typeof $ == "string";
}
function isNumber($) {
  return typeof $ == "number";
}
function isObject$1($) {
  return $ !== null && typeof $ == "object";
}
function isPlainObject$1($) {
  if (toString.call($) !== "[object Object]")
    return !1;
  var ee = Object.getPrototypeOf($);
  return ee === null || ee === Object.prototype;
}
function isDate($) {
  return toString.call($) === "[object Date]";
}
function isFile$1($) {
  return toString.call($) === "[object File]";
}
function isBlob$1($) {
  return toString.call($) === "[object Blob]";
}
function isFunction($) {
  return toString.call($) === "[object Function]";
}
function isStream($) {
  return isObject$1($) && isFunction($.pipe);
}
function isURLSearchParams($) {
  return typeof URLSearchParams < "u" && $ instanceof URLSearchParams;
}
function trim$1($) {
  return $.trim ? $.trim() : $.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach($, ee) {
  if (!($ === null || typeof $ > "u"))
    if (typeof $ != "object" && ($ = [$]), isArray($))
      for (var te = 0, ne = $.length; te < ne; te++)
        ee.call(null, $[te], te, $);
    else
      for (var re in $)
        Object.prototype.hasOwnProperty.call($, re) && ee.call(null, $[re], re, $);
}
function merge$2() {
  var $ = {};
  function ee(re, se) {
    isPlainObject$1($[se]) && isPlainObject$1(re) ? $[se] = merge$2($[se], re) : isPlainObject$1(re) ? $[se] = merge$2({}, re) : isArray(re) ? $[se] = re.slice() : $[se] = re;
  }
  for (var te = 0, ne = arguments.length; te < ne; te++)
    forEach(arguments[te], ee);
  return $;
}
function extend($, ee, te) {
  return forEach(ee, function(re, se) {
    te && typeof re == "function" ? $[se] = bind$1(re, te) : $[se] = re;
  }), $;
}
function stripBOM($) {
  return $.charCodeAt(0) === 65279 && ($ = $.slice(1)), $;
}
var utils$8 = {
  isArray,
  isArrayBuffer: isArrayBuffer$2,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isUndefined,
  isDate,
  isFile: isFile$1,
  isBlob: isBlob$1,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$2,
  extend,
  trim: trim$1,
  stripBOM
}, utils$7 = utils$8;
function encode($) {
  return encodeURIComponent($).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function(ee, te, ne) {
  if (!te)
    return ee;
  var re;
  if (ne)
    re = ne(te);
  else if (utils$7.isURLSearchParams(te))
    re = te.toString();
  else {
    var se = [];
    utils$7.forEach(te, function(le, ue) {
      le === null || typeof le > "u" || (utils$7.isArray(le) ? ue = ue + "[]" : le = [le], utils$7.forEach(le, function(fe) {
        utils$7.isDate(fe) ? fe = fe.toISOString() : utils$7.isObject(fe) && (fe = JSON.stringify(fe)), se.push(encode(ue) + "=" + encode(fe));
      }));
    }), re = se.join("&");
  }
  if (re) {
    var ie = ee.indexOf("#");
    ie !== -1 && (ee = ee.slice(0, ie)), ee += (ee.indexOf("?") === -1 ? "?" : "&") + re;
  }
  return ee;
}, utils$6 = utils$8;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function(ee, te, ne) {
  return this.handlers.push({
    fulfilled: ee,
    rejected: te,
    synchronous: ne ? ne.synchronous : !1,
    runWhen: ne ? ne.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function(ee) {
  this.handlers[ee] && (this.handlers[ee] = null);
};
InterceptorManager$1.prototype.forEach = function(ee) {
  utils$6.forEach(this.handlers, function(ne) {
    ne !== null && ee(ne);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$5 = utils$8, normalizeHeaderName = function(ee, te) {
  utils$5.forEach(ee, function(re, se) {
    se !== te && se.toUpperCase() === te.toUpperCase() && (ee[te] = re, delete ee[se]);
  });
}, enhanceError = function(ee, te, ne, re, se) {
  return ee.config = te, ne && (ee.code = ne), ee.request = re, ee.response = se, ee.isAxiosError = !0, ee.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, ee;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var $ = enhanceError;
  return createError = function(te, ne, re, se, ie) {
    var oe = new Error(te);
    return $(oe, ne, re, se, ie);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var $ = requireCreateError();
  return settle = function(te, ne, re) {
    var se = re.config.validateStatus;
    !re.status || !se || se(re.status) ? te(re) : ne($(
      "Request failed with status code " + re.status,
      re.config,
      null,
      re.request,
      re
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var $ = utils$8;
  return cookies = $.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(ne, re, se, ie, oe, le) {
          var ue = [];
          ue.push(ne + "=" + encodeURIComponent(re)), $.isNumber(se) && ue.push("expires=" + new Date(se).toGMTString()), $.isString(ie) && ue.push("path=" + ie), $.isString(oe) && ue.push("domain=" + oe), le === !0 && ue.push("secure"), document.cookie = ue.join("; ");
        },
        read: function(ne) {
          var re = document.cookie.match(new RegExp("(^|;\\s*)(" + ne + ")=([^;]*)"));
          return re ? decodeURIComponent(re[3]) : null;
        },
        remove: function(ne) {
          this.write(ne, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(ee) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(ee);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(ee, te) {
    return te ? ee.replace(/\/+$/, "") + "/" + te.replace(/^\/+/, "") : ee;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var $ = requireIsAbsoluteURL(), ee = requireCombineURLs();
  return buildFullPath = function(ne, re) {
    return ne && !$(re) ? ee(ne, re) : re;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var $ = utils$8, ee = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(ne) {
    var re = {}, se, ie, oe;
    return ne && $.forEach(ne.split(`
`), function(ue) {
      if (oe = ue.indexOf(":"), se = $.trim(ue.substr(0, oe)).toLowerCase(), ie = $.trim(ue.substr(oe + 1)), se) {
        if (re[se] && ee.indexOf(se) >= 0)
          return;
        se === "set-cookie" ? re[se] = (re[se] ? re[se] : []).concat([ie]) : re[se] = re[se] ? re[se] + ", " + ie : ie;
      }
    }), re;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var $ = utils$8;
  return isURLSameOrigin = $.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var te = /(msie|trident)/i.test(navigator.userAgent), ne = document.createElement("a"), re;
      function se(ie) {
        var oe = ie;
        return te && (ne.setAttribute("href", oe), oe = ne.href), ne.setAttribute("href", oe), {
          href: ne.href,
          protocol: ne.protocol ? ne.protocol.replace(/:$/, "") : "",
          host: ne.host,
          search: ne.search ? ne.search.replace(/^\?/, "") : "",
          hash: ne.hash ? ne.hash.replace(/^#/, "") : "",
          hostname: ne.hostname,
          port: ne.port,
          pathname: ne.pathname.charAt(0) === "/" ? ne.pathname : "/" + ne.pathname
        };
      }
      return re = se(window.location.href), function(oe) {
        var le = $.isString(oe) ? se(oe) : oe;
        return le.protocol === re.protocol && le.host === re.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function $(ee) {
    this.message = ee;
  }
  return $.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, $.prototype.__CANCEL__ = !0, Cancel_1 = $, Cancel_1;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var $ = utils$8, ee = requireSettle(), te = requireCookies(), ne = buildURL$1, re = requireBuildFullPath(), se = requireParseHeaders(), ie = requireIsURLSameOrigin(), oe = requireCreateError(), le = requireDefaults(), ue = requireCancel();
  return xhr = function(fe) {
    return new Promise(function(ye, me) {
      var ve = fe.data, ge = fe.headers, xe = fe.responseType, Ee;
      function Te() {
        fe.cancelToken && fe.cancelToken.unsubscribe(Ee), fe.signal && fe.signal.removeEventListener("abort", Ee);
      }
      $.isFormData(ve) && delete ge["Content-Type"];
      var Se = new XMLHttpRequest();
      if (fe.auth) {
        var he = fe.auth.username || "", Pe = fe.auth.password ? unescape(encodeURIComponent(fe.auth.password)) : "";
        ge.Authorization = "Basic " + btoa(he + ":" + Pe);
      }
      var Ie = re(fe.baseURL, fe.url);
      Se.open(fe.method.toUpperCase(), ne(Ie, fe.params, fe.paramsSerializer), !0), Se.timeout = fe.timeout;
      function De() {
        if (Se) {
          var Ne = "getAllResponseHeaders" in Se ? se(Se.getAllResponseHeaders()) : null, Me = !xe || xe === "text" || xe === "json" ? Se.responseText : Se.response, Be = {
            data: Me,
            status: Se.status,
            statusText: Se.statusText,
            headers: Ne,
            config: fe,
            request: Se
          };
          ee(function(Le) {
            ye(Le), Te();
          }, function(Le) {
            me(Le), Te();
          }, Be), Se = null;
        }
      }
      if ("onloadend" in Se ? Se.onloadend = De : Se.onreadystatechange = function() {
        !Se || Se.readyState !== 4 || Se.status === 0 && !(Se.responseURL && Se.responseURL.indexOf("file:") === 0) || setTimeout(De);
      }, Se.onabort = function() {
        Se && (me(oe("Request aborted", fe, "ECONNABORTED", Se)), Se = null);
      }, Se.onerror = function() {
        me(oe("Network Error", fe, null, Se)), Se = null;
      }, Se.ontimeout = function() {
        var Me = "timeout of " + fe.timeout + "ms exceeded", Be = fe.transitional || le.transitional;
        fe.timeoutErrorMessage && (Me = fe.timeoutErrorMessage), me(oe(
          Me,
          fe,
          Be.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          Se
        )), Se = null;
      }, $.isStandardBrowserEnv()) {
        var Ce = (fe.withCredentials || ie(Ie)) && fe.xsrfCookieName ? te.read(fe.xsrfCookieName) : void 0;
        Ce && (ge[fe.xsrfHeaderName] = Ce);
      }
      "setRequestHeader" in Se && $.forEach(ge, function(Me, Be) {
        typeof ve > "u" && Be.toLowerCase() === "content-type" ? delete ge[Be] : Se.setRequestHeader(Be, Me);
      }), $.isUndefined(fe.withCredentials) || (Se.withCredentials = !!fe.withCredentials), xe && xe !== "json" && (Se.responseType = fe.responseType), typeof fe.onDownloadProgress == "function" && Se.addEventListener("progress", fe.onDownloadProgress), typeof fe.onUploadProgress == "function" && Se.upload && Se.upload.addEventListener("progress", fe.onUploadProgress), (fe.cancelToken || fe.signal) && (Ee = function(Ne) {
        Se && (me(!Ne || Ne && Ne.type ? new ue("canceled") : Ne), Se.abort(), Se = null);
      }, fe.cancelToken && fe.cancelToken.subscribe(Ee), fe.signal && (fe.signal.aborted ? Ee() : fe.signal.addEventListener("abort", Ee))), ve || (ve = null), Se.send(ve);
    });
  }, xhr;
}
var defaults_1, hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var $ = utils$8, ee = normalizeHeaderName, te = enhanceError, ne = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function re(le, ue) {
    !$.isUndefined(le) && $.isUndefined(le["Content-Type"]) && (le["Content-Type"] = ue);
  }
  function se() {
    var le;
    return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (le = requireXhr()), le;
  }
  function ie(le, ue, de) {
    if ($.isString(le))
      try {
        return (ue || JSON.parse)(le), $.trim(le);
      } catch (fe) {
        if (fe.name !== "SyntaxError")
          throw fe;
      }
    return (de || JSON.stringify)(le);
  }
  var oe = {
    transitional: {
      silentJSONParsing: !0,
      forcedJSONParsing: !0,
      clarifyTimeoutError: !1
    },
    adapter: se(),
    transformRequest: [function(ue, de) {
      return ee(de, "Accept"), ee(de, "Content-Type"), $.isFormData(ue) || $.isArrayBuffer(ue) || $.isBuffer(ue) || $.isStream(ue) || $.isFile(ue) || $.isBlob(ue) ? ue : $.isArrayBufferView(ue) ? ue.buffer : $.isURLSearchParams(ue) ? (re(de, "application/x-www-form-urlencoded;charset=utf-8"), ue.toString()) : $.isObject(ue) || de && de["Content-Type"] === "application/json" ? (re(de, "application/json"), ie(ue)) : ue;
    }],
    transformResponse: [function(ue) {
      var de = this.transitional || oe.transitional, fe = de && de.silentJSONParsing, pe = de && de.forcedJSONParsing, ye = !fe && this.responseType === "json";
      if (ye || pe && $.isString(ue) && ue.length)
        try {
          return JSON.parse(ue);
        } catch (me) {
          if (ye)
            throw me.name === "SyntaxError" ? te(me, this, "E_JSON_PARSE") : me;
        }
      return ue;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function(ue) {
      return ue >= 200 && ue < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*"
      }
    }
  };
  return $.forEach(["delete", "get", "head"], function(ue) {
    oe.headers[ue] = {};
  }), $.forEach(["post", "put", "patch"], function(ue) {
    oe.headers[ue] = $.merge(ne);
  }), defaults_1 = oe, defaults_1;
}
var utils$4 = utils$8, defaults$2 = requireDefaults(), transformData$1 = function(ee, te, ne) {
  var re = this || defaults$2;
  return utils$4.forEach(ne, function(ie) {
    ee = ie.call(re, ee, te);
  }), ee;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(ee) {
    return !!(ee && ee.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$8, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = requireDefaults(), Cancel = requireCancel();
function throwIfCancellationRequested($) {
  if ($.cancelToken && $.cancelToken.throwIfRequested(), $.signal && $.signal.aborted)
    throw new Cancel("canceled");
}
var dispatchRequest$1 = function(ee) {
  throwIfCancellationRequested(ee), ee.headers = ee.headers || {}, ee.data = transformData.call(
    ee,
    ee.data,
    ee.headers,
    ee.transformRequest
  ), ee.headers = utils$3.merge(
    ee.headers.common || {},
    ee.headers[ee.method] || {},
    ee.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(re) {
      delete ee.headers[re];
    }
  );
  var te = ee.adapter || defaults$1.adapter;
  return te(ee).then(function(re) {
    return throwIfCancellationRequested(ee), re.data = transformData.call(
      ee,
      re.data,
      re.headers,
      ee.transformResponse
    ), re;
  }, function(re) {
    return isCancel(re) || (throwIfCancellationRequested(ee), re && re.response && (re.response.data = transformData.call(
      ee,
      re.response.data,
      re.response.headers,
      ee.transformResponse
    ))), Promise.reject(re);
  });
}, utils$2 = utils$8, mergeConfig$2 = function(ee, te) {
  te = te || {};
  var ne = {};
  function re(de, fe) {
    return utils$2.isPlainObject(de) && utils$2.isPlainObject(fe) ? utils$2.merge(de, fe) : utils$2.isPlainObject(fe) ? utils$2.merge({}, fe) : utils$2.isArray(fe) ? fe.slice() : fe;
  }
  function se(de) {
    if (utils$2.isUndefined(te[de])) {
      if (!utils$2.isUndefined(ee[de]))
        return re(void 0, ee[de]);
    } else
      return re(ee[de], te[de]);
  }
  function ie(de) {
    if (!utils$2.isUndefined(te[de]))
      return re(void 0, te[de]);
  }
  function oe(de) {
    if (utils$2.isUndefined(te[de])) {
      if (!utils$2.isUndefined(ee[de]))
        return re(void 0, ee[de]);
    } else
      return re(void 0, te[de]);
  }
  function le(de) {
    if (de in te)
      return re(ee[de], te[de]);
    if (de in ee)
      return re(void 0, ee[de]);
  }
  var ue = {
    url: ie,
    method: ie,
    data: ie,
    baseURL: oe,
    transformRequest: oe,
    transformResponse: oe,
    paramsSerializer: oe,
    timeout: oe,
    timeoutMessage: oe,
    withCredentials: oe,
    adapter: oe,
    responseType: oe,
    xsrfCookieName: oe,
    xsrfHeaderName: oe,
    onUploadProgress: oe,
    onDownloadProgress: oe,
    decompress: oe,
    maxContentLength: oe,
    maxBodyLength: oe,
    transport: oe,
    httpAgent: oe,
    httpsAgent: oe,
    cancelToken: oe,
    socketPath: oe,
    responseEncoding: oe,
    validateStatus: le
  };
  return utils$2.forEach(Object.keys(ee).concat(Object.keys(te)), function(fe) {
    var pe = ue[fe] || se, ye = pe(fe);
    utils$2.isUndefined(ye) && pe !== le || (ne[fe] = ye);
  }), ne;
}, data, hasRequiredData;
function requireData() {
  return hasRequiredData || (hasRequiredData = 1, data = {
    version: "0.22.0"
  }), data;
}
var VERSION = requireData().version, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function($, ee) {
  validators$1[$] = function(ne) {
    return typeof ne === $ || "a" + (ee < 1 ? "n " : " ") + $;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function(ee, te, ne) {
  function re(se, ie) {
    return "[Axios v" + VERSION + "] Transitional option '" + se + "'" + ie + (ne ? ". " + ne : "");
  }
  return function(se, ie, oe) {
    if (ee === !1)
      throw new Error(re(ie, " has been removed" + (te ? " in " + te : "")));
    return te && !deprecatedWarnings[ie] && (deprecatedWarnings[ie] = !0, console.warn(
      re(
        ie,
        " has been deprecated since v" + te + " and will be removed in the near future"
      )
    )), ee ? ee(se, ie, oe) : !0;
  };
};
function assertOptions($, ee, te) {
  if (typeof $ != "object")
    throw new TypeError("options must be an object");
  for (var ne = Object.keys($), re = ne.length; re-- > 0; ) {
    var se = ne[re], ie = ee[se];
    if (ie) {
      var oe = $[se], le = oe === void 0 || ie(oe, se, $);
      if (le !== !0)
        throw new TypeError("option " + se + " must be " + le);
      continue;
    }
    if (te !== !0)
      throw Error("Unknown option " + se);
  }
}
var validator$5 = {
  assertOptions,
  validators: validators$1
}, utils$1 = utils$8, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator$4 = validator$5, validators = validator$4.validators;
function Axios$1($) {
  this.defaults = $, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function(ee) {
  typeof ee == "string" ? (ee = arguments[1] || {}, ee.url = arguments[0]) : ee = ee || {}, ee = mergeConfig$1(this.defaults, ee), ee.method ? ee.method = ee.method.toLowerCase() : this.defaults.method ? ee.method = this.defaults.method.toLowerCase() : ee.method = "get";
  var te = ee.transitional;
  te !== void 0 && validator$4.assertOptions(te, {
    silentJSONParsing: validators.transitional(validators.boolean),
    forcedJSONParsing: validators.transitional(validators.boolean),
    clarifyTimeoutError: validators.transitional(validators.boolean)
  }, !1);
  var ne = [], re = !0;
  this.interceptors.request.forEach(function(pe) {
    typeof pe.runWhen == "function" && pe.runWhen(ee) === !1 || (re = re && pe.synchronous, ne.unshift(pe.fulfilled, pe.rejected));
  });
  var se = [];
  this.interceptors.response.forEach(function(pe) {
    se.push(pe.fulfilled, pe.rejected);
  });
  var ie;
  if (!re) {
    var oe = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(oe, ne), oe = oe.concat(se), ie = Promise.resolve(ee); oe.length; )
      ie = ie.then(oe.shift(), oe.shift());
    return ie;
  }
  for (var le = ee; ne.length; ) {
    var ue = ne.shift(), de = ne.shift();
    try {
      le = ue(le);
    } catch (fe) {
      de(fe);
      break;
    }
  }
  try {
    ie = dispatchRequest(le);
  } catch (fe) {
    return Promise.reject(fe);
  }
  for (; se.length; )
    ie = ie.then(se.shift(), se.shift());
  return ie;
};
Axios$1.prototype.getUri = function(ee) {
  return ee = mergeConfig$1(this.defaults, ee), buildURL(ee.url, ee.params, ee.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function(ee) {
  Axios$1.prototype[ee] = function(te, ne) {
    return this.request(mergeConfig$1(ne || {}, {
      method: ee,
      url: te,
      data: (ne || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function(ee) {
  Axios$1.prototype[ee] = function(te, ne, re) {
    return this.request(mergeConfig$1(re || {}, {
      method: ee,
      url: te,
      data: ne
    }));
  };
});
var Axios_1 = Axios$1, CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var $ = requireCancel();
  function ee(te) {
    if (typeof te != "function")
      throw new TypeError("executor must be a function.");
    var ne;
    this.promise = new Promise(function(ie) {
      ne = ie;
    });
    var re = this;
    this.promise.then(function(se) {
      if (re._listeners) {
        var ie, oe = re._listeners.length;
        for (ie = 0; ie < oe; ie++)
          re._listeners[ie](se);
        re._listeners = null;
      }
    }), this.promise.then = function(se) {
      var ie, oe = new Promise(function(le) {
        re.subscribe(le), ie = le;
      }).then(se);
      return oe.cancel = function() {
        re.unsubscribe(ie);
      }, oe;
    }, te(function(ie) {
      re.reason || (re.reason = new $(ie), ne(re.reason));
    });
  }
  return ee.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, ee.prototype.subscribe = function(ne) {
    if (this.reason) {
      ne(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(ne) : this._listeners = [ne];
  }, ee.prototype.unsubscribe = function(ne) {
    if (this._listeners) {
      var re = this._listeners.indexOf(ne);
      re !== -1 && this._listeners.splice(re, 1);
    }
  }, ee.source = function() {
    var ne, re = new ee(function(ie) {
      ne = ie;
    });
    return {
      token: re,
      cancel: ne
    };
  }, CancelToken_1 = ee, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(ee) {
    return function(ne) {
      return ee.apply(null, ne);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(ee) {
    return typeof ee == "object" && ee.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$8, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = requireDefaults();
function createInstance($) {
  var ee = new Axios($), te = bind(Axios.prototype.request, ee);
  return utils.extend(te, Axios.prototype, ee), utils.extend(te, ee), te.create = function(re) {
    return createInstance(mergeConfig($, re));
  }, te;
}
var axios = createInstance(defaults);
axios.Axios = Axios;
axios.Cancel = requireCancel();
axios.CancelToken = requireCancelToken();
axios.isCancel = requireIsCancel();
axios.VERSION = requireData().version;
axios.all = function(ee) {
  return Promise.all(ee);
};
axios.spread = requireSpread();
axios.isAxiosError = requireIsAxiosError();
axios$1.exports = axios;
axios$1.exports.default = axios;
var n$1;
(function($) {
  $.LOCAL_ACCESS_TOKEN = "LOCAL_ACCESS_TOKEN", $.LOCAL_REFRESH_TOKEN = "LOCAL_REFRESH_TOKEN", $.LOCAL_USER = "LOCAL_USER", $.LOCAL_API_KEY = "LOCAL_API_KEY";
})(n$1 || (n$1 = {}));
var y$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne, re) {
    this.userName = void 0, this.uuid = void 0, this.isGuest = void 0, this.apikey = void 0, this.token_expiry_beta = 1, this.rtm_token_expiry_beta = 1, this.userName = ee, this.uuid = te, this.isGuest = ne, this.apikey = re;
  }
  return $.builder = function() {
    return new w$1();
  }, $;
}(), w$1 = /* @__PURE__ */ function() {
  function $() {
    this.userName = void 0, this.uuid = void 0, this.isGuest = void 0, this.apiKey = void 0;
  }
  var ee = $.prototype;
  return ee.setUserName = function(te) {
    return this.userName = te, this;
  }, ee.setUUID = function(te) {
    return this.uuid = te, this;
  }, ee.setApiKey = function(te) {
    return this.apiKey = te, this;
  }, ee.setIsGuest = function(te) {
    return this.isGuest = te, this;
  }, ee.build = function() {
    return new y$1(this.userName, this.uuid, this.isGuest || !1, this.apiKey);
  }, $;
}(), I$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne, re, se, ie) {
    this.text = void 0, this.attachments = void 0, this.heading = void 0, this.topic_ids = void 0, this.tempId = void 0, this.onBehalfOfUuid = void 0, this.text = ee, this.attachments = te, this.heading = ne, this.topic_ids = re, this.tempId = se, this.onBehalfOfUuid = ie;
  }
  return $.builder = function() {
    return new P$1();
  }, $;
}(), P$1 = /* @__PURE__ */ function() {
  function $() {
    this.text = void 0, this.attachments = void 0, this.heading = void 0, this.topic_ids = void 0, this.tempId = void 0, this.onBehalfOfUUID = void 0;
  }
  var ee = $.prototype;
  return ee.setText = function(te) {
    return this.text = te, this;
  }, ee.setHeading = function(te) {
    return this.heading = te, this;
  }, ee.setAttachments = function(te) {
    return this.attachments = te, this;
  }, ee.setTopicIds = function(te) {
    return this.topic_ids = te, this;
  }, ee.setOnBehalfOfUUID = function(te) {
    return this.onBehalfOfUUID = te, this;
  }, ee.setTempId = function(te) {
    return this.tempId = te, this;
  }, ee.build = function() {
    if (!this.text && !this.attachments)
      throw new Error("text and attachments are required.");
    return new I$1(this.text, this.attachments, this.heading, this.topic_ids, this.tempId, this.onBehalfOfUUID);
  }, $;
}(), S$1 = /* @__PURE__ */ function() {
  function $(ee, te) {
    this.attachmentType = void 0, this.attachmentMeta = void 0, this.attachmentType = ee, this.attachmentMeta = te;
  }
  return $.builder = function() {
    return new T$1();
  }, $;
}(), T$1 = /* @__PURE__ */ function() {
  function $() {
    this.attachmentType = void 0, this.attachmentMeta = void 0;
  }
  var ee = $.prototype;
  return ee.setAttachmentType = function(te) {
    return this.attachmentType = te, this;
  }, ee.setAttachmentMeta = function(te) {
    return this.attachmentMeta = te, this;
  }, ee.build = function() {
    if (!this.attachmentType || !this.attachmentMeta)
      throw new Error("attachmentType and attachmentMeta are required.");
    return new S$1(this.attachmentType, this.attachmentMeta);
  }, $;
}(), A$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne, re, se, ie, oe, le, ue, de, fe, pe, ye, me, ve, ge, xe, Ee, Te, Se) {
    ve === void 0 && (ve = 1), ge === void 0 && (ge = !1), xe === void 0 && (xe = !1), this.name = void 0, this.url = void 0, this.format = void 0, this.size = void 0, this.duration = void 0, this.pageCount = void 0, this.ogTags = void 0, this.coverImageUrl = void 0, this.title = void 0, this.body = void 0, this.thumbnailUrl = void 0, this.pollQuestion = void 0, this.expiryTime = void 0, this.options = void 0, this.multipleSelectState = void 0, this.pollType = void 0, this.multipleSelectNumber = void 0, this.isAnonymous = void 0, this.allowAddOption = void 0, this.entityId = void 0, this.name = ee, this.url = te, this.format = ne, this.size = re, this.duration = se, this.pageCount = ie, this.ogTags = oe, this.coverImageUrl = le, this.title = ue, this.pollQuestion = de, this.expiryTime = fe, this.options = pe, this.multipleSelectState = ye, this.pollType = me, this.multipleSelectNumber = ve, this.isAnonymous = ge, this.allowAddOption = xe, this.body = Ee, this.thumbnailUrl = Te, this.entityId = Se;
  }
  return $.builder = function() {
    return new L$1();
  }, $;
}(), L$1 = /* @__PURE__ */ function() {
  function $() {
    this.name = void 0, this.url = void 0, this.format = void 0, this.size = void 0, this.duration = void 0, this.pageCount = void 0, this.ogTags = void 0, this.title = void 0, this.coverImageUrl = void 0, this.body = void 0, this.thumbnailUrl = void 0, this.pollQuestion = void 0, this.expiryTime = void 0, this.options = void 0, this.multipleSelectState = void 0, this.pollType = void 0, this.multipleSelectNumber = void 0, this.isAnonymous = void 0, this.allowAddOption = void 0, this.entityId = void 0;
  }
  var ee = $.prototype;
  return ee.setname = function(te) {
    return this.name = te, this;
  }, ee.setThumbnailUrl = function(te) {
    return this.thumbnailUrl = te, this;
  }, ee.seturl = function(te) {
    return this.url = te, this;
  }, ee.setformat = function(te) {
    return this.format = te, this;
  }, ee.setsize = function(te) {
    return this.size = te, this;
  }, ee.setduration = function(te) {
    return this.duration = te, this;
  }, ee.setpageCount = function(te) {
    return this.pageCount = te, this;
  }, ee.setogTags = function(te) {
    return this.ogTags = te, this;
  }, ee.setTitle = function(te) {
    return this.title = te, this;
  }, ee.setBody = function(te) {
    return this.body = te, this;
  }, ee.setCoverImageUrl = function(te) {
    return this.coverImageUrl = te, this;
  }, ee.setPollQuestion = function(te) {
    return this.pollQuestion = te, this;
  }, ee.setExpiryTime = function(te) {
    return this.expiryTime = te, this;
  }, ee.setOptions = function(te) {
    return this.options = te, this;
  }, ee.setMultipleSelectState = function(te) {
    return this.multipleSelectState = te, this;
  }, ee.setPollType = function(te) {
    return this.pollType = te, this;
  }, ee.setMultipleSelectNumber = function(te) {
    return this.multipleSelectNumber = te, this;
  }, ee.setIsAnonymous = function(te) {
    return this.isAnonymous = te, this;
  }, ee.setAllowAddOption = function(te) {
    return this.allowAddOption = te, this;
  }, ee.setEntityId = function(te) {
    return this.entityId = te, this;
  }, ee.build = function() {
    return new A$1(this.name, this.url, this.format, this.size, this.duration, this.pageCount, this.ogTags, this.coverImageUrl, this.title, this.pollQuestion, this.expiryTime, this.options, this.multipleSelectState, this.pollType, this.multipleSelectNumber, this.isAnonymous, this.allowAddOption, this.body, this.thumbnailUrl, this.entityId);
  }, $;
}(), C$1 = /* @__PURE__ */ function() {
  function $(ee) {
    this.url = void 0, this.url = ee;
  }
  return $.builder = function() {
    return new E$1();
  }, $;
}(), E$1 = /* @__PURE__ */ function() {
  function $() {
    this.url = void 0;
  }
  var ee = $.prototype;
  return ee.setURL = function(te) {
    return this.url = te, this;
  }, ee.build = function() {
    if (!this.url)
      throw new Error("URL is required.");
    return new C$1(this.url);
  }, $;
}(), R$1 = /* @__PURE__ */ function() {
  function $(ee, te) {
    this.postId = void 0, this.deleteReason = void 0, this.postId = ee, this.deleteReason = te;
  }
  return $.builder = function() {
    return new q$1();
  }, $;
}(), q$1 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.deleteReason = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setdeleteReason = function(te) {
    return this.deleteReason = te, this;
  }, ee.build = function() {
    if (!this.postId)
      throw new Error("attachmentType and DeletePostRequest are required.");
    return new R$1(this.postId, this.deleteReason);
  }, $;
}(), z$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne, re, se) {
    this.postId = void 0, this.text = void 0, this.attachments = void 0, this.heading = void 0, this.topic_ids = void 0, this.postId = ee, this.text = te, this.attachments = ne, this.heading = re, this.topic_ids = se;
  }
  return $.builder = function() {
    return new _$2();
  }, $;
}(), _$2 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.text = void 0, this.attachments = void 0, this.heading = void 0, this.topic_ids = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.settext = function(te) {
    return this.text = te, this;
  }, ee.setHeading = function(te) {
    return this.heading = te, this;
  }, ee.setTopicIds = function(te) {
    return this.topic_ids = te, this;
  }, ee.setattachments = function(te) {
    return this.attachments = te, this;
  }, ee.build = function() {
    if (!this.postId)
      throw new Error("attachmentType and EditPostRequest are required.");
    return new z$1(this.postId, this.text, this.attachments, this.heading, this.topic_ids);
  }, $;
}(), x$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.postId = void 0, this.page = void 0, this.pageSize = void 0, this.postId = ee, this.page = te, this.pageSize = ne;
  }
  return $.builder = function() {
    return new U$1();
  }, $;
}(), U$1 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.page || !this.pageSize)
      throw new Error("postId, page and pageSize are required.");
    return new x$1(this.postId, this.page, this.pageSize);
  }, $;
}(), O$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.postId = void 0, this.page = void 0, this.pageSize = void 0, this.postId = ee, this.page = te, this.pageSize = ne;
  }
  return $.builder = function() {
    return new B$1();
  }, $;
}(), B$1 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.page || !this.pageSize)
      throw new Error("postId, page and pageSize are required.");
    return new O$1(this.postId, this.page, this.pageSize);
  }, $;
}(), j$1 = /* @__PURE__ */ function() {
  function $(ee) {
    this.postId = void 0, this.postId = ee;
  }
  return $.builder = function() {
    return new M$1();
  }, $;
}(), M$1 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.build = function() {
    if (!this.postId)
      throw new Error("postId is required.");
    return new j$1(this.postId);
  }, $;
}(), K$1 = /* @__PURE__ */ function() {
  function $(ee) {
    this.postId = void 0, this.postId = ee;
  }
  return $.builder = function() {
    return new N$1();
  }, $;
}(), N$1 = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.build = function() {
    if (!this.postId)
      throw new Error("postId is required.");
    return new K$1(this.postId);
  }, $;
}(), G$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.searchName = void 0, this.page = void 0, this.pageSize = void 0, this.searchName = ee, this.page = te, this.pageSize = ne;
  }
  return $.builder = function() {
    return new V$1();
  }, $;
}(), V$1 = /* @__PURE__ */ function() {
  function $() {
    this.searchName = void 0, this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setsearchName = function(te) {
    return this.searchName = te, this;
  }, ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.page || !this.pageSize)
      throw new Error("searchName, page and pageSize are required.");
    return new G$1(this.searchName, this.page, this.pageSize);
  }, $;
}(), H$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.page = void 0, this.pageSize = void 0, this.topicIds = void 0, this.page = ee, this.pageSize = te, this.topicIds = ne;
  }
  return $.builder = function() {
    return new Q$1();
  }, $;
}(), Q$1 = /* @__PURE__ */ function() {
  function $() {
    this.page = void 0, this.pageSize = void 0, this.topicIds = void 0;
  }
  var ee = $.prototype;
  return ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setTopicIds = function(te) {
    return this.topicIds = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.page || !this.pageSize)
      throw new Error("page and pageSize are required.");
    return new H$1(this.page, this.pageSize, this.topicIds);
  }, $;
}(), J$1 = /* @__PURE__ */ function() {
  function $(ee) {
    this.type = void 0, this.type = ee;
  }
  return $.builder = function() {
    return new Z$1();
  }, $;
}(), Z$1 = /* @__PURE__ */ function() {
  function $() {
    this.type = void 0;
  }
  var ee = $.prototype;
  return ee.settype = function(te) {
    return this.type = te, this;
  }, ee.build = function() {
    return new J$1(this.type);
  }, $;
}(), W$1 = /* @__PURE__ */ function() {
  function $(ee, te, ne, re, se) {
    this.entityId = void 0, this.uuid = void 0, this.entityType = void 0, this.tagId = void 0, this.reason = void 0, this.entityId = ee, this.uuid = te, this.entityType = ne, this.tagId = re, this.reason = se;
  }
  return $.builder = function() {
    return new X$1();
  }, $;
}(), X$1 = /* @__PURE__ */ function() {
  function $() {
    this.entityId = void 0, this.uuid = void 0, this.entityType = void 0, this.tagId = void 0, this.reason = void 0;
  }
  var ee = $.prototype;
  return ee.setEntityId = function(te) {
    return this.entityId = te, this;
  }, ee.setUuid = function(te) {
    return this.uuid = te, this;
  }, ee.setEntityType = function(te) {
    return this.entityType = te, this;
  }, ee.setTagId = function(te) {
    return this.tagId = te, this;
  }, ee.setReason = function(te) {
    return this.reason = te, this;
  }, ee.build = function() {
    if (!(this.entityId && this.uuid && this.entityType && this.tagId))
      throw new Error("entityId, uuid, entityType and tagId are required.");
    return new W$1(this.entityId, this.uuid, this.entityType, this.tagId, this.reason);
  }, $;
}(), tt = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.postId = void 0, this.text = void 0, this.tempId = void 0, this.postId = ee, this.text = te, this.tempId = ne;
  }
  return $.builder = function() {
    return new et();
  }, $;
}(), et = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.text = void 0, this.tempId = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.settext = function(te) {
    return this.text = te, this;
  }, ee.setTempId = function(te) {
    return this.tempId = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.text)
      throw new Error("postId and text are required.");
    return new tt(this.postId, this.text, this.tempId);
  }, $;
}(), nt = /* @__PURE__ */ function() {
  function $(ee) {
    this.page = void 0, this.page = ee;
  }
  return $.builder = function() {
    return new rt();
  }, $;
}(), rt = /* @__PURE__ */ function() {
  function $() {
    this.page = void 0;
  }
  var ee = $.prototype;
  return ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.build = function() {
    return new nt(this.page);
  }, $;
}(), it = /* @__PURE__ */ function() {
  function $(ee, te, ne, re) {
    this.postId = void 0, this.commentId = void 0, this.text = void 0, this.tempId = void 0, this.postId = ee, this.commentId = te, this.text = ne, this.tempId = re;
  }
  return $.builder = function() {
    return new ot();
  }, $;
}(), ot = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.commentId = void 0, this.text = void 0, this.tempId = void 0;
  }
  var ee = $.prototype;
  return ee.setPostId = function(te) {
    return this.postId = te, this;
  }, ee.setCommentId = function(te) {
    return this.commentId = te, this;
  }, ee.setText = function(te) {
    return this.text = te, this;
  }, ee.setTempId = function(te) {
    return this.tempId = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.commentId)
      throw new Error("postId and commentId are required.");
    return new it(this.postId, this.commentId, this.text, this.tempId);
  }, $;
}(), st = /* @__PURE__ */ function() {
  function $(ee, te, ne, re) {
    this.postId = void 0, this.commentId = void 0, this.page = void 0, this.pageSize = void 0, this.postId = ee, this.commentId = te, this.page = ne, this.pageSize = re;
  }
  return $.builder = function() {
    return new ut();
  }, $;
}(), ut = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.commentId = void 0, this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setcommentId = function(te) {
    return this.commentId = te, this;
  }, ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.commentId)
      throw new Error("postId and commentId are required.");
    return new st(this.postId, this.commentId, this.page, this.pageSize);
  }, $;
}(), ht = /* @__PURE__ */ function() {
  function $(ee, te) {
    this.postId = void 0, this.commentId = void 0, this.postId = ee, this.commentId = te;
  }
  return $.builder = function() {
    return new dt();
  }, $;
}(), dt = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.commentId = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setcommentId = function(te) {
    return this.commentId = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.commentId)
      throw new Error("postId and commentId are required.");
    return new ht(this.postId, this.commentId);
  }, $;
}(), lt = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.postId = void 0, this.commentId = void 0, this.reason = void 0, this.postId = ee, this.commentId = te, this.reason = ne;
  }
  return $.builder = function() {
    return new ft();
  }, $;
}(), ft = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.commentId = void 0, this.reason = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setcommentId = function(te) {
    return this.commentId = te, this;
  }, ee.setreason = function(te) {
    return this.reason = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.commentId)
      throw new Error("postId and commentId are required.");
    return new lt(this.postId, this.commentId, this.reason);
  }, $;
}(), mt = /* @__PURE__ */ function() {
  function $(ee, te) {
    this.page = void 0, this.pageSize = void 0, this.page = ee, this.pageSize = te;
  }
  return $.builder = function() {
    return new vt();
  }, $;
}(), vt = /* @__PURE__ */ function() {
  function $() {
    this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setpage = function(te) {
    return this.page = te, this;
  }, ee.setpageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!this.page || !this.pageSize)
      throw new Error("UUID and DeviceI are required.");
    return new mt(this.page, this.pageSize);
  }, $;
}(), gt = /* @__PURE__ */ function() {
  function $(ee) {
    this.activityId = void 0, this.activityId = ee;
  }
  return $.builder = function() {
    return new yt();
  }, $;
}(), yt = /* @__PURE__ */ function() {
  function $() {
    this.activityId = void 0;
  }
  var ee = $.prototype;
  return ee.setactivityId = function(te) {
    return this.activityId = te, this;
  }, ee.build = function() {
    if (!this.activityId)
      throw new Error("activityId is required.");
    return new gt(this.activityId);
  }, $;
}(), wt = /* @__PURE__ */ function() {
  function $(ee, te, ne) {
    this.postId = void 0, this.commentId = void 0, this.text = void 0, this.postId = ee, this.commentId = te, this.text = ne;
  }
  return $.builder = function() {
    return new kt();
  }, $;
}(), kt = /* @__PURE__ */ function() {
  function $() {
    this.postId = void 0, this.commentId = void 0, this.text = void 0;
  }
  var ee = $.prototype;
  return ee.setpostId = function(te) {
    return this.postId = te, this;
  }, ee.setcommentId = function(te) {
    return this.commentId = te, this;
  }, ee.settext = function(te) {
    return this.text = te, this;
  }, ee.build = function() {
    if (!this.postId || !this.commentId)
      throw new Error("postId and commentId are required.");
    return new wt(this.postId, this.commentId, this.text);
  }, $;
}(), It = /* @__PURE__ */ function() {
  function $(ee, te, ne, re, se) {
    this.isEnabled = void 0, this.search = void 0, this.searchType = void 0, this.page = void 0, this.pageSize = void 0, this.isEnabled = ee, this.search = te, this.page = re, this.pageSize = se, this.searchType = ne;
  }
  return $.builder = function() {
    return new Pt();
  }, $;
}(), Pt = /* @__PURE__ */ function() {
  function $() {
    this.isEnabled = void 0, this.search = void 0, this.searchType = void 0, this.page = void 0, this.pageSize = void 0;
  }
  var ee = $.prototype;
  return ee.setIsEnabled = function(te) {
    return this.isEnabled = te, this;
  }, ee.setSearch = function(te) {
    return this.search = te, this;
  }, ee.setSearchType = function(te) {
    return this.searchType = te, this;
  }, ee.setPage = function(te) {
    return this.page = te, this;
  }, ee.setPageSize = function(te) {
    return this.pageSize = te, this;
  }, ee.build = function() {
    if (!(this.page && this.pageSize && this.search !== void 0 && this.searchType))
      throw new Error("Some parameters are missing");
    return new It(this.isEnabled, this.search, this.searchType, this.page, this.pageSize);
  }, $;
}(), bt$1 = /* @__PURE__ */ function() {
  function $(ee, te) {
    this.accessToken = void 0, this.refreshToken = void 0, this.accessToken = ee, this.refreshToken = te;
  }
  return $.builder = function() {
    return new St();
  }, $;
}(), St = /* @__PURE__ */ function() {
  function $() {
    this.accessToken = void 0, this.refreshToken = void 0;
  }
  var ee = $.prototype;
  return ee.setaccessToken = function(te) {
    return this.accessToken = te, this;
  }, ee.setrefreshToken = function(te) {
    return this.refreshToken = te, this;
  }, ee.build = function() {
    if (!this.accessToken || !this.refreshToken)
      throw new Error("Access Token and Refresh Token are required.");
    return new bt$1(this.accessToken, this.refreshToken);
  }, $;
}(), Ct = function() {
}, LMFeedCustomActionEvents = /* @__PURE__ */ (($) => ($.OPEN_CREATE_POST_DIALOUGE = "OPEN_CREATE_POST_DIALOUGE", $.DELETE_POST = "DELETE_POST", $.REPORT_POST = "REPORT_POST", $.PIN_POST = "PIN_POST", $.UNPIN_POST = "UNPIN_POST", $.USER_INITIATED = "USER_INITIATED", $.REPLY_POSTED = "REPLY_POSTED", $.REPLY_DELETED = "REPLY_DELETED", $.COMMENT_DELETED = "COMMENT_DELETED", $.POST_CREATED = "POST_CREATED", $.POST_EDITED = "POST_EDITED", $.LIKE_POST_CALLED = "LIKE_POST_CALLED", $.COMMENT_ADDED = "COMMENT_ADDED", $.COMMENT_REMOVED = "COMMENT_REMOVED", $.POST_EDITED_TARGET_DETAILS = "POST_EDITED_TARGET_DETAILS", $.PINNED_ON_DETAIL = "PINNED_ON_DETAIL", $.DELETE_POST_ON_DETAILS = "DELETE_POST_ON_DETAILS", $.TRIGGER_SET_USER = "TRIGGER_SET_USER", $))(LMFeedCustomActionEvents || {});
function useUserProvider($, ee, te) {
  const [ne, re] = useState(null), [se, ie] = useState(null);
  useEffect(() => {
    const { accessToken: le, refreshToken: ue, username: de, uuid: fe, isGuest: pe, apiKey: ye } = te;
    if (console.log(te), !$)
      return;
    function me(Ee, Te) {
      $.setAccessTokenInLocalStorage(Ee), $.setRefreshTokenInLocalStorage(Te);
    }
    async function ve(Ee, Te) {
      var Se, he, Pe;
      try {
        me(Ee, Te);
        const Ie = await ($ == null ? void 0 : $.validateUser(
          bt$1.builder().setaccessToken(Ee).setrefreshToken(Te).build()
        ));
        console.log("Outside validate user request"), console.log(Ie), Ie.success && (me(Ee, Te), $.setUserInLocalStorage(
          JSON.stringify((Se = Ie.data) == null ? void 0 : Se.user)
        ));
        const De = await ($ == null ? void 0 : $.getMemberState());
        if (Ie && De.success) {
          const Ce = {
            ...(he = Ie.data) == null ? void 0 : he.user,
            ...De.data.member
          };
          re(Ce || null), ie(
            ((Pe = Ie == null ? void 0 : Ie.data) == null ? void 0 : Pe.community) || null
          );
        }
      } catch (Ie) {
        return console.log(Ie), Ie;
      }
    }
    async function ge(Ee, Te, Se, he) {
      var Pe, Ie, De, Ce, Ne;
      try {
        if (!(Ee && Te && Se))
          throw Error("Either API key or UUID or Username not provided");
        alert();
        const Me = await ($ == null ? void 0 : $.initiateUser(
          y$1.builder().setUUID(Te || "").setIsGuest(he || !1).setUserName(Se || "").setApiKey(Ee).build()
        ));
        alert(), Me && (me(
          ((Pe = Me.data) == null ? void 0 : Pe.accessToken) || "",
          ((Ie = Me.data) == null ? void 0 : Ie.refreshToken) || ""
        ), $.setApiKeyInLocalStorage(Ee), $.setUserInLocalStorage(
          JSON.stringify((De = Me.data) == null ? void 0 : De.user)
        ));
        const Be = await ($ == null ? void 0 : $.getMemberState());
        if (Me && Be.success) {
          const We = {
            ...(Ce = Me.data) == null ? void 0 : Ce.user,
            ...Be.data.member
          };
          re(We || null), ie(
            ((Ne = Me == null ? void 0 : Me.data) == null ? void 0 : Ne.community) || null
          );
        }
      } catch (Me) {
        return console.log(Me), Me;
      }
    }
    ee.listen(
      LMFeedCustomActionEvents.TRIGGER_SET_USER,
      xe
    );
    async function xe() {
      try {
        if (ye && de && fe) {
          const Ee = $.getAccessTokenFromLocalStorage(), Te = $.getRefreshTokenFromLocalStorage();
          console.log("The local access tokens are: ", Ee), console.log("The local refresh tokens are: ", Te), Ee && Te && Ee.length && Te.length ? await ve(Ee, Te) : await ge(ye, fe, de, pe || !1);
        } else if (le && ue)
          await ve(le, ue);
        else
          throw Error("Neither API key nor Tokens provided");
      } catch (Ee) {
        console.log(Ee);
      }
    }
    return ee.listen(
      LMFeedCustomActionEvents.TRIGGER_SET_USER,
      xe
    ), xe(), () => {
      ee.remove(LMFeedCustomActionEvents.TRIGGER_SET_USER);
    };
  }, [ee, $, te]), useEffect(() => {
    ne && ee.dispatchEvent(LMFeedCustomActionEvents.USER_INITIATED, {
      lmFeedClient: $,
      user: ne
    });
  }, [ee, ne, $]);
  function oe() {
    re(null);
  }
  return {
    lmFeedUser: ne,
    logoutUser: oe,
    lmFeedUserCurrentCommunity: se
  };
}
const CustomAgentProviderContext = createContext({});
function commonjsRequire($) {
  throw new Error('Could not dynamically require "' + $ + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf$2 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$5$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(ee, te) {
    module.exports = ee.pdfjsLib = te();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        ($, ee) => {
          var Rn;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.VerbosityLevel = ee.Util = ee.UnknownErrorException = ee.UnexpectedResponseException = ee.TextRenderingMode = ee.RenderingIntentFlag = ee.PromiseCapability = ee.PermissionFlag = ee.PasswordResponses = ee.PasswordException = ee.PageActionEventType = ee.OPS = ee.MissingPDFException = ee.MAX_IMAGE_SIZE_TO_CACHE = ee.LINE_FACTOR = ee.LINE_DESCENT_FACTOR = ee.InvalidPDFException = ee.ImageKind = ee.IDENTITY_MATRIX = ee.FormatError = ee.FeatureTest = ee.FONT_IDENTITY_MATRIX = ee.DocumentActionEventType = ee.CMapCompressionType = ee.BaseException = ee.BASELINE_FACTOR = ee.AnnotationType = ee.AnnotationReplyType = ee.AnnotationPrefix = ee.AnnotationMode = ee.AnnotationFlag = ee.AnnotationFieldFlag = ee.AnnotationEditorType = ee.AnnotationEditorPrefix = ee.AnnotationEditorParamsType = ee.AnnotationBorderStyleType = ee.AnnotationActionEventType = ee.AbortException = void 0, ee.assert = Qe, ee.bytesToString = Ye, ee.createValidAbsoluteUrl = Ot, ee.getModificationDate = sn, ee.getUuid = Tn, ee.getVerbosityLevel = He, ee.info = Ge, ee.isArrayBuffer = Gt, ee.isArrayEqual = ln, ee.isNodeJS = void 0, ee.normalizeUnicode = wn, ee.objectFromMap = Bt, ee.objectSize = pt, ee.setVerbosityLevel = Le, ee.shadow = At, ee.string32 = Tt, ee.stringToBytes = Ke, ee.stringToPDFString = Yt, ee.stringToUTF8String = Ut, ee.unreachable = Ue, ee.utf8StringToString = jt, ee.warn = Ze;
          const te = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          ee.isNodeJS = te;
          const ne = [1, 0, 0, 1, 0, 0];
          ee.IDENTITY_MATRIX = ne;
          const re = [1e-3, 0, 0, 1e-3, 0, 0];
          ee.FONT_IDENTITY_MATRIX = re;
          const se = 1e7;
          ee.MAX_IMAGE_SIZE_TO_CACHE = se;
          const ie = 1.35;
          ee.LINE_FACTOR = ie;
          const oe = 0.35;
          ee.LINE_DESCENT_FACTOR = oe;
          const le = oe / ie;
          ee.BASELINE_FACTOR = le;
          const ue = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            SAVE: 8,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          ee.RenderingIntentFlag = ue;
          const de = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          ee.AnnotationMode = de;
          const fe = "pdfjs_internal_editor_";
          ee.AnnotationEditorPrefix = fe;
          const pe = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            STAMP: 13,
            INK: 15
          };
          ee.AnnotationEditorType = pe;
          const ye = {
            RESIZE: 1,
            CREATE: 2,
            FREETEXT_SIZE: 11,
            FREETEXT_COLOR: 12,
            FREETEXT_OPACITY: 13,
            INK_COLOR: 21,
            INK_THICKNESS: 22,
            INK_OPACITY: 23
          };
          ee.AnnotationEditorParamsType = ye;
          const me = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          ee.PermissionFlag = me;
          const ve = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          ee.TextRenderingMode = ve;
          const ge = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          ee.ImageKind = ge;
          const xe = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          ee.AnnotationType = xe;
          const Ee = {
            GROUP: "Group",
            REPLY: "R"
          };
          ee.AnnotationReplyType = Ee;
          const Te = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          ee.AnnotationFlag = Te;
          const Se = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          ee.AnnotationFieldFlag = Se;
          const he = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          ee.AnnotationBorderStyleType = he;
          const Pe = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          ee.AnnotationActionEventType = Pe;
          const Ie = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          ee.DocumentActionEventType = Ie;
          const De = {
            O: "PageOpen",
            C: "PageClose"
          };
          ee.PageActionEventType = De;
          const Ce = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          ee.VerbosityLevel = Ce;
          const Ne = {
            NONE: 0,
            BINARY: 1
          };
          ee.CMapCompressionType = Ne;
          const Me = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          ee.OPS = Me;
          const Be = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          ee.PasswordResponses = Be;
          let We = Ce.WARNINGS;
          function Le(Kt) {
            Number.isInteger(Kt) && (We = Kt);
          }
          function He() {
            return We;
          }
          function Ge(Kt) {
            We >= Ce.INFOS && console.log(`Info: ${Kt}`);
          }
          function Ze(Kt) {
            We >= Ce.WARNINGS && console.log(`Warning: ${Kt}`);
          }
          function Ue(Kt) {
            throw new Error(Kt);
          }
          function Qe(Kt, Ht) {
            Kt || Ue(Ht);
          }
          function Je(Kt) {
            switch (Kt == null ? void 0 : Kt.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function Ot(Kt, Ht = null, Lt = null) {
            if (!Kt)
              return null;
            try {
              if (Lt && typeof Kt == "string") {
                if (Lt.addDefaultProtocol && Kt.startsWith("www.")) {
                  const Jt = Kt.match(/\./g);
                  (Jt == null ? void 0 : Jt.length) >= 2 && (Kt = `http://${Kt}`);
                }
                if (Lt.tryConvertEncoding)
                  try {
                    Kt = Ut(Kt);
                  } catch {
                  }
              }
              const Zt = Ht ? new URL(Kt, Ht) : new URL(Kt);
              if (Je(Zt))
                return Zt;
            } catch {
            }
            return null;
          }
          function At(Kt, Ht, Lt, Zt = !1) {
            return Object.defineProperty(Kt, Ht, {
              value: Lt,
              enumerable: !Zt,
              configurable: !0,
              writable: !1
            }), Lt;
          }
          const ze = function() {
            function Ht(Lt, Zt) {
              this.constructor === Ht && Ue("Cannot initialize BaseException."), this.message = Lt, this.name = Zt;
            }
            return Ht.prototype = new Error(), Ht.constructor = Ht, Ht;
          }();
          ee.BaseException = ze;
          class we extends ze {
            constructor(Ht, Lt) {
              super(Ht, "PasswordException"), this.code = Lt;
            }
          }
          ee.PasswordException = we;
          class Ae extends ze {
            constructor(Ht, Lt) {
              super(Ht, "UnknownErrorException"), this.details = Lt;
            }
          }
          ee.UnknownErrorException = Ae;
          class Re extends ze {
            constructor(Ht) {
              super(Ht, "InvalidPDFException");
            }
          }
          ee.InvalidPDFException = Re;
          class je extends ze {
            constructor(Ht) {
              super(Ht, "MissingPDFException");
            }
          }
          ee.MissingPDFException = je;
          class Fe extends ze {
            constructor(Ht, Lt) {
              super(Ht, "UnexpectedResponseException"), this.status = Lt;
            }
          }
          ee.UnexpectedResponseException = Fe;
          class $e extends ze {
            constructor(Ht) {
              super(Ht, "FormatError");
            }
          }
          ee.FormatError = $e;
          class qe extends ze {
            constructor(Ht) {
              super(Ht, "AbortException");
            }
          }
          ee.AbortException = qe;
          function Ye(Kt) {
            (typeof Kt != "object" || (Kt == null ? void 0 : Kt.length) === void 0) && Ue("Invalid argument for bytesToString");
            const Ht = Kt.length, Lt = 8192;
            if (Ht < Lt)
              return String.fromCharCode.apply(null, Kt);
            const Zt = [];
            for (let Jt = 0; Jt < Ht; Jt += Lt) {
              const Dn = Math.min(Jt + Lt, Ht), kn = Kt.subarray(Jt, Dn);
              Zt.push(String.fromCharCode.apply(null, kn));
            }
            return Zt.join("");
          }
          function Ke(Kt) {
            typeof Kt != "string" && Ue("Invalid argument for stringToBytes");
            const Ht = Kt.length, Lt = new Uint8Array(Ht);
            for (let Zt = 0; Zt < Ht; ++Zt)
              Lt[Zt] = Kt.charCodeAt(Zt) & 255;
            return Lt;
          }
          function Tt(Kt) {
            return String.fromCharCode(Kt >> 24 & 255, Kt >> 16 & 255, Kt >> 8 & 255, Kt & 255);
          }
          function pt(Kt) {
            return Object.keys(Kt).length;
          }
          function Bt(Kt) {
            const Ht = /* @__PURE__ */ Object.create(null);
            for (const [Lt, Zt] of Kt)
              Ht[Lt] = Zt;
            return Ht;
          }
          function Vt() {
            const Kt = new Uint8Array(4);
            return Kt[0] = 1, new Uint32Array(Kt.buffer, 0, 1)[0] === 1;
          }
          function qt() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class nn {
            static get isLittleEndian() {
              return At(this, "isLittleEndian", Vt());
            }
            static get isEvalSupported() {
              return At(this, "isEvalSupported", qt());
            }
            static get isOffscreenCanvasSupported() {
              return At(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
            static get platform() {
              return typeof navigator > "u" ? At(this, "platform", {
                isWin: !1,
                isMac: !1
              }) : At(this, "platform", {
                isWin: navigator.platform.includes("Win"),
                isMac: navigator.platform.includes("Mac")
              });
            }
            static get isCSSRoundSupported() {
              var Ht, Lt;
              return At(this, "isCSSRoundSupported", (Lt = (Ht = globalThis.CSS) == null ? void 0 : Ht.supports) == null ? void 0 : Lt.call(Ht, "width: round(1.5px, 1px)"));
            }
          }
          ee.FeatureTest = nn;
          const mn = [...Array(256).keys()].map((Kt) => Kt.toString(16).padStart(2, "0"));
          class en {
            static makeHexColor(Ht, Lt, Zt) {
              return `#${mn[Ht]}${mn[Lt]}${mn[Zt]}`;
            }
            static scaleMinMax(Ht, Lt) {
              let Zt;
              Ht[0] ? (Ht[0] < 0 && (Zt = Lt[0], Lt[0] = Lt[1], Lt[1] = Zt), Lt[0] *= Ht[0], Lt[1] *= Ht[0], Ht[3] < 0 && (Zt = Lt[2], Lt[2] = Lt[3], Lt[3] = Zt), Lt[2] *= Ht[3], Lt[3] *= Ht[3]) : (Zt = Lt[0], Lt[0] = Lt[2], Lt[2] = Zt, Zt = Lt[1], Lt[1] = Lt[3], Lt[3] = Zt, Ht[1] < 0 && (Zt = Lt[2], Lt[2] = Lt[3], Lt[3] = Zt), Lt[2] *= Ht[1], Lt[3] *= Ht[1], Ht[2] < 0 && (Zt = Lt[0], Lt[0] = Lt[1], Lt[1] = Zt), Lt[0] *= Ht[2], Lt[1] *= Ht[2]), Lt[0] += Ht[4], Lt[1] += Ht[4], Lt[2] += Ht[5], Lt[3] += Ht[5];
            }
            static transform(Ht, Lt) {
              return [Ht[0] * Lt[0] + Ht[2] * Lt[1], Ht[1] * Lt[0] + Ht[3] * Lt[1], Ht[0] * Lt[2] + Ht[2] * Lt[3], Ht[1] * Lt[2] + Ht[3] * Lt[3], Ht[0] * Lt[4] + Ht[2] * Lt[5] + Ht[4], Ht[1] * Lt[4] + Ht[3] * Lt[5] + Ht[5]];
            }
            static applyTransform(Ht, Lt) {
              const Zt = Ht[0] * Lt[0] + Ht[1] * Lt[2] + Lt[4], Jt = Ht[0] * Lt[1] + Ht[1] * Lt[3] + Lt[5];
              return [Zt, Jt];
            }
            static applyInverseTransform(Ht, Lt) {
              const Zt = Lt[0] * Lt[3] - Lt[1] * Lt[2], Jt = (Ht[0] * Lt[3] - Ht[1] * Lt[2] + Lt[2] * Lt[5] - Lt[4] * Lt[3]) / Zt, Dn = (-Ht[0] * Lt[1] + Ht[1] * Lt[0] + Lt[4] * Lt[1] - Lt[5] * Lt[0]) / Zt;
              return [Jt, Dn];
            }
            static getAxialAlignedBoundingBox(Ht, Lt) {
              const Zt = this.applyTransform(Ht, Lt), Jt = this.applyTransform(Ht.slice(2, 4), Lt), Dn = this.applyTransform([Ht[0], Ht[3]], Lt), kn = this.applyTransform([Ht[2], Ht[1]], Lt);
              return [Math.min(Zt[0], Jt[0], Dn[0], kn[0]), Math.min(Zt[1], Jt[1], Dn[1], kn[1]), Math.max(Zt[0], Jt[0], Dn[0], kn[0]), Math.max(Zt[1], Jt[1], Dn[1], kn[1])];
            }
            static inverseTransform(Ht) {
              const Lt = Ht[0] * Ht[3] - Ht[1] * Ht[2];
              return [Ht[3] / Lt, -Ht[1] / Lt, -Ht[2] / Lt, Ht[0] / Lt, (Ht[2] * Ht[5] - Ht[4] * Ht[3]) / Lt, (Ht[4] * Ht[1] - Ht[5] * Ht[0]) / Lt];
            }
            static singularValueDecompose2dScale(Ht) {
              const Lt = [Ht[0], Ht[2], Ht[1], Ht[3]], Zt = Ht[0] * Lt[0] + Ht[1] * Lt[2], Jt = Ht[0] * Lt[1] + Ht[1] * Lt[3], Dn = Ht[2] * Lt[0] + Ht[3] * Lt[2], kn = Ht[2] * Lt[1] + Ht[3] * Lt[3], $t = (Zt + kn) / 2, on = Math.sqrt((Zt + kn) ** 2 - 4 * (Zt * kn - Dn * Jt)) / 2, gn = $t + on || 1, dn = $t - on || 1;
              return [Math.sqrt(gn), Math.sqrt(dn)];
            }
            static normalizeRect(Ht) {
              const Lt = Ht.slice(0);
              return Ht[0] > Ht[2] && (Lt[0] = Ht[2], Lt[2] = Ht[0]), Ht[1] > Ht[3] && (Lt[1] = Ht[3], Lt[3] = Ht[1]), Lt;
            }
            static intersect(Ht, Lt) {
              const Zt = Math.max(Math.min(Ht[0], Ht[2]), Math.min(Lt[0], Lt[2])), Jt = Math.min(Math.max(Ht[0], Ht[2]), Math.max(Lt[0], Lt[2]));
              if (Zt > Jt)
                return null;
              const Dn = Math.max(Math.min(Ht[1], Ht[3]), Math.min(Lt[1], Lt[3])), kn = Math.min(Math.max(Ht[1], Ht[3]), Math.max(Lt[1], Lt[3]));
              return Dn > kn ? null : [Zt, Dn, Jt, kn];
            }
            static bezierBoundingBox(Ht, Lt, Zt, Jt, Dn, kn, $t, on) {
              const gn = [], dn = [[], []];
              let vn, xn, In, Qt, Mn, yn, xt, ke;
              for (let Ft = 0; Ft < 2; ++Ft) {
                if (Ft === 0 ? (xn = 6 * Ht - 12 * Zt + 6 * Dn, vn = -3 * Ht + 9 * Zt - 9 * Dn + 3 * $t, In = 3 * Zt - 3 * Ht) : (xn = 6 * Lt - 12 * Jt + 6 * kn, vn = -3 * Lt + 9 * Jt - 9 * kn + 3 * on, In = 3 * Jt - 3 * Lt), Math.abs(vn) < 1e-12) {
                  if (Math.abs(xn) < 1e-12)
                    continue;
                  Qt = -In / xn, 0 < Qt && Qt < 1 && gn.push(Qt);
                  continue;
                }
                xt = xn * xn - 4 * In * vn, ke = Math.sqrt(xt), !(xt < 0) && (Mn = (-xn + ke) / (2 * vn), 0 < Mn && Mn < 1 && gn.push(Mn), yn = (-xn - ke) / (2 * vn), 0 < yn && yn < 1 && gn.push(yn));
              }
              let Xe = gn.length, Et;
              const Mt = Xe;
              for (; Xe--; )
                Qt = gn[Xe], Et = 1 - Qt, dn[0][Xe] = Et * Et * Et * Ht + 3 * Et * Et * Qt * Zt + 3 * Et * Qt * Qt * Dn + Qt * Qt * Qt * $t, dn[1][Xe] = Et * Et * Et * Lt + 3 * Et * Et * Qt * Jt + 3 * Et * Qt * Qt * kn + Qt * Qt * Qt * on;
              return dn[0][Mt] = Ht, dn[1][Mt] = Lt, dn[0][Mt + 1] = $t, dn[1][Mt + 1] = on, dn[0].length = dn[1].length = Mt + 2, [Math.min(...dn[0]), Math.min(...dn[1]), Math.max(...dn[0]), Math.max(...dn[1])];
            }
          }
          ee.Util = en;
          const pn = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function Yt(Kt) {
            if (Kt[0] >= "") {
              let Lt;
              if (Kt[0] === "" && Kt[1] === "" ? Lt = "utf-16be" : Kt[0] === "" && Kt[1] === "" ? Lt = "utf-16le" : Kt[0] === "" && Kt[1] === "" && Kt[2] === "" && (Lt = "utf-8"), Lt)
                try {
                  const Zt = new TextDecoder(Lt, {
                    fatal: !0
                  }), Jt = Ke(Kt);
                  return Zt.decode(Jt);
                } catch (Zt) {
                  Ze(`stringToPDFString: "${Zt}".`);
                }
            }
            const Ht = [];
            for (let Lt = 0, Zt = Kt.length; Lt < Zt; Lt++) {
              const Jt = pn[Kt.charCodeAt(Lt)];
              Ht.push(Jt ? String.fromCharCode(Jt) : Kt.charAt(Lt));
            }
            return Ht.join("");
          }
          function Ut(Kt) {
            return decodeURIComponent(escape(Kt));
          }
          function jt(Kt) {
            return unescape(encodeURIComponent(Kt));
          }
          function Gt(Kt) {
            return typeof Kt == "object" && (Kt == null ? void 0 : Kt.byteLength) !== void 0;
          }
          function ln(Kt, Ht) {
            if (Kt.length !== Ht.length)
              return !1;
            for (let Lt = 0, Zt = Kt.length; Lt < Zt; Lt++)
              if (Kt[Lt] !== Ht[Lt])
                return !1;
            return !0;
          }
          function sn(Kt = /* @__PURE__ */ new Date()) {
            return [Kt.getUTCFullYear().toString(), (Kt.getUTCMonth() + 1).toString().padStart(2, "0"), Kt.getUTCDate().toString().padStart(2, "0"), Kt.getUTCHours().toString().padStart(2, "0"), Kt.getUTCMinutes().toString().padStart(2, "0"), Kt.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          class _n {
            constructor() {
              Rt(this, Rn, !1);
              this.promise = new Promise((Ht, Lt) => {
                this.resolve = (Zt) => {
                  zt(this, Rn, !0), Ht(Zt);
                }, this.reject = (Zt) => {
                  zt(this, Rn, !0), Lt(Zt);
                };
              });
            }
            get settled() {
              return Oe(this, Rn);
            }
          }
          Rn = new WeakMap(), ee.PromiseCapability = _n;
          let un = null, En = null;
          function wn(Kt) {
            return un || (un = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, En = /* @__PURE__ */ new Map([["", "t"]])), Kt.replaceAll(un, (Ht, Lt, Zt) => Lt ? Lt.normalize("NFKC") : En.get(Zt));
          }
          function Tn() {
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
              return crypto.randomUUID();
            const Kt = new Uint8Array(32);
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
              crypto.getRandomValues(Kt);
            else
              for (let Ht = 0; Ht < 32; Ht++)
                Kt[Ht] = Math.floor(Math.random() * 255);
            return Ye(Kt);
          }
          const Pn = "pdfjs_internal_id_";
          ee.AnnotationPrefix = Pn;
        },
        /* 2 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var $, te, ne, re, zn, ie, sr, le, ue, de, fe, pe, ye, me, ve, ge, ir, Ee, Te, Sr, he, Pe;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
            enumerable: !0,
            get: function() {
              return _displaySvg.SVGGraphics;
            }
          }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
          exports.DefaultFilterFactory = DefaultFilterFactory;
          const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
          function getDocument(De) {
            if (typeof De == "string" || De instanceof URL ? De = {
              url: De
            } : (0, _util.isArrayBuffer)(De) && (De = {
              data: De
            }), typeof De != "object")
              throw new Error("Invalid parameter in getDocument, need parameter object.");
            if (!De.url && !De.data && !De.range)
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            const Ce = new PDFDocumentLoadingTask(), {
              docId: Ne
            } = Ce, Me = De.url ? getUrlProp(De.url) : null, Be = De.data ? getDataProp(De.data) : null, We = De.httpHeaders || null, Le = De.withCredentials === !0, He = De.password ?? null, Ge = De.range instanceof PDFDataRangeTransport ? De.range : null, Ze = Number.isInteger(De.rangeChunkSize) && De.rangeChunkSize > 0 ? De.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
            let Ue = De.worker instanceof PDFWorker ? De.worker : null;
            const Qe = De.verbosity, Je = typeof De.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(De.docBaseUrl) ? De.docBaseUrl : null, Ot = typeof De.cMapUrl == "string" ? De.cMapUrl : null, At = De.cMapPacked !== !1, ze = De.CMapReaderFactory || DefaultCMapReaderFactory, we = typeof De.standardFontDataUrl == "string" ? De.standardFontDataUrl : null, Ae = De.StandardFontDataFactory || DefaultStandardFontDataFactory, Re = De.stopAtErrors !== !0, je = Number.isInteger(De.maxImageSize) && De.maxImageSize > -1 ? De.maxImageSize : -1, Fe = De.isEvalSupported !== !1, $e = typeof De.isOffscreenCanvasSupported == "boolean" ? De.isOffscreenCanvasSupported : !_util.isNodeJS, qe = Number.isInteger(De.canvasMaxAreaInBytes) ? De.canvasMaxAreaInBytes : -1, Ye = typeof De.disableFontFace == "boolean" ? De.disableFontFace : _util.isNodeJS, Ke = De.fontExtraProperties === !0, Tt = De.enableXfa === !0, pt = De.ownerDocument || globalThis.document, Bt = De.disableRange === !0, Vt = De.disableStream === !0, qt = De.disableAutoFetch === !0, nn = De.pdfBug === !0, mn = Ge ? Ge.length : De.length ?? NaN, en = typeof De.useSystemFonts == "boolean" ? De.useSystemFonts : !_util.isNodeJS && !Ye, pn = typeof De.useWorkerFetch == "boolean" ? De.useWorkerFetch : ze === _display_utils.DOMCMapReaderFactory && Ae === _display_utils.DOMStandardFontDataFactory && Ot && we && (0, _display_utils.isValidFetchUrl)(Ot, document.baseURI) && (0, _display_utils.isValidFetchUrl)(we, document.baseURI), Yt = De.canvasFactory || new DefaultCanvasFactory({
              ownerDocument: pt
            }), Ut = De.filterFactory || new DefaultFilterFactory({
              docId: Ne,
              ownerDocument: pt
            }), jt = null;
            (0, _util.setVerbosityLevel)(Qe);
            const Gt = {
              canvasFactory: Yt,
              filterFactory: Ut
            };
            if (pn || (Gt.cMapReaderFactory = new ze({
              baseUrl: Ot,
              isCompressed: At
            }), Gt.standardFontDataFactory = new Ae({
              baseUrl: we
            })), !Ue) {
              const _n = {
                verbosity: Qe,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              Ue = _n.port ? PDFWorker.fromPort(_n) : new PDFWorker(_n), Ce._worker = Ue;
            }
            const ln = {
              docId: Ne,
              apiVersion: "3.11.174",
              data: Be,
              password: He,
              disableAutoFetch: qt,
              rangeChunkSize: Ze,
              length: mn,
              docBaseUrl: Je,
              enableXfa: Tt,
              evaluatorOptions: {
                maxImageSize: je,
                disableFontFace: Ye,
                ignoreErrors: Re,
                isEvalSupported: Fe,
                isOffscreenCanvasSupported: $e,
                canvasMaxAreaInBytes: qe,
                fontExtraProperties: Ke,
                useSystemFonts: en,
                cMapUrl: pn ? Ot : null,
                standardFontDataUrl: pn ? we : null
              }
            }, sn = {
              ignoreErrors: Re,
              isEvalSupported: Fe,
              disableFontFace: Ye,
              fontExtraProperties: Ke,
              enableXfa: Tt,
              ownerDocument: pt,
              disableAutoFetch: qt,
              pdfBug: nn,
              styleElement: jt
            };
            return Ue.promise.then(function() {
              if (Ce.destroyed)
                throw new Error("Loading aborted");
              const _n = _fetchDocument(Ue, ln), un = new Promise(function(En) {
                let wn;
                Ge ? wn = new _transport_stream.PDFDataTransportStream({
                  length: mn,
                  initialData: Ge.initialData,
                  progressiveDone: Ge.progressiveDone,
                  contentDispositionFilename: Ge.contentDispositionFilename,
                  disableRange: Bt,
                  disableStream: Vt
                }, Ge) : Be || (wn = ((Pn) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Pn) : (0, _display_utils.isValidFetchUrl)(Pn.url) ? new _displayFetch_stream.PDFFetchStream(Pn) : new _displayNetwork.PDFNetworkStream(Pn))({
                  url: Me,
                  length: mn,
                  httpHeaders: We,
                  withCredentials: Le,
                  rangeChunkSize: Ze,
                  disableRange: Bt,
                  disableStream: Vt
                })), En(wn);
              });
              return Promise.all([_n, un]).then(function([En, wn]) {
                if (Ce.destroyed)
                  throw new Error("Loading aborted");
                const Tn = new _message_handler.MessageHandler(Ne, En, Ue.port), Pn = new WorkerTransport(Tn, Ce, wn, sn, Gt);
                Ce._transport = Pn, Tn.send("Ready", null);
              });
            }).catch(Ce._capability.reject), Ce;
          }
          async function _fetchDocument(De, Ce) {
            if (De.destroyed)
              throw new Error("Worker was destroyed");
            const Ne = await De.messageHandler.sendWithPromise("GetDocRequest", Ce, Ce.data ? [Ce.data.buffer] : null);
            if (De.destroyed)
              throw new Error("Worker was destroyed");
            return Ne;
          }
          function getUrlProp(De) {
            if (De instanceof URL)
              return De.href;
            try {
              return new URL(De, window.location).href;
            } catch {
              if (_util.isNodeJS && typeof De == "string")
                return De;
            }
            throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
          }
          function getDataProp(De) {
            if (_util.isNodeJS && typeof Buffer < "u" && De instanceof Buffer)
              throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
            if (De instanceof Uint8Array && De.byteLength === De.buffer.byteLength)
              return De;
            if (typeof De == "string")
              return (0, _util.stringToBytes)(De);
            if (typeof De == "object" && !isNaN(De == null ? void 0 : De.length) || (0, _util.isArrayBuffer)(De))
              return new Uint8Array(De);
            throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
          }
          const ee = class ee {
            constructor() {
              this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${Xn(ee, $)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var Ce, Ne, Me;
              this.destroyed = !0;
              try {
                (Ce = this._worker) != null && Ce.port && (this._worker._pendingDestroy = !0), await ((Ne = this._transport) == null ? void 0 : Ne.destroy());
              } catch (Be) {
                throw (Me = this._worker) != null && Me.port && delete this._worker._pendingDestroy, Be;
              }
              this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          $ = new WeakMap(), Rt(ee, $, 0);
          let PDFDocumentLoadingTask = ee;
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(Ce, Ne, Me = !1, Be = null) {
              this.length = Ce, this.initialData = Ne, this.progressiveDone = Me, this.contentDispositionFilename = Be, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
            }
            addRangeListener(Ce) {
              this._rangeListeners.push(Ce);
            }
            addProgressListener(Ce) {
              this._progressListeners.push(Ce);
            }
            addProgressiveReadListener(Ce) {
              this._progressiveReadListeners.push(Ce);
            }
            addProgressiveDoneListener(Ce) {
              this._progressiveDoneListeners.push(Ce);
            }
            onDataRange(Ce, Ne) {
              for (const Me of this._rangeListeners)
                Me(Ce, Ne);
            }
            onDataProgress(Ce, Ne) {
              this._readyCapability.promise.then(() => {
                for (const Me of this._progressListeners)
                  Me(Ce, Ne);
              });
            }
            onDataProgressiveRead(Ce) {
              this._readyCapability.promise.then(() => {
                for (const Ne of this._progressiveReadListeners)
                  Ne(Ce);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const Ce of this._progressiveDoneListeners)
                  Ce();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(Ce, Ne) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(Ce, Ne) {
              this._pdfInfo = Ce, this._transport = Ne, Object.defineProperty(this, "getJavaScript", {
                value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((Me) => {
                  if (!Me)
                    return Me;
                  const Be = [];
                  for (const We in Me)
                    Be.push(...Me[We]);
                  return Be;
                }))
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(Ce) {
              return this._transport.getPage(Ce);
            }
            getPageIndex(Ce) {
              return this._transport.getPageIndex(Ce);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(Ce) {
              return this._transport.getDestination(Ce);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            saveDocument() {
              return this._transport.saveDocument();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(Ce = !1) {
              return this._transport.startCleanup(Ce || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(Ce, Ne, Me, Be = !1) {
              Rt(this, re);
              Rt(this, ie);
              Rt(this, te, null);
              Rt(this, ne, !1);
              this._pageIndex = Ce, this._pageInfo = Ne, this._transport = Me, this._stats = Be ? new _display_utils.StatTimer() : null, this._pdfBug = Be, this.commonObjs = Me.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: Ce,
              rotation: Ne = this.rotate,
              offsetX: Me = 0,
              offsetY: Be = 0,
              dontFlip: We = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: Ce,
                rotation: Ne,
                offsetX: Me,
                offsetY: Be,
                dontFlip: We
              });
            }
            getAnnotations({
              intent: Ce = "display"
            } = {}) {
              const Ne = this._transport.getRenderingIntent(Ce);
              return this._transport.getAnnotations(this._pageIndex, Ne.renderingIntent);
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex);
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            async getXfa() {
              var Ce;
              return ((Ce = this._transport._htmlForXfa) == null ? void 0 : Ce.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: Ce,
              viewport: Ne,
              intent: Me = "display",
              annotationMode: Be = _util.AnnotationMode.ENABLE,
              transform: We = null,
              background: Le = null,
              optionalContentConfigPromise: He = null,
              annotationCanvasMap: Ge = null,
              pageColors: Ze = null,
              printAnnotationStorage: Ue = null
            }) {
              var Ae, Re;
              (Ae = this._stats) == null || Ae.time("Overall");
              const Qe = this._transport.getRenderingIntent(Me, Be, Ue);
              zt(this, ne, !1), Nt(this, ie, sr).call(this), He || (He = this._transport.getOptionalContentConfig());
              let Je = this._intentStates.get(Qe.cacheKey);
              Je || (Je = /* @__PURE__ */ Object.create(null), this._intentStates.set(Qe.cacheKey, Je)), Je.streamReaderCancelTimeout && (clearTimeout(Je.streamReaderCancelTimeout), Je.streamReaderCancelTimeout = null);
              const Ot = !!(Qe.renderingIntent & _util.RenderingIntentFlag.PRINT);
              Je.displayReadyCapability || (Je.displayReadyCapability = new _util.PromiseCapability(), Je.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (Re = this._stats) == null || Re.time("Page Request"), this._pumpOperatorList(Qe));
              const At = (je) => {
                var Fe, $e;
                Je.renderTasks.delete(ze), (this._maybeCleanupAfterRender || Ot) && zt(this, ne, !0), Nt(this, re, zn).call(this, !Ot), je ? (ze.capability.reject(je), this._abortOperatorList({
                  intentState: Je,
                  reason: je instanceof Error ? je : new Error(je)
                })) : ze.capability.resolve(), (Fe = this._stats) == null || Fe.timeEnd("Rendering"), ($e = this._stats) == null || $e.timeEnd("Overall");
              }, ze = new InternalRenderTask({
                callback: At,
                params: {
                  canvasContext: Ce,
                  viewport: Ne,
                  transform: We,
                  background: Le
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: Ge,
                operatorList: Je.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: this._transport.canvasFactory,
                filterFactory: this._transport.filterFactory,
                useRequestAnimationFrame: !Ot,
                pdfBug: this._pdfBug,
                pageColors: Ze
              });
              (Je.renderTasks || (Je.renderTasks = /* @__PURE__ */ new Set())).add(ze);
              const we = ze.task;
              return Promise.all([Je.displayReadyCapability.promise, He]).then(([je, Fe]) => {
                var $e;
                if (this.destroyed) {
                  At();
                  return;
                }
                ($e = this._stats) == null || $e.time("Rendering"), ze.initializeGraphics({
                  transparency: je,
                  optionalContentConfig: Fe
                }), ze.operatorListChanged();
              }).catch(At), we;
            }
            getOperatorList({
              intent: Ce = "display",
              annotationMode: Ne = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: Me = null
            } = {}) {
              var Ge;
              function Be() {
                Le.operatorList.lastChunk && (Le.opListReadCapability.resolve(Le.operatorList), Le.renderTasks.delete(He));
              }
              const We = this._transport.getRenderingIntent(Ce, Ne, Me, !0);
              let Le = this._intentStates.get(We.cacheKey);
              Le || (Le = /* @__PURE__ */ Object.create(null), this._intentStates.set(We.cacheKey, Le));
              let He;
              return Le.opListReadCapability || (He = /* @__PURE__ */ Object.create(null), He.operatorListChanged = Be, Le.opListReadCapability = new _util.PromiseCapability(), (Le.renderTasks || (Le.renderTasks = /* @__PURE__ */ new Set())).add(He), Le.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (Ge = this._stats) == null || Ge.time("Page Request"), this._pumpOperatorList(We)), Le.opListReadCapability.promise;
            }
            streamTextContent({
              includeMarkedContent: Ce = !1,
              disableNormalization: Ne = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                includeMarkedContent: Ce === !0,
                disableNormalization: Ne === !0
              }, {
                highWaterMark: 100,
                size(Be) {
                  return Be.items.length;
                }
              });
            }
            getTextContent(Ce = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((Me) => _xfa_text.XfaText.textContent(Me));
              const Ne = this.streamTextContent(Ce);
              return new Promise(function(Me, Be) {
                function We() {
                  Le.read().then(function({
                    value: Ge,
                    done: Ze
                  }) {
                    if (Ze) {
                      Me(He);
                      return;
                    }
                    Object.assign(He.styles, Ge.styles), He.items.push(...Ge.items), We();
                  }, Be);
                }
                const Le = Ne.getReader(), He = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                We();
              });
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex);
            }
            _destroy() {
              this.destroyed = !0;
              const Ce = [];
              for (const Ne of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: Ne,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !Ne.opListReadCapability)
                  for (const Me of Ne.renderTasks)
                    Ce.push(Me.completed), Me.cancel();
              return this.objs.clear(), zt(this, ne, !1), Nt(this, ie, sr).call(this), Promise.all(Ce);
            }
            cleanup(Ce = !1) {
              zt(this, ne, !0);
              const Ne = Nt(this, re, zn).call(this, !1);
              return Ce && Ne && this._stats && (this._stats = new _display_utils.StatTimer()), Ne;
            }
            _startRenderPage(Ce, Ne) {
              var Be, We;
              const Me = this._intentStates.get(Ne);
              Me && ((Be = this._stats) == null || Be.timeEnd("Page Request"), (We = Me.displayReadyCapability) == null || We.resolve(Ce));
            }
            _renderPageChunk(Ce, Ne) {
              for (let Me = 0, Be = Ce.length; Me < Be; Me++)
                Ne.operatorList.fnArray.push(Ce.fnArray[Me]), Ne.operatorList.argsArray.push(Ce.argsArray[Me]);
              Ne.operatorList.lastChunk = Ce.lastChunk, Ne.operatorList.separateAnnots = Ce.separateAnnots;
              for (const Me of Ne.renderTasks)
                Me.operatorListChanged();
              Ce.lastChunk && Nt(this, re, zn).call(this, !0);
            }
            _pumpOperatorList({
              renderingIntent: Ce,
              cacheKey: Ne,
              annotationStorageSerializable: Me
            }) {
              const {
                map: Be,
                transfers: We
              } = Me, He = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: Ce,
                cacheKey: Ne,
                annotationStorage: Be
              }, We).getReader(), Ge = this._intentStates.get(Ne);
              Ge.streamReader = He;
              const Ze = () => {
                He.read().then(({
                  value: Ue,
                  done: Qe
                }) => {
                  if (Qe) {
                    Ge.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(Ue, Ge), Ze());
                }, (Ue) => {
                  if (Ge.streamReader = null, !this._transport.destroyed) {
                    if (Ge.operatorList) {
                      Ge.operatorList.lastChunk = !0;
                      for (const Qe of Ge.renderTasks)
                        Qe.operatorListChanged();
                      Nt(this, re, zn).call(this, !0);
                    }
                    if (Ge.displayReadyCapability)
                      Ge.displayReadyCapability.reject(Ue);
                    else if (Ge.opListReadCapability)
                      Ge.opListReadCapability.reject(Ue);
                    else
                      throw Ue;
                  }
                });
              };
              Ze();
            }
            _abortOperatorList({
              intentState: Ce,
              reason: Ne,
              force: Me = !1
            }) {
              if (Ce.streamReader) {
                if (Ce.streamReaderCancelTimeout && (clearTimeout(Ce.streamReaderCancelTimeout), Ce.streamReaderCancelTimeout = null), !Me) {
                  if (Ce.renderTasks.size > 0)
                    return;
                  if (Ne instanceof _display_utils.RenderingCancelledException) {
                    let Be = RENDERING_CANCELLED_TIMEOUT;
                    Ne.extraDelay > 0 && Ne.extraDelay < 1e3 && (Be += Ne.extraDelay), Ce.streamReaderCancelTimeout = setTimeout(() => {
                      Ce.streamReaderCancelTimeout = null, this._abortOperatorList({
                        intentState: Ce,
                        reason: Ne,
                        force: !0
                      });
                    }, Be);
                    return;
                  }
                }
                if (Ce.streamReader.cancel(new _util.AbortException(Ne.message)).catch(() => {
                }), Ce.streamReader = null, !this._transport.destroyed) {
                  for (const [Be, We] of this._intentStates)
                    if (We === Ce) {
                      this._intentStates.delete(Be);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          te = new WeakMap(), ne = new WeakMap(), re = new WeakSet(), zn = function(Ce = !1) {
            if (Nt(this, ie, sr).call(this), !Oe(this, ne) || this.destroyed)
              return !1;
            if (Ce)
              return zt(this, te, setTimeout(() => {
                zt(this, te, null), Nt(this, re, zn).call(this, !1);
              }, DELAYED_CLEANUP_TIMEOUT)), !1;
            for (const {
              renderTasks: Ne,
              operatorList: Me
            } of this._intentStates.values())
              if (Ne.size > 0 || !Me.lastChunk)
                return !1;
            return this._intentStates.clear(), this.objs.clear(), zt(this, ne, !1), !0;
          }, ie = new WeakSet(), sr = function() {
            Oe(this, te) && (clearTimeout(Oe(this, te)), zt(this, te, null));
          }, exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              Rt(this, le, /* @__PURE__ */ new Set());
              Rt(this, ue, Promise.resolve());
            }
            postMessage(Ce, Ne) {
              const Me = {
                data: structuredClone(Ce, Ne ? {
                  transfer: Ne
                } : null)
              };
              Oe(this, ue).then(() => {
                for (const Be of Oe(this, le))
                  Be.call(this, Me);
              });
            }
            addEventListener(Ce, Ne) {
              Oe(this, le).add(Ne);
            }
            removeEventListener(Ce, Ne) {
              Oe(this, le).delete(Ne);
            }
            terminate() {
              Oe(this, le).clear();
            }
          }
          le = new WeakMap(), ue = new WeakMap(), exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_util.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const De = (de = document == null ? void 0 : document.currentScript) == null ? void 0 : de.src;
              De && (PDFWorkerUtil.fallbackWorkerSrc = De.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(De, Ce) {
              let Ne;
              try {
                if (Ne = new URL(De), !Ne.origin || Ne.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const Me = new URL(Ce, Ne);
              return Ne.origin === Me.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(De) {
              const Ce = `importScripts("${De}");`;
              return URL.createObjectURL(new Blob([Ce]));
            };
          }
          const _PDFWorker = class _PDFWorker {
            constructor({
              name: De = null,
              port: Ce = null,
              verbosity: Ne = (0, _util.getVerbosityLevel)()
            } = {}) {
              var Me;
              if (this.name = De, this.destroyed = !1, this.verbosity = Ne, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, Ce) {
                if ((Me = Oe(_PDFWorker, fe)) != null && Me.has(Ce))
                  throw new Error("Cannot use more than one PDFWorker per port.");
                (Oe(_PDFWorker, fe) || zt(_PDFWorker, fe, /* @__PURE__ */ new WeakMap())).set(Ce, this), this._initializeFromPort(Ce);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(De) {
              this._port = De, this._messageHandler = new _message_handler.MessageHandler("main", "worker", De), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: De
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, De) || (De = PDFWorkerUtil.createCDNWrapper(new URL(De, window.location).href));
                  const Ce = new Worker(De), Ne = new _message_handler.MessageHandler("main", "worker", Ce), Me = () => {
                    Ce.removeEventListener("error", Be), Ne.destroy(), Ce.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, Be = () => {
                    this._webWorker || Me();
                  };
                  Ce.addEventListener("error", Be), Ne.on("test", (Le) => {
                    if (Ce.removeEventListener("error", Be), this.destroyed) {
                      Me();
                      return;
                    }
                    Le ? (this._messageHandler = Ne, this._port = Ce, this._webWorker = Ce, this._readyCapability.resolve(), Ne.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), Ne.destroy(), Ce.terminate());
                  }), Ne.on("ready", (Le) => {
                    if (Ce.removeEventListener("error", Be), this.destroyed) {
                      Me();
                      return;
                    }
                    try {
                      We();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const We = () => {
                    const Le = new Uint8Array();
                    Ne.send("test", Le, [Le.buffer]);
                  };
                  We();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((De) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const Ce = new LoopbackPort();
                this._port = Ce;
                const Ne = `fake${PDFWorkerUtil.fakeWorkerId++}`, Me = new _message_handler.MessageHandler(Ne + "_worker", Ne, Ce);
                De.setup(Me, Ce);
                const Be = new _message_handler.MessageHandler(Ne, Ne + "_worker", Ce);
                this._messageHandler = Be, this._readyCapability.resolve(), Be.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((De) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${De.message}".`));
              });
            }
            destroy() {
              var De;
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (De = Oe(_PDFWorker, fe)) == null || De.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(De) {
              var Ne;
              if (!(De != null && De.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              const Ce = (Ne = Oe(this, fe)) == null ? void 0 : Ne.get(De.port);
              if (Ce) {
                if (Ce._pendingDestroy)
                  throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                return Ce;
              }
              return new _PDFWorker(De);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var De;
              try {
                return ((De = globalThis.pdfjsWorker) == null ? void 0 : De.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_util.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          fe = new WeakMap(), Rt(_PDFWorker, fe, void 0);
          let PDFWorker = _PDFWorker;
          exports.PDFWorker = PDFWorker;
          class WorkerTransport {
            constructor(Ce, Ne, Me, Be, We) {
              Rt(this, ge);
              Rt(this, pe, /* @__PURE__ */ new Map());
              Rt(this, ye, /* @__PURE__ */ new Map());
              Rt(this, me, /* @__PURE__ */ new Map());
              Rt(this, ve, null);
              this.messageHandler = Ce, this.loadingTask = Ne, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                ownerDocument: Be.ownerDocument,
                styleElement: Be.styleElement
              }), this._params = Be, this.canvasFactory = We.canvasFactory, this.filterFactory = We.filterFactory, this.cMapReaderFactory = We.cMapReaderFactory, this.standardFontDataFactory = We.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = Me, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            getRenderingIntent(Ce, Ne = _util.AnnotationMode.ENABLE, Me = null, Be = !1) {
              let We = _util.RenderingIntentFlag.DISPLAY, Le = _annotation_storage.SerializableEmpty;
              switch (Ce) {
                case "any":
                  We = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  We = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${Ce}`);
              }
              switch (Ne) {
                case _util.AnnotationMode.DISABLE:
                  We += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  We += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  We += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, Le = (We & _util.RenderingIntentFlag.PRINT && Me instanceof _annotation_storage.PrintAnnotationStorage ? Me : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${Ne}`);
              }
              return Be && (We += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: We,
                cacheKey: `${We}_${Le.hash}`,
                annotationStorageSerializable: Le
              };
            }
            destroy() {
              var Me;
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (Me = Oe(this, ve)) == null || Me.reject(new Error("Worker was destroyed during onPassword callback"));
              const Ce = [];
              for (const Be of Oe(this, ye).values())
                Ce.push(Be._destroy());
              Oe(this, ye).clear(), Oe(this, me).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const Ne = this.messageHandler.sendWithPromise("Terminate", null);
              return Ce.push(Ne), Promise.all(Ce).then(() => {
                var Be;
                this.commonObjs.clear(), this.fontLoader.clear(), Oe(this, pe).clear(), this.filterFactory.destroy(), (Be = this._networkStream) == null || Be.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: Ce,
                loadingTask: Ne
              } = this;
              Ce.on("GetReader", (Me, Be) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (We) => {
                  this._lastProgress = {
                    loaded: We.loaded,
                    total: We.total
                  };
                }, Be.onPull = () => {
                  this._fullReader.read().then(function({
                    value: We,
                    done: Le
                  }) {
                    if (Le) {
                      Be.close();
                      return;
                    }
                    (0, _util.assert)(We instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), Be.enqueue(new Uint8Array(We), 1, [We]);
                  }).catch((We) => {
                    Be.error(We);
                  });
                }, Be.onCancel = (We) => {
                  this._fullReader.cancel(We), Be.ready.catch((Le) => {
                    if (!this.destroyed)
                      throw Le;
                  });
                };
              }), Ce.on("ReaderHeadersReady", (Me) => {
                const Be = new _util.PromiseCapability(), We = this._fullReader;
                return We.headersReady.then(() => {
                  var Le;
                  (!We.isStreamingSupported || !We.isRangeSupported) && (this._lastProgress && ((Le = Ne.onProgress) == null || Le.call(Ne, this._lastProgress)), We.onProgress = (He) => {
                    var Ge;
                    (Ge = Ne.onProgress) == null || Ge.call(Ne, {
                      loaded: He.loaded,
                      total: He.total
                    });
                  }), Be.resolve({
                    isStreamingSupported: We.isStreamingSupported,
                    isRangeSupported: We.isRangeSupported,
                    contentLength: We.contentLength
                  });
                }, Be.reject), Be.promise;
              }), Ce.on("GetRangeReader", (Me, Be) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const We = this._networkStream.getRangeReader(Me.begin, Me.end);
                if (!We) {
                  Be.close();
                  return;
                }
                Be.onPull = () => {
                  We.read().then(function({
                    value: Le,
                    done: He
                  }) {
                    if (He) {
                      Be.close();
                      return;
                    }
                    (0, _util.assert)(Le instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), Be.enqueue(new Uint8Array(Le), 1, [Le]);
                  }).catch((Le) => {
                    Be.error(Le);
                  });
                }, Be.onCancel = (Le) => {
                  We.cancel(Le), Be.ready.catch((He) => {
                    if (!this.destroyed)
                      throw He;
                  });
                };
              }), Ce.on("GetDoc", ({
                pdfInfo: Me
              }) => {
                this._numPages = Me.numPages, this._htmlForXfa = Me.htmlForXfa, delete Me.htmlForXfa, Ne._capability.resolve(new PDFDocumentProxy(Me, this));
              }), Ce.on("DocException", function(Me) {
                let Be;
                switch (Me.name) {
                  case "PasswordException":
                    Be = new _util.PasswordException(Me.message, Me.code);
                    break;
                  case "InvalidPDFException":
                    Be = new _util.InvalidPDFException(Me.message);
                    break;
                  case "MissingPDFException":
                    Be = new _util.MissingPDFException(Me.message);
                    break;
                  case "UnexpectedResponseException":
                    Be = new _util.UnexpectedResponseException(Me.message, Me.status);
                    break;
                  case "UnknownErrorException":
                    Be = new _util.UnknownErrorException(Me.message, Me.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                Ne._capability.reject(Be);
              }), Ce.on("PasswordRequest", (Me) => {
                if (zt(this, ve, new _util.PromiseCapability()), Ne.onPassword) {
                  const Be = (We) => {
                    We instanceof Error ? Oe(this, ve).reject(We) : Oe(this, ve).resolve({
                      password: We
                    });
                  };
                  try {
                    Ne.onPassword(Be, Me.code);
                  } catch (We) {
                    Oe(this, ve).reject(We);
                  }
                } else
                  Oe(this, ve).reject(new _util.PasswordException(Me.message, Me.code));
                return Oe(this, ve).promise;
              }), Ce.on("DataLoaded", (Me) => {
                var Be;
                (Be = Ne.onProgress) == null || Be.call(Ne, {
                  loaded: Me.length,
                  total: Me.length
                }), this.downloadInfoCapability.resolve(Me);
              }), Ce.on("StartRenderPage", (Me) => {
                if (this.destroyed)
                  return;
                Oe(this, ye).get(Me.pageIndex)._startRenderPage(Me.transparency, Me.cacheKey);
              }), Ce.on("commonobj", ([Me, Be, We]) => {
                var Le;
                if (!this.destroyed && !this.commonObjs.has(Me))
                  switch (Be) {
                    case "Font":
                      const He = this._params;
                      if ("error" in We) {
                        const Ue = We.error;
                        (0, _util.warn)(`Error during font loading: ${Ue}`), this.commonObjs.resolve(Me, Ue);
                        break;
                      }
                      const Ge = He.pdfBug && ((Le = globalThis.FontInspector) != null && Le.enabled) ? (Ue, Qe) => globalThis.FontInspector.fontAdded(Ue, Qe) : null, Ze = new _font_loader.FontFaceObject(We, {
                        isEvalSupported: He.isEvalSupported,
                        disableFontFace: He.disableFontFace,
                        ignoreErrors: He.ignoreErrors,
                        inspectFont: Ge
                      });
                      this.fontLoader.bind(Ze).catch((Ue) => Ce.sendWithPromise("FontFallback", {
                        id: Me
                      })).finally(() => {
                        !He.fontExtraProperties && Ze.data && (Ze.data = null), this.commonObjs.resolve(Me, Ze);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                    case "Pattern":
                      this.commonObjs.resolve(Me, We);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${Be}`);
                  }
              }), Ce.on("obj", ([Me, Be, We, Le]) => {
                var Ge;
                if (this.destroyed)
                  return;
                const He = Oe(this, ye).get(Be);
                if (!He.objs.has(Me))
                  switch (We) {
                    case "Image":
                      if (He.objs.resolve(Me, Le), Le) {
                        let Ze;
                        if (Le.bitmap) {
                          const {
                            width: Ue,
                            height: Qe
                          } = Le;
                          Ze = Ue * Qe * 4;
                        } else
                          Ze = ((Ge = Le.data) == null ? void 0 : Ge.length) || 0;
                        Ze > _util.MAX_IMAGE_SIZE_TO_CACHE && (He._maybeCleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      He.objs.resolve(Me, Le);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${We}`);
                  }
              }), Ce.on("DocProgress", (Me) => {
                var Be;
                this.destroyed || (Be = Ne.onProgress) == null || Be.call(Ne, {
                  loaded: Me.loaded,
                  total: Me.total
                });
              }), Ce.on("FetchBuiltInCMap", (Me) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(Me) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), Ce.on("FetchStandardFontData", (Me) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(Me) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            saveDocument() {
              var Me;
              this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
              const {
                map: Ce,
                transfers: Ne
              } = this.annotationStorage.serializable;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: Ce,
                filename: ((Me = this._fullReader) == null ? void 0 : Me.filename) ?? null
              }, Ne).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getPage(Ce) {
              if (!Number.isInteger(Ce) || Ce <= 0 || Ce > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const Ne = Ce - 1, Me = Oe(this, me).get(Ne);
              if (Me)
                return Me;
              const Be = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: Ne
              }).then((We) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const Le = new PDFPageProxy(Ne, We, this, this._params.pdfBug);
                return Oe(this, ye).set(Ne, Le), Le;
              });
              return Oe(this, me).set(Ne, Be), Be;
            }
            getPageIndex(Ce) {
              return typeof Ce != "object" || Ce === null || !Number.isInteger(Ce.num) || Ce.num < 0 || !Number.isInteger(Ce.gen) || Ce.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: Ce.num,
                gen: Ce.gen
              });
            }
            getAnnotations(Ce, Ne) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: Ce,
                intent: Ne
              });
            }
            getFieldObjects() {
              return Nt(this, ge, ir).call(this, "GetFieldObjects");
            }
            hasJSActions() {
              return Nt(this, ge, ir).call(this, "HasJSActions");
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(Ce) {
              return typeof Ce != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: Ce
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getDocJSActions() {
              return Nt(this, ge, ir).call(this, "GetDocJSActions");
            }
            getPageJSActions(Ce) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: Ce
              });
            }
            getStructTree(Ce) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: Ce
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((Ce) => new _optional_content_config.OptionalContentConfig(Ce));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              const Ce = "GetMetadata", Ne = Oe(this, pe).get(Ce);
              if (Ne)
                return Ne;
              const Me = this.messageHandler.sendWithPromise(Ce, null).then((Be) => {
                var We, Le;
                return {
                  info: Be[0],
                  metadata: Be[1] ? new _metadata.Metadata(Be[1]) : null,
                  contentDispositionFilename: ((We = this._fullReader) == null ? void 0 : We.filename) ?? null,
                  contentLength: ((Le = this._fullReader) == null ? void 0 : Le.contentLength) ?? null
                };
              });
              return Oe(this, pe).set(Ce, Me), Me;
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(Ce = !1) {
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const Ne of Oe(this, ye).values())
                  if (!Ne.cleanup())
                    throw new Error(`startCleanup: Page ${Ne.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), Ce || this.fontLoader.clear(), Oe(this, pe).clear(), this.filterFactory.destroy(!0);
              }
            }
            get loadingParams() {
              const {
                disableAutoFetch: Ce,
                enableXfa: Ne
              } = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: Ce,
                enableXfa: Ne
              });
            }
          }
          pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakSet(), ir = function(Ce, Ne = null) {
            const Me = Oe(this, pe).get(Ce);
            if (Me)
              return Me;
            const Be = this.messageHandler.sendWithPromise(Ce, Ne);
            return Oe(this, pe).set(Ce, Be), Be;
          };
          class PDFObjects {
            constructor() {
              Rt(this, Te);
              Rt(this, Ee, /* @__PURE__ */ Object.create(null));
            }
            get(Ce, Ne = null) {
              if (Ne) {
                const Be = Nt(this, Te, Sr).call(this, Ce);
                return Be.capability.promise.then(() => Ne(Be.data)), null;
              }
              const Me = Oe(this, Ee)[Ce];
              if (!(Me != null && Me.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${Ce}.`);
              return Me.data;
            }
            has(Ce) {
              const Ne = Oe(this, Ee)[Ce];
              return (Ne == null ? void 0 : Ne.capability.settled) || !1;
            }
            resolve(Ce, Ne = null) {
              const Me = Nt(this, Te, Sr).call(this, Ce);
              Me.data = Ne, Me.capability.resolve();
            }
            clear() {
              var Ce;
              for (const Ne in Oe(this, Ee)) {
                const {
                  data: Me
                } = Oe(this, Ee)[Ne];
                (Ce = Me == null ? void 0 : Me.bitmap) == null || Ce.close();
              }
              zt(this, Ee, /* @__PURE__ */ Object.create(null));
            }
          }
          Ee = new WeakMap(), Te = new WeakSet(), Sr = function(Ce) {
            var Ne;
            return (Ne = Oe(this, Ee))[Ce] || (Ne[Ce] = {
              capability: new _util.PromiseCapability(),
              data: null
            });
          };
          class RenderTask {
            constructor(Ce) {
              Rt(this, he, null);
              zt(this, he, Ce), this.onContinue = null;
            }
            get promise() {
              return Oe(this, he).capability.promise;
            }
            cancel(Ce = 0) {
              Oe(this, he).cancel(null, Ce);
            }
            get separateAnnots() {
              const {
                separateAnnots: Ce
              } = Oe(this, he).operatorList;
              if (!Ce)
                return !1;
              const {
                annotationCanvasMap: Ne
              } = Oe(this, he);
              return Ce.form || Ce.canvas && (Ne == null ? void 0 : Ne.size) > 0;
            }
          }
          he = new WeakMap(), exports.RenderTask = RenderTask;
          const Ie = class Ie {
            constructor({
              callback: Ce,
              params: Ne,
              objs: Me,
              commonObjs: Be,
              annotationCanvasMap: We,
              operatorList: Le,
              pageIndex: He,
              canvasFactory: Ge,
              filterFactory: Ze,
              useRequestAnimationFrame: Ue = !1,
              pdfBug: Qe = !1,
              pageColors: Je = null
            }) {
              this.callback = Ce, this.params = Ne, this.objs = Me, this.commonObjs = Be, this.annotationCanvasMap = We, this.operatorListIdx = null, this.operatorList = Le, this._pageIndex = He, this.canvasFactory = Ge, this.filterFactory = Ze, this._pdfBug = Qe, this.pageColors = Je, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = Ue === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = Ne.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: Ce = !1,
              optionalContentConfig: Ne
            }) {
              var He, Ge;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (Oe(Ie, Pe).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                Oe(Ie, Pe).add(this._canvas);
              }
              this._pdfBug && ((He = globalThis.StepperManager) != null && He.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: Me,
                viewport: Be,
                transform: We,
                background: Le
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(Me, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: Ne
              }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: We,
                viewport: Be,
                transparency: Ce,
                background: Le
              }), this.operatorListIdx = 0, this.graphicsReady = !0, (Ge = this.graphicsReadyCallback) == null || Ge.call(this);
            }
            cancel(Ce = null, Ne = 0) {
              var Me;
              this.running = !1, this.cancelled = !0, (Me = this.gfx) == null || Me.endDrawing(), Oe(Ie, Pe).delete(this._canvas), this.callback(Ce || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, Ne));
            }
            operatorListChanged() {
              var Ce;
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              (Ce = this.stepper) == null || Ce.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), Oe(Ie, Pe).delete(this._canvas), this.callback())));
            }
          };
          Pe = new WeakMap(), Rt(Ie, Pe, /* @__PURE__ */ new WeakSet());
          let InternalRenderTask = Ie;
          const version = "3.11.174";
          exports.version = version;
          const build = "ce8716743";
          exports.build = build;
        },
        /* 3 */
        /***/
        ($, ee, te) => {
          var ue, de, fe, rs, ye;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.SerializableEmpty = ee.PrintAnnotationStorage = ee.AnnotationStorage = void 0;
          var ne = te(1), re = te(4), se = te(8);
          const ie = Object.freeze({
            map: null,
            hash: "",
            transfers: void 0
          });
          ee.SerializableEmpty = ie;
          class oe {
            constructor() {
              Rt(this, fe);
              Rt(this, ue, !1);
              Rt(this, de, /* @__PURE__ */ new Map());
              this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(ve, ge) {
              const xe = Oe(this, de).get(ve);
              return xe === void 0 ? ge : Object.assign(ge, xe);
            }
            getRawValue(ve) {
              return Oe(this, de).get(ve);
            }
            remove(ve) {
              if (Oe(this, de).delete(ve), Oe(this, de).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const ge of Oe(this, de).values())
                  if (ge instanceof re.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(ve, ge) {
              const xe = Oe(this, de).get(ve);
              let Ee = !1;
              if (xe !== void 0)
                for (const [Te, Se] of Object.entries(ge))
                  xe[Te] !== Se && (Ee = !0, xe[Te] = Se);
              else
                Ee = !0, Oe(this, de).set(ve, ge);
              Ee && Nt(this, fe, rs).call(this), ge instanceof re.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(ge.constructor._type);
            }
            has(ve) {
              return Oe(this, de).has(ve);
            }
            getAll() {
              return Oe(this, de).size > 0 ? (0, ne.objectFromMap)(Oe(this, de)) : null;
            }
            setAll(ve) {
              for (const [ge, xe] of Object.entries(ve))
                this.setValue(ge, xe);
            }
            get size() {
              return Oe(this, de).size;
            }
            resetModified() {
              Oe(this, ue) && (zt(this, ue, !1), typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new le(this);
            }
            get serializable() {
              if (Oe(this, de).size === 0)
                return ie;
              const ve = /* @__PURE__ */ new Map(), ge = new se.MurmurHash3_64(), xe = [], Ee = /* @__PURE__ */ Object.create(null);
              let Te = !1;
              for (const [Se, he] of Oe(this, de)) {
                const Pe = he instanceof re.AnnotationEditor ? he.serialize(!1, Ee) : he;
                Pe && (ve.set(Se, Pe), ge.update(`${Se}:${JSON.stringify(Pe)}`), Te || (Te = !!Pe.bitmap));
              }
              if (Te)
                for (const Se of ve.values())
                  Se.bitmap && xe.push(Se.bitmap);
              return ve.size > 0 ? {
                map: ve,
                hash: ge.hexdigest(),
                transfers: xe
              } : ie;
            }
          }
          ue = new WeakMap(), de = new WeakMap(), fe = new WeakSet(), rs = function() {
            Oe(this, ue) || (zt(this, ue, !0), typeof this.onSetModified == "function" && this.onSetModified());
          }, ee.AnnotationStorage = oe;
          class le extends oe {
            constructor(ge) {
              super();
              Rt(this, ye, void 0);
              const {
                map: xe,
                hash: Ee,
                transfers: Te
              } = ge.serializable, Se = structuredClone(xe, Te ? {
                transfer: Te
              } : null);
              zt(this, ye, {
                map: Se,
                hash: Ee,
                transfers: Te
              });
            }
            get print() {
              (0, ne.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return Oe(this, ye);
            }
          }
          ye = new WeakMap(), ee.PrintAnnotationStorage = le;
        },
        /* 4 */
        /***/
        ($, ee, te) => {
          var le, ue, de, fe, pe, ye, me, ve, ge, xe, Ee, Te, Se, he, Pe, Tr, De, Pr, Ne, Cr, Be, wr, Le, ss, Ge, is, Ue, os, Je, Rr, At, ls;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.AnnotationEditor = void 0;
          var ne = te(5), re = te(1), se = te(6);
          const we = class we {
            constructor(Re) {
              Rt(this, Pe);
              Rt(this, De);
              Rt(this, Be);
              Rt(this, Le);
              Rt(this, Ge);
              Rt(this, Ue);
              Rt(this, Je);
              Rt(this, At);
              Rt(this, le, "");
              Rt(this, ue, !1);
              Rt(this, de, null);
              Rt(this, fe, null);
              Rt(this, pe, null);
              Rt(this, ye, !1);
              Rt(this, me, null);
              Rt(this, ve, this.focusin.bind(this));
              Rt(this, ge, this.focusout.bind(this));
              Rt(this, xe, !1);
              Rt(this, Ee, !1);
              Rt(this, Te, !1);
              On(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
              On(this, "_uiManager", null);
              On(this, "_focusEventsAllowed", !0);
              On(this, "_l10nPromise", null);
              Rt(this, Se, !1);
              Rt(this, he, we._zIndex++);
              this.constructor === we && (0, re.unreachable)("Cannot initialize AnnotationEditor."), this.parent = Re.parent, this.id = Re.id, this.width = this.height = null, this.pageIndex = Re.parent.pageIndex, this.name = Re.name, this.div = null, this._uiManager = Re.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = Re.isCentered, this._structTreeParentId = null;
              const {
                rotation: je,
                rawDims: {
                  pageWidth: Fe,
                  pageHeight: $e,
                  pageX: qe,
                  pageY: Ye
                }
              } = this.parent.viewport;
              this.rotation = je, this.pageRotation = (360 + je - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [Fe, $e], this.pageTranslation = [qe, Ye];
              const [Ke, Tt] = this.parentDimensions;
              this.x = Re.x / Ke, this.y = Re.y / Tt, this.isAttachedToDOM = !1, this.deleted = !1;
            }
            get editorType() {
              return Object.getPrototypeOf(this).constructor._type;
            }
            static get _defaultLineColor() {
              return (0, re.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            static deleteAnnotationElement(Re) {
              const je = new oe({
                id: Re.parent.getNextId(),
                parent: Re.parent,
                uiManager: Re._uiManager
              });
              je.annotationElementId = Re.annotationElementId, je.deleted = !0, je._uiManager.addToAnnotationStorage(je);
            }
            static initialize(Re, je = null) {
              if (we._l10nPromise || (we._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map(($e) => [$e, Re.get($e)]))), je != null && je.strings)
                for (const $e of je.strings)
                  we._l10nPromise.set($e, Re.get($e));
              if (we._borderLineWidth !== -1)
                return;
              const Fe = getComputedStyle(document.documentElement);
              we._borderLineWidth = parseFloat(Fe.getPropertyValue("--outline-width")) || 0;
            }
            static updateDefaultParams(Re, je) {
            }
            static get defaultPropertiesToUpdate() {
              return [];
            }
            static isHandlingMimeForPasting(Re) {
              return !1;
            }
            static paste(Re, je) {
              (0, re.unreachable)("Not implemented");
            }
            get propertiesToUpdate() {
              return [];
            }
            get _isDraggable() {
              return Oe(this, Se);
            }
            set _isDraggable(Re) {
              var je;
              zt(this, Se, Re), (je = this.div) == null || je.classList.toggle("draggable", Re);
            }
            center() {
              const [Re, je] = this.pageDimensions;
              switch (this.parentRotation) {
                case 90:
                  this.x -= this.height * je / (Re * 2), this.y += this.width * Re / (je * 2);
                  break;
                case 180:
                  this.x += this.width / 2, this.y += this.height / 2;
                  break;
                case 270:
                  this.x += this.height * je / (Re * 2), this.y -= this.width * Re / (je * 2);
                  break;
                default:
                  this.x -= this.width / 2, this.y -= this.height / 2;
                  break;
              }
              this.fixAndSetPosition();
            }
            addCommands(Re) {
              this._uiManager.addCommands(Re);
            }
            get currentLayer() {
              return this._uiManager.currentLayer;
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = Oe(this, he);
            }
            setParent(Re) {
              Re !== null && (this.pageIndex = Re.pageIndex, this.pageDimensions = Re.pageDimensions), this.parent = Re;
            }
            focusin(Re) {
              this._focusEventsAllowed && (Oe(this, xe) ? zt(this, xe, !1) : this.parent.setSelected(this));
            }
            focusout(Re) {
              var Fe;
              if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                return;
              const je = Re.relatedTarget;
              je != null && je.closest(`#${this.id}`) || (Re.preventDefault(), (Fe = this.parent) != null && Fe.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.addToAnnotationStorage();
            }
            addToAnnotationStorage() {
              this._uiManager.addToAnnotationStorage(this);
            }
            setAt(Re, je, Fe, $e) {
              const [qe, Ye] = this.parentDimensions;
              [Fe, $e] = this.screenToPageTranslation(Fe, $e), this.x = (Re + Fe) / qe, this.y = (je + $e) / Ye, this.fixAndSetPosition();
            }
            translate(Re, je) {
              Nt(this, Pe, Tr).call(this, this.parentDimensions, Re, je);
            }
            translateInPage(Re, je) {
              Nt(this, Pe, Tr).call(this, this.pageDimensions, Re, je), this.div.scrollIntoView({
                block: "nearest"
              });
            }
            drag(Re, je) {
              const [Fe, $e] = this.parentDimensions;
              if (this.x += Re / Fe, this.y += je / $e, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                const {
                  x: pt,
                  y: Bt
                } = this.div.getBoundingClientRect();
                this.parent.findNewParent(this, pt, Bt) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
              }
              let {
                x: qe,
                y: Ye
              } = this;
              const [Ke, Tt] = Nt(this, De, Pr).call(this);
              qe += Ke, Ye += Tt, this.div.style.left = `${(100 * qe).toFixed(2)}%`, this.div.style.top = `${(100 * Ye).toFixed(2)}%`, this.div.scrollIntoView({
                block: "nearest"
              });
            }
            fixAndSetPosition() {
              const [Re, je] = this.pageDimensions;
              let {
                x: Fe,
                y: $e,
                width: qe,
                height: Ye
              } = this;
              switch (qe *= Re, Ye *= je, Fe *= Re, $e *= je, this.rotation) {
                case 0:
                  Fe = Math.max(0, Math.min(Re - qe, Fe)), $e = Math.max(0, Math.min(je - Ye, $e));
                  break;
                case 90:
                  Fe = Math.max(0, Math.min(Re - Ye, Fe)), $e = Math.min(je, Math.max(qe, $e));
                  break;
                case 180:
                  Fe = Math.min(Re, Math.max(qe, Fe)), $e = Math.min(je, Math.max(Ye, $e));
                  break;
                case 270:
                  Fe = Math.min(Re, Math.max(Ye, Fe)), $e = Math.max(0, Math.min(je - qe, $e));
                  break;
              }
              this.x = Fe /= Re, this.y = $e /= je;
              const [Ke, Tt] = Nt(this, De, Pr).call(this);
              Fe += Ke, $e += Tt;
              const {
                style: pt
              } = this.div;
              pt.left = `${(100 * Fe).toFixed(2)}%`, pt.top = `${(100 * $e).toFixed(2)}%`, this.moveInDOM();
            }
            screenToPageTranslation(Re, je) {
              var Fe;
              return Nt(Fe = we, Ne, Cr).call(Fe, Re, je, this.parentRotation);
            }
            pageTranslationToScreen(Re, je) {
              var Fe;
              return Nt(Fe = we, Ne, Cr).call(Fe, Re, je, 360 - this.parentRotation);
            }
            get parentScale() {
              return this._uiManager.viewParameters.realScale;
            }
            get parentRotation() {
              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
            }
            get parentDimensions() {
              const {
                parentScale: Re,
                pageDimensions: [je, Fe]
              } = this, $e = je * Re, qe = Fe * Re;
              return re.FeatureTest.isCSSRoundSupported ? [Math.round($e), Math.round(qe)] : [$e, qe];
            }
            setDims(Re, je) {
              var qe;
              const [Fe, $e] = this.parentDimensions;
              this.div.style.width = `${(100 * Re / Fe).toFixed(2)}%`, Oe(this, ye) || (this.div.style.height = `${(100 * je / $e).toFixed(2)}%`), (qe = Oe(this, de)) == null || qe.classList.toggle("small", Re < we.SMALL_EDITOR_SIZE || je < we.SMALL_EDITOR_SIZE);
            }
            fixDims() {
              const {
                style: Re
              } = this.div, {
                height: je,
                width: Fe
              } = Re, $e = Fe.endsWith("%"), qe = !Oe(this, ye) && je.endsWith("%");
              if ($e && qe)
                return;
              const [Ye, Ke] = this.parentDimensions;
              $e || (Re.width = `${(100 * parseFloat(Fe) / Ye).toFixed(2)}%`), !Oe(this, ye) && !qe && (Re.height = `${(100 * parseFloat(je) / Ke).toFixed(2)}%`);
            }
            getInitialTranslation() {
              return [0, 0];
            }
            async addAltTextButton() {
              if (Oe(this, de))
                return;
              const Re = zt(this, de, document.createElement("button"));
              Re.className = "altText";
              const je = await we._l10nPromise.get("editor_alt_text_button_label");
              Re.textContent = je, Re.setAttribute("aria-label", je), Re.tabIndex = "0", Re.addEventListener("contextmenu", se.noContextMenu), Re.addEventListener("pointerdown", (Fe) => Fe.stopPropagation()), Re.addEventListener("click", (Fe) => {
                Fe.preventDefault(), this._uiManager.editAltText(this);
              }, {
                capture: !0
              }), Re.addEventListener("keydown", (Fe) => {
                Fe.target === Re && Fe.key === "Enter" && (Fe.preventDefault(), this._uiManager.editAltText(this));
              }), Nt(this, Je, Rr).call(this), this.div.append(Re), we.SMALL_EDITOR_SIZE || (we.SMALL_EDITOR_SIZE = Math.min(128, Math.round(Re.getBoundingClientRect().width * 1.4)));
            }
            getClientDimensions() {
              return this.div.getBoundingClientRect();
            }
            get altTextData() {
              return {
                altText: Oe(this, le),
                decorative: Oe(this, ue)
              };
            }
            set altTextData({
              altText: Re,
              decorative: je
            }) {
              Oe(this, le) === Re && Oe(this, ue) === je || (zt(this, le, Re), zt(this, ue, je), Nt(this, Je, Rr).call(this));
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", Oe(this, ve)), this.div.addEventListener("focusout", Oe(this, ge));
              const [Re, je] = this.parentDimensions;
              this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * je / Re).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * Re / je).toFixed(2)}%`);
              const [Fe, $e] = this.getInitialTranslation();
              return this.translate(Fe, $e), (0, ne.bindEvents)(this, this.div, ["pointerdown"]), this.div;
            }
            pointerdown(Re) {
              const {
                isMac: je
              } = re.FeatureTest.platform;
              if (Re.button !== 0 || Re.ctrlKey && je) {
                Re.preventDefault();
                return;
              }
              zt(this, xe, !0), Nt(this, At, ls).call(this, Re);
            }
            moveInDOM() {
              var Re;
              (Re = this.parent) == null || Re.moveEditorInDOM(this);
            }
            _setParentAndPosition(Re, je, Fe) {
              Re.changeParent(this), this.x = je, this.y = Fe, this.fixAndSetPosition();
            }
            getRect(Re, je) {
              const Fe = this.parentScale, [$e, qe] = this.pageDimensions, [Ye, Ke] = this.pageTranslation, Tt = Re / Fe, pt = je / Fe, Bt = this.x * $e, Vt = this.y * qe, qt = this.width * $e, nn = this.height * qe;
              switch (this.rotation) {
                case 0:
                  return [Bt + Tt + Ye, qe - Vt - pt - nn + Ke, Bt + Tt + qt + Ye, qe - Vt - pt + Ke];
                case 90:
                  return [Bt + pt + Ye, qe - Vt + Tt + Ke, Bt + pt + nn + Ye, qe - Vt + Tt + qt + Ke];
                case 180:
                  return [Bt - Tt - qt + Ye, qe - Vt + pt + Ke, Bt - Tt + Ye, qe - Vt + pt + nn + Ke];
                case 270:
                  return [Bt - pt - nn + Ye, qe - Vt - Tt - qt + Ke, Bt - pt + Ye, qe - Vt - Tt + Ke];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(Re, je) {
              const [Fe, $e, qe, Ye] = Re, Ke = qe - Fe, Tt = Ye - $e;
              switch (this.rotation) {
                case 0:
                  return [Fe, je - Ye, Ke, Tt];
                case 90:
                  return [Fe, je - $e, Tt, Ke];
                case 180:
                  return [qe, je - $e, Ke, Tt];
                case 270:
                  return [qe, je - Ye, Tt, Ke];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              zt(this, Te, !0);
            }
            disableEditMode() {
              zt(this, Te, !1);
            }
            isInEditMode() {
              return Oe(this, Te);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var Re, je;
              (Re = this.div) == null || Re.addEventListener("focusin", Oe(this, ve)), (je = this.div) == null || je.addEventListener("focusout", Oe(this, ge));
            }
            serialize(Re = !1, je = null) {
              (0, re.unreachable)("An editor must be serializable");
            }
            static deserialize(Re, je, Fe) {
              const $e = new this.prototype.constructor({
                parent: je,
                id: je.getNextId(),
                uiManager: Fe
              });
              $e.rotation = Re.rotation;
              const [qe, Ye] = $e.pageDimensions, [Ke, Tt, pt, Bt] = $e.getRectInCurrentCoords(Re.rect, Ye);
              return $e.x = Ke / qe, $e.y = Tt / Ye, $e.width = pt / qe, $e.height = Bt / Ye, $e;
            }
            remove() {
              var Re;
              this.div.removeEventListener("focusin", Oe(this, ve)), this.div.removeEventListener("focusout", Oe(this, ge)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (Re = Oe(this, de)) == null || Re.remove(), zt(this, de, null), zt(this, fe, null);
            }
            get isResizable() {
              return !1;
            }
            makeResizable() {
              this.isResizable && (Nt(this, Le, ss).call(this), Oe(this, me).classList.remove("hidden"));
            }
            select() {
              var Re;
              this.makeResizable(), (Re = this.div) == null || Re.classList.add("selectedEditor");
            }
            unselect() {
              var Re, je, Fe;
              (Re = Oe(this, me)) == null || Re.classList.add("hidden"), (je = this.div) == null || je.classList.remove("selectedEditor"), (Fe = this.div) != null && Fe.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
            }
            updateParams(Re, je) {
            }
            disableEditing() {
              Oe(this, de) && (Oe(this, de).hidden = !0);
            }
            enableEditing() {
              Oe(this, de) && (Oe(this, de).hidden = !1);
            }
            enterInEditMode() {
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return Oe(this, Ee);
            }
            set isEditing(Re) {
              zt(this, Ee, Re), this.parent && (Re ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
            }
            setAspectRatio(Re, je) {
              zt(this, ye, !0);
              const Fe = Re / je, {
                style: $e
              } = this.div;
              $e.aspectRatio = Fe, $e.height = "auto";
            }
            static get MIN_SIZE() {
              return 16;
            }
          };
          le = new WeakMap(), ue = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakMap(), Ee = new WeakMap(), Te = new WeakMap(), Se = new WeakMap(), he = new WeakMap(), Pe = new WeakSet(), Tr = function([Re, je], Fe, $e) {
            [Fe, $e] = this.screenToPageTranslation(Fe, $e), this.x += Fe / Re, this.y += $e / je, this.fixAndSetPosition();
          }, De = new WeakSet(), Pr = function() {
            const [Re, je] = this.parentDimensions, {
              _borderLineWidth: Fe
            } = we, $e = Fe / Re, qe = Fe / je;
            switch (this.rotation) {
              case 90:
                return [-$e, qe];
              case 180:
                return [$e, qe];
              case 270:
                return [$e, -qe];
              default:
                return [-$e, -qe];
            }
          }, Ne = new WeakSet(), Cr = function(Re, je, Fe) {
            switch (Fe) {
              case 90:
                return [je, -Re];
              case 180:
                return [-Re, -je];
              case 270:
                return [-je, Re];
              default:
                return [Re, je];
            }
          }, Be = new WeakSet(), wr = function(Re) {
            switch (Re) {
              case 90: {
                const [je, Fe] = this.pageDimensions;
                return [0, -je / Fe, Fe / je, 0];
              }
              case 180:
                return [-1, 0, 0, -1];
              case 270: {
                const [je, Fe] = this.pageDimensions;
                return [0, je / Fe, -Fe / je, 0];
              }
              default:
                return [1, 0, 0, 1];
            }
          }, Le = new WeakSet(), ss = function() {
            if (Oe(this, me))
              return;
            zt(this, me, document.createElement("div")), Oe(this, me).classList.add("resizers");
            const Re = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
            this._willKeepAspectRatio || Re.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
            for (const je of Re) {
              const Fe = document.createElement("div");
              Oe(this, me).append(Fe), Fe.classList.add("resizer", je), Fe.addEventListener("pointerdown", Nt(this, Ge, is).bind(this, je)), Fe.addEventListener("contextmenu", se.noContextMenu);
            }
            this.div.prepend(Oe(this, me));
          }, Ge = new WeakSet(), is = function(Re, je) {
            je.preventDefault();
            const {
              isMac: Fe
            } = re.FeatureTest.platform;
            if (je.button !== 0 || je.ctrlKey && Fe)
              return;
            const $e = Nt(this, Ue, os).bind(this, Re), qe = this._isDraggable;
            this._isDraggable = !1;
            const Ye = {
              passive: !0,
              capture: !0
            };
            window.addEventListener("pointermove", $e, Ye);
            const Ke = this.x, Tt = this.y, pt = this.width, Bt = this.height, Vt = this.parent.div.style.cursor, qt = this.div.style.cursor;
            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(je.target).cursor;
            const nn = () => {
              this._isDraggable = qe, window.removeEventListener("pointerup", nn), window.removeEventListener("blur", nn), window.removeEventListener("pointermove", $e, Ye), this.parent.div.style.cursor = Vt, this.div.style.cursor = qt;
              const mn = this.x, en = this.y, pn = this.width, Yt = this.height;
              mn === Ke && en === Tt && pn === pt && Yt === Bt || this.addCommands({
                cmd: () => {
                  this.width = pn, this.height = Yt, this.x = mn, this.y = en;
                  const [Ut, jt] = this.parentDimensions;
                  this.setDims(Ut * pn, jt * Yt), this.fixAndSetPosition();
                },
                undo: () => {
                  this.width = pt, this.height = Bt, this.x = Ke, this.y = Tt;
                  const [Ut, jt] = this.parentDimensions;
                  this.setDims(Ut * pt, jt * Bt), this.fixAndSetPosition();
                },
                mustExec: !0
              });
            };
            window.addEventListener("pointerup", nn), window.addEventListener("blur", nn);
          }, Ue = new WeakSet(), os = function(Re, je) {
            const [Fe, $e] = this.parentDimensions, qe = this.x, Ye = this.y, Ke = this.width, Tt = this.height, pt = we.MIN_SIZE / Fe, Bt = we.MIN_SIZE / $e, Vt = (Zt) => Math.round(Zt * 1e4) / 1e4, qt = Nt(this, Be, wr).call(this, this.rotation), nn = (Zt, Jt) => [qt[0] * Zt + qt[2] * Jt, qt[1] * Zt + qt[3] * Jt], mn = Nt(this, Be, wr).call(this, 360 - this.rotation), en = (Zt, Jt) => [mn[0] * Zt + mn[2] * Jt, mn[1] * Zt + mn[3] * Jt];
            let pn, Yt, Ut = !1, jt = !1;
            switch (Re) {
              case "topLeft":
                Ut = !0, pn = (Zt, Jt) => [0, 0], Yt = (Zt, Jt) => [Zt, Jt];
                break;
              case "topMiddle":
                pn = (Zt, Jt) => [Zt / 2, 0], Yt = (Zt, Jt) => [Zt / 2, Jt];
                break;
              case "topRight":
                Ut = !0, pn = (Zt, Jt) => [Zt, 0], Yt = (Zt, Jt) => [0, Jt];
                break;
              case "middleRight":
                jt = !0, pn = (Zt, Jt) => [Zt, Jt / 2], Yt = (Zt, Jt) => [0, Jt / 2];
                break;
              case "bottomRight":
                Ut = !0, pn = (Zt, Jt) => [Zt, Jt], Yt = (Zt, Jt) => [0, 0];
                break;
              case "bottomMiddle":
                pn = (Zt, Jt) => [Zt / 2, Jt], Yt = (Zt, Jt) => [Zt / 2, 0];
                break;
              case "bottomLeft":
                Ut = !0, pn = (Zt, Jt) => [0, Jt], Yt = (Zt, Jt) => [Zt, 0];
                break;
              case "middleLeft":
                jt = !0, pn = (Zt, Jt) => [0, Jt / 2], Yt = (Zt, Jt) => [Zt, Jt / 2];
                break;
            }
            const Gt = pn(Ke, Tt), ln = Yt(Ke, Tt);
            let sn = nn(...ln);
            const _n = Vt(qe + sn[0]), un = Vt(Ye + sn[1]);
            let En = 1, wn = 1, [Tn, Pn] = this.screenToPageTranslation(je.movementX, je.movementY);
            if ([Tn, Pn] = en(Tn / Fe, Pn / $e), Ut) {
              const Zt = Math.hypot(Ke, Tt);
              En = wn = Math.max(Math.min(Math.hypot(ln[0] - Gt[0] - Tn, ln[1] - Gt[1] - Pn) / Zt, 1 / Ke, 1 / Tt), pt / Ke, Bt / Tt);
            } else
              jt ? En = Math.max(pt, Math.min(1, Math.abs(ln[0] - Gt[0] - Tn))) / Ke : wn = Math.max(Bt, Math.min(1, Math.abs(ln[1] - Gt[1] - Pn))) / Tt;
            const Rn = Vt(Ke * En), Kt = Vt(Tt * wn);
            sn = nn(...Yt(Rn, Kt));
            const Ht = _n - sn[0], Lt = un - sn[1];
            this.width = Rn, this.height = Kt, this.x = Ht, this.y = Lt, this.setDims(Fe * Rn, $e * Kt), this.fixAndSetPosition();
          }, Je = new WeakSet(), Rr = async function() {
            var Fe;
            const Re = Oe(this, de);
            if (!Re)
              return;
            if (!Oe(this, le) && !Oe(this, ue)) {
              Re.classList.remove("done"), (Fe = Oe(this, fe)) == null || Fe.remove();
              return;
            }
            we._l10nPromise.get("editor_alt_text_edit_button_label").then(($e) => {
              Re.setAttribute("aria-label", $e);
            });
            let je = Oe(this, fe);
            if (!je) {
              zt(this, fe, je = document.createElement("span")), je.className = "tooltip", je.setAttribute("role", "tooltip");
              const $e = je.id = `alt-text-tooltip-${this.id}`;
              Re.setAttribute("aria-describedby", $e);
              const qe = 100;
              Re.addEventListener("mouseenter", () => {
                zt(this, pe, setTimeout(() => {
                  zt(this, pe, null), Oe(this, fe).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                    source: this,
                    details: {
                      type: "editing",
                      subtype: this.editorType,
                      data: {
                        action: "alt_text_tooltip"
                      }
                    }
                  });
                }, qe));
              }), Re.addEventListener("mouseleave", () => {
                var Ye;
                clearTimeout(Oe(this, pe)), zt(this, pe, null), (Ye = Oe(this, fe)) == null || Ye.classList.remove("show");
              });
            }
            Re.classList.add("done"), je.innerText = Oe(this, ue) ? await we._l10nPromise.get("editor_alt_text_decorative_tooltip") : Oe(this, le), je.parentNode || Re.append(je);
          }, At = new WeakSet(), ls = function(Re) {
            if (!this._isDraggable)
              return;
            const je = this._uiManager.isSelected(this);
            this._uiManager.setUpDragSession();
            let Fe, $e;
            je && (Fe = {
              passive: !0,
              capture: !0
            }, $e = (Ye) => {
              const [Ke, Tt] = this.screenToPageTranslation(Ye.movementX, Ye.movementY);
              this._uiManager.dragSelectedEditors(Ke, Tt);
            }, window.addEventListener("pointermove", $e, Fe));
            const qe = () => {
              if (window.removeEventListener("pointerup", qe), window.removeEventListener("blur", qe), je && window.removeEventListener("pointermove", $e, Fe), zt(this, xe, !1), !this._uiManager.endDragSession()) {
                const {
                  isMac: Ye
                } = re.FeatureTest.platform;
                Re.ctrlKey && !Ye || Re.shiftKey || Re.metaKey && Ye ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
              }
            };
            window.addEventListener("pointerup", qe), window.addEventListener("blur", qe);
          }, Rt(we, Ne), On(we, "_borderLineWidth", -1), On(we, "_colorManager", new ne.ColorManager()), On(we, "_zIndex", 1), On(we, "SMALL_EDITOR_SIZE", 0);
          let ie = we;
          ee.AnnotationEditor = ie;
          class oe extends ie {
            constructor(Re) {
              super(Re), this.annotationElementId = Re.annotationElementId, this.deleted = !0;
            }
            serialize() {
              return {
                id: this.annotationElementId,
                deleted: !0,
                pageIndex: this.pageIndex
              };
            }
          }
        },
        /* 5 */
        /***/
        ($, ee, te) => {
          var ye, me, ve, ge, xe, Ar, Se, he, Pe, Ie, De, us, Me, Be, We, Le, He, Ge, Ze, Ue, Qe, Je, Ot, At, ze, we, Ae, Re, je, Fe, $e, qe, Ye, Ke, Tt, pt, Bt, Vt, qt, nn, mn, en, pn, Yt, Ut, jt, Gt, ds, sn, Or, un, Mr, wn, or, Pn, Ir, Kt, kr, Lt, Un, Jt, Yn, kn, fs, on, ps, dn, Dr, xn, Zn, Qt, Nr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.KeyboardManager = ee.CommandManager = ee.ColorManager = ee.AnnotationEditorUIManager = void 0, ee.bindEvents = se, ee.opacityToHex = ie;
          var ne = te(1), re = te(6);
          function se(xt, ke, Xe) {
            for (const Et of Xe)
              ke.addEventListener(Et, xt[Et].bind(xt));
          }
          function ie(xt) {
            return Math.round(Math.min(255, Math.max(1, 255 * xt))).toString(16).padStart(2, "0");
          }
          class oe {
            constructor() {
              Rt(this, ye, 0);
            }
            getId() {
              return `${ne.AnnotationEditorPrefix}${Xn(this, ye)._++}`;
            }
          }
          ye = new WeakMap();
          const Te = class Te {
            constructor() {
              Rt(this, xe);
              Rt(this, me, (0, ne.getUuid)());
              Rt(this, ve, 0);
              Rt(this, ge, null);
            }
            static get _isSVGFittingCanvas() {
              const ke = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', Et = new OffscreenCanvas(1, 3).getContext("2d"), Mt = new Image();
              Mt.src = ke;
              const Ft = Mt.decode().then(() => (Et.drawImage(Mt, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(Et.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
              return (0, ne.shadow)(this, "_isSVGFittingCanvas", Ft);
            }
            async getFromFile(ke) {
              const {
                lastModified: Xe,
                name: Et,
                size: Mt,
                type: Ft
              } = ke;
              return Nt(this, xe, Ar).call(this, `${Xe}_${Et}_${Mt}_${Ft}`, ke);
            }
            async getFromUrl(ke) {
              return Nt(this, xe, Ar).call(this, ke, ke);
            }
            async getFromId(ke) {
              Oe(this, ge) || zt(this, ge, /* @__PURE__ */ new Map());
              const Xe = Oe(this, ge).get(ke);
              return Xe ? Xe.bitmap ? (Xe.refCounter += 1, Xe) : Xe.file ? this.getFromFile(Xe.file) : this.getFromUrl(Xe.url) : null;
            }
            getSvgUrl(ke) {
              const Xe = Oe(this, ge).get(ke);
              return Xe != null && Xe.isSvg ? Xe.svgUrl : null;
            }
            deleteId(ke) {
              Oe(this, ge) || zt(this, ge, /* @__PURE__ */ new Map());
              const Xe = Oe(this, ge).get(ke);
              Xe && (Xe.refCounter -= 1, Xe.refCounter === 0 && (Xe.bitmap = null));
            }
            isValidId(ke) {
              return ke.startsWith(`image_${Oe(this, me)}_`);
            }
          };
          me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakSet(), Ar = async function(ke, Xe) {
            Oe(this, ge) || zt(this, ge, /* @__PURE__ */ new Map());
            let Et = Oe(this, ge).get(ke);
            if (Et === null)
              return null;
            if (Et != null && Et.bitmap)
              return Et.refCounter += 1, Et;
            try {
              Et || (Et = {
                bitmap: null,
                id: `image_${Oe(this, me)}_${Xn(this, ve)._++}`,
                refCounter: 0,
                isSvg: !1
              });
              let Mt;
              if (typeof Xe == "string") {
                Et.url = Xe;
                const Ft = await fetch(Xe);
                if (!Ft.ok)
                  throw new Error(Ft.statusText);
                Mt = await Ft.blob();
              } else
                Mt = Et.file = Xe;
              if (Mt.type === "image/svg+xml") {
                const Ft = Te._isSVGFittingCanvas, Ve = new FileReader(), Dt = new Image(), Wt = new Promise((Xt, hn) => {
                  Dt.onload = () => {
                    Et.bitmap = Dt, Et.isSvg = !0, Xt();
                  }, Ve.onload = async () => {
                    const rn = Et.svgUrl = Ve.result;
                    Dt.src = await Ft ? `${rn}#svgView(preserveAspectRatio(none))` : rn;
                  }, Dt.onerror = Ve.onerror = hn;
                });
                Ve.readAsDataURL(Mt), await Wt;
              } else
                Et.bitmap = await createImageBitmap(Mt);
              Et.refCounter = 1;
            } catch (Mt) {
              console.error(Mt), Et = null;
            }
            return Oe(this, ge).set(ke, Et), Et && Oe(this, ge).set(Et.id, Et), Et;
          };
          let le = Te;
          class ue {
            constructor(ke = 128) {
              Rt(this, Se, []);
              Rt(this, he, !1);
              Rt(this, Pe, void 0);
              Rt(this, Ie, -1);
              zt(this, Pe, ke);
            }
            add({
              cmd: ke,
              undo: Xe,
              mustExec: Et,
              type: Mt = NaN,
              overwriteIfSameType: Ft = !1,
              keepUndo: Ve = !1
            }) {
              if (Et && ke(), Oe(this, he))
                return;
              const Dt = {
                cmd: ke,
                undo: Xe,
                type: Mt
              };
              if (Oe(this, Ie) === -1) {
                Oe(this, Se).length > 0 && (Oe(this, Se).length = 0), zt(this, Ie, 0), Oe(this, Se).push(Dt);
                return;
              }
              if (Ft && Oe(this, Se)[Oe(this, Ie)].type === Mt) {
                Ve && (Dt.undo = Oe(this, Se)[Oe(this, Ie)].undo), Oe(this, Se)[Oe(this, Ie)] = Dt;
                return;
              }
              const Wt = Oe(this, Ie) + 1;
              Wt === Oe(this, Pe) ? Oe(this, Se).splice(0, 1) : (zt(this, Ie, Wt), Wt < Oe(this, Se).length && Oe(this, Se).splice(Wt)), Oe(this, Se).push(Dt);
            }
            undo() {
              Oe(this, Ie) !== -1 && (zt(this, he, !0), Oe(this, Se)[Oe(this, Ie)].undo(), zt(this, he, !1), zt(this, Ie, Oe(this, Ie) - 1));
            }
            redo() {
              Oe(this, Ie) < Oe(this, Se).length - 1 && (zt(this, Ie, Oe(this, Ie) + 1), zt(this, he, !0), Oe(this, Se)[Oe(this, Ie)].cmd(), zt(this, he, !1));
            }
            hasSomethingToUndo() {
              return Oe(this, Ie) !== -1;
            }
            hasSomethingToRedo() {
              return Oe(this, Ie) < Oe(this, Se).length - 1;
            }
            destroy() {
              zt(this, Se, null);
            }
          }
          Se = new WeakMap(), he = new WeakMap(), Pe = new WeakMap(), Ie = new WeakMap(), ee.CommandManager = ue;
          class de {
            constructor(ke) {
              Rt(this, De);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const {
                isMac: Xe
              } = ne.FeatureTest.platform;
              for (const [Et, Mt, Ft = {}] of ke)
                for (const Ve of Et) {
                  const Dt = Ve.startsWith("mac+");
                  Xe && Dt ? (this.callbacks.set(Ve.slice(4), {
                    callback: Mt,
                    options: Ft
                  }), this.allKeys.add(Ve.split("+").at(-1))) : !Xe && !Dt && (this.callbacks.set(Ve, {
                    callback: Mt,
                    options: Ft
                  }), this.allKeys.add(Ve.split("+").at(-1)));
                }
            }
            exec(ke, Xe) {
              if (!this.allKeys.has(Xe.key))
                return;
              const Et = this.callbacks.get(Nt(this, De, us).call(this, Xe));
              if (!Et)
                return;
              const {
                callback: Mt,
                options: {
                  bubbles: Ft = !1,
                  args: Ve = [],
                  checker: Dt = null
                }
              } = Et;
              Dt && !Dt(ke, Xe) || (Mt.bind(ke, ...Ve)(), Ft || (Xe.stopPropagation(), Xe.preventDefault()));
            }
          }
          De = new WeakSet(), us = function(ke) {
            ke.altKey && this.buffer.push("alt"), ke.ctrlKey && this.buffer.push("ctrl"), ke.metaKey && this.buffer.push("meta"), ke.shiftKey && this.buffer.push("shift"), this.buffer.push(ke.key);
            const Xe = this.buffer.join("+");
            return this.buffer.length = 0, Xe;
          }, ee.KeyboardManager = de;
          const Ne = class Ne {
            get _colors() {
              const ke = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, re.getColorValues)(ke), (0, ne.shadow)(this, "_colors", ke);
            }
            convert(ke) {
              const Xe = (0, re.getRGB)(ke);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return Xe;
              for (const [Et, Mt] of this._colors)
                if (Mt.every((Ft, Ve) => Ft === Xe[Ve]))
                  return Ne._colorsMapping.get(Et);
              return Xe;
            }
            getHexCode(ke) {
              const Xe = this._colors.get(ke);
              return Xe ? ne.Util.makeHexColor(...Xe) : ke;
            }
          };
          On(Ne, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
          let fe = Ne;
          ee.ColorManager = fe;
          const yn = class yn {
            constructor(ke, Xe, Et, Mt, Ft, Ve) {
              Rt(this, Gt);
              Rt(this, sn);
              Rt(this, un);
              Rt(this, wn);
              Rt(this, Pn);
              Rt(this, Kt);
              Rt(this, Lt);
              Rt(this, Jt);
              Rt(this, kn);
              Rt(this, on);
              Rt(this, dn);
              Rt(this, xn);
              Rt(this, Qt);
              Rt(this, Me, null);
              Rt(this, Be, /* @__PURE__ */ new Map());
              Rt(this, We, /* @__PURE__ */ new Map());
              Rt(this, Le, null);
              Rt(this, He, null);
              Rt(this, Ge, new ue());
              Rt(this, Ze, 0);
              Rt(this, Ue, /* @__PURE__ */ new Set());
              Rt(this, Qe, null);
              Rt(this, Je, null);
              Rt(this, Ot, /* @__PURE__ */ new Set());
              Rt(this, At, null);
              Rt(this, ze, new oe());
              Rt(this, we, !1);
              Rt(this, Ae, !1);
              Rt(this, Re, null);
              Rt(this, je, ne.AnnotationEditorType.NONE);
              Rt(this, Fe, /* @__PURE__ */ new Set());
              Rt(this, $e, null);
              Rt(this, qe, this.blur.bind(this));
              Rt(this, Ye, this.focus.bind(this));
              Rt(this, Ke, this.copy.bind(this));
              Rt(this, Tt, this.cut.bind(this));
              Rt(this, pt, this.paste.bind(this));
              Rt(this, Bt, this.keydown.bind(this));
              Rt(this, Vt, this.onEditingAction.bind(this));
              Rt(this, qt, this.onPageChanging.bind(this));
              Rt(this, nn, this.onScaleChanging.bind(this));
              Rt(this, mn, this.onRotationChanging.bind(this));
              Rt(this, en, {
                isEditing: !1,
                isEmpty: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              Rt(this, pn, [0, 0]);
              Rt(this, Yt, null);
              Rt(this, Ut, null);
              Rt(this, jt, null);
              zt(this, Ut, ke), zt(this, jt, Xe), zt(this, Le, Et), this._eventBus = Mt, this._eventBus._on("editingaction", Oe(this, Vt)), this._eventBus._on("pagechanging", Oe(this, qt)), this._eventBus._on("scalechanging", Oe(this, nn)), this._eventBus._on("rotationchanging", Oe(this, mn)), zt(this, He, Ft.annotationStorage), zt(this, At, Ft.filterFactory), zt(this, $e, Ve), this.viewParameters = {
                realScale: re.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: 0
              };
            }
            static get _keyboardManager() {
              const ke = yn.prototype, Xe = (Ft) => {
                const {
                  activeElement: Ve
                } = document;
                return Ve && Oe(Ft, Ut).contains(Ve) && Ft.hasSomethingToControl();
              }, Et = this.TRANSLATE_SMALL, Mt = this.TRANSLATE_BIG;
              return (0, ne.shadow)(this, "_keyboardManager", new de([[["ctrl+a", "mac+meta+a"], ke.selectAll], [["ctrl+z", "mac+meta+z"], ke.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], ke.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], ke.delete], [["Escape", "mac+Escape"], ke.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], ke.translateSelectedEditors, {
                args: [-Et, 0],
                checker: Xe
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], ke.translateSelectedEditors, {
                args: [-Mt, 0],
                checker: Xe
              }], [["ArrowRight", "mac+ArrowRight"], ke.translateSelectedEditors, {
                args: [Et, 0],
                checker: Xe
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], ke.translateSelectedEditors, {
                args: [Mt, 0],
                checker: Xe
              }], [["ArrowUp", "mac+ArrowUp"], ke.translateSelectedEditors, {
                args: [0, -Et],
                checker: Xe
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], ke.translateSelectedEditors, {
                args: [0, -Mt],
                checker: Xe
              }], [["ArrowDown", "mac+ArrowDown"], ke.translateSelectedEditors, {
                args: [0, Et],
                checker: Xe
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], ke.translateSelectedEditors, {
                args: [0, Mt],
                checker: Xe
              }]]));
            }
            destroy() {
              Nt(this, wn, or).call(this), Nt(this, sn, Or).call(this), this._eventBus._off("editingaction", Oe(this, Vt)), this._eventBus._off("pagechanging", Oe(this, qt)), this._eventBus._off("scalechanging", Oe(this, nn)), this._eventBus._off("rotationchanging", Oe(this, mn));
              for (const ke of Oe(this, We).values())
                ke.destroy();
              Oe(this, We).clear(), Oe(this, Be).clear(), Oe(this, Ot).clear(), zt(this, Me, null), Oe(this, Fe).clear(), Oe(this, Ge).destroy(), Oe(this, Le).destroy();
            }
            get hcmFilter() {
              return (0, ne.shadow)(this, "hcmFilter", Oe(this, $e) ? Oe(this, At).addHCMFilter(Oe(this, $e).foreground, Oe(this, $e).background) : "none");
            }
            get direction() {
              return (0, ne.shadow)(this, "direction", getComputedStyle(Oe(this, Ut)).direction);
            }
            editAltText(ke) {
              var Xe;
              (Xe = Oe(this, Le)) == null || Xe.editAltText(this, ke);
            }
            onPageChanging({
              pageNumber: ke
            }) {
              zt(this, Ze, ke - 1);
            }
            focusMainContainer() {
              Oe(this, Ut).focus();
            }
            findParent(ke, Xe) {
              for (const Et of Oe(this, We).values()) {
                const {
                  x: Mt,
                  y: Ft,
                  width: Ve,
                  height: Dt
                } = Et.div.getBoundingClientRect();
                if (ke >= Mt && ke <= Mt + Ve && Xe >= Ft && Xe <= Ft + Dt)
                  return Et;
              }
              return null;
            }
            disableUserSelect(ke = !1) {
              Oe(this, jt).classList.toggle("noUserSelect", ke);
            }
            addShouldRescale(ke) {
              Oe(this, Ot).add(ke);
            }
            removeShouldRescale(ke) {
              Oe(this, Ot).delete(ke);
            }
            onScaleChanging({
              scale: ke
            }) {
              this.commitOrRemove(), this.viewParameters.realScale = ke * re.PixelsPerInch.PDF_TO_CSS_UNITS;
              for (const Xe of Oe(this, Ot))
                Xe.onScaleChanging();
            }
            onRotationChanging({
              pagesRotation: ke
            }) {
              this.commitOrRemove(), this.viewParameters.rotation = ke;
            }
            addToAnnotationStorage(ke) {
              !ke.isEmpty() && Oe(this, He) && !Oe(this, He).has(ke.id) && Oe(this, He).setValue(ke.id, ke);
            }
            blur() {
              if (!this.hasSelection)
                return;
              const {
                activeElement: ke
              } = document;
              for (const Xe of Oe(this, Fe))
                if (Xe.div.contains(ke)) {
                  zt(this, Re, [Xe, ke]), Xe._focusEventsAllowed = !1;
                  break;
                }
            }
            focus() {
              if (!Oe(this, Re))
                return;
              const [ke, Xe] = Oe(this, Re);
              zt(this, Re, null), Xe.addEventListener("focusin", () => {
                ke._focusEventsAllowed = !0;
              }, {
                once: !0
              }), Xe.focus();
            }
            addEditListeners() {
              Nt(this, un, Mr).call(this), Nt(this, Pn, Ir).call(this);
            }
            removeEditListeners() {
              Nt(this, wn, or).call(this), Nt(this, Kt, kr).call(this);
            }
            copy(ke) {
              var Et;
              if (ke.preventDefault(), (Et = Oe(this, Me)) == null || Et.commitOrRemove(), !this.hasSelection)
                return;
              const Xe = [];
              for (const Mt of Oe(this, Fe)) {
                const Ft = Mt.serialize(!0);
                Ft && Xe.push(Ft);
              }
              Xe.length !== 0 && ke.clipboardData.setData("application/pdfjs", JSON.stringify(Xe));
            }
            cut(ke) {
              this.copy(ke), this.delete();
            }
            paste(ke) {
              ke.preventDefault();
              const {
                clipboardData: Xe
              } = ke;
              for (const Ft of Xe.items)
                for (const Ve of Oe(this, Je))
                  if (Ve.isHandlingMimeForPasting(Ft.type)) {
                    Ve.paste(Ft, this.currentLayer);
                    return;
                  }
              let Et = Xe.getData("application/pdfjs");
              if (!Et)
                return;
              try {
                Et = JSON.parse(Et);
              } catch (Ft) {
                (0, ne.warn)(`paste: "${Ft.message}".`);
                return;
              }
              if (!Array.isArray(Et))
                return;
              this.unselectAll();
              const Mt = this.currentLayer;
              try {
                const Ft = [];
                for (const Wt of Et) {
                  const Xt = Mt.deserialize(Wt);
                  if (!Xt)
                    return;
                  Ft.push(Xt);
                }
                const Ve = () => {
                  for (const Wt of Ft)
                    Nt(this, dn, Dr).call(this, Wt);
                  Nt(this, Qt, Nr).call(this, Ft);
                }, Dt = () => {
                  for (const Wt of Ft)
                    Wt.remove();
                };
                this.addCommands({
                  cmd: Ve,
                  undo: Dt,
                  mustExec: !0
                });
              } catch (Ft) {
                (0, ne.warn)(`paste: "${Ft.message}".`);
              }
            }
            keydown(ke) {
              var Xe;
              (Xe = this.getActive()) != null && Xe.shouldGetKeyboardEvents() || yn._keyboardManager.exec(this, ke);
            }
            onEditingAction(ke) {
              ["undo", "redo", "delete", "selectAll"].includes(ke.name) && this[ke.name]();
            }
            setEditingState(ke) {
              ke ? (Nt(this, Gt, ds).call(this), Nt(this, un, Mr).call(this), Nt(this, Pn, Ir).call(this), Nt(this, Lt, Un).call(this, {
                isEditing: Oe(this, je) !== ne.AnnotationEditorType.NONE,
                isEmpty: Nt(this, xn, Zn).call(this),
                hasSomethingToUndo: Oe(this, Ge).hasSomethingToUndo(),
                hasSomethingToRedo: Oe(this, Ge).hasSomethingToRedo(),
                hasSelectedEditor: !1
              })) : (Nt(this, sn, Or).call(this), Nt(this, wn, or).call(this), Nt(this, Kt, kr).call(this), Nt(this, Lt, Un).call(this, {
                isEditing: !1
              }), this.disableUserSelect(!1));
            }
            registerEditorTypes(ke) {
              if (!Oe(this, Je)) {
                zt(this, Je, ke);
                for (const Xe of Oe(this, Je))
                  Nt(this, Jt, Yn).call(this, Xe.defaultPropertiesToUpdate);
              }
            }
            getId() {
              return Oe(this, ze).getId();
            }
            get currentLayer() {
              return Oe(this, We).get(Oe(this, Ze));
            }
            getLayer(ke) {
              return Oe(this, We).get(ke);
            }
            get currentPageIndex() {
              return Oe(this, Ze);
            }
            addLayer(ke) {
              Oe(this, We).set(ke.pageIndex, ke), Oe(this, we) ? ke.enable() : ke.disable();
            }
            removeLayer(ke) {
              Oe(this, We).delete(ke.pageIndex);
            }
            updateMode(ke, Xe = null) {
              if (Oe(this, je) !== ke) {
                if (zt(this, je, ke), ke === ne.AnnotationEditorType.NONE) {
                  this.setEditingState(!1), Nt(this, on, ps).call(this);
                  return;
                }
                this.setEditingState(!0), Nt(this, kn, fs).call(this), this.unselectAll();
                for (const Et of Oe(this, We).values())
                  Et.updateMode(ke);
                if (Xe) {
                  for (const Et of Oe(this, Be).values())
                    if (Et.annotationElementId === Xe) {
                      this.setSelected(Et), Et.enterInEditMode();
                      break;
                    }
                }
              }
            }
            updateToolbar(ke) {
              ke !== Oe(this, je) && this._eventBus.dispatch("switchannotationeditormode", {
                source: this,
                mode: ke
              });
            }
            updateParams(ke, Xe) {
              if (Oe(this, Je)) {
                if (ke === ne.AnnotationEditorParamsType.CREATE) {
                  this.currentLayer.addNewEditor(ke);
                  return;
                }
                for (const Et of Oe(this, Fe))
                  Et.updateParams(ke, Xe);
                for (const Et of Oe(this, Je))
                  Et.updateDefaultParams(ke, Xe);
              }
            }
            enableWaiting(ke = !1) {
              if (Oe(this, Ae) !== ke) {
                zt(this, Ae, ke);
                for (const Xe of Oe(this, We).values())
                  ke ? Xe.disableClick() : Xe.enableClick(), Xe.div.classList.toggle("waiting", ke);
              }
            }
            getEditors(ke) {
              const Xe = [];
              for (const Et of Oe(this, Be).values())
                Et.pageIndex === ke && Xe.push(Et);
              return Xe;
            }
            getEditor(ke) {
              return Oe(this, Be).get(ke);
            }
            addEditor(ke) {
              Oe(this, Be).set(ke.id, ke);
            }
            removeEditor(ke) {
              var Xe;
              Oe(this, Be).delete(ke.id), this.unselect(ke), (!ke.annotationElementId || !Oe(this, Ue).has(ke.annotationElementId)) && ((Xe = Oe(this, He)) == null || Xe.remove(ke.id));
            }
            addDeletedAnnotationElement(ke) {
              Oe(this, Ue).add(ke.annotationElementId), ke.deleted = !0;
            }
            isDeletedAnnotationElement(ke) {
              return Oe(this, Ue).has(ke);
            }
            removeDeletedAnnotationElement(ke) {
              Oe(this, Ue).delete(ke.annotationElementId), ke.deleted = !1;
            }
            setActiveEditor(ke) {
              Oe(this, Me) !== ke && (zt(this, Me, ke), ke && Nt(this, Jt, Yn).call(this, ke.propertiesToUpdate));
            }
            toggleSelected(ke) {
              if (Oe(this, Fe).has(ke)) {
                Oe(this, Fe).delete(ke), ke.unselect(), Nt(this, Lt, Un).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              Oe(this, Fe).add(ke), ke.select(), Nt(this, Jt, Yn).call(this, ke.propertiesToUpdate), Nt(this, Lt, Un).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(ke) {
              for (const Xe of Oe(this, Fe))
                Xe !== ke && Xe.unselect();
              Oe(this, Fe).clear(), Oe(this, Fe).add(ke), ke.select(), Nt(this, Jt, Yn).call(this, ke.propertiesToUpdate), Nt(this, Lt, Un).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(ke) {
              return Oe(this, Fe).has(ke);
            }
            unselect(ke) {
              ke.unselect(), Oe(this, Fe).delete(ke), Nt(this, Lt, Un).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return Oe(this, Fe).size !== 0;
            }
            undo() {
              Oe(this, Ge).undo(), Nt(this, Lt, Un).call(this, {
                hasSomethingToUndo: Oe(this, Ge).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: Nt(this, xn, Zn).call(this)
              });
            }
            redo() {
              Oe(this, Ge).redo(), Nt(this, Lt, Un).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: Oe(this, Ge).hasSomethingToRedo(),
                isEmpty: Nt(this, xn, Zn).call(this)
              });
            }
            addCommands(ke) {
              Oe(this, Ge).add(ke), Nt(this, Lt, Un).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: Nt(this, xn, Zn).call(this)
              });
            }
            delete() {
              if (this.commitOrRemove(), !this.hasSelection)
                return;
              const ke = [...Oe(this, Fe)], Xe = () => {
                for (const Mt of ke)
                  Mt.remove();
              }, Et = () => {
                for (const Mt of ke)
                  Nt(this, dn, Dr).call(this, Mt);
              };
              this.addCommands({
                cmd: Xe,
                undo: Et,
                mustExec: !0
              });
            }
            commitOrRemove() {
              var ke;
              (ke = Oe(this, Me)) == null || ke.commitOrRemove();
            }
            hasSomethingToControl() {
              return Oe(this, Me) || this.hasSelection;
            }
            selectAll() {
              for (const ke of Oe(this, Fe))
                ke.commit();
              Nt(this, Qt, Nr).call(this, Oe(this, Be).values());
            }
            unselectAll() {
              if (Oe(this, Me)) {
                Oe(this, Me).commitOrRemove();
                return;
              }
              if (this.hasSelection) {
                for (const ke of Oe(this, Fe))
                  ke.unselect();
                Oe(this, Fe).clear(), Nt(this, Lt, Un).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            translateSelectedEditors(ke, Xe, Et = !1) {
              if (Et || this.commitOrRemove(), !this.hasSelection)
                return;
              Oe(this, pn)[0] += ke, Oe(this, pn)[1] += Xe;
              const [Mt, Ft] = Oe(this, pn), Ve = [...Oe(this, Fe)], Dt = 1e3;
              Oe(this, Yt) && clearTimeout(Oe(this, Yt)), zt(this, Yt, setTimeout(() => {
                zt(this, Yt, null), Oe(this, pn)[0] = Oe(this, pn)[1] = 0, this.addCommands({
                  cmd: () => {
                    for (const Wt of Ve)
                      Oe(this, Be).has(Wt.id) && Wt.translateInPage(Mt, Ft);
                  },
                  undo: () => {
                    for (const Wt of Ve)
                      Oe(this, Be).has(Wt.id) && Wt.translateInPage(-Mt, -Ft);
                  },
                  mustExec: !1
                });
              }, Dt));
              for (const Wt of Ve)
                Wt.translateInPage(ke, Xe);
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0), zt(this, Qe, /* @__PURE__ */ new Map());
                for (const ke of Oe(this, Fe))
                  Oe(this, Qe).set(ke, {
                    savedX: ke.x,
                    savedY: ke.y,
                    savedPageIndex: ke.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1
                  });
              }
            }
            endDragSession() {
              if (!Oe(this, Qe))
                return !1;
              this.disableUserSelect(!1);
              const ke = Oe(this, Qe);
              zt(this, Qe, null);
              let Xe = !1;
              for (const [{
                x: Mt,
                y: Ft,
                pageIndex: Ve
              }, Dt] of ke)
                Dt.newX = Mt, Dt.newY = Ft, Dt.newPageIndex = Ve, Xe || (Xe = Mt !== Dt.savedX || Ft !== Dt.savedY || Ve !== Dt.savedPageIndex);
              if (!Xe)
                return !1;
              const Et = (Mt, Ft, Ve, Dt) => {
                if (Oe(this, Be).has(Mt.id)) {
                  const Wt = Oe(this, We).get(Dt);
                  Wt ? Mt._setParentAndPosition(Wt, Ft, Ve) : (Mt.pageIndex = Dt, Mt.x = Ft, Mt.y = Ve);
                }
              };
              return this.addCommands({
                cmd: () => {
                  for (const [Mt, {
                    newX: Ft,
                    newY: Ve,
                    newPageIndex: Dt
                  }] of ke)
                    Et(Mt, Ft, Ve, Dt);
                },
                undo: () => {
                  for (const [Mt, {
                    savedX: Ft,
                    savedY: Ve,
                    savedPageIndex: Dt
                  }] of ke)
                    Et(Mt, Ft, Ve, Dt);
                },
                mustExec: !0
              }), !0;
            }
            dragSelectedEditors(ke, Xe) {
              if (Oe(this, Qe))
                for (const Et of Oe(this, Qe).keys())
                  Et.drag(ke, Xe);
            }
            rebuild(ke) {
              if (ke.parent === null) {
                const Xe = this.getLayer(ke.pageIndex);
                Xe ? (Xe.changeParent(ke), Xe.addOrRebuild(ke)) : (this.addEditor(ke), this.addToAnnotationStorage(ke), ke.rebuild());
              } else
                ke.parent.addOrRebuild(ke);
            }
            isActive(ke) {
              return Oe(this, Me) === ke;
            }
            getActive() {
              return Oe(this, Me);
            }
            getMode() {
              return Oe(this, je);
            }
            get imageManager() {
              return (0, ne.shadow)(this, "imageManager", new le());
            }
          };
          Me = new WeakMap(), Be = new WeakMap(), We = new WeakMap(), Le = new WeakMap(), He = new WeakMap(), Ge = new WeakMap(), Ze = new WeakMap(), Ue = new WeakMap(), Qe = new WeakMap(), Je = new WeakMap(), Ot = new WeakMap(), At = new WeakMap(), ze = new WeakMap(), we = new WeakMap(), Ae = new WeakMap(), Re = new WeakMap(), je = new WeakMap(), Fe = new WeakMap(), $e = new WeakMap(), qe = new WeakMap(), Ye = new WeakMap(), Ke = new WeakMap(), Tt = new WeakMap(), pt = new WeakMap(), Bt = new WeakMap(), Vt = new WeakMap(), qt = new WeakMap(), nn = new WeakMap(), mn = new WeakMap(), en = new WeakMap(), pn = new WeakMap(), Yt = new WeakMap(), Ut = new WeakMap(), jt = new WeakMap(), Gt = new WeakSet(), ds = function() {
            window.addEventListener("focus", Oe(this, Ye)), window.addEventListener("blur", Oe(this, qe));
          }, sn = new WeakSet(), Or = function() {
            window.removeEventListener("focus", Oe(this, Ye)), window.removeEventListener("blur", Oe(this, qe));
          }, un = new WeakSet(), Mr = function() {
            window.addEventListener("keydown", Oe(this, Bt), {
              capture: !0
            });
          }, wn = new WeakSet(), or = function() {
            window.removeEventListener("keydown", Oe(this, Bt), {
              capture: !0
            });
          }, Pn = new WeakSet(), Ir = function() {
            document.addEventListener("copy", Oe(this, Ke)), document.addEventListener("cut", Oe(this, Tt)), document.addEventListener("paste", Oe(this, pt));
          }, Kt = new WeakSet(), kr = function() {
            document.removeEventListener("copy", Oe(this, Ke)), document.removeEventListener("cut", Oe(this, Tt)), document.removeEventListener("paste", Oe(this, pt));
          }, Lt = new WeakSet(), Un = function(ke) {
            Object.entries(ke).some(([Et, Mt]) => Oe(this, en)[Et] !== Mt) && this._eventBus.dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(Oe(this, en), ke)
            });
          }, Jt = new WeakSet(), Yn = function(ke) {
            this._eventBus.dispatch("annotationeditorparamschanged", {
              source: this,
              details: ke
            });
          }, kn = new WeakSet(), fs = function() {
            if (!Oe(this, we)) {
              zt(this, we, !0);
              for (const ke of Oe(this, We).values())
                ke.enable();
            }
          }, on = new WeakSet(), ps = function() {
            if (this.unselectAll(), Oe(this, we)) {
              zt(this, we, !1);
              for (const ke of Oe(this, We).values())
                ke.disable();
            }
          }, dn = new WeakSet(), Dr = function(ke) {
            const Xe = Oe(this, We).get(ke.pageIndex);
            Xe ? Xe.addOrRebuild(ke) : this.addEditor(ke);
          }, xn = new WeakSet(), Zn = function() {
            if (Oe(this, Be).size === 0)
              return !0;
            if (Oe(this, Be).size === 1)
              for (const ke of Oe(this, Be).values())
                return ke.isEmpty();
            return !1;
          }, Qt = new WeakSet(), Nr = function(ke) {
            Oe(this, Fe).clear();
            for (const Xe of ke)
              Xe.isEmpty() || (Oe(this, Fe).add(Xe), Xe.select());
            Nt(this, Lt, Un).call(this, {
              hasSelectedEditor: !0
            });
          }, On(yn, "TRANSLATE_SMALL", 1), On(yn, "TRANSLATE_BIG", 10);
          let pe = yn;
          ee.AnnotationEditorUIManager = pe;
        },
        /* 6 */
        /***/
        ($, ee, te) => {
          var Ze, Ue, Qe, Je, Ot, At, ze, we, Ae, Re, je, Fe, qn, qe, Vn, Ke, Lr, pt, lr, Vt, ur, nn, Jn, en, Qn;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.StatTimer = ee.RenderingCancelledException = ee.PixelsPerInch = ee.PageViewport = ee.PDFDateString = ee.DOMStandardFontDataFactory = ee.DOMSVGFactory = ee.DOMFilterFactory = ee.DOMCanvasFactory = ee.DOMCMapReaderFactory = void 0, ee.deprecated = Ie, ee.getColorValues = Be, ee.getCurrentTransform = We, ee.getCurrentTransformInverse = Le, ee.getFilenameFromUrl = xe, ee.getPdfFilenameFromUrl = Ee, ee.getRGB = Me, ee.getXfaPageViewport = Ne, ee.isDataScheme = ve, ee.isPdfFile = ge, ee.isValidFetchUrl = Se, ee.loadScript = Pe, ee.noContextMenu = he, ee.setLayerDimensions = He;
          var ne = te(7), re = te(1);
          const se = "http://www.w3.org/2000/svg", Ge = class Ge {
          };
          On(Ge, "CSS", 96), On(Ge, "PDF", 72), On(Ge, "PDF_TO_CSS_UNITS", Ge.CSS / Ge.PDF);
          let ie = Ge;
          ee.PixelsPerInch = ie;
          class oe extends ne.BaseFilterFactory {
            constructor({
              docId: jt,
              ownerDocument: Gt = globalThis.document
            } = {}) {
              super();
              Rt(this, Fe);
              Rt(this, qe);
              Rt(this, Ke);
              Rt(this, pt);
              Rt(this, Vt);
              Rt(this, nn);
              Rt(this, en);
              Rt(this, Ze, void 0);
              Rt(this, Ue, void 0);
              Rt(this, Qe, void 0);
              Rt(this, Je, void 0);
              Rt(this, Ot, void 0);
              Rt(this, At, void 0);
              Rt(this, ze, void 0);
              Rt(this, we, void 0);
              Rt(this, Ae, void 0);
              Rt(this, Re, void 0);
              Rt(this, je, 0);
              zt(this, Qe, jt), zt(this, Je, Gt);
            }
            addFilter(jt) {
              if (!jt)
                return "none";
              let Gt = Oe(this, Fe, qn).get(jt);
              if (Gt)
                return Gt;
              let ln, sn, _n, un;
              if (jt.length === 1) {
                const Pn = jt[0], Rn = new Array(256);
                for (let Kt = 0; Kt < 256; Kt++)
                  Rn[Kt] = Pn[Kt] / 255;
                un = ln = sn = _n = Rn.join(",");
              } else {
                const [Pn, Rn, Kt] = jt, Ht = new Array(256), Lt = new Array(256), Zt = new Array(256);
                for (let Jt = 0; Jt < 256; Jt++)
                  Ht[Jt] = Pn[Jt] / 255, Lt[Jt] = Rn[Jt] / 255, Zt[Jt] = Kt[Jt] / 255;
                ln = Ht.join(","), sn = Lt.join(","), _n = Zt.join(","), un = `${ln}${sn}${_n}`;
              }
              if (Gt = Oe(this, Fe, qn).get(un), Gt)
                return Oe(this, Fe, qn).set(jt, Gt), Gt;
              const En = `g_${Oe(this, Qe)}_transfer_map_${Xn(this, je)._++}`, wn = `url(#${En})`;
              Oe(this, Fe, qn).set(jt, wn), Oe(this, Fe, qn).set(un, wn);
              const Tn = Nt(this, pt, lr).call(this, En);
              return Nt(this, nn, Jn).call(this, ln, sn, _n, Tn), wn;
            }
            addHCMFilter(jt, Gt) {
              var Rn;
              const ln = `${jt}-${Gt}`;
              if (Oe(this, At) === ln)
                return Oe(this, ze);
              if (zt(this, At, ln), zt(this, ze, "none"), (Rn = Oe(this, Ot)) == null || Rn.remove(), !jt || !Gt)
                return Oe(this, ze);
              const sn = Nt(this, en, Qn).call(this, jt);
              jt = re.Util.makeHexColor(...sn);
              const _n = Nt(this, en, Qn).call(this, Gt);
              if (Gt = re.Util.makeHexColor(..._n), Oe(this, qe, Vn).style.color = "", jt === "#000000" && Gt === "#ffffff" || jt === Gt)
                return Oe(this, ze);
              const un = new Array(256);
              for (let Kt = 0; Kt <= 255; Kt++) {
                const Ht = Kt / 255;
                un[Kt] = Ht <= 0.03928 ? Ht / 12.92 : ((Ht + 0.055) / 1.055) ** 2.4;
              }
              const En = un.join(","), wn = `g_${Oe(this, Qe)}_hcm_filter`, Tn = zt(this, we, Nt(this, pt, lr).call(this, wn));
              Nt(this, nn, Jn).call(this, En, En, En, Tn), Nt(this, Ke, Lr).call(this, Tn);
              const Pn = (Kt, Ht) => {
                const Lt = sn[Kt] / 255, Zt = _n[Kt] / 255, Jt = new Array(Ht + 1);
                for (let Dn = 0; Dn <= Ht; Dn++)
                  Jt[Dn] = Lt + Dn / Ht * (Zt - Lt);
                return Jt.join(",");
              };
              return Nt(this, nn, Jn).call(this, Pn(0, 5), Pn(1, 5), Pn(2, 5), Tn), zt(this, ze, `url(#${wn})`), Oe(this, ze);
            }
            addHighlightHCMFilter(jt, Gt, ln, sn) {
              var Zt;
              const _n = `${jt}-${Gt}-${ln}-${sn}`;
              if (Oe(this, Ae) === _n)
                return Oe(this, Re);
              if (zt(this, Ae, _n), zt(this, Re, "none"), (Zt = Oe(this, we)) == null || Zt.remove(), !jt || !Gt)
                return Oe(this, Re);
              const [un, En] = [jt, Gt].map(Nt(this, en, Qn).bind(this));
              let wn = Math.round(0.2126 * un[0] + 0.7152 * un[1] + 0.0722 * un[2]), Tn = Math.round(0.2126 * En[0] + 0.7152 * En[1] + 0.0722 * En[2]), [Pn, Rn] = [ln, sn].map(Nt(this, en, Qn).bind(this));
              Tn < wn && ([wn, Tn, Pn, Rn] = [Tn, wn, Rn, Pn]), Oe(this, qe, Vn).style.color = "";
              const Kt = (Jt, Dn, kn) => {
                const $t = new Array(256), on = (Tn - wn) / kn, gn = Jt / 255, dn = (Dn - Jt) / (255 * kn);
                let vn = 0;
                for (let xn = 0; xn <= kn; xn++) {
                  const In = Math.round(wn + xn * on), Qt = gn + xn * dn;
                  for (let Mn = vn; Mn <= In; Mn++)
                    $t[Mn] = Qt;
                  vn = In + 1;
                }
                for (let xn = vn; xn < 256; xn++)
                  $t[xn] = $t[vn - 1];
                return $t.join(",");
              }, Ht = `g_${Oe(this, Qe)}_hcm_highlight_filter`, Lt = zt(this, we, Nt(this, pt, lr).call(this, Ht));
              return Nt(this, Ke, Lr).call(this, Lt), Nt(this, nn, Jn).call(this, Kt(Pn[0], Rn[0], 5), Kt(Pn[1], Rn[1], 5), Kt(Pn[2], Rn[2], 5), Lt), zt(this, Re, `url(#${Ht})`), Oe(this, Re);
            }
            destroy(jt = !1) {
              jt && (Oe(this, ze) || Oe(this, Re)) || (Oe(this, Ue) && (Oe(this, Ue).parentNode.parentNode.remove(), zt(this, Ue, null)), Oe(this, Ze) && (Oe(this, Ze).clear(), zt(this, Ze, null)), zt(this, je, 0));
            }
          }
          Ze = new WeakMap(), Ue = new WeakMap(), Qe = new WeakMap(), Je = new WeakMap(), Ot = new WeakMap(), At = new WeakMap(), ze = new WeakMap(), we = new WeakMap(), Ae = new WeakMap(), Re = new WeakMap(), je = new WeakMap(), Fe = new WeakSet(), qn = function() {
            return Oe(this, Ze) || zt(this, Ze, /* @__PURE__ */ new Map());
          }, qe = new WeakSet(), Vn = function() {
            if (!Oe(this, Ue)) {
              const jt = Oe(this, Je).createElement("div"), {
                style: Gt
              } = jt;
              Gt.visibility = "hidden", Gt.contain = "strict", Gt.width = Gt.height = 0, Gt.position = "absolute", Gt.top = Gt.left = 0, Gt.zIndex = -1;
              const ln = Oe(this, Je).createElementNS(se, "svg");
              ln.setAttribute("width", 0), ln.setAttribute("height", 0), zt(this, Ue, Oe(this, Je).createElementNS(se, "defs")), jt.append(ln), ln.append(Oe(this, Ue)), Oe(this, Je).body.append(jt);
            }
            return Oe(this, Ue);
          }, Ke = new WeakSet(), Lr = function(jt) {
            const Gt = Oe(this, Je).createElementNS(se, "feColorMatrix");
            Gt.setAttribute("type", "matrix"), Gt.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), jt.append(Gt);
          }, pt = new WeakSet(), lr = function(jt) {
            const Gt = Oe(this, Je).createElementNS(se, "filter");
            return Gt.setAttribute("color-interpolation-filters", "sRGB"), Gt.setAttribute("id", jt), Oe(this, qe, Vn).append(Gt), Gt;
          }, Vt = new WeakSet(), ur = function(jt, Gt, ln) {
            const sn = Oe(this, Je).createElementNS(se, Gt);
            sn.setAttribute("type", "discrete"), sn.setAttribute("tableValues", ln), jt.append(sn);
          }, nn = new WeakSet(), Jn = function(jt, Gt, ln, sn) {
            const _n = Oe(this, Je).createElementNS(se, "feComponentTransfer");
            sn.append(_n), Nt(this, Vt, ur).call(this, _n, "feFuncR", jt), Nt(this, Vt, ur).call(this, _n, "feFuncG", Gt), Nt(this, Vt, ur).call(this, _n, "feFuncB", ln);
          }, en = new WeakSet(), Qn = function(jt) {
            return Oe(this, qe, Vn).style.color = jt, Me(getComputedStyle(Oe(this, qe, Vn)).getPropertyValue("color"));
          }, ee.DOMFilterFactory = oe;
          class le extends ne.BaseCanvasFactory {
            constructor({
              ownerDocument: Ut = globalThis.document
            } = {}) {
              super(), this._document = Ut;
            }
            _createCanvas(Ut, jt) {
              const Gt = this._document.createElement("canvas");
              return Gt.width = Ut, Gt.height = jt, Gt;
            }
          }
          ee.DOMCanvasFactory = le;
          async function ue(Yt, Ut = !1) {
            if (Se(Yt, document.baseURI)) {
              const jt = await fetch(Yt);
              if (!jt.ok)
                throw new Error(jt.statusText);
              return Ut ? new Uint8Array(await jt.arrayBuffer()) : (0, re.stringToBytes)(await jt.text());
            }
            return new Promise((jt, Gt) => {
              const ln = new XMLHttpRequest();
              ln.open("GET", Yt, !0), Ut && (ln.responseType = "arraybuffer"), ln.onreadystatechange = () => {
                if (ln.readyState === XMLHttpRequest.DONE) {
                  if (ln.status === 200 || ln.status === 0) {
                    let sn;
                    if (Ut && ln.response ? sn = new Uint8Array(ln.response) : !Ut && ln.responseText && (sn = (0, re.stringToBytes)(ln.responseText)), sn) {
                      jt(sn);
                      return;
                    }
                  }
                  Gt(new Error(ln.statusText));
                }
              }, ln.send(null);
            });
          }
          class de extends ne.BaseCMapReaderFactory {
            _fetchData(Ut, jt) {
              return ue(Ut, this.isCompressed).then((Gt) => ({
                cMapData: Gt,
                compressionType: jt
              }));
            }
          }
          ee.DOMCMapReaderFactory = de;
          class fe extends ne.BaseStandardFontDataFactory {
            _fetchData(Ut) {
              return ue(Ut, !0);
            }
          }
          ee.DOMStandardFontDataFactory = fe;
          class pe extends ne.BaseSVGFactory {
            _createSVG(Ut) {
              return document.createElementNS(se, Ut);
            }
          }
          ee.DOMSVGFactory = pe;
          class ye {
            constructor({
              viewBox: Ut,
              scale: jt,
              rotation: Gt,
              offsetX: ln = 0,
              offsetY: sn = 0,
              dontFlip: _n = !1
            }) {
              this.viewBox = Ut, this.scale = jt, this.rotation = Gt, this.offsetX = ln, this.offsetY = sn;
              const un = (Ut[2] + Ut[0]) / 2, En = (Ut[3] + Ut[1]) / 2;
              let wn, Tn, Pn, Rn;
              switch (Gt %= 360, Gt < 0 && (Gt += 360), Gt) {
                case 180:
                  wn = -1, Tn = 0, Pn = 0, Rn = 1;
                  break;
                case 90:
                  wn = 0, Tn = 1, Pn = 1, Rn = 0;
                  break;
                case 270:
                  wn = 0, Tn = -1, Pn = -1, Rn = 0;
                  break;
                case 0:
                  wn = 1, Tn = 0, Pn = 0, Rn = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              _n && (Pn = -Pn, Rn = -Rn);
              let Kt, Ht, Lt, Zt;
              wn === 0 ? (Kt = Math.abs(En - Ut[1]) * jt + ln, Ht = Math.abs(un - Ut[0]) * jt + sn, Lt = (Ut[3] - Ut[1]) * jt, Zt = (Ut[2] - Ut[0]) * jt) : (Kt = Math.abs(un - Ut[0]) * jt + ln, Ht = Math.abs(En - Ut[1]) * jt + sn, Lt = (Ut[2] - Ut[0]) * jt, Zt = (Ut[3] - Ut[1]) * jt), this.transform = [wn * jt, Tn * jt, Pn * jt, Rn * jt, Kt - wn * jt * un - Pn * jt * En, Ht - Tn * jt * un - Rn * jt * En], this.width = Lt, this.height = Zt;
            }
            get rawDims() {
              const {
                viewBox: Ut
              } = this;
              return (0, re.shadow)(this, "rawDims", {
                pageWidth: Ut[2] - Ut[0],
                pageHeight: Ut[3] - Ut[1],
                pageX: Ut[0],
                pageY: Ut[1]
              });
            }
            clone({
              scale: Ut = this.scale,
              rotation: jt = this.rotation,
              offsetX: Gt = this.offsetX,
              offsetY: ln = this.offsetY,
              dontFlip: sn = !1
            } = {}) {
              return new ye({
                viewBox: this.viewBox.slice(),
                scale: Ut,
                rotation: jt,
                offsetX: Gt,
                offsetY: ln,
                dontFlip: sn
              });
            }
            convertToViewportPoint(Ut, jt) {
              return re.Util.applyTransform([Ut, jt], this.transform);
            }
            convertToViewportRectangle(Ut) {
              const jt = re.Util.applyTransform([Ut[0], Ut[1]], this.transform), Gt = re.Util.applyTransform([Ut[2], Ut[3]], this.transform);
              return [jt[0], jt[1], Gt[0], Gt[1]];
            }
            convertToPdfPoint(Ut, jt) {
              return re.Util.applyInverseTransform([Ut, jt], this.transform);
            }
          }
          ee.PageViewport = ye;
          class me extends re.BaseException {
            constructor(Ut, jt = 0) {
              super(Ut, "RenderingCancelledException"), this.extraDelay = jt;
            }
          }
          ee.RenderingCancelledException = me;
          function ve(Yt) {
            const Ut = Yt.length;
            let jt = 0;
            for (; jt < Ut && Yt[jt].trim() === ""; )
              jt++;
            return Yt.substring(jt, jt + 5).toLowerCase() === "data:";
          }
          function ge(Yt) {
            return typeof Yt == "string" && /\.pdf$/i.test(Yt);
          }
          function xe(Yt, Ut = !1) {
            return Ut || ([Yt] = Yt.split(/[#?]/, 1)), Yt.substring(Yt.lastIndexOf("/") + 1);
          }
          function Ee(Yt, Ut = "document.pdf") {
            if (typeof Yt != "string")
              return Ut;
            if (ve(Yt))
              return (0, re.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), Ut;
            const jt = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, Gt = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, ln = jt.exec(Yt);
            let sn = Gt.exec(ln[1]) || Gt.exec(ln[2]) || Gt.exec(ln[3]);
            if (sn && (sn = sn[0], sn.includes("%")))
              try {
                sn = Gt.exec(decodeURIComponent(sn))[0];
              } catch {
              }
            return sn || Ut;
          }
          class Te {
            constructor() {
              On(this, "started", /* @__PURE__ */ Object.create(null));
              On(this, "times", []);
            }
            time(Ut) {
              Ut in this.started && (0, re.warn)(`Timer is already running for ${Ut}`), this.started[Ut] = Date.now();
            }
            timeEnd(Ut) {
              Ut in this.started || (0, re.warn)(`Timer has not been started for ${Ut}`), this.times.push({
                name: Ut,
                start: this.started[Ut],
                end: Date.now()
              }), delete this.started[Ut];
            }
            toString() {
              const Ut = [];
              let jt = 0;
              for (const {
                name: Gt
              } of this.times)
                jt = Math.max(Gt.length, jt);
              for (const {
                name: Gt,
                start: ln,
                end: sn
              } of this.times)
                Ut.push(`${Gt.padEnd(jt)} ${sn - ln}ms
`);
              return Ut.join("");
            }
          }
          ee.StatTimer = Te;
          function Se(Yt, Ut) {
            try {
              const {
                protocol: jt
              } = Ut ? new URL(Yt, Ut) : new URL(Yt);
              return jt === "http:" || jt === "https:";
            } catch {
              return !1;
            }
          }
          function he(Yt) {
            Yt.preventDefault();
          }
          function Pe(Yt, Ut = !1) {
            return new Promise((jt, Gt) => {
              const ln = document.createElement("script");
              ln.src = Yt, ln.onload = function(sn) {
                Ut && ln.remove(), jt(sn);
              }, ln.onerror = function() {
                Gt(new Error(`Cannot load script at: ${ln.src}`));
              }, (document.head || document.documentElement).append(ln);
            });
          }
          function Ie(Yt) {
            console.log("Deprecated API usage: " + Yt);
          }
          let De;
          class Ce {
            static toDateObject(Ut) {
              if (!Ut || typeof Ut != "string")
                return null;
              De || (De = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const jt = De.exec(Ut);
              if (!jt)
                return null;
              const Gt = parseInt(jt[1], 10);
              let ln = parseInt(jt[2], 10);
              ln = ln >= 1 && ln <= 12 ? ln - 1 : 0;
              let sn = parseInt(jt[3], 10);
              sn = sn >= 1 && sn <= 31 ? sn : 1;
              let _n = parseInt(jt[4], 10);
              _n = _n >= 0 && _n <= 23 ? _n : 0;
              let un = parseInt(jt[5], 10);
              un = un >= 0 && un <= 59 ? un : 0;
              let En = parseInt(jt[6], 10);
              En = En >= 0 && En <= 59 ? En : 0;
              const wn = jt[7] || "Z";
              let Tn = parseInt(jt[8], 10);
              Tn = Tn >= 0 && Tn <= 23 ? Tn : 0;
              let Pn = parseInt(jt[9], 10) || 0;
              return Pn = Pn >= 0 && Pn <= 59 ? Pn : 0, wn === "-" ? (_n += Tn, un += Pn) : wn === "+" && (_n -= Tn, un -= Pn), new Date(Date.UTC(Gt, ln, sn, _n, un, En));
            }
          }
          ee.PDFDateString = Ce;
          function Ne(Yt, {
            scale: Ut = 1,
            rotation: jt = 0
          }) {
            const {
              width: Gt,
              height: ln
            } = Yt.attributes.style, sn = [0, 0, parseInt(Gt), parseInt(ln)];
            return new ye({
              viewBox: sn,
              scale: Ut,
              rotation: jt
            });
          }
          function Me(Yt) {
            if (Yt.startsWith("#")) {
              const Ut = parseInt(Yt.slice(1), 16);
              return [(Ut & 16711680) >> 16, (Ut & 65280) >> 8, Ut & 255];
            }
            return Yt.startsWith("rgb(") ? Yt.slice(4, -1).split(",").map((Ut) => parseInt(Ut)) : Yt.startsWith("rgba(") ? Yt.slice(5, -1).split(",").map((Ut) => parseInt(Ut)).slice(0, 3) : ((0, re.warn)(`Not a valid color format: "${Yt}"`), [0, 0, 0]);
          }
          function Be(Yt) {
            const Ut = document.createElement("span");
            Ut.style.visibility = "hidden", document.body.append(Ut);
            for (const jt of Yt.keys()) {
              Ut.style.color = jt;
              const Gt = window.getComputedStyle(Ut).color;
              Yt.set(jt, Me(Gt));
            }
            Ut.remove();
          }
          function We(Yt) {
            const {
              a: Ut,
              b: jt,
              c: Gt,
              d: ln,
              e: sn,
              f: _n
            } = Yt.getTransform();
            return [Ut, jt, Gt, ln, sn, _n];
          }
          function Le(Yt) {
            const {
              a: Ut,
              b: jt,
              c: Gt,
              d: ln,
              e: sn,
              f: _n
            } = Yt.getTransform().invertSelf();
            return [Ut, jt, Gt, ln, sn, _n];
          }
          function He(Yt, Ut, jt = !1, Gt = !0) {
            if (Ut instanceof ye) {
              const {
                pageWidth: ln,
                pageHeight: sn
              } = Ut.rawDims, {
                style: _n
              } = Yt, un = re.FeatureTest.isCSSRoundSupported, En = `var(--scale-factor) * ${ln}px`, wn = `var(--scale-factor) * ${sn}px`, Tn = un ? `round(${En}, 1px)` : `calc(${En})`, Pn = un ? `round(${wn}, 1px)` : `calc(${wn})`;
              !jt || Ut.rotation % 180 === 0 ? (_n.width = Tn, _n.height = Pn) : (_n.width = Pn, _n.height = Tn);
            }
            Gt && Yt.setAttribute("data-main-rotation", Ut.rotation);
          }
        },
        /* 7 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.BaseStandardFontDataFactory = ee.BaseSVGFactory = ee.BaseFilterFactory = ee.BaseCanvasFactory = ee.BaseCMapReaderFactory = void 0;
          var ne = te(1);
          class re {
            constructor() {
              this.constructor === re && (0, ne.unreachable)("Cannot initialize BaseFilterFactory.");
            }
            addFilter(de) {
              return "none";
            }
            addHCMFilter(de, fe) {
              return "none";
            }
            addHighlightHCMFilter(de, fe, pe, ye) {
              return "none";
            }
            destroy(de = !1) {
            }
          }
          ee.BaseFilterFactory = re;
          class se {
            constructor() {
              this.constructor === se && (0, ne.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(de, fe) {
              if (de <= 0 || fe <= 0)
                throw new Error("Invalid canvas size");
              const pe = this._createCanvas(de, fe);
              return {
                canvas: pe,
                context: pe.getContext("2d")
              };
            }
            reset(de, fe, pe) {
              if (!de.canvas)
                throw new Error("Canvas is not specified");
              if (fe <= 0 || pe <= 0)
                throw new Error("Invalid canvas size");
              de.canvas.width = fe, de.canvas.height = pe;
            }
            destroy(de) {
              if (!de.canvas)
                throw new Error("Canvas is not specified");
              de.canvas.width = 0, de.canvas.height = 0, de.canvas = null, de.context = null;
            }
            _createCanvas(de, fe) {
              (0, ne.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          ee.BaseCanvasFactory = se;
          class ie {
            constructor({
              baseUrl: de = null,
              isCompressed: fe = !0
            }) {
              this.constructor === ie && (0, ne.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = de, this.isCompressed = fe;
            }
            async fetch({
              name: de
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!de)
                throw new Error("CMap name must be specified.");
              const fe = this.baseUrl + de + (this.isCompressed ? ".bcmap" : ""), pe = this.isCompressed ? ne.CMapCompressionType.BINARY : ne.CMapCompressionType.NONE;
              return this._fetchData(fe, pe).catch((ye) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${fe}`);
              });
            }
            _fetchData(de, fe) {
              (0, ne.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ee.BaseCMapReaderFactory = ie;
          class oe {
            constructor({
              baseUrl: de = null
            }) {
              this.constructor === oe && (0, ne.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = de;
            }
            async fetch({
              filename: de
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!de)
                throw new Error("Font filename must be specified.");
              const fe = `${this.baseUrl}${de}`;
              return this._fetchData(fe).catch((pe) => {
                throw new Error(`Unable to load font data at: ${fe}`);
              });
            }
            _fetchData(de) {
              (0, ne.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          ee.BaseStandardFontDataFactory = oe;
          class le {
            constructor() {
              this.constructor === le && (0, ne.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(de, fe, pe = !1) {
              if (de <= 0 || fe <= 0)
                throw new Error("Invalid SVG dimensions");
              const ye = this._createSVG("svg:svg");
              return ye.setAttribute("version", "1.1"), pe || (ye.setAttribute("width", `${de}px`), ye.setAttribute("height", `${fe}px`)), ye.setAttribute("preserveAspectRatio", "none"), ye.setAttribute("viewBox", `0 0 ${de} ${fe}`), ye;
            }
            createElement(de) {
              if (typeof de != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(de);
            }
            _createSVG(de) {
              (0, ne.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          ee.BaseSVGFactory = le;
        },
        /* 8 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.MurmurHash3_64 = void 0;
          var ne = te(1);
          const re = 3285377520, se = 4294901760, ie = 65535;
          class oe {
            constructor(ue) {
              this.h1 = ue ? ue & 4294967295 : re, this.h2 = ue ? ue & 4294967295 : re;
            }
            update(ue) {
              let de, fe;
              if (typeof ue == "string") {
                de = new Uint8Array(ue.length * 2), fe = 0;
                for (let Ie = 0, De = ue.length; Ie < De; Ie++) {
                  const Ce = ue.charCodeAt(Ie);
                  Ce <= 255 ? de[fe++] = Ce : (de[fe++] = Ce >>> 8, de[fe++] = Ce & 255);
                }
              } else if ((0, ne.isArrayBuffer)(ue))
                de = ue.slice(), fe = de.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const pe = fe >> 2, ye = fe - pe * 4, me = new Uint32Array(de.buffer, 0, pe);
              let ve = 0, ge = 0, xe = this.h1, Ee = this.h2;
              const Te = 3432918353, Se = 461845907, he = Te & ie, Pe = Se & ie;
              for (let Ie = 0; Ie < pe; Ie++)
                Ie & 1 ? (ve = me[Ie], ve = ve * Te & se | ve * he & ie, ve = ve << 15 | ve >>> 17, ve = ve * Se & se | ve * Pe & ie, xe ^= ve, xe = xe << 13 | xe >>> 19, xe = xe * 5 + 3864292196) : (ge = me[Ie], ge = ge * Te & se | ge * he & ie, ge = ge << 15 | ge >>> 17, ge = ge * Se & se | ge * Pe & ie, Ee ^= ge, Ee = Ee << 13 | Ee >>> 19, Ee = Ee * 5 + 3864292196);
              switch (ve = 0, ye) {
                case 3:
                  ve ^= de[pe * 4 + 2] << 16;
                case 2:
                  ve ^= de[pe * 4 + 1] << 8;
                case 1:
                  ve ^= de[pe * 4], ve = ve * Te & se | ve * he & ie, ve = ve << 15 | ve >>> 17, ve = ve * Se & se | ve * Pe & ie, pe & 1 ? xe ^= ve : Ee ^= ve;
              }
              this.h1 = xe, this.h2 = Ee;
            }
            hexdigest() {
              let ue = this.h1, de = this.h2;
              return ue ^= de >>> 1, ue = ue * 3981806797 & se | ue * 36045 & ie, de = de * 4283543511 & se | ((de << 16 | ue >>> 16) * 2950163797 & se) >>> 16, ue ^= de >>> 1, ue = ue * 444984403 & se | ue * 60499 & ie, de = de * 3301882366 & se | ((de << 16 | ue >>> 16) * 3120437893 & se) >>> 16, ue ^= de >>> 1, (ue >>> 0).toString(16).padStart(8, "0") + (de >>> 0).toString(16).padStart(8, "0");
            }
          }
          ee.MurmurHash3_64 = oe;
        },
        /* 9 */
        /***/
        ($, ee, te) => {
          var ie;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.FontLoader = ee.FontFaceObject = void 0;
          var ne = te(1);
          class re {
            constructor({
              ownerDocument: le = globalThis.document,
              styleElement: ue = null
            }) {
              Rt(this, ie, /* @__PURE__ */ new Set());
              this._document = le, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
            }
            addNativeFontFace(le) {
              this.nativeFontFaces.add(le), this._document.fonts.add(le);
            }
            removeNativeFontFace(le) {
              this.nativeFontFaces.delete(le), this._document.fonts.delete(le);
            }
            insertRule(le) {
              this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
              const ue = this.styleElement.sheet;
              ue.insertRule(le, ue.cssRules.length);
            }
            clear() {
              for (const le of this.nativeFontFaces)
                this._document.fonts.delete(le);
              this.nativeFontFaces.clear(), Oe(this, ie).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async loadSystemFont(le) {
              if (!(!le || Oe(this, ie).has(le.loadedName))) {
                if ((0, ne.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                  const {
                    loadedName: ue,
                    src: de,
                    style: fe
                  } = le, pe = new FontFace(ue, de, fe);
                  this.addNativeFontFace(pe);
                  try {
                    await pe.load(), Oe(this, ie).add(ue);
                  } catch {
                    (0, ne.warn)(`Cannot load system font: ${le.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(pe);
                  }
                  return;
                }
                (0, ne.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
              }
            }
            async bind(le) {
              if (le.attached || le.missingFile && !le.systemFontInfo)
                return;
              if (le.attached = !0, le.systemFontInfo) {
                await this.loadSystemFont(le.systemFontInfo);
                return;
              }
              if (this.isFontLoadingAPISupported) {
                const de = le.createNativeFontFace();
                if (de) {
                  this.addNativeFontFace(de);
                  try {
                    await de.loaded;
                  } catch (fe) {
                    throw (0, ne.warn)(`Failed to load font '${de.family}': '${fe}'.`), le.disableFontFace = !0, fe;
                  }
                }
                return;
              }
              const ue = le.createFontFaceRule();
              if (ue) {
                if (this.insertRule(ue), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((de) => {
                  const fe = this._queueLoadingCallback(de);
                  this._prepareFontLoadEvent(le, fe);
                });
              }
            }
            get isFontLoadingAPISupported() {
              var ue;
              const le = !!((ue = this._document) != null && ue.fonts);
              return (0, ne.shadow)(this, "isFontLoadingAPISupported", le);
            }
            get isSyncFontLoadingSupported() {
              let le = !1;
              return (ne.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (le = !0), (0, ne.shadow)(this, "isSyncFontLoadingSupported", le);
            }
            _queueLoadingCallback(le) {
              function ue() {
                for ((0, ne.assert)(!fe.done, "completeRequest() cannot be called twice."), fe.done = !0; de.length > 0 && de[0].done; ) {
                  const pe = de.shift();
                  setTimeout(pe.callback, 0);
                }
              }
              const {
                loadingRequests: de
              } = this, fe = {
                done: !1,
                complete: ue,
                callback: le
              };
              return de.push(fe), fe;
            }
            get _loadTestFont() {
              const le = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              return (0, ne.shadow)(this, "_loadTestFont", le);
            }
            _prepareFontLoadEvent(le, ue) {
              function de(Me, Be) {
                return Me.charCodeAt(Be) << 24 | Me.charCodeAt(Be + 1) << 16 | Me.charCodeAt(Be + 2) << 8 | Me.charCodeAt(Be + 3) & 255;
              }
              function fe(Me, Be, We, Le) {
                const He = Me.substring(0, Be), Ge = Me.substring(Be + We);
                return He + Le + Ge;
              }
              let pe, ye;
              const me = this._document.createElement("canvas");
              me.width = 1, me.height = 1;
              const ve = me.getContext("2d");
              let ge = 0;
              function xe(Me, Be) {
                if (++ge > 30) {
                  (0, ne.warn)("Load test font never loaded."), Be();
                  return;
                }
                if (ve.font = "30px " + Me, ve.fillText(".", 0, 20), ve.getImageData(0, 0, 1, 1).data[3] > 0) {
                  Be();
                  return;
                }
                setTimeout(xe.bind(null, Me, Be));
              }
              const Ee = `lt${Date.now()}${this.loadTestFontId++}`;
              let Te = this._loadTestFont;
              Te = fe(Te, 976, Ee.length, Ee);
              const he = 16, Pe = 1482184792;
              let Ie = de(Te, he);
              for (pe = 0, ye = Ee.length - 3; pe < ye; pe += 4)
                Ie = Ie - Pe + de(Ee, pe) | 0;
              pe < Ee.length && (Ie = Ie - Pe + de(Ee + "XXX", pe) | 0), Te = fe(Te, he, 4, (0, ne.string32)(Ie));
              const De = `url(data:font/opentype;base64,${btoa(Te)});`, Ce = `@font-face {font-family:"${Ee}";src:${De}}`;
              this.insertRule(Ce);
              const Ne = this._document.createElement("div");
              Ne.style.visibility = "hidden", Ne.style.width = Ne.style.height = "10px", Ne.style.position = "absolute", Ne.style.top = Ne.style.left = "0px";
              for (const Me of [le.loadedName, Ee]) {
                const Be = this._document.createElement("span");
                Be.textContent = "Hi", Be.style.fontFamily = Me, Ne.append(Be);
              }
              this._document.body.append(Ne), xe(Ee, () => {
                Ne.remove(), ue.complete();
              });
            }
          }
          ie = new WeakMap(), ee.FontLoader = re;
          class se {
            constructor(le, {
              isEvalSupported: ue = !0,
              disableFontFace: de = !1,
              ignoreErrors: fe = !1,
              inspectFont: pe = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const ye in le)
                this[ye] = le[ye];
              this.isEvalSupported = ue !== !1, this.disableFontFace = de === !0, this.ignoreErrors = fe === !0, this._inspectFont = pe;
            }
            createNativeFontFace() {
              var ue;
              if (!this.data || this.disableFontFace)
                return null;
              let le;
              if (!this.cssFontInfo)
                le = new FontFace(this.loadedName, this.data, {});
              else {
                const de = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (de.style = `oblique ${this.cssFontInfo.italicAngle}deg`), le = new FontFace(this.cssFontInfo.fontFamily, this.data, de);
              }
              return (ue = this._inspectFont) == null || ue.call(this, this), le;
            }
            createFontFaceRule() {
              var fe;
              if (!this.data || this.disableFontFace)
                return null;
              const le = (0, ne.bytesToString)(this.data), ue = `url(data:${this.mimetype};base64,${btoa(le)});`;
              let de;
              if (!this.cssFontInfo)
                de = `@font-face {font-family:"${this.loadedName}";src:${ue}}`;
              else {
                let pe = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (pe += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), de = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${pe}src:${ue}}`;
              }
              return (fe = this._inspectFont) == null || fe.call(this, this, ue), de;
            }
            getPathGenerator(le, ue) {
              if (this.compiledGlyphs[ue] !== void 0)
                return this.compiledGlyphs[ue];
              let de;
              try {
                de = le.get(this.loadedName + "_path_" + ue);
              } catch (fe) {
                if (!this.ignoreErrors)
                  throw fe;
                return (0, ne.warn)(`getPathGenerator - ignoring character: "${fe}".`), this.compiledGlyphs[ue] = function(pe, ye) {
                };
              }
              if (this.isEvalSupported && ne.FeatureTest.isEvalSupported) {
                const fe = [];
                for (const pe of de) {
                  const ye = pe.args !== void 0 ? pe.args.join(",") : "";
                  fe.push("c.", pe.cmd, "(", ye, `);
`);
                }
                return this.compiledGlyphs[ue] = new Function("c", "size", fe.join(""));
              }
              return this.compiledGlyphs[ue] = function(fe, pe) {
                for (const ye of de)
                  ye.cmd === "scale" && (ye.args = [pe, -pe]), fe[ye.cmd].apply(fe, ye.args);
              };
            }
          }
          ee.FontFaceObject = se;
        },
        /* 10 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.NodeStandardFontDataFactory = ee.NodeFilterFactory = ee.NodeCanvasFactory = ee.NodeCMapReaderFactory = void 0;
          var ne = te(7);
          te(1);
          const re = function(ue) {
            return new Promise((de, fe) => {
              require$$5$2.readFile(ue, (ye, me) => {
                if (ye || !me) {
                  fe(new Error(ye));
                  return;
                }
                de(new Uint8Array(me));
              });
            });
          };
          class se extends ne.BaseFilterFactory {
          }
          ee.NodeFilterFactory = se;
          class ie extends ne.BaseCanvasFactory {
            _createCanvas(de, fe) {
              return require$$5$2.createCanvas(de, fe);
            }
          }
          ee.NodeCanvasFactory = ie;
          class oe extends ne.BaseCMapReaderFactory {
            _fetchData(de, fe) {
              return re(de).then((pe) => ({
                cMapData: pe,
                compressionType: fe
              }));
            }
          }
          ee.NodeCMapReaderFactory = oe;
          class le extends ne.BaseStandardFontDataFactory {
            _fetchData(de) {
              return re(de);
            }
          }
          ee.NodeStandardFontDataFactory = le;
        },
        /* 11 */
        /***/
        ($, ee, te) => {
          var Ue, jr, Je, Fr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.CanvasGraphics = void 0;
          var ne = te(1), re = te(6), se = te(12), ie = te(13);
          const oe = 16, le = 100, ue = 4096, de = 15, fe = 10, pe = 1e3, ye = 16;
          function me(ze, we) {
            if (ze._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            ze.__originalSave = ze.save, ze.__originalRestore = ze.restore, ze.__originalRotate = ze.rotate, ze.__originalScale = ze.scale, ze.__originalTranslate = ze.translate, ze.__originalTransform = ze.transform, ze.__originalSetTransform = ze.setTransform, ze.__originalResetTransform = ze.resetTransform, ze.__originalClip = ze.clip, ze.__originalMoveTo = ze.moveTo, ze.__originalLineTo = ze.lineTo, ze.__originalBezierCurveTo = ze.bezierCurveTo, ze.__originalRect = ze.rect, ze.__originalClosePath = ze.closePath, ze.__originalBeginPath = ze.beginPath, ze._removeMirroring = () => {
              ze.save = ze.__originalSave, ze.restore = ze.__originalRestore, ze.rotate = ze.__originalRotate, ze.scale = ze.__originalScale, ze.translate = ze.__originalTranslate, ze.transform = ze.__originalTransform, ze.setTransform = ze.__originalSetTransform, ze.resetTransform = ze.__originalResetTransform, ze.clip = ze.__originalClip, ze.moveTo = ze.__originalMoveTo, ze.lineTo = ze.__originalLineTo, ze.bezierCurveTo = ze.__originalBezierCurveTo, ze.rect = ze.__originalRect, ze.closePath = ze.__originalClosePath, ze.beginPath = ze.__originalBeginPath, delete ze._removeMirroring;
            }, ze.save = function() {
              we.save(), this.__originalSave();
            }, ze.restore = function() {
              we.restore(), this.__originalRestore();
            }, ze.translate = function(Re, je) {
              we.translate(Re, je), this.__originalTranslate(Re, je);
            }, ze.scale = function(Re, je) {
              we.scale(Re, je), this.__originalScale(Re, je);
            }, ze.transform = function(Re, je, Fe, $e, qe, Ye) {
              we.transform(Re, je, Fe, $e, qe, Ye), this.__originalTransform(Re, je, Fe, $e, qe, Ye);
            }, ze.setTransform = function(Re, je, Fe, $e, qe, Ye) {
              we.setTransform(Re, je, Fe, $e, qe, Ye), this.__originalSetTransform(Re, je, Fe, $e, qe, Ye);
            }, ze.resetTransform = function() {
              we.resetTransform(), this.__originalResetTransform();
            }, ze.rotate = function(Re) {
              we.rotate(Re), this.__originalRotate(Re);
            }, ze.clip = function(Re) {
              we.clip(Re), this.__originalClip(Re);
            }, ze.moveTo = function(Ae, Re) {
              we.moveTo(Ae, Re), this.__originalMoveTo(Ae, Re);
            }, ze.lineTo = function(Ae, Re) {
              we.lineTo(Ae, Re), this.__originalLineTo(Ae, Re);
            }, ze.bezierCurveTo = function(Ae, Re, je, Fe, $e, qe) {
              we.bezierCurveTo(Ae, Re, je, Fe, $e, qe), this.__originalBezierCurveTo(Ae, Re, je, Fe, $e, qe);
            }, ze.rect = function(Ae, Re, je, Fe) {
              we.rect(Ae, Re, je, Fe), this.__originalRect(Ae, Re, je, Fe);
            }, ze.closePath = function() {
              we.closePath(), this.__originalClosePath();
            }, ze.beginPath = function() {
              we.beginPath(), this.__originalBeginPath();
            };
          }
          class ve {
            constructor(we) {
              this.canvasFactory = we, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(we, Ae, Re) {
              let je;
              return this.cache[we] !== void 0 ? (je = this.cache[we], this.canvasFactory.reset(je, Ae, Re)) : (je = this.canvasFactory.create(Ae, Re), this.cache[we] = je), je;
            }
            delete(we) {
              delete this.cache[we];
            }
            clear() {
              for (const we in this.cache) {
                const Ae = this.cache[we];
                this.canvasFactory.destroy(Ae), delete this.cache[we];
              }
            }
          }
          function ge(ze, we, Ae, Re, je, Fe, $e, qe, Ye, Ke) {
            const [Tt, pt, Bt, Vt, qt, nn] = (0, re.getCurrentTransform)(ze);
            if (pt === 0 && Bt === 0) {
              const pn = $e * Tt + qt, Yt = Math.round(pn), Ut = qe * Vt + nn, jt = Math.round(Ut), Gt = ($e + Ye) * Tt + qt, ln = Math.abs(Math.round(Gt) - Yt) || 1, sn = (qe + Ke) * Vt + nn, _n = Math.abs(Math.round(sn) - jt) || 1;
              return ze.setTransform(Math.sign(Tt), 0, 0, Math.sign(Vt), Yt, jt), ze.drawImage(we, Ae, Re, je, Fe, 0, 0, ln, _n), ze.setTransform(Tt, pt, Bt, Vt, qt, nn), [ln, _n];
            }
            if (Tt === 0 && Vt === 0) {
              const pn = qe * Bt + qt, Yt = Math.round(pn), Ut = $e * pt + nn, jt = Math.round(Ut), Gt = (qe + Ke) * Bt + qt, ln = Math.abs(Math.round(Gt) - Yt) || 1, sn = ($e + Ye) * pt + nn, _n = Math.abs(Math.round(sn) - jt) || 1;
              return ze.setTransform(0, Math.sign(pt), Math.sign(Bt), 0, Yt, jt), ze.drawImage(we, Ae, Re, je, Fe, 0, 0, _n, ln), ze.setTransform(Tt, pt, Bt, Vt, qt, nn), [_n, ln];
            }
            ze.drawImage(we, Ae, Re, je, Fe, $e, qe, Ye, Ke);
            const mn = Math.hypot(Tt, pt), en = Math.hypot(Bt, Vt);
            return [mn * Ye, en * Ke];
          }
          function xe(ze) {
            const {
              width: we,
              height: Ae
            } = ze;
            if (we > pe || Ae > pe)
              return null;
            const Re = 1e3, je = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), Fe = we + 1;
            let $e = new Uint8Array(Fe * (Ae + 1)), qe, Ye, Ke;
            const Tt = we + 7 & -8;
            let pt = new Uint8Array(Tt * Ae), Bt = 0;
            for (const en of ze.data) {
              let pn = 128;
              for (; pn > 0; )
                pt[Bt++] = en & pn ? 0 : 255, pn >>= 1;
            }
            let Vt = 0;
            for (Bt = 0, pt[Bt] !== 0 && ($e[0] = 1, ++Vt), Ye = 1; Ye < we; Ye++)
              pt[Bt] !== pt[Bt + 1] && ($e[Ye] = pt[Bt] ? 2 : 1, ++Vt), Bt++;
            for (pt[Bt] !== 0 && ($e[Ye] = 2, ++Vt), qe = 1; qe < Ae; qe++) {
              Bt = qe * Tt, Ke = qe * Fe, pt[Bt - Tt] !== pt[Bt] && ($e[Ke] = pt[Bt] ? 1 : 8, ++Vt);
              let en = (pt[Bt] ? 4 : 0) + (pt[Bt - Tt] ? 8 : 0);
              for (Ye = 1; Ye < we; Ye++)
                en = (en >> 2) + (pt[Bt + 1] ? 4 : 0) + (pt[Bt - Tt + 1] ? 8 : 0), je[en] && ($e[Ke + Ye] = je[en], ++Vt), Bt++;
              if (pt[Bt - Tt] !== pt[Bt] && ($e[Ke + Ye] = pt[Bt] ? 2 : 4, ++Vt), Vt > Re)
                return null;
            }
            for (Bt = Tt * (Ae - 1), Ke = qe * Fe, pt[Bt] !== 0 && ($e[Ke] = 8, ++Vt), Ye = 1; Ye < we; Ye++)
              pt[Bt] !== pt[Bt + 1] && ($e[Ke + Ye] = pt[Bt] ? 4 : 8, ++Vt), Bt++;
            if (pt[Bt] !== 0 && ($e[Ke + Ye] = 4, ++Vt), Vt > Re)
              return null;
            const qt = new Int32Array([0, Fe, -1, 0, -Fe, 0, 0, 0, 1]), nn = new Path2D();
            for (qe = 0; Vt && qe <= Ae; qe++) {
              let en = qe * Fe;
              const pn = en + we;
              for (; en < pn && !$e[en]; )
                en++;
              if (en === pn)
                continue;
              nn.moveTo(en % Fe, qe);
              const Yt = en;
              let Ut = $e[en];
              do {
                const jt = qt[Ut];
                do
                  en += jt;
                while (!$e[en]);
                const Gt = $e[en];
                Gt !== 5 && Gt !== 10 ? (Ut = Gt, $e[en] = 0) : (Ut = Gt & 51 * Ut >> 4, $e[en] &= Ut >> 2 | Ut << 2), nn.lineTo(en % Fe, en / Fe | 0), $e[en] || --Vt;
              } while (Yt !== en);
              --qe;
            }
            return pt = null, $e = null, function(en) {
              en.save(), en.scale(1 / we, -1 / Ae), en.translate(0, -Ae), en.fill(nn), en.beginPath(), en.restore();
            };
          }
          class Ee {
            constructor(we, Ae) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = ne.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = ne.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = ne.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, we, Ae]);
            }
            clone() {
              const we = Object.create(this);
              return we.clipBox = this.clipBox.slice(), we;
            }
            setCurrentPoint(we, Ae) {
              this.x = we, this.y = Ae;
            }
            updatePathMinMax(we, Ae, Re) {
              [Ae, Re] = ne.Util.applyTransform([Ae, Re], we), this.minX = Math.min(this.minX, Ae), this.minY = Math.min(this.minY, Re), this.maxX = Math.max(this.maxX, Ae), this.maxY = Math.max(this.maxY, Re);
            }
            updateRectMinMax(we, Ae) {
              const Re = ne.Util.applyTransform(Ae, we), je = ne.Util.applyTransform(Ae.slice(2), we);
              this.minX = Math.min(this.minX, Re[0], je[0]), this.minY = Math.min(this.minY, Re[1], je[1]), this.maxX = Math.max(this.maxX, Re[0], je[0]), this.maxY = Math.max(this.maxY, Re[1], je[1]);
            }
            updateScalingPathMinMax(we, Ae) {
              ne.Util.scaleMinMax(we, Ae), this.minX = Math.min(this.minX, Ae[0]), this.maxX = Math.max(this.maxX, Ae[1]), this.minY = Math.min(this.minY, Ae[2]), this.maxY = Math.max(this.maxY, Ae[3]);
            }
            updateCurvePathMinMax(we, Ae, Re, je, Fe, $e, qe, Ye, Ke, Tt) {
              const pt = ne.Util.bezierBoundingBox(Ae, Re, je, Fe, $e, qe, Ye, Ke);
              if (Tt) {
                Tt[0] = Math.min(Tt[0], pt[0], pt[2]), Tt[1] = Math.max(Tt[1], pt[0], pt[2]), Tt[2] = Math.min(Tt[2], pt[1], pt[3]), Tt[3] = Math.max(Tt[3], pt[1], pt[3]);
                return;
              }
              this.updateRectMinMax(we, pt);
            }
            getPathBoundingBox(we = se.PathType.FILL, Ae = null) {
              const Re = [this.minX, this.minY, this.maxX, this.maxY];
              if (we === se.PathType.STROKE) {
                Ae || (0, ne.unreachable)("Stroke bounding box must include transform.");
                const je = ne.Util.singularValueDecompose2dScale(Ae), Fe = je[0] * this.lineWidth / 2, $e = je[1] * this.lineWidth / 2;
                Re[0] -= Fe, Re[1] -= $e, Re[2] += Fe, Re[3] += $e;
              }
              return Re;
            }
            updateClipFromPath() {
              const we = ne.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(we || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(we) {
              this.clipBox = we, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(we = se.PathType.FILL, Ae = null) {
              return ne.Util.intersect(this.clipBox, this.getPathBoundingBox(we, Ae));
            }
          }
          function Te(ze, we) {
            if (typeof ImageData < "u" && we instanceof ImageData) {
              ze.putImageData(we, 0, 0);
              return;
            }
            const Ae = we.height, Re = we.width, je = Ae % ye, Fe = (Ae - je) / ye, $e = je === 0 ? Fe : Fe + 1, qe = ze.createImageData(Re, ye);
            let Ye = 0, Ke;
            const Tt = we.data, pt = qe.data;
            let Bt, Vt, qt, nn;
            if (we.kind === ne.ImageKind.GRAYSCALE_1BPP) {
              const mn = Tt.byteLength, en = new Uint32Array(pt.buffer, 0, pt.byteLength >> 2), pn = en.length, Yt = Re + 7 >> 3, Ut = 4294967295, jt = ne.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (Bt = 0; Bt < $e; Bt++) {
                for (qt = Bt < Fe ? ye : je, Ke = 0, Vt = 0; Vt < qt; Vt++) {
                  const Gt = mn - Ye;
                  let ln = 0;
                  const sn = Gt > Yt ? Re : Gt * 8 - 7, _n = sn & -8;
                  let un = 0, En = 0;
                  for (; ln < _n; ln += 8)
                    En = Tt[Ye++], en[Ke++] = En & 128 ? Ut : jt, en[Ke++] = En & 64 ? Ut : jt, en[Ke++] = En & 32 ? Ut : jt, en[Ke++] = En & 16 ? Ut : jt, en[Ke++] = En & 8 ? Ut : jt, en[Ke++] = En & 4 ? Ut : jt, en[Ke++] = En & 2 ? Ut : jt, en[Ke++] = En & 1 ? Ut : jt;
                  for (; ln < sn; ln++)
                    un === 0 && (En = Tt[Ye++], un = 128), en[Ke++] = En & un ? Ut : jt, un >>= 1;
                }
                for (; Ke < pn; )
                  en[Ke++] = 0;
                ze.putImageData(qe, 0, Bt * ye);
              }
            } else if (we.kind === ne.ImageKind.RGBA_32BPP) {
              for (Vt = 0, nn = Re * ye * 4, Bt = 0; Bt < Fe; Bt++)
                pt.set(Tt.subarray(Ye, Ye + nn)), Ye += nn, ze.putImageData(qe, 0, Vt), Vt += ye;
              Bt < $e && (nn = Re * je * 4, pt.set(Tt.subarray(Ye, Ye + nn)), ze.putImageData(qe, 0, Vt));
            } else if (we.kind === ne.ImageKind.RGB_24BPP)
              for (qt = ye, nn = Re * qt, Bt = 0; Bt < $e; Bt++) {
                for (Bt >= Fe && (qt = je, nn = Re * qt), Ke = 0, Vt = nn; Vt--; )
                  pt[Ke++] = Tt[Ye++], pt[Ke++] = Tt[Ye++], pt[Ke++] = Tt[Ye++], pt[Ke++] = 255;
                ze.putImageData(qe, 0, Bt * ye);
              }
            else
              throw new Error(`bad image kind: ${we.kind}`);
          }
          function Se(ze, we) {
            if (we.bitmap) {
              ze.drawImage(we.bitmap, 0, 0);
              return;
            }
            const Ae = we.height, Re = we.width, je = Ae % ye, Fe = (Ae - je) / ye, $e = je === 0 ? Fe : Fe + 1, qe = ze.createImageData(Re, ye);
            let Ye = 0;
            const Ke = we.data, Tt = qe.data;
            for (let pt = 0; pt < $e; pt++) {
              const Bt = pt < Fe ? ye : je;
              ({
                srcPos: Ye
              } = (0, ie.convertBlackAndWhiteToRGBA)({
                src: Ke,
                srcPos: Ye,
                dest: Tt,
                width: Re,
                height: Bt,
                nonBlackColor: 0
              })), ze.putImageData(qe, 0, pt * ye);
            }
          }
          function he(ze, we) {
            const Ae = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
            for (const Re of Ae)
              ze[Re] !== void 0 && (we[Re] = ze[Re]);
            ze.setLineDash !== void 0 && (we.setLineDash(ze.getLineDash()), we.lineDashOffset = ze.lineDashOffset);
          }
          function Pe(ze) {
            if (ze.strokeStyle = ze.fillStyle = "#000000", ze.fillRule = "nonzero", ze.globalAlpha = 1, ze.lineWidth = 1, ze.lineCap = "butt", ze.lineJoin = "miter", ze.miterLimit = 10, ze.globalCompositeOperation = "source-over", ze.font = "10px sans-serif", ze.setLineDash !== void 0 && (ze.setLineDash([]), ze.lineDashOffset = 0), !ne.isNodeJS) {
              const {
                filter: we
              } = ze;
              we !== "none" && we !== "" && (ze.filter = "none");
            }
          }
          function Ie(ze, we, Ae, Re) {
            const je = ze.length;
            for (let Fe = 3; Fe < je; Fe += 4) {
              const $e = ze[Fe];
              if ($e === 0)
                ze[Fe - 3] = we, ze[Fe - 2] = Ae, ze[Fe - 1] = Re;
              else if ($e < 255) {
                const qe = 255 - $e;
                ze[Fe - 3] = ze[Fe - 3] * $e + we * qe >> 8, ze[Fe - 2] = ze[Fe - 2] * $e + Ae * qe >> 8, ze[Fe - 1] = ze[Fe - 1] * $e + Re * qe >> 8;
              }
            }
          }
          function De(ze, we, Ae) {
            const Re = ze.length, je = 1 / 255;
            for (let Fe = 3; Fe < Re; Fe += 4) {
              const $e = Ae ? Ae[ze[Fe]] : ze[Fe];
              we[Fe] = we[Fe] * $e * je | 0;
            }
          }
          function Ce(ze, we, Ae) {
            const Re = ze.length;
            for (let je = 3; je < Re; je += 4) {
              const Fe = ze[je - 3] * 77 + ze[je - 2] * 152 + ze[je - 1] * 28;
              we[je] = Ae ? we[je] * Ae[Fe >> 8] >> 8 : we[je] * Fe >> 16;
            }
          }
          function Ne(ze, we, Ae, Re, je, Fe, $e, qe, Ye, Ke, Tt) {
            const pt = !!Fe, Bt = pt ? Fe[0] : 0, Vt = pt ? Fe[1] : 0, qt = pt ? Fe[2] : 0, nn = je === "Luminosity" ? Ce : De, en = Math.min(Re, Math.ceil(1048576 / Ae));
            for (let pn = 0; pn < Re; pn += en) {
              const Yt = Math.min(en, Re - pn), Ut = ze.getImageData(qe - Ke, pn + (Ye - Tt), Ae, Yt), jt = we.getImageData(qe, pn + Ye, Ae, Yt);
              pt && Ie(Ut.data, Bt, Vt, qt), nn(Ut.data, jt.data, $e), we.putImageData(jt, qe, pn + Ye);
            }
          }
          function Me(ze, we, Ae, Re) {
            const je = Re[0], Fe = Re[1], $e = Re[2] - je, qe = Re[3] - Fe;
            $e === 0 || qe === 0 || (Ne(we.context, Ae, $e, qe, we.subtype, we.backdrop, we.transferMap, je, Fe, we.offsetX, we.offsetY), ze.save(), ze.globalAlpha = 1, ze.globalCompositeOperation = "source-over", ze.setTransform(1, 0, 0, 1, 0, 0), ze.drawImage(Ae.canvas, 0, 0), ze.restore());
          }
          function Be(ze, we) {
            const Ae = ne.Util.singularValueDecompose2dScale(ze);
            Ae[0] = Math.fround(Ae[0]), Ae[1] = Math.fround(Ae[1]);
            const Re = Math.fround((globalThis.devicePixelRatio || 1) * re.PixelsPerInch.PDF_TO_CSS_UNITS);
            return we !== void 0 ? we : Ae[0] <= Re || Ae[1] <= Re;
          }
          const We = ["butt", "round", "square"], Le = ["miter", "round", "bevel"], He = {}, Ge = {}, At = class At {
            constructor(we, Ae, Re, je, Fe, {
              optionalContentConfig: $e,
              markedContentStack: qe = null
            }, Ye, Ke) {
              Rt(this, Ue);
              Rt(this, Je);
              this.ctx = we, this.current = new Ee(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = Ae, this.objs = Re, this.canvasFactory = je, this.filterFactory = Fe, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = qe || [], this.optionalContentConfig = $e, this.cachedCanvases = new ve(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = Ye, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = Ke, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(we, Ae = null) {
              return typeof we == "string" ? we.startsWith("g_") ? this.commonObjs.get(we) : this.objs.get(we) : Ae;
            }
            beginDrawing({
              transform: we,
              viewport: Ae,
              transparency: Re = !1,
              background: je = null
            }) {
              const Fe = this.ctx.canvas.width, $e = this.ctx.canvas.height, qe = this.ctx.fillStyle;
              if (this.ctx.fillStyle = je || "#ffffff", this.ctx.fillRect(0, 0, Fe, $e), this.ctx.fillStyle = qe, Re) {
                const Ye = this.cachedCanvases.getCanvas("transparent", Fe, $e);
                this.compositeCtx = this.ctx, this.transparentCanvas = Ye.canvas, this.ctx = Ye.context, this.ctx.save(), this.ctx.transform(...(0, re.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), Pe(this.ctx), we && (this.ctx.transform(...we), this.outputScaleX = we[0], this.outputScaleY = we[0]), this.ctx.transform(...Ae.transform), this.viewportScale = Ae.scale, this.baseTransform = (0, re.getCurrentTransform)(this.ctx);
            }
            executeOperatorList(we, Ae, Re, je) {
              const Fe = we.argsArray, $e = we.fnArray;
              let qe = Ae || 0;
              const Ye = Fe.length;
              if (Ye === qe)
                return qe;
              const Ke = Ye - qe > fe && typeof Re == "function", Tt = Ke ? Date.now() + de : 0;
              let pt = 0;
              const Bt = this.commonObjs, Vt = this.objs;
              let qt;
              for (; ; ) {
                if (je !== void 0 && qe === je.nextBreakPoint)
                  return je.breakIt(qe, Re), qe;
                if (qt = $e[qe], qt !== ne.OPS.dependency)
                  this[qt].apply(this, Fe[qe]);
                else
                  for (const nn of Fe[qe]) {
                    const mn = nn.startsWith("g_") ? Bt : Vt;
                    if (!mn.has(nn))
                      return mn.get(nn, Re), qe;
                  }
                if (qe++, qe === Ye)
                  return qe;
                if (Ke && ++pt > fe) {
                  if (Date.now() > Tt)
                    return Re(), qe;
                  pt = 0;
                }
              }
            }
            endDrawing() {
              Nt(this, Ue, jr).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const we of this._cachedBitmapsMap.values()) {
                for (const Ae of we.values())
                  typeof HTMLCanvasElement < "u" && Ae instanceof HTMLCanvasElement && (Ae.width = Ae.height = 0);
                we.clear();
              }
              this._cachedBitmapsMap.clear(), Nt(this, Je, Fr).call(this);
            }
            _scaleImage(we, Ae) {
              const Re = we.width, je = we.height;
              let Fe = Math.max(Math.hypot(Ae[0], Ae[1]), 1), $e = Math.max(Math.hypot(Ae[2], Ae[3]), 1), qe = Re, Ye = je, Ke = "prescale1", Tt, pt;
              for (; Fe > 2 && qe > 1 || $e > 2 && Ye > 1; ) {
                let Bt = qe, Vt = Ye;
                Fe > 2 && qe > 1 && (Bt = qe >= 16384 ? Math.floor(qe / 2) - 1 || 1 : Math.ceil(qe / 2), Fe /= qe / Bt), $e > 2 && Ye > 1 && (Vt = Ye >= 16384 ? Math.floor(Ye / 2) - 1 || 1 : Math.ceil(Ye) / 2, $e /= Ye / Vt), Tt = this.cachedCanvases.getCanvas(Ke, Bt, Vt), pt = Tt.context, pt.clearRect(0, 0, Bt, Vt), pt.drawImage(we, 0, 0, qe, Ye, 0, 0, Bt, Vt), we = Tt.canvas, qe = Bt, Ye = Vt, Ke = Ke === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: we,
                paintWidth: qe,
                paintHeight: Ye
              };
            }
            _createMaskCanvas(we) {
              const Ae = this.ctx, {
                width: Re,
                height: je
              } = we, Fe = this.current.fillColor, $e = this.current.patternFill, qe = (0, re.getCurrentTransform)(Ae);
              let Ye, Ke, Tt, pt;
              if ((we.bitmap || we.data) && we.count > 1) {
                const ln = we.bitmap || we.data.buffer;
                Ke = JSON.stringify($e ? qe : [qe.slice(0, 4), Fe]), Ye = this._cachedBitmapsMap.get(ln), Ye || (Ye = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(ln, Ye));
                const sn = Ye.get(Ke);
                if (sn && !$e) {
                  const _n = Math.round(Math.min(qe[0], qe[2]) + qe[4]), un = Math.round(Math.min(qe[1], qe[3]) + qe[5]);
                  return {
                    canvas: sn,
                    offsetX: _n,
                    offsetY: un
                  };
                }
                Tt = sn;
              }
              Tt || (pt = this.cachedCanvases.getCanvas("maskCanvas", Re, je), Se(pt.context, we));
              let Bt = ne.Util.transform(qe, [1 / Re, 0, 0, -1 / je, 0, 0]);
              Bt = ne.Util.transform(Bt, [1, 0, 0, 1, 0, -je]);
              const Vt = ne.Util.applyTransform([0, 0], Bt), qt = ne.Util.applyTransform([Re, je], Bt), nn = ne.Util.normalizeRect([Vt[0], Vt[1], qt[0], qt[1]]), mn = Math.round(nn[2] - nn[0]) || 1, en = Math.round(nn[3] - nn[1]) || 1, pn = this.cachedCanvases.getCanvas("fillCanvas", mn, en), Yt = pn.context, Ut = Math.min(Vt[0], qt[0]), jt = Math.min(Vt[1], qt[1]);
              Yt.translate(-Ut, -jt), Yt.transform(...Bt), Tt || (Tt = this._scaleImage(pt.canvas, (0, re.getCurrentTransformInverse)(Yt)), Tt = Tt.img, Ye && $e && Ye.set(Ke, Tt)), Yt.imageSmoothingEnabled = Be((0, re.getCurrentTransform)(Yt), we.interpolate), ge(Yt, Tt, 0, 0, Tt.width, Tt.height, 0, 0, Re, je), Yt.globalCompositeOperation = "source-in";
              const Gt = ne.Util.transform((0, re.getCurrentTransformInverse)(Yt), [1, 0, 0, 1, -Ut, -jt]);
              return Yt.fillStyle = $e ? Fe.getPattern(Ae, this, Gt, se.PathType.FILL) : Fe, Yt.fillRect(0, 0, Re, je), Ye && !$e && (this.cachedCanvases.delete("fillCanvas"), Ye.set(Ke, pn.canvas)), {
                canvas: pn.canvas,
                offsetX: Math.round(Ut),
                offsetY: Math.round(jt)
              };
            }
            setLineWidth(we) {
              we !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = we, this.ctx.lineWidth = we;
            }
            setLineCap(we) {
              this.ctx.lineCap = We[we];
            }
            setLineJoin(we) {
              this.ctx.lineJoin = Le[we];
            }
            setMiterLimit(we) {
              this.ctx.miterLimit = we;
            }
            setDash(we, Ae) {
              const Re = this.ctx;
              Re.setLineDash !== void 0 && (Re.setLineDash(we), Re.lineDashOffset = Ae);
            }
            setRenderingIntent(we) {
            }
            setFlatness(we) {
            }
            setGState(we) {
              for (const [Ae, Re] of we)
                switch (Ae) {
                  case "LW":
                    this.setLineWidth(Re);
                    break;
                  case "LC":
                    this.setLineCap(Re);
                    break;
                  case "LJ":
                    this.setLineJoin(Re);
                    break;
                  case "ML":
                    this.setMiterLimit(Re);
                    break;
                  case "D":
                    this.setDash(Re[0], Re[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(Re);
                    break;
                  case "FL":
                    this.setFlatness(Re);
                    break;
                  case "Font":
                    this.setFont(Re[0], Re[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = Re;
                    break;
                  case "ca":
                    this.current.fillAlpha = Re, this.ctx.globalAlpha = Re;
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = Re;
                    break;
                  case "SMask":
                    this.current.activeSMask = Re ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(Re);
                    break;
                }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const we = this.inSMaskMode;
              this.current.activeSMask && !we ? this.beginSMaskMode() : !this.current.activeSMask && we && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const we = this.ctx.canvas.width, Ae = this.ctx.canvas.height, Re = "smaskGroupAt" + this.groupLevel, je = this.cachedCanvases.getCanvas(Re, we, Ae);
              this.suspendedCtx = this.ctx, this.ctx = je.context;
              const Fe = this.ctx;
              Fe.setTransform(...(0, re.getCurrentTransform)(this.suspendedCtx)), he(this.suspendedCtx, Fe), me(Fe, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), he(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(we) {
              if (!this.current.activeSMask)
                return;
              we ? (we[0] = Math.floor(we[0]), we[1] = Math.floor(we[1]), we[2] = Math.ceil(we[2]), we[3] = Math.ceil(we[3])) : we = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const Ae = this.current.activeSMask, Re = this.suspendedCtx;
              Me(Re, Ae, this.ctx, we), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (he(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const we = this.current;
              this.stateStack.push(we), this.current = we.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), he(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
            }
            transform(we, Ae, Re, je, Fe, $e) {
              this.ctx.transform(we, Ae, Re, je, Fe, $e), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(we, Ae, Re) {
              const je = this.ctx, Fe = this.current;
              let $e = Fe.x, qe = Fe.y, Ye, Ke;
              const Tt = (0, re.getCurrentTransform)(je), pt = Tt[0] === 0 && Tt[3] === 0 || Tt[1] === 0 && Tt[2] === 0, Bt = pt ? Re.slice(0) : null;
              for (let Vt = 0, qt = 0, nn = we.length; Vt < nn; Vt++)
                switch (we[Vt] | 0) {
                  case ne.OPS.rectangle:
                    $e = Ae[qt++], qe = Ae[qt++];
                    const mn = Ae[qt++], en = Ae[qt++], pn = $e + mn, Yt = qe + en;
                    je.moveTo($e, qe), mn === 0 || en === 0 ? je.lineTo(pn, Yt) : (je.lineTo(pn, qe), je.lineTo(pn, Yt), je.lineTo($e, Yt)), pt || Fe.updateRectMinMax(Tt, [$e, qe, pn, Yt]), je.closePath();
                    break;
                  case ne.OPS.moveTo:
                    $e = Ae[qt++], qe = Ae[qt++], je.moveTo($e, qe), pt || Fe.updatePathMinMax(Tt, $e, qe);
                    break;
                  case ne.OPS.lineTo:
                    $e = Ae[qt++], qe = Ae[qt++], je.lineTo($e, qe), pt || Fe.updatePathMinMax(Tt, $e, qe);
                    break;
                  case ne.OPS.curveTo:
                    Ye = $e, Ke = qe, $e = Ae[qt + 4], qe = Ae[qt + 5], je.bezierCurveTo(Ae[qt], Ae[qt + 1], Ae[qt + 2], Ae[qt + 3], $e, qe), Fe.updateCurvePathMinMax(Tt, Ye, Ke, Ae[qt], Ae[qt + 1], Ae[qt + 2], Ae[qt + 3], $e, qe, Bt), qt += 6;
                    break;
                  case ne.OPS.curveTo2:
                    Ye = $e, Ke = qe, je.bezierCurveTo($e, qe, Ae[qt], Ae[qt + 1], Ae[qt + 2], Ae[qt + 3]), Fe.updateCurvePathMinMax(Tt, Ye, Ke, $e, qe, Ae[qt], Ae[qt + 1], Ae[qt + 2], Ae[qt + 3], Bt), $e = Ae[qt + 2], qe = Ae[qt + 3], qt += 4;
                    break;
                  case ne.OPS.curveTo3:
                    Ye = $e, Ke = qe, $e = Ae[qt + 2], qe = Ae[qt + 3], je.bezierCurveTo(Ae[qt], Ae[qt + 1], $e, qe, $e, qe), Fe.updateCurvePathMinMax(Tt, Ye, Ke, Ae[qt], Ae[qt + 1], $e, qe, $e, qe, Bt), qt += 4;
                    break;
                  case ne.OPS.closePath:
                    je.closePath();
                    break;
                }
              pt && Fe.updateScalingPathMinMax(Tt, Bt), Fe.setCurrentPoint($e, qe);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(we = !0) {
              const Ae = this.ctx, Re = this.current.strokeColor;
              Ae.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof Re == "object" && (Re != null && Re.getPattern) ? (Ae.save(), Ae.strokeStyle = Re.getPattern(Ae, this, (0, re.getCurrentTransformInverse)(Ae), se.PathType.STROKE), this.rescaleAndStroke(!1), Ae.restore()) : this.rescaleAndStroke(!0)), we && this.consumePath(this.current.getClippedPathBoundingBox()), Ae.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(we = !0) {
              const Ae = this.ctx, Re = this.current.fillColor, je = this.current.patternFill;
              let Fe = !1;
              je && (Ae.save(), Ae.fillStyle = Re.getPattern(Ae, this, (0, re.getCurrentTransformInverse)(Ae), se.PathType.FILL), Fe = !0);
              const $e = this.current.getClippedPathBoundingBox();
              this.contentVisible && $e !== null && (this.pendingEOFill ? (Ae.fill("evenodd"), this.pendingEOFill = !1) : Ae.fill()), Fe && Ae.restore(), we && this.consumePath($e);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = He;
            }
            eoClip() {
              this.pendingClip = Ge;
            }
            beginText() {
              this.current.textMatrix = ne.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const we = this.pendingTextPaths, Ae = this.ctx;
              if (we === void 0) {
                Ae.beginPath();
                return;
              }
              Ae.save(), Ae.beginPath();
              for (const Re of we)
                Ae.setTransform(...Re.transform), Ae.translate(Re.x, Re.y), Re.addToPath(Ae, Re.fontSize);
              Ae.restore(), Ae.clip(), Ae.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(we) {
              this.current.charSpacing = we;
            }
            setWordSpacing(we) {
              this.current.wordSpacing = we;
            }
            setHScale(we) {
              this.current.textHScale = we / 100;
            }
            setLeading(we) {
              this.current.leading = -we;
            }
            setFont(we, Ae) {
              var Tt;
              const Re = this.commonObjs.get(we), je = this.current;
              if (!Re)
                throw new Error(`Can't find font for ${we}`);
              if (je.fontMatrix = Re.fontMatrix || ne.FONT_IDENTITY_MATRIX, (je.fontMatrix[0] === 0 || je.fontMatrix[3] === 0) && (0, ne.warn)("Invalid font matrix for font " + we), Ae < 0 ? (Ae = -Ae, je.fontDirection = -1) : je.fontDirection = 1, this.current.font = Re, this.current.fontSize = Ae, Re.isType3Font)
                return;
              const Fe = Re.loadedName || "sans-serif", $e = ((Tt = Re.systemFontInfo) == null ? void 0 : Tt.css) || `"${Fe}", ${Re.fallbackName}`;
              let qe = "normal";
              Re.black ? qe = "900" : Re.bold && (qe = "bold");
              const Ye = Re.italic ? "italic" : "normal";
              let Ke = Ae;
              Ae < oe ? Ke = oe : Ae > le && (Ke = le), this.current.fontSizeScale = Ae / Ke, this.ctx.font = `${Ye} ${qe} ${Ke}px ${$e}`;
            }
            setTextRenderingMode(we) {
              this.current.textRenderingMode = we;
            }
            setTextRise(we) {
              this.current.textRise = we;
            }
            moveText(we, Ae) {
              this.current.x = this.current.lineX += we, this.current.y = this.current.lineY += Ae;
            }
            setLeadingMoveText(we, Ae) {
              this.setLeading(-Ae), this.moveText(we, Ae);
            }
            setTextMatrix(we, Ae, Re, je, Fe, $e) {
              this.current.textMatrix = [we, Ae, Re, je, Fe, $e], this.current.textMatrixScale = Math.hypot(we, Ae), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(we, Ae, Re, je) {
              const Fe = this.ctx, $e = this.current, qe = $e.font, Ye = $e.textRenderingMode, Ke = $e.fontSize / $e.fontSizeScale, Tt = Ye & ne.TextRenderingMode.FILL_STROKE_MASK, pt = !!(Ye & ne.TextRenderingMode.ADD_TO_PATH_FLAG), Bt = $e.patternFill && !qe.missingFile;
              let Vt;
              (qe.disableFontFace || pt || Bt) && (Vt = qe.getPathGenerator(this.commonObjs, we)), qe.disableFontFace || Bt ? (Fe.save(), Fe.translate(Ae, Re), Fe.beginPath(), Vt(Fe, Ke), je && Fe.setTransform(...je), (Tt === ne.TextRenderingMode.FILL || Tt === ne.TextRenderingMode.FILL_STROKE) && Fe.fill(), (Tt === ne.TextRenderingMode.STROKE || Tt === ne.TextRenderingMode.FILL_STROKE) && Fe.stroke(), Fe.restore()) : ((Tt === ne.TextRenderingMode.FILL || Tt === ne.TextRenderingMode.FILL_STROKE) && Fe.fillText(we, Ae, Re), (Tt === ne.TextRenderingMode.STROKE || Tt === ne.TextRenderingMode.FILL_STROKE) && Fe.strokeText(we, Ae, Re)), pt && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, re.getCurrentTransform)(Fe),
                x: Ae,
                y: Re,
                fontSize: Ke,
                addToPath: Vt
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: we
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              we.scale(1.5, 1), we.fillText("I", 0, 10);
              const Ae = we.getImageData(0, 0, 10, 10).data;
              let Re = !1;
              for (let je = 3; je < Ae.length; je += 4)
                if (Ae[je] > 0 && Ae[je] < 255) {
                  Re = !0;
                  break;
                }
              return (0, ne.shadow)(this, "isFontSubpixelAAEnabled", Re);
            }
            showText(we) {
              const Ae = this.current, Re = Ae.font;
              if (Re.isType3Font)
                return this.showType3Text(we);
              const je = Ae.fontSize;
              if (je === 0)
                return;
              const Fe = this.ctx, $e = Ae.fontSizeScale, qe = Ae.charSpacing, Ye = Ae.wordSpacing, Ke = Ae.fontDirection, Tt = Ae.textHScale * Ke, pt = we.length, Bt = Re.vertical, Vt = Bt ? 1 : -1, qt = Re.defaultVMetrics, nn = je * Ae.fontMatrix[0], mn = Ae.textRenderingMode === ne.TextRenderingMode.FILL && !Re.disableFontFace && !Ae.patternFill;
              Fe.save(), Fe.transform(...Ae.textMatrix), Fe.translate(Ae.x, Ae.y + Ae.textRise), Ke > 0 ? Fe.scale(Tt, -1) : Fe.scale(Tt, 1);
              let en;
              if (Ae.patternFill) {
                Fe.save();
                const Gt = Ae.fillColor.getPattern(Fe, this, (0, re.getCurrentTransformInverse)(Fe), se.PathType.FILL);
                en = (0, re.getCurrentTransform)(Fe), Fe.restore(), Fe.fillStyle = Gt;
              }
              let pn = Ae.lineWidth;
              const Yt = Ae.textMatrixScale;
              if (Yt === 0 || pn === 0) {
                const Gt = Ae.textRenderingMode & ne.TextRenderingMode.FILL_STROKE_MASK;
                (Gt === ne.TextRenderingMode.STROKE || Gt === ne.TextRenderingMode.FILL_STROKE) && (pn = this.getSinglePixelWidth());
              } else
                pn /= Yt;
              if ($e !== 1 && (Fe.scale($e, $e), pn /= $e), Fe.lineWidth = pn, Re.isInvalidPDFjsFont) {
                const Gt = [];
                let ln = 0;
                for (const sn of we)
                  Gt.push(sn.unicode), ln += sn.width;
                Fe.fillText(Gt.join(""), 0, 0), Ae.x += ln * nn * Tt, Fe.restore(), this.compose();
                return;
              }
              let Ut = 0, jt;
              for (jt = 0; jt < pt; ++jt) {
                const Gt = we[jt];
                if (typeof Gt == "number") {
                  Ut += Vt * Gt * je / 1e3;
                  continue;
                }
                let ln = !1;
                const sn = (Gt.isSpace ? Ye : 0) + qe, _n = Gt.fontChar, un = Gt.accent;
                let En, wn, Tn = Gt.width;
                if (Bt) {
                  const Rn = Gt.vmetric || qt, Kt = -(Gt.vmetric ? Rn[1] : Tn * 0.5) * nn, Ht = Rn[2] * nn;
                  Tn = Rn ? -Rn[0] : Tn, En = Kt / $e, wn = (Ut + Ht) / $e;
                } else
                  En = Ut / $e, wn = 0;
                if (Re.remeasure && Tn > 0) {
                  const Rn = Fe.measureText(_n).width * 1e3 / je * $e;
                  if (Tn < Rn && this.isFontSubpixelAAEnabled) {
                    const Kt = Tn / Rn;
                    ln = !0, Fe.save(), Fe.scale(Kt, 1), En /= Kt;
                  } else
                    Tn !== Rn && (En += (Tn - Rn) / 2e3 * je / $e);
                }
                if (this.contentVisible && (Gt.isInFont || Re.missingFile)) {
                  if (mn && !un)
                    Fe.fillText(_n, En, wn);
                  else if (this.paintChar(_n, En, wn, en), un) {
                    const Rn = En + je * un.offset.x / $e, Kt = wn - je * un.offset.y / $e;
                    this.paintChar(un.fontChar, Rn, Kt, en);
                  }
                }
                const Pn = Bt ? Tn * nn - sn * Ke : Tn * nn + sn * Ke;
                Ut += Pn, ln && Fe.restore();
              }
              Bt ? Ae.y -= Ut : Ae.x += Ut * Tt, Fe.restore(), this.compose();
            }
            showType3Text(we) {
              const Ae = this.ctx, Re = this.current, je = Re.font, Fe = Re.fontSize, $e = Re.fontDirection, qe = je.vertical ? 1 : -1, Ye = Re.charSpacing, Ke = Re.wordSpacing, Tt = Re.textHScale * $e, pt = Re.fontMatrix || ne.FONT_IDENTITY_MATRIX, Bt = we.length, Vt = Re.textRenderingMode === ne.TextRenderingMode.INVISIBLE;
              let qt, nn, mn, en;
              if (!(Vt || Fe === 0)) {
                for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, Ae.save(), Ae.transform(...Re.textMatrix), Ae.translate(Re.x, Re.y), Ae.scale(Tt, $e), qt = 0; qt < Bt; ++qt) {
                  if (nn = we[qt], typeof nn == "number") {
                    en = qe * nn * Fe / 1e3, this.ctx.translate(en, 0), Re.x += en * Tt;
                    continue;
                  }
                  const pn = (nn.isSpace ? Ke : 0) + Ye, Yt = je.charProcOperatorList[nn.operatorListId];
                  if (!Yt) {
                    (0, ne.warn)(`Type3 character "${nn.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = nn, this.save(), Ae.scale(Fe, Fe), Ae.transform(...pt), this.executeOperatorList(Yt), this.restore()), mn = ne.Util.applyTransform([nn.width, 0], pt)[0] * Fe + pn, Ae.translate(mn, 0), Re.x += mn * Tt;
                }
                Ae.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(we, Ae) {
            }
            setCharWidthAndBounds(we, Ae, Re, je, Fe, $e) {
              this.ctx.rect(Re, je, Fe - Re, $e - je), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(we) {
              let Ae;
              if (we[0] === "TilingPattern") {
                const Re = we[1], je = this.baseTransform || (0, re.getCurrentTransform)(this.ctx), Fe = {
                  createCanvasGraphics: ($e) => new At($e, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig: this.optionalContentConfig,
                    markedContentStack: this.markedContentStack
                  })
                };
                Ae = new se.TilingPattern(we, Re, this.ctx, Fe, je);
              } else
                Ae = this._getPattern(we[1], we[2]);
              return Ae;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(we, Ae, Re) {
              const je = ne.Util.makeHexColor(we, Ae, Re);
              this.ctx.strokeStyle = je, this.current.strokeColor = je;
            }
            setFillRGBColor(we, Ae, Re) {
              const je = ne.Util.makeHexColor(we, Ae, Re);
              this.ctx.fillStyle = je, this.current.fillColor = je, this.current.patternFill = !1;
            }
            _getPattern(we, Ae = null) {
              let Re;
              return this.cachedPatterns.has(we) ? Re = this.cachedPatterns.get(we) : (Re = (0, se.getShadingPattern)(this.getObject(we)), this.cachedPatterns.set(we, Re)), Ae && (Re.matrix = Ae), Re;
            }
            shadingFill(we) {
              if (!this.contentVisible)
                return;
              const Ae = this.ctx;
              this.save();
              const Re = this._getPattern(we);
              Ae.fillStyle = Re.getPattern(Ae, this, (0, re.getCurrentTransformInverse)(Ae), se.PathType.SHADING);
              const je = (0, re.getCurrentTransformInverse)(Ae);
              if (je) {
                const {
                  width: Fe,
                  height: $e
                } = Ae.canvas, [qe, Ye, Ke, Tt] = ne.Util.getAxialAlignedBoundingBox([0, 0, Fe, $e], je);
                this.ctx.fillRect(qe, Ye, Ke - qe, Tt - Ye);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, ne.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, ne.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(we, Ae) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(we) && we.length === 6 && this.transform(...we), this.baseTransform = (0, re.getCurrentTransform)(this.ctx), Ae)) {
                const Re = Ae[2] - Ae[0], je = Ae[3] - Ae[1];
                this.ctx.rect(Ae[0], Ae[1], Re, je), this.current.updateRectMinMax((0, re.getCurrentTransform)(this.ctx), Ae), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(we) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const Ae = this.ctx;
              we.isolated || (0, ne.info)("TODO: Support non-isolated groups."), we.knockout && (0, ne.warn)("Knockout groups not supported.");
              const Re = (0, re.getCurrentTransform)(Ae);
              if (we.matrix && Ae.transform(...we.matrix), !we.bbox)
                throw new Error("Bounding box is required.");
              let je = ne.Util.getAxialAlignedBoundingBox(we.bbox, (0, re.getCurrentTransform)(Ae));
              const Fe = [0, 0, Ae.canvas.width, Ae.canvas.height];
              je = ne.Util.intersect(je, Fe) || [0, 0, 0, 0];
              const $e = Math.floor(je[0]), qe = Math.floor(je[1]);
              let Ye = Math.max(Math.ceil(je[2]) - $e, 1), Ke = Math.max(Math.ceil(je[3]) - qe, 1), Tt = 1, pt = 1;
              Ye > ue && (Tt = Ye / ue, Ye = ue), Ke > ue && (pt = Ke / ue, Ke = ue), this.current.startNewPathAndClipBox([0, 0, Ye, Ke]);
              let Bt = "groupAt" + this.groupLevel;
              we.smask && (Bt += "_smask_" + this.smaskCounter++ % 2);
              const Vt = this.cachedCanvases.getCanvas(Bt, Ye, Ke), qt = Vt.context;
              qt.scale(1 / Tt, 1 / pt), qt.translate(-$e, -qe), qt.transform(...Re), we.smask ? this.smaskStack.push({
                canvas: Vt.canvas,
                context: qt,
                offsetX: $e,
                offsetY: qe,
                scaleX: Tt,
                scaleY: pt,
                subtype: we.smask.subtype,
                backdrop: we.smask.backdrop,
                transferMap: we.smask.transferMap || null,
                startTransformInverse: null
              }) : (Ae.setTransform(1, 0, 0, 1, 0, 0), Ae.translate($e, qe), Ae.scale(Tt, pt), Ae.save()), he(Ae, qt), this.ctx = qt, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(Ae), this.groupLevel++;
            }
            endGroup(we) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const Ae = this.ctx, Re = this.groupStack.pop();
              if (this.ctx = Re, this.ctx.imageSmoothingEnabled = !1, we.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const je = (0, re.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...je);
                const Fe = ne.Util.getAxialAlignedBoundingBox([0, 0, Ae.canvas.width, Ae.canvas.height], je);
                this.ctx.drawImage(Ae.canvas, 0, 0), this.ctx.restore(), this.compose(Fe);
              }
            }
            beginAnnotation(we, Ae, Re, je, Fe) {
              if (Nt(this, Ue, jr).call(this), Pe(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(Ae) && Ae.length === 4) {
                const $e = Ae[2] - Ae[0], qe = Ae[3] - Ae[1];
                if (Fe && this.annotationCanvasMap) {
                  Re = Re.slice(), Re[4] -= Ae[0], Re[5] -= Ae[1], Ae = Ae.slice(), Ae[0] = Ae[1] = 0, Ae[2] = $e, Ae[3] = qe;
                  const [Ye, Ke] = ne.Util.singularValueDecompose2dScale((0, re.getCurrentTransform)(this.ctx)), {
                    viewportScale: Tt
                  } = this, pt = Math.ceil($e * this.outputScaleX * Tt), Bt = Math.ceil(qe * this.outputScaleY * Tt);
                  this.annotationCanvas = this.canvasFactory.create(pt, Bt);
                  const {
                    canvas: Vt,
                    context: qt
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(we, Vt), this.annotationCanvas.savedCtx = this.ctx, this.ctx = qt, this.ctx.save(), this.ctx.setTransform(Ye, 0, 0, -Ke, 0, qe * Ke), Pe(this.ctx);
                } else
                  Pe(this.ctx), this.ctx.rect(Ae[0], Ae[1], $e, qe), this.ctx.clip(), this.endPath();
              }
              this.current = new Ee(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...Re), this.transform(...je);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx.restore(), Nt(this, Je, Fr).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(we) {
              if (!this.contentVisible)
                return;
              const Ae = we.count;
              we = this.getObject(we.data, we), we.count = Ae;
              const Re = this.ctx, je = this.processingType3;
              if (je && (je.compiled === void 0 && (je.compiled = xe(we)), je.compiled)) {
                je.compiled(Re);
                return;
              }
              const Fe = this._createMaskCanvas(we), $e = Fe.canvas;
              Re.save(), Re.setTransform(1, 0, 0, 1, 0, 0), Re.drawImage($e, Fe.offsetX, Fe.offsetY), Re.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(we, Ae, Re = 0, je = 0, Fe, $e) {
              if (!this.contentVisible)
                return;
              we = this.getObject(we.data, we);
              const qe = this.ctx;
              qe.save();
              const Ye = (0, re.getCurrentTransform)(qe);
              qe.transform(Ae, Re, je, Fe, 0, 0);
              const Ke = this._createMaskCanvas(we);
              qe.setTransform(1, 0, 0, 1, Ke.offsetX - Ye[4], Ke.offsetY - Ye[5]);
              for (let Tt = 0, pt = $e.length; Tt < pt; Tt += 2) {
                const Bt = ne.Util.transform(Ye, [Ae, Re, je, Fe, $e[Tt], $e[Tt + 1]]), [Vt, qt] = ne.Util.applyTransform([0, 0], Bt);
                qe.drawImage(Ke.canvas, Vt, qt);
              }
              qe.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(we) {
              if (!this.contentVisible)
                return;
              const Ae = this.ctx, Re = this.current.fillColor, je = this.current.patternFill;
              for (const Fe of we) {
                const {
                  data: $e,
                  width: qe,
                  height: Ye,
                  transform: Ke
                } = Fe, Tt = this.cachedCanvases.getCanvas("maskCanvas", qe, Ye), pt = Tt.context;
                pt.save();
                const Bt = this.getObject($e, Fe);
                Se(pt, Bt), pt.globalCompositeOperation = "source-in", pt.fillStyle = je ? Re.getPattern(pt, this, (0, re.getCurrentTransformInverse)(Ae), se.PathType.FILL) : Re, pt.fillRect(0, 0, qe, Ye), pt.restore(), Ae.save(), Ae.transform(...Ke), Ae.scale(1, -1), ge(Ae, Tt.canvas, 0, 0, qe, Ye, 0, -1, 1, 1), Ae.restore();
              }
              this.compose();
            }
            paintImageXObject(we) {
              if (!this.contentVisible)
                return;
              const Ae = this.getObject(we);
              if (!Ae) {
                (0, ne.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(Ae);
            }
            paintImageXObjectRepeat(we, Ae, Re, je) {
              if (!this.contentVisible)
                return;
              const Fe = this.getObject(we);
              if (!Fe) {
                (0, ne.warn)("Dependent image isn't ready yet");
                return;
              }
              const $e = Fe.width, qe = Fe.height, Ye = [];
              for (let Ke = 0, Tt = je.length; Ke < Tt; Ke += 2)
                Ye.push({
                  transform: [Ae, 0, 0, Re, je[Ke], je[Ke + 1]],
                  x: 0,
                  y: 0,
                  w: $e,
                  h: qe
                });
              this.paintInlineImageXObjectGroup(Fe, Ye);
            }
            applyTransferMapsToCanvas(we) {
              return this.current.transferMaps !== "none" && (we.filter = this.current.transferMaps, we.drawImage(we.canvas, 0, 0), we.filter = "none"), we.canvas;
            }
            applyTransferMapsToBitmap(we) {
              if (this.current.transferMaps === "none")
                return we.bitmap;
              const {
                bitmap: Ae,
                width: Re,
                height: je
              } = we, Fe = this.cachedCanvases.getCanvas("inlineImage", Re, je), $e = Fe.context;
              return $e.filter = this.current.transferMaps, $e.drawImage(Ae, 0, 0), $e.filter = "none", Fe.canvas;
            }
            paintInlineImageXObject(we) {
              if (!this.contentVisible)
                return;
              const Ae = we.width, Re = we.height, je = this.ctx;
              if (this.save(), !ne.isNodeJS) {
                const {
                  filter: qe
                } = je;
                qe !== "none" && qe !== "" && (je.filter = "none");
              }
              je.scale(1 / Ae, -1 / Re);
              let Fe;
              if (we.bitmap)
                Fe = this.applyTransferMapsToBitmap(we);
              else if (typeof HTMLElement == "function" && we instanceof HTMLElement || !we.data)
                Fe = we;
              else {
                const Ye = this.cachedCanvases.getCanvas("inlineImage", Ae, Re).context;
                Te(Ye, we), Fe = this.applyTransferMapsToCanvas(Ye);
              }
              const $e = this._scaleImage(Fe, (0, re.getCurrentTransformInverse)(je));
              je.imageSmoothingEnabled = Be((0, re.getCurrentTransform)(je), we.interpolate), ge(je, $e.img, 0, 0, $e.paintWidth, $e.paintHeight, 0, -Re, Ae, Re), this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(we, Ae) {
              if (!this.contentVisible)
                return;
              const Re = this.ctx;
              let je;
              if (we.bitmap)
                je = we.bitmap;
              else {
                const Fe = we.width, $e = we.height, Ye = this.cachedCanvases.getCanvas("inlineImage", Fe, $e).context;
                Te(Ye, we), je = this.applyTransferMapsToCanvas(Ye);
              }
              for (const Fe of Ae)
                Re.save(), Re.transform(...Fe.transform), Re.scale(1, -1), ge(Re, je, Fe.x, Fe.y, Fe.w, Fe.h, 0, -1, 1, 1), Re.restore();
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(we) {
            }
            markPointProps(we, Ae) {
            }
            beginMarkedContent(we) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(we, Ae) {
              we === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(Ae)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(we) {
              const Ae = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(we);
              const Re = this.ctx;
              this.pendingClip && (Ae || (this.pendingClip === Ge ? Re.clip("evenodd") : Re.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), Re.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const we = (0, re.getCurrentTransform)(this.ctx);
                if (we[1] === 0 && we[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(we[0]), Math.abs(we[3]));
                else {
                  const Ae = Math.abs(we[0] * we[3] - we[2] * we[1]), Re = Math.hypot(we[0], we[2]), je = Math.hypot(we[1], we[3]);
                  this._cachedGetSinglePixelWidth = Math.max(Re, je) / Ae;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (this._cachedScaleForStroking[0] === -1) {
                const {
                  lineWidth: we
                } = this.current, {
                  a: Ae,
                  b: Re,
                  c: je,
                  d: Fe
                } = this.ctx.getTransform();
                let $e, qe;
                if (Re === 0 && je === 0) {
                  const Ye = Math.abs(Ae), Ke = Math.abs(Fe);
                  if (Ye === Ke)
                    if (we === 0)
                      $e = qe = 1 / Ye;
                    else {
                      const Tt = Ye * we;
                      $e = qe = Tt < 1 ? 1 / Tt : 1;
                    }
                  else if (we === 0)
                    $e = 1 / Ye, qe = 1 / Ke;
                  else {
                    const Tt = Ye * we, pt = Ke * we;
                    $e = Tt < 1 ? 1 / Tt : 1, qe = pt < 1 ? 1 / pt : 1;
                  }
                } else {
                  const Ye = Math.abs(Ae * Fe - Re * je), Ke = Math.hypot(Ae, Re), Tt = Math.hypot(je, Fe);
                  if (we === 0)
                    $e = Tt / Ye, qe = Ke / Ye;
                  else {
                    const pt = we * Ye;
                    $e = Tt > pt ? Tt / pt : 1, qe = Ke > pt ? Ke / pt : 1;
                  }
                }
                this._cachedScaleForStroking[0] = $e, this._cachedScaleForStroking[1] = qe;
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(we) {
              const {
                ctx: Ae
              } = this, {
                lineWidth: Re
              } = this.current, [je, Fe] = this.getScaleForStroking();
              if (Ae.lineWidth = Re || 1, je === 1 && Fe === 1) {
                Ae.stroke();
                return;
              }
              const $e = Ae.getLineDash();
              if (we && Ae.save(), Ae.scale(je, Fe), $e.length > 0) {
                const qe = Math.max(je, Fe);
                Ae.setLineDash($e.map((Ye) => Ye / qe)), Ae.lineDashOffset /= qe;
              }
              Ae.stroke(), we && Ae.restore();
            }
            isContentVisible() {
              for (let we = this.markedContentStack.length - 1; we >= 0; we--)
                if (!this.markedContentStack[we].visible)
                  return !1;
              return !0;
            }
          };
          Ue = new WeakSet(), jr = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, Je = new WeakSet(), Fr = function() {
            if (this.pageColors) {
              const we = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
              if (we !== "none") {
                const Ae = this.ctx.filter;
                this.ctx.filter = we, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = Ae;
              }
            }
          };
          let Ze = At;
          ee.CanvasGraphics = Ze;
          for (const ze in ne.OPS)
            Ze.prototype[ze] !== void 0 && (Ze.prototype[ne.OPS[ze]] = Ze.prototype[ze]);
        },
        /* 12 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.TilingPattern = ee.PathType = void 0, ee.getShadingPattern = ye;
          var ne = te(1), re = te(6);
          const se = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          ee.PathType = se;
          function ie(xe, Ee) {
            if (!Ee)
              return;
            const Te = Ee[2] - Ee[0], Se = Ee[3] - Ee[1], he = new Path2D();
            he.rect(Ee[0], Ee[1], Te, Se), xe.clip(he);
          }
          class oe {
            constructor() {
              this.constructor === oe && (0, ne.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, ne.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class le extends oe {
            constructor(Ee) {
              super(), this._type = Ee[1], this._bbox = Ee[2], this._colorStops = Ee[3], this._p0 = Ee[4], this._p1 = Ee[5], this._r0 = Ee[6], this._r1 = Ee[7], this.matrix = null;
            }
            _createGradient(Ee) {
              let Te;
              this._type === "axial" ? Te = Ee.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (Te = Ee.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const Se of this._colorStops)
                Te.addColorStop(Se[0], Se[1]);
              return Te;
            }
            getPattern(Ee, Te, Se, he) {
              let Pe;
              if (he === se.STROKE || he === se.FILL) {
                const Ie = Te.current.getClippedPathBoundingBox(he, (0, re.getCurrentTransform)(Ee)) || [0, 0, 0, 0], De = Math.ceil(Ie[2] - Ie[0]) || 1, Ce = Math.ceil(Ie[3] - Ie[1]) || 1, Ne = Te.cachedCanvases.getCanvas("pattern", De, Ce, !0), Me = Ne.context;
                Me.clearRect(0, 0, Me.canvas.width, Me.canvas.height), Me.beginPath(), Me.rect(0, 0, Me.canvas.width, Me.canvas.height), Me.translate(-Ie[0], -Ie[1]), Se = ne.Util.transform(Se, [1, 0, 0, 1, Ie[0], Ie[1]]), Me.transform(...Te.baseTransform), this.matrix && Me.transform(...this.matrix), ie(Me, this._bbox), Me.fillStyle = this._createGradient(Me), Me.fill(), Pe = Ee.createPattern(Ne.canvas, "no-repeat");
                const Be = new DOMMatrix(Se);
                Pe.setTransform(Be);
              } else
                ie(Ee, this._bbox), Pe = this._createGradient(Ee);
              return Pe;
            }
          }
          function ue(xe, Ee, Te, Se, he, Pe, Ie, De) {
            const Ce = Ee.coords, Ne = Ee.colors, Me = xe.data, Be = xe.width * 4;
            let We;
            Ce[Te + 1] > Ce[Se + 1] && (We = Te, Te = Se, Se = We, We = Pe, Pe = Ie, Ie = We), Ce[Se + 1] > Ce[he + 1] && (We = Se, Se = he, he = We, We = Ie, Ie = De, De = We), Ce[Te + 1] > Ce[Se + 1] && (We = Te, Te = Se, Se = We, We = Pe, Pe = Ie, Ie = We);
            const Le = (Ce[Te] + Ee.offsetX) * Ee.scaleX, He = (Ce[Te + 1] + Ee.offsetY) * Ee.scaleY, Ge = (Ce[Se] + Ee.offsetX) * Ee.scaleX, Ze = (Ce[Se + 1] + Ee.offsetY) * Ee.scaleY, Ue = (Ce[he] + Ee.offsetX) * Ee.scaleX, Qe = (Ce[he + 1] + Ee.offsetY) * Ee.scaleY;
            if (He >= Qe)
              return;
            const Je = Ne[Pe], Ot = Ne[Pe + 1], At = Ne[Pe + 2], ze = Ne[Ie], we = Ne[Ie + 1], Ae = Ne[Ie + 2], Re = Ne[De], je = Ne[De + 1], Fe = Ne[De + 2], $e = Math.round(He), qe = Math.round(Qe);
            let Ye, Ke, Tt, pt, Bt, Vt, qt, nn;
            for (let mn = $e; mn <= qe; mn++) {
              if (mn < Ze) {
                const jt = mn < He ? 0 : (He - mn) / (He - Ze);
                Ye = Le - (Le - Ge) * jt, Ke = Je - (Je - ze) * jt, Tt = Ot - (Ot - we) * jt, pt = At - (At - Ae) * jt;
              } else {
                let jt;
                mn > Qe ? jt = 1 : Ze === Qe ? jt = 0 : jt = (Ze - mn) / (Ze - Qe), Ye = Ge - (Ge - Ue) * jt, Ke = ze - (ze - Re) * jt, Tt = we - (we - je) * jt, pt = Ae - (Ae - Fe) * jt;
              }
              let en;
              mn < He ? en = 0 : mn > Qe ? en = 1 : en = (He - mn) / (He - Qe), Bt = Le - (Le - Ue) * en, Vt = Je - (Je - Re) * en, qt = Ot - (Ot - je) * en, nn = At - (At - Fe) * en;
              const pn = Math.round(Math.min(Ye, Bt)), Yt = Math.round(Math.max(Ye, Bt));
              let Ut = Be * mn + pn * 4;
              for (let jt = pn; jt <= Yt; jt++)
                en = (Ye - jt) / (Ye - Bt), en < 0 ? en = 0 : en > 1 && (en = 1), Me[Ut++] = Ke - (Ke - Vt) * en | 0, Me[Ut++] = Tt - (Tt - qt) * en | 0, Me[Ut++] = pt - (pt - nn) * en | 0, Me[Ut++] = 255;
            }
          }
          function de(xe, Ee, Te) {
            const Se = Ee.coords, he = Ee.colors;
            let Pe, Ie;
            switch (Ee.type) {
              case "lattice":
                const De = Ee.verticesPerRow, Ce = Math.floor(Se.length / De) - 1, Ne = De - 1;
                for (Pe = 0; Pe < Ce; Pe++) {
                  let Me = Pe * De;
                  for (let Be = 0; Be < Ne; Be++, Me++)
                    ue(xe, Te, Se[Me], Se[Me + 1], Se[Me + De], he[Me], he[Me + 1], he[Me + De]), ue(xe, Te, Se[Me + De + 1], Se[Me + 1], Se[Me + De], he[Me + De + 1], he[Me + 1], he[Me + De]);
                }
                break;
              case "triangles":
                for (Pe = 0, Ie = Se.length; Pe < Ie; Pe += 3)
                  ue(xe, Te, Se[Pe], Se[Pe + 1], Se[Pe + 2], he[Pe], he[Pe + 1], he[Pe + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class fe extends oe {
            constructor(Ee) {
              super(), this._coords = Ee[2], this._colors = Ee[3], this._figures = Ee[4], this._bounds = Ee[5], this._bbox = Ee[7], this._background = Ee[8], this.matrix = null;
            }
            _createMeshCanvas(Ee, Te, Se) {
              const De = Math.floor(this._bounds[0]), Ce = Math.floor(this._bounds[1]), Ne = Math.ceil(this._bounds[2]) - De, Me = Math.ceil(this._bounds[3]) - Ce, Be = Math.min(Math.ceil(Math.abs(Ne * Ee[0] * 1.1)), 3e3), We = Math.min(Math.ceil(Math.abs(Me * Ee[1] * 1.1)), 3e3), Le = Ne / Be, He = Me / We, Ge = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -De,
                offsetY: -Ce,
                scaleX: 1 / Le,
                scaleY: 1 / He
              }, Ze = Be + 2 * 2, Ue = We + 2 * 2, Qe = Se.getCanvas("mesh", Ze, Ue, !1), Je = Qe.context, Ot = Je.createImageData(Be, We);
              if (Te) {
                const ze = Ot.data;
                for (let we = 0, Ae = ze.length; we < Ae; we += 4)
                  ze[we] = Te[0], ze[we + 1] = Te[1], ze[we + 2] = Te[2], ze[we + 3] = 255;
              }
              for (const ze of this._figures)
                de(Ot, ze, Ge);
              return Je.putImageData(Ot, 2, 2), {
                canvas: Qe.canvas,
                offsetX: De - 2 * Le,
                offsetY: Ce - 2 * He,
                scaleX: Le,
                scaleY: He
              };
            }
            getPattern(Ee, Te, Se, he) {
              ie(Ee, this._bbox);
              let Pe;
              if (he === se.SHADING)
                Pe = ne.Util.singularValueDecompose2dScale((0, re.getCurrentTransform)(Ee));
              else if (Pe = ne.Util.singularValueDecompose2dScale(Te.baseTransform), this.matrix) {
                const De = ne.Util.singularValueDecompose2dScale(this.matrix);
                Pe = [Pe[0] * De[0], Pe[1] * De[1]];
              }
              const Ie = this._createMeshCanvas(Pe, he === se.SHADING ? null : this._background, Te.cachedCanvases);
              return he !== se.SHADING && (Ee.setTransform(...Te.baseTransform), this.matrix && Ee.transform(...this.matrix)), Ee.translate(Ie.offsetX, Ie.offsetY), Ee.scale(Ie.scaleX, Ie.scaleY), Ee.createPattern(Ie.canvas, "no-repeat");
            }
          }
          class pe extends oe {
            getPattern() {
              return "hotpink";
            }
          }
          function ye(xe) {
            switch (xe[0]) {
              case "RadialAxial":
                return new le(xe);
              case "Mesh":
                return new fe(xe);
              case "Dummy":
                return new pe();
            }
            throw new Error(`Unknown IR type: ${xe[0]}`);
          }
          const me = {
            COLORED: 1,
            UNCOLORED: 2
          }, ge = class ge {
            constructor(Ee, Te, Se, he, Pe) {
              this.operatorList = Ee[2], this.matrix = Ee[3] || [1, 0, 0, 1, 0, 0], this.bbox = Ee[4], this.xstep = Ee[5], this.ystep = Ee[6], this.paintType = Ee[7], this.tilingType = Ee[8], this.color = Te, this.ctx = Se, this.canvasGraphicsFactory = he, this.baseTransform = Pe;
            }
            createPatternCanvas(Ee) {
              const Te = this.operatorList, Se = this.bbox, he = this.xstep, Pe = this.ystep, Ie = this.paintType, De = this.tilingType, Ce = this.color, Ne = this.canvasGraphicsFactory;
              (0, ne.info)("TilingType: " + De);
              const Me = Se[0], Be = Se[1], We = Se[2], Le = Se[3], He = ne.Util.singularValueDecompose2dScale(this.matrix), Ge = ne.Util.singularValueDecompose2dScale(this.baseTransform), Ze = [He[0] * Ge[0], He[1] * Ge[1]], Ue = this.getSizeAndScale(he, this.ctx.canvas.width, Ze[0]), Qe = this.getSizeAndScale(Pe, this.ctx.canvas.height, Ze[1]), Je = Ee.cachedCanvases.getCanvas("pattern", Ue.size, Qe.size, !0), Ot = Je.context, At = Ne.createCanvasGraphics(Ot);
              At.groupLevel = Ee.groupLevel, this.setFillAndStrokeStyleToContext(At, Ie, Ce);
              let ze = Me, we = Be, Ae = We, Re = Le;
              return Me < 0 && (ze = 0, Ae += Math.abs(Me)), Be < 0 && (we = 0, Re += Math.abs(Be)), Ot.translate(-(Ue.scale * ze), -(Qe.scale * we)), At.transform(Ue.scale, 0, 0, Qe.scale, 0, 0), Ot.save(), this.clipBbox(At, ze, we, Ae, Re), At.baseTransform = (0, re.getCurrentTransform)(At.ctx), At.executeOperatorList(Te), At.endDrawing(), {
                canvas: Je.canvas,
                scaleX: Ue.scale,
                scaleY: Qe.scale,
                offsetX: ze,
                offsetY: we
              };
            }
            getSizeAndScale(Ee, Te, Se) {
              Ee = Math.abs(Ee);
              const he = Math.max(ge.MAX_PATTERN_SIZE, Te);
              let Pe = Math.ceil(Ee * Se);
              return Pe >= he ? Pe = he : Se = Pe / Ee, {
                scale: Se,
                size: Pe
              };
            }
            clipBbox(Ee, Te, Se, he, Pe) {
              const Ie = he - Te, De = Pe - Se;
              Ee.ctx.rect(Te, Se, Ie, De), Ee.current.updateRectMinMax((0, re.getCurrentTransform)(Ee.ctx), [Te, Se, he, Pe]), Ee.clip(), Ee.endPath();
            }
            setFillAndStrokeStyleToContext(Ee, Te, Se) {
              const he = Ee.ctx, Pe = Ee.current;
              switch (Te) {
                case me.COLORED:
                  const Ie = this.ctx;
                  he.fillStyle = Ie.fillStyle, he.strokeStyle = Ie.strokeStyle, Pe.fillColor = Ie.fillStyle, Pe.strokeColor = Ie.strokeStyle;
                  break;
                case me.UNCOLORED:
                  const De = ne.Util.makeHexColor(Se[0], Se[1], Se[2]);
                  he.fillStyle = De, he.strokeStyle = De, Pe.fillColor = De, Pe.strokeColor = De;
                  break;
                default:
                  throw new ne.FormatError(`Unsupported paint type: ${Te}`);
              }
            }
            getPattern(Ee, Te, Se, he) {
              let Pe = Se;
              he !== se.SHADING && (Pe = ne.Util.transform(Pe, Te.baseTransform), this.matrix && (Pe = ne.Util.transform(Pe, this.matrix)));
              const Ie = this.createPatternCanvas(Te);
              let De = new DOMMatrix(Pe);
              De = De.translate(Ie.offsetX, Ie.offsetY), De = De.scale(1 / Ie.scaleX, 1 / Ie.scaleY);
              const Ce = Ee.createPattern(Ie.canvas, "repeat");
              return Ce.setTransform(De), Ce;
            }
          };
          On(ge, "MAX_PATTERN_SIZE", 3e3);
          let ve = ge;
          ee.TilingPattern = ve;
        },
        /* 13 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.convertBlackAndWhiteToRGBA = se, ee.convertToRGBA = re, ee.grayToRGBA = oe;
          var ne = te(1);
          function re(le) {
            switch (le.kind) {
              case ne.ImageKind.GRAYSCALE_1BPP:
                return se(le);
              case ne.ImageKind.RGB_24BPP:
                return ie(le);
            }
            return null;
          }
          function se({
            src: le,
            srcPos: ue = 0,
            dest: de,
            width: fe,
            height: pe,
            nonBlackColor: ye = 4294967295,
            inverseDecode: me = !1
          }) {
            const ve = ne.FeatureTest.isLittleEndian ? 4278190080 : 255, [ge, xe] = me ? [ye, ve] : [ve, ye], Ee = fe >> 3, Te = fe & 7, Se = le.length;
            de = new Uint32Array(de.buffer);
            let he = 0;
            for (let Pe = 0; Pe < pe; Pe++) {
              for (const De = ue + Ee; ue < De; ue++) {
                const Ce = ue < Se ? le[ue] : 255;
                de[he++] = Ce & 128 ? xe : ge, de[he++] = Ce & 64 ? xe : ge, de[he++] = Ce & 32 ? xe : ge, de[he++] = Ce & 16 ? xe : ge, de[he++] = Ce & 8 ? xe : ge, de[he++] = Ce & 4 ? xe : ge, de[he++] = Ce & 2 ? xe : ge, de[he++] = Ce & 1 ? xe : ge;
              }
              if (Te === 0)
                continue;
              const Ie = ue < Se ? le[ue++] : 255;
              for (let De = 0; De < Te; De++)
                de[he++] = Ie & 1 << 7 - De ? xe : ge;
            }
            return {
              srcPos: ue,
              destPos: he
            };
          }
          function ie({
            src: le,
            srcPos: ue = 0,
            dest: de,
            destPos: fe = 0,
            width: pe,
            height: ye
          }) {
            let me = 0;
            const ve = le.length >> 2, ge = new Uint32Array(le.buffer, ue, ve);
            if (ne.FeatureTest.isLittleEndian) {
              for (; me < ve - 2; me += 3, fe += 4) {
                const xe = ge[me], Ee = ge[me + 1], Te = ge[me + 2];
                de[fe] = xe | 4278190080, de[fe + 1] = xe >>> 24 | Ee << 8 | 4278190080, de[fe + 2] = Ee >>> 16 | Te << 16 | 4278190080, de[fe + 3] = Te >>> 8 | 4278190080;
              }
              for (let xe = me * 4, Ee = le.length; xe < Ee; xe += 3)
                de[fe++] = le[xe] | le[xe + 1] << 8 | le[xe + 2] << 16 | 4278190080;
            } else {
              for (; me < ve - 2; me += 3, fe += 4) {
                const xe = ge[me], Ee = ge[me + 1], Te = ge[me + 2];
                de[fe] = xe | 255, de[fe + 1] = xe << 24 | Ee >>> 8 | 255, de[fe + 2] = Ee << 16 | Te >>> 16 | 255, de[fe + 3] = Te << 8 | 255;
              }
              for (let xe = me * 4, Ee = le.length; xe < Ee; xe += 3)
                de[fe++] = le[xe] << 24 | le[xe + 1] << 16 | le[xe + 2] << 8 | 255;
            }
            return {
              srcPos: ue,
              destPos: fe
            };
          }
          function oe(le, ue) {
            if (ne.FeatureTest.isLittleEndian)
              for (let de = 0, fe = le.length; de < fe; de++)
                ue[de] = le[de] * 65793 | 4278190080;
            else
              for (let de = 0, fe = le.length; de < fe; de++)
                ue[de] = le[de] * 16843008 | 255;
          }
        },
        /* 14 */
        /***/
        ($, ee) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.GlobalWorkerOptions = void 0;
          const te = /* @__PURE__ */ Object.create(null);
          ee.GlobalWorkerOptions = te, te.workerPort = null, te.workerSrc = "";
        },
        /* 15 */
        /***/
        ($, ee, te) => {
          var le, hs, de, ms, pe, dr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.MessageHandler = void 0;
          var ne = te(1);
          const re = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, se = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function ie(me) {
            switch (me instanceof Error || typeof me == "object" && me !== null || (0, ne.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), me.name) {
              case "AbortException":
                return new ne.AbortException(me.message);
              case "MissingPDFException":
                return new ne.MissingPDFException(me.message);
              case "PasswordException":
                return new ne.PasswordException(me.message, me.code);
              case "UnexpectedResponseException":
                return new ne.UnexpectedResponseException(me.message, me.status);
              case "UnknownErrorException":
                return new ne.UnknownErrorException(me.message, me.details);
              default:
                return new ne.UnknownErrorException(me.message, me.toString());
            }
          }
          class oe {
            constructor(ve, ge, xe) {
              Rt(this, le);
              Rt(this, de);
              Rt(this, pe);
              this.sourceName = ve, this.targetName = ge, this.comObj = xe, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (Ee) => {
                const Te = Ee.data;
                if (Te.targetName !== this.sourceName)
                  return;
                if (Te.stream) {
                  Nt(this, de, ms).call(this, Te);
                  return;
                }
                if (Te.callback) {
                  const he = Te.callbackId, Pe = this.callbackCapabilities[he];
                  if (!Pe)
                    throw new Error(`Cannot resolve callback ${he}`);
                  if (delete this.callbackCapabilities[he], Te.callback === re.DATA)
                    Pe.resolve(Te.data);
                  else if (Te.callback === re.ERROR)
                    Pe.reject(ie(Te.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const Se = this.actionHandler[Te.action];
                if (!Se)
                  throw new Error(`Unknown action from worker: ${Te.action}`);
                if (Te.callbackId) {
                  const he = this.sourceName, Pe = Te.sourceName;
                  new Promise(function(Ie) {
                    Ie(Se(Te.data));
                  }).then(function(Ie) {
                    xe.postMessage({
                      sourceName: he,
                      targetName: Pe,
                      callback: re.DATA,
                      callbackId: Te.callbackId,
                      data: Ie
                    });
                  }, function(Ie) {
                    xe.postMessage({
                      sourceName: he,
                      targetName: Pe,
                      callback: re.ERROR,
                      callbackId: Te.callbackId,
                      reason: ie(Ie)
                    });
                  });
                  return;
                }
                if (Te.streamId) {
                  Nt(this, le, hs).call(this, Te);
                  return;
                }
                Se(Te.data);
              }, xe.addEventListener("message", this._onComObjOnMessage);
            }
            on(ve, ge) {
              const xe = this.actionHandler;
              if (xe[ve])
                throw new Error(`There is already an actionName called "${ve}"`);
              xe[ve] = ge;
            }
            send(ve, ge, xe) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: ve,
                data: ge
              }, xe);
            }
            sendWithPromise(ve, ge, xe) {
              const Ee = this.callbackId++, Te = new ne.PromiseCapability();
              this.callbackCapabilities[Ee] = Te;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: ve,
                  callbackId: Ee,
                  data: ge
                }, xe);
              } catch (Se) {
                Te.reject(Se);
              }
              return Te.promise;
            }
            sendWithStream(ve, ge, xe, Ee) {
              const Te = this.streamId++, Se = this.sourceName, he = this.targetName, Pe = this.comObj;
              return new ReadableStream({
                start: (Ie) => {
                  const De = new ne.PromiseCapability();
                  return this.streamControllers[Te] = {
                    controller: Ie,
                    startCall: De,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, Pe.postMessage({
                    sourceName: Se,
                    targetName: he,
                    action: ve,
                    streamId: Te,
                    data: ge,
                    desiredSize: Ie.desiredSize
                  }, Ee), De.promise;
                },
                pull: (Ie) => {
                  const De = new ne.PromiseCapability();
                  return this.streamControllers[Te].pullCall = De, Pe.postMessage({
                    sourceName: Se,
                    targetName: he,
                    stream: se.PULL,
                    streamId: Te,
                    desiredSize: Ie.desiredSize
                  }), De.promise;
                },
                cancel: (Ie) => {
                  (0, ne.assert)(Ie instanceof Error, "cancel must have a valid reason");
                  const De = new ne.PromiseCapability();
                  return this.streamControllers[Te].cancelCall = De, this.streamControllers[Te].isClosed = !0, Pe.postMessage({
                    sourceName: Se,
                    targetName: he,
                    stream: se.CANCEL,
                    streamId: Te,
                    reason: ie(Ie)
                  }), De.promise;
                }
              }, xe);
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          le = new WeakSet(), hs = function(ve) {
            const ge = ve.streamId, xe = this.sourceName, Ee = ve.sourceName, Te = this.comObj, Se = this, he = this.actionHandler[ve.action], Pe = {
              enqueue(Ie, De = 1, Ce) {
                if (this.isCancelled)
                  return;
                const Ne = this.desiredSize;
                this.desiredSize -= De, Ne > 0 && this.desiredSize <= 0 && (this.sinkCapability = new ne.PromiseCapability(), this.ready = this.sinkCapability.promise), Te.postMessage({
                  sourceName: xe,
                  targetName: Ee,
                  stream: se.ENQUEUE,
                  streamId: ge,
                  chunk: Ie
                }, Ce);
              },
              close() {
                this.isCancelled || (this.isCancelled = !0, Te.postMessage({
                  sourceName: xe,
                  targetName: Ee,
                  stream: se.CLOSE,
                  streamId: ge
                }), delete Se.streamSinks[ge]);
              },
              error(Ie) {
                (0, ne.assert)(Ie instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, Te.postMessage({
                  sourceName: xe,
                  targetName: Ee,
                  stream: se.ERROR,
                  streamId: ge,
                  reason: ie(Ie)
                }));
              },
              sinkCapability: new ne.PromiseCapability(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: ve.desiredSize,
              ready: null
            };
            Pe.sinkCapability.resolve(), Pe.ready = Pe.sinkCapability.promise, this.streamSinks[ge] = Pe, new Promise(function(Ie) {
              Ie(he(ve.data, Pe));
            }).then(function() {
              Te.postMessage({
                sourceName: xe,
                targetName: Ee,
                stream: se.START_COMPLETE,
                streamId: ge,
                success: !0
              });
            }, function(Ie) {
              Te.postMessage({
                sourceName: xe,
                targetName: Ee,
                stream: se.START_COMPLETE,
                streamId: ge,
                reason: ie(Ie)
              });
            });
          }, de = new WeakSet(), ms = function(ve) {
            const ge = ve.streamId, xe = this.sourceName, Ee = ve.sourceName, Te = this.comObj, Se = this.streamControllers[ge], he = this.streamSinks[ge];
            switch (ve.stream) {
              case se.START_COMPLETE:
                ve.success ? Se.startCall.resolve() : Se.startCall.reject(ie(ve.reason));
                break;
              case se.PULL_COMPLETE:
                ve.success ? Se.pullCall.resolve() : Se.pullCall.reject(ie(ve.reason));
                break;
              case se.PULL:
                if (!he) {
                  Te.postMessage({
                    sourceName: xe,
                    targetName: Ee,
                    stream: se.PULL_COMPLETE,
                    streamId: ge,
                    success: !0
                  });
                  break;
                }
                he.desiredSize <= 0 && ve.desiredSize > 0 && he.sinkCapability.resolve(), he.desiredSize = ve.desiredSize, new Promise(function(Pe) {
                  var Ie;
                  Pe((Ie = he.onPull) == null ? void 0 : Ie.call(he));
                }).then(function() {
                  Te.postMessage({
                    sourceName: xe,
                    targetName: Ee,
                    stream: se.PULL_COMPLETE,
                    streamId: ge,
                    success: !0
                  });
                }, function(Pe) {
                  Te.postMessage({
                    sourceName: xe,
                    targetName: Ee,
                    stream: se.PULL_COMPLETE,
                    streamId: ge,
                    reason: ie(Pe)
                  });
                });
                break;
              case se.ENQUEUE:
                if ((0, ne.assert)(Se, "enqueue should have stream controller"), Se.isClosed)
                  break;
                Se.controller.enqueue(ve.chunk);
                break;
              case se.CLOSE:
                if ((0, ne.assert)(Se, "close should have stream controller"), Se.isClosed)
                  break;
                Se.isClosed = !0, Se.controller.close(), Nt(this, pe, dr).call(this, Se, ge);
                break;
              case se.ERROR:
                (0, ne.assert)(Se, "error should have stream controller"), Se.controller.error(ie(ve.reason)), Nt(this, pe, dr).call(this, Se, ge);
                break;
              case se.CANCEL_COMPLETE:
                ve.success ? Se.cancelCall.resolve() : Se.cancelCall.reject(ie(ve.reason)), Nt(this, pe, dr).call(this, Se, ge);
                break;
              case se.CANCEL:
                if (!he)
                  break;
                new Promise(function(Pe) {
                  var Ie;
                  Pe((Ie = he.onCancel) == null ? void 0 : Ie.call(he, ie(ve.reason)));
                }).then(function() {
                  Te.postMessage({
                    sourceName: xe,
                    targetName: Ee,
                    stream: se.CANCEL_COMPLETE,
                    streamId: ge,
                    success: !0
                  });
                }, function(Pe) {
                  Te.postMessage({
                    sourceName: xe,
                    targetName: Ee,
                    stream: se.CANCEL_COMPLETE,
                    streamId: ge,
                    reason: ie(Pe)
                  });
                }), he.sinkCapability.reject(ie(ve.reason)), he.isCancelled = !0, delete this.streamSinks[ge];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }, pe = new WeakSet(), dr = async function(ve, ge) {
            var xe, Ee, Te;
            await Promise.allSettled([(xe = ve.startCall) == null ? void 0 : xe.promise, (Ee = ve.pullCall) == null ? void 0 : Ee.promise, (Te = ve.cancelCall) == null ? void 0 : Te.promise]), delete this.streamControllers[ge];
          }, ee.MessageHandler = oe;
        },
        /* 16 */
        /***/
        ($, ee, te) => {
          var se, ie;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.Metadata = void 0;
          var ne = te(1);
          class re {
            constructor({
              parsedData: le,
              rawData: ue
            }) {
              Rt(this, se, void 0);
              Rt(this, ie, void 0);
              zt(this, se, le), zt(this, ie, ue);
            }
            getRaw() {
              return Oe(this, ie);
            }
            get(le) {
              return Oe(this, se).get(le) ?? null;
            }
            getAll() {
              return (0, ne.objectFromMap)(Oe(this, se));
            }
            has(le) {
              return Oe(this, se).has(le);
            }
          }
          se = new WeakMap(), ie = new WeakMap(), ee.Metadata = re;
        },
        /* 17 */
        /***/
        ($, ee, te) => {
          var le, ue, de, fe, pe, ye, $r;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.OptionalContentConfig = void 0;
          var ne = te(1), re = te(8);
          const se = Symbol("INTERNAL");
          class ie {
            constructor(ge, xe) {
              Rt(this, le, !0);
              this.name = ge, this.intent = xe;
            }
            get visible() {
              return Oe(this, le);
            }
            _setVisible(ge, xe) {
              ge !== se && (0, ne.unreachable)("Internal method `_setVisible` called."), zt(this, le, xe);
            }
          }
          le = new WeakMap();
          class oe {
            constructor(ge) {
              Rt(this, ye);
              Rt(this, ue, null);
              Rt(this, de, /* @__PURE__ */ new Map());
              Rt(this, fe, null);
              Rt(this, pe, null);
              if (this.name = null, this.creator = null, ge !== null) {
                this.name = ge.name, this.creator = ge.creator, zt(this, pe, ge.order);
                for (const xe of ge.groups)
                  Oe(this, de).set(xe.id, new ie(xe.name, xe.intent));
                if (ge.baseState === "OFF")
                  for (const xe of Oe(this, de).values())
                    xe._setVisible(se, !1);
                for (const xe of ge.on)
                  Oe(this, de).get(xe)._setVisible(se, !0);
                for (const xe of ge.off)
                  Oe(this, de).get(xe)._setVisible(se, !1);
                zt(this, fe, this.getHash());
              }
            }
            isVisible(ge) {
              if (Oe(this, de).size === 0)
                return !0;
              if (!ge)
                return (0, ne.warn)("Optional content group not defined."), !0;
              if (ge.type === "OCG")
                return Oe(this, de).has(ge.id) ? Oe(this, de).get(ge.id).visible : ((0, ne.warn)(`Optional content group not found: ${ge.id}`), !0);
              if (ge.type === "OCMD") {
                if (ge.expression)
                  return Nt(this, ye, $r).call(this, ge.expression);
                if (!ge.policy || ge.policy === "AnyOn") {
                  for (const xe of ge.ids) {
                    if (!Oe(this, de).has(xe))
                      return (0, ne.warn)(`Optional content group not found: ${xe}`), !0;
                    if (Oe(this, de).get(xe).visible)
                      return !0;
                  }
                  return !1;
                } else if (ge.policy === "AllOn") {
                  for (const xe of ge.ids) {
                    if (!Oe(this, de).has(xe))
                      return (0, ne.warn)(`Optional content group not found: ${xe}`), !0;
                    if (!Oe(this, de).get(xe).visible)
                      return !1;
                  }
                  return !0;
                } else if (ge.policy === "AnyOff") {
                  for (const xe of ge.ids) {
                    if (!Oe(this, de).has(xe))
                      return (0, ne.warn)(`Optional content group not found: ${xe}`), !0;
                    if (!Oe(this, de).get(xe).visible)
                      return !0;
                  }
                  return !1;
                } else if (ge.policy === "AllOff") {
                  for (const xe of ge.ids) {
                    if (!Oe(this, de).has(xe))
                      return (0, ne.warn)(`Optional content group not found: ${xe}`), !0;
                    if (Oe(this, de).get(xe).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, ne.warn)(`Unknown optional content policy ${ge.policy}.`), !0;
              }
              return (0, ne.warn)(`Unknown group type ${ge.type}.`), !0;
            }
            setVisibility(ge, xe = !0) {
              if (!Oe(this, de).has(ge)) {
                (0, ne.warn)(`Optional content group not found: ${ge}`);
                return;
              }
              Oe(this, de).get(ge)._setVisible(se, !!xe), zt(this, ue, null);
            }
            get hasInitialVisibility() {
              return Oe(this, fe) === null || this.getHash() === Oe(this, fe);
            }
            getOrder() {
              return Oe(this, de).size ? Oe(this, pe) ? Oe(this, pe).slice() : [...Oe(this, de).keys()] : null;
            }
            getGroups() {
              return Oe(this, de).size > 0 ? (0, ne.objectFromMap)(Oe(this, de)) : null;
            }
            getGroup(ge) {
              return Oe(this, de).get(ge) || null;
            }
            getHash() {
              if (Oe(this, ue) !== null)
                return Oe(this, ue);
              const ge = new re.MurmurHash3_64();
              for (const [xe, Ee] of Oe(this, de))
                ge.update(`${xe}:${Ee.visible}`);
              return zt(this, ue, ge.hexdigest());
            }
          }
          ue = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakSet(), $r = function(ge) {
            const xe = ge.length;
            if (xe < 2)
              return !0;
            const Ee = ge[0];
            for (let Te = 1; Te < xe; Te++) {
              const Se = ge[Te];
              let he;
              if (Array.isArray(Se))
                he = Nt(this, ye, $r).call(this, Se);
              else if (Oe(this, de).has(Se))
                he = Oe(this, de).get(Se).visible;
              else
                return (0, ne.warn)(`Optional content group not found: ${Se}`), !0;
              switch (Ee) {
                case "And":
                  if (!he)
                    return !1;
                  break;
                case "Or":
                  if (he)
                    return !0;
                  break;
                case "Not":
                  return !he;
                default:
                  return !0;
              }
            }
            return Ee === "And";
          }, ee.OptionalContentConfig = oe;
        },
        /* 18 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.PDFDataTransportStream = void 0;
          var ne = te(1), re = te(6);
          class se {
            constructor({
              length: ue,
              initialData: de,
              progressiveDone: fe = !1,
              contentDispositionFilename: pe = null,
              disableRange: ye = !1,
              disableStream: me = !1
            }, ve) {
              if ((0, ne.assert)(ve, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = fe, this._contentDispositionFilename = pe, (de == null ? void 0 : de.length) > 0) {
                const ge = de instanceof Uint8Array && de.byteLength === de.buffer.byteLength ? de.buffer : new Uint8Array(de).buffer;
                this._queuedChunks.push(ge);
              }
              this._pdfDataRangeTransport = ve, this._isStreamingSupported = !me, this._isRangeSupported = !ye, this._contentLength = ue, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((ge, xe) => {
                this._onReceiveData({
                  begin: ge,
                  chunk: xe
                });
              }), this._pdfDataRangeTransport.addProgressListener((ge, xe) => {
                this._onProgress({
                  loaded: ge,
                  total: xe
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((ge) => {
                this._onReceiveData({
                  chunk: ge
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData({
              begin: ue,
              chunk: de
            }) {
              const fe = de instanceof Uint8Array && de.byteLength === de.buffer.byteLength ? de.buffer : new Uint8Array(de).buffer;
              if (ue === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(fe) : this._queuedChunks.push(fe);
              else {
                const pe = this._rangeReaders.some(function(ye) {
                  return ye._begin !== ue ? !1 : (ye._enqueue(fe), !0);
                });
                (0, ne.assert)(pe, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var ue;
              return ((ue = this._fullRequestReader) == null ? void 0 : ue._loaded) ?? 0;
            }
            _onProgress(ue) {
              var de, fe, pe, ye;
              ue.total === void 0 ? (fe = (de = this._rangeReaders[0]) == null ? void 0 : de.onProgress) == null || fe.call(de, {
                loaded: ue.loaded
              }) : (ye = (pe = this._fullRequestReader) == null ? void 0 : pe.onProgress) == null || ye.call(pe, {
                loaded: ue.loaded,
                total: ue.total
              });
            }
            _onProgressiveDone() {
              var ue;
              (ue = this._fullRequestReader) == null || ue.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(ue) {
              const de = this._rangeReaders.indexOf(ue);
              de >= 0 && this._rangeReaders.splice(de, 1);
            }
            getFullReader() {
              (0, ne.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const ue = this._queuedChunks;
              return this._queuedChunks = null, new ie(this, ue, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(ue, de) {
              if (de <= this._progressiveDataLength)
                return null;
              const fe = new oe(this, ue, de);
              return this._pdfDataRangeTransport.requestDataRange(ue, de), this._rangeReaders.push(fe), fe;
            }
            cancelAllRequests(ue) {
              var de;
              (de = this._fullRequestReader) == null || de.cancel(ue);
              for (const fe of this._rangeReaders.slice(0))
                fe.cancel(ue);
              this._pdfDataRangeTransport.abort();
            }
          }
          ee.PDFDataTransportStream = se;
          class ie {
            constructor(ue, de, fe = !1, pe = null) {
              this._stream = ue, this._done = fe || !1, this._filename = (0, re.isPdfFile)(pe) ? pe : null, this._queuedChunks = de || [], this._loaded = 0;
              for (const ye of this._queuedChunks)
                this._loaded += ye.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), ue._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(ue) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: ue,
                done: !1
              }) : this._queuedChunks.push(ue), this._loaded += ue.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const ue = new ne.PromiseCapability();
              return this._requests.push(ue), ue.promise;
            }
            cancel(ue) {
              this._done = !0;
              for (const de of this._requests)
                de.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class oe {
            constructor(ue, de, fe) {
              this._stream = ue, this._begin = de, this._end = fe, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(ue) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = ue;
                else {
                  this._requests.shift().resolve({
                    value: ue,
                    done: !1
                  });
                  for (const fe of this._requests)
                    fe.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const de = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: de,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const ue = new ne.PromiseCapability();
              return this._requests.push(ue), ue.promise;
            }
            cancel(ue) {
              this._done = !0;
              for (const de of this._requests)
                de.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 19 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.PDFFetchStream = void 0;
          var ne = te(1), re = te(20);
          function se(fe, pe, ye) {
            return {
              method: "GET",
              headers: fe,
              signal: ye.signal,
              mode: "cors",
              credentials: pe ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function ie(fe) {
            const pe = new Headers();
            for (const ye in fe) {
              const me = fe[ye];
              me !== void 0 && pe.append(ye, me);
            }
            return pe;
          }
          function oe(fe) {
            return fe instanceof Uint8Array ? fe.buffer : fe instanceof ArrayBuffer ? fe : ((0, ne.warn)(`getArrayBuffer - unexpected data format: ${fe}`), new Uint8Array(fe).buffer);
          }
          class le {
            constructor(pe) {
              this.source = pe, this.isHttp = /^https?:/i.test(pe.url), this.httpHeaders = this.isHttp && pe.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var pe;
              return ((pe = this._fullRequestReader) == null ? void 0 : pe._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ne.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new ue(this), this._fullRequestReader;
            }
            getRangeReader(pe, ye) {
              if (ye <= this._progressiveDataLength)
                return null;
              const me = new de(this, pe, ye);
              return this._rangeRequestReaders.push(me), me;
            }
            cancelAllRequests(pe) {
              var ye;
              (ye = this._fullRequestReader) == null || ye.cancel(pe);
              for (const me of this._rangeRequestReaders.slice(0))
                me.cancel(pe);
            }
          }
          ee.PDFFetchStream = le;
          class ue {
            constructor(pe) {
              this._stream = pe, this._reader = null, this._loaded = 0, this._filename = null;
              const ye = pe.source;
              this._withCredentials = ye.withCredentials || !1, this._contentLength = ye.length, this._headersCapability = new ne.PromiseCapability(), this._disableRange = ye.disableRange || !1, this._rangeChunkSize = ye.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !ye.disableStream, this._isRangeSupported = !ye.disableRange, this._headers = ie(this._stream.httpHeaders);
              const me = ye.url;
              fetch(me, se(this._headers, this._withCredentials, this._abortController)).then((ve) => {
                if (!(0, re.validateResponseStatus)(ve.status))
                  throw (0, re.createResponseStatusError)(ve.status, me);
                this._reader = ve.body.getReader(), this._headersCapability.resolve();
                const ge = (Te) => ve.headers.get(Te), {
                  allowRangeRequests: xe,
                  suggestedLength: Ee
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: ge,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = xe, this._contentLength = Ee || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(ge), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ne.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var me;
              await this._headersCapability.promise;
              const {
                value: pe,
                done: ye
              } = await this._reader.read();
              return ye ? {
                value: pe,
                done: ye
              } : (this._loaded += pe.byteLength, (me = this.onProgress) == null || me.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: oe(pe),
                done: !1
              });
            }
            cancel(pe) {
              var ye;
              (ye = this._reader) == null || ye.cancel(pe), this._abortController.abort();
            }
          }
          class de {
            constructor(pe, ye, me) {
              this._stream = pe, this._reader = null, this._loaded = 0;
              const ve = pe.source;
              this._withCredentials = ve.withCredentials || !1, this._readCapability = new ne.PromiseCapability(), this._isStreamingSupported = !ve.disableStream, this._abortController = new AbortController(), this._headers = ie(this._stream.httpHeaders), this._headers.append("Range", `bytes=${ye}-${me - 1}`);
              const ge = ve.url;
              fetch(ge, se(this._headers, this._withCredentials, this._abortController)).then((xe) => {
                if (!(0, re.validateResponseStatus)(xe.status))
                  throw (0, re.createResponseStatusError)(xe.status, ge);
                this._readCapability.resolve(), this._reader = xe.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var me;
              await this._readCapability.promise;
              const {
                value: pe,
                done: ye
              } = await this._reader.read();
              return ye ? {
                value: pe,
                done: ye
              } : (this._loaded += pe.byteLength, (me = this.onProgress) == null || me.call(this, {
                loaded: this._loaded
              }), {
                value: oe(pe),
                done: !1
              });
            }
            cancel(pe) {
              var ye;
              (ye = this._reader) == null || ye.cancel(pe), this._abortController.abort();
            }
          }
        },
        /* 20 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.createResponseStatusError = le, ee.extractFilenameFromHeader = oe, ee.validateRangeRequestCapabilities = ie, ee.validateResponseStatus = ue;
          var ne = te(1), re = te(21), se = te(6);
          function ie({
            getResponseHeader: de,
            isHttp: fe,
            rangeChunkSize: pe,
            disableRange: ye
          }) {
            const me = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, ve = parseInt(de("Content-Length"), 10);
            return !Number.isInteger(ve) || (me.suggestedLength = ve, ve <= 2 * pe) || ye || !fe || de("Accept-Ranges") !== "bytes" || (de("Content-Encoding") || "identity") !== "identity" || (me.allowRangeRequests = !0), me;
          }
          function oe(de) {
            const fe = de("Content-Disposition");
            if (fe) {
              let pe = (0, re.getFilenameFromContentDispositionHeader)(fe);
              if (pe.includes("%"))
                try {
                  pe = decodeURIComponent(pe);
                } catch {
                }
              if ((0, se.isPdfFile)(pe))
                return pe;
            }
            return null;
          }
          function le(de, fe) {
            return de === 404 || de === 0 && fe.startsWith("file:") ? new ne.MissingPDFException('Missing PDF "' + fe + '".') : new ne.UnexpectedResponseException(`Unexpected server response (${de}) while retrieving PDF "${fe}".`, de);
          }
          function ue(de) {
            return de === 200 || de === 206;
          }
        },
        /* 21 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.getFilenameFromContentDispositionHeader = re;
          var ne = te(1);
          function re(se) {
            let ie = !0, oe = le("filename\\*", "i").exec(se);
            if (oe) {
              oe = oe[1];
              let ve = pe(oe);
              return ve = unescape(ve), ve = ye(ve), ve = me(ve), de(ve);
            }
            if (oe = fe(se), oe) {
              const ve = me(oe);
              return de(ve);
            }
            if (oe = le("filename", "i").exec(se), oe) {
              oe = oe[1];
              let ve = pe(oe);
              return ve = me(ve), de(ve);
            }
            function le(ve, ge) {
              return new RegExp("(?:^|;)\\s*" + ve + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', ge);
            }
            function ue(ve, ge) {
              if (ve) {
                if (!/^[\x00-\xFF]+$/.test(ge))
                  return ge;
                try {
                  const xe = new TextDecoder(ve, {
                    fatal: !0
                  }), Ee = (0, ne.stringToBytes)(ge);
                  ge = xe.decode(Ee), ie = !1;
                } catch {
                }
              }
              return ge;
            }
            function de(ve) {
              return ie && /[\x80-\xff]/.test(ve) && (ve = ue("utf-8", ve), ie && (ve = ue("iso-8859-1", ve))), ve;
            }
            function fe(ve) {
              const ge = [];
              let xe;
              const Ee = le("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (xe = Ee.exec(ve)) !== null; ) {
                let [, Se, he, Pe] = xe;
                if (Se = parseInt(Se, 10), Se in ge) {
                  if (Se === 0)
                    break;
                  continue;
                }
                ge[Se] = [he, Pe];
              }
              const Te = [];
              for (let Se = 0; Se < ge.length && Se in ge; ++Se) {
                let [he, Pe] = ge[Se];
                Pe = pe(Pe), he && (Pe = unescape(Pe), Se === 0 && (Pe = ye(Pe))), Te.push(Pe);
              }
              return Te.join("");
            }
            function pe(ve) {
              if (ve.startsWith('"')) {
                const ge = ve.slice(1).split('\\"');
                for (let xe = 0; xe < ge.length; ++xe) {
                  const Ee = ge[xe].indexOf('"');
                  Ee !== -1 && (ge[xe] = ge[xe].slice(0, Ee), ge.length = xe + 1), ge[xe] = ge[xe].replaceAll(/\\(.)/g, "$1");
                }
                ve = ge.join('"');
              }
              return ve;
            }
            function ye(ve) {
              const ge = ve.indexOf("'");
              if (ge === -1)
                return ve;
              const xe = ve.slice(0, ge), Te = ve.slice(ge + 1).replace(/^[^']*'/, "");
              return ue(xe, Te);
            }
            function me(ve) {
              return !ve.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(ve) ? ve : ve.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(ge, xe, Ee, Te) {
                if (Ee === "q" || Ee === "Q")
                  return Te = Te.replaceAll("_", " "), Te = Te.replaceAll(/=([0-9a-fA-F]{2})/g, function(Se, he) {
                    return String.fromCharCode(parseInt(he, 16));
                  }), ue(xe, Te);
                try {
                  Te = atob(Te);
                } catch {
                }
                return ue(xe, Te);
              });
            }
            return "";
          }
        },
        /* 22 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.PDFNetworkStream = void 0;
          var ne = te(1), re = te(20);
          const se = 200, ie = 206;
          function oe(pe) {
            const ye = pe.response;
            return typeof ye != "string" ? ye : (0, ne.stringToBytes)(ye).buffer;
          }
          class le {
            constructor(ye, me = {}) {
              this.url = ye, this.isHttp = /^https?:/i.test(ye), this.httpHeaders = this.isHttp && me.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = me.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(ye, me, ve) {
              const ge = {
                begin: ye,
                end: me
              };
              for (const xe in ve)
                ge[xe] = ve[xe];
              return this.request(ge);
            }
            requestFull(ye) {
              return this.request(ye);
            }
            request(ye) {
              const me = new XMLHttpRequest(), ve = this.currXhrId++, ge = this.pendingRequests[ve] = {
                xhr: me
              };
              me.open("GET", this.url), me.withCredentials = this.withCredentials;
              for (const xe in this.httpHeaders) {
                const Ee = this.httpHeaders[xe];
                Ee !== void 0 && me.setRequestHeader(xe, Ee);
              }
              return this.isHttp && "begin" in ye && "end" in ye ? (me.setRequestHeader("Range", `bytes=${ye.begin}-${ye.end - 1}`), ge.expectedStatus = ie) : ge.expectedStatus = se, me.responseType = "arraybuffer", ye.onError && (me.onerror = function(xe) {
                ye.onError(me.status);
              }), me.onreadystatechange = this.onStateChange.bind(this, ve), me.onprogress = this.onProgress.bind(this, ve), ge.onHeadersReceived = ye.onHeadersReceived, ge.onDone = ye.onDone, ge.onError = ye.onError, ge.onProgress = ye.onProgress, me.send(null), ve;
            }
            onProgress(ye, me) {
              var ge;
              const ve = this.pendingRequests[ye];
              ve && ((ge = ve.onProgress) == null || ge.call(ve, me));
            }
            onStateChange(ye, me) {
              var Se, he, Pe;
              const ve = this.pendingRequests[ye];
              if (!ve)
                return;
              const ge = ve.xhr;
              if (ge.readyState >= 2 && ve.onHeadersReceived && (ve.onHeadersReceived(), delete ve.onHeadersReceived), ge.readyState !== 4 || !(ye in this.pendingRequests))
                return;
              if (delete this.pendingRequests[ye], ge.status === 0 && this.isHttp) {
                (Se = ve.onError) == null || Se.call(ve, ge.status);
                return;
              }
              const xe = ge.status || se;
              if (!(xe === se && ve.expectedStatus === ie) && xe !== ve.expectedStatus) {
                (he = ve.onError) == null || he.call(ve, ge.status);
                return;
              }
              const Te = oe(ge);
              if (xe === ie) {
                const Ie = ge.getResponseHeader("Content-Range"), De = /bytes (\d+)-(\d+)\/(\d+)/.exec(Ie);
                ve.onDone({
                  begin: parseInt(De[1], 10),
                  chunk: Te
                });
              } else
                Te ? ve.onDone({
                  begin: 0,
                  chunk: Te
                }) : (Pe = ve.onError) == null || Pe.call(ve, ge.status);
            }
            getRequestXhr(ye) {
              return this.pendingRequests[ye].xhr;
            }
            isPendingRequest(ye) {
              return ye in this.pendingRequests;
            }
            abortRequest(ye) {
              const me = this.pendingRequests[ye].xhr;
              delete this.pendingRequests[ye], me.abort();
            }
          }
          class ue {
            constructor(ye) {
              this._source = ye, this._manager = new le(ye.url, {
                httpHeaders: ye.httpHeaders,
                withCredentials: ye.withCredentials
              }), this._rangeChunkSize = ye.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(ye) {
              const me = this._rangeRequestReaders.indexOf(ye);
              me >= 0 && this._rangeRequestReaders.splice(me, 1);
            }
            getFullReader() {
              return (0, ne.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new de(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(ye, me) {
              const ve = new fe(this._manager, ye, me);
              return ve.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(ve), ve;
            }
            cancelAllRequests(ye) {
              var me;
              (me = this._fullRequestReader) == null || me.cancel(ye);
              for (const ve of this._rangeRequestReaders.slice(0))
                ve.cancel(ye);
            }
          }
          ee.PDFNetworkStream = ue;
          class de {
            constructor(ye, me) {
              this._manager = ye;
              const ve = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = me.url, this._fullRequestId = ye.requestFull(ve), this._headersReceivedCapability = new ne.PromiseCapability(), this._disableRange = me.disableRange || !1, this._contentLength = me.length, this._rangeChunkSize = me.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const ye = this._fullRequestId, me = this._manager.getRequestXhr(ye), ve = (Ee) => me.getResponseHeader(Ee), {
                allowRangeRequests: ge,
                suggestedLength: xe
              } = (0, re.validateRangeRequestCapabilities)({
                getResponseHeader: ve,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              ge && (this._isRangeSupported = !0), this._contentLength = xe || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(ve), this._isRangeSupported && this._manager.abortRequest(ye), this._headersReceivedCapability.resolve();
            }
            _onDone(ye) {
              if (ye && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: ye.chunk,
                done: !1
              }) : this._cachedChunks.push(ye.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const me of this._requests)
                  me.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(ye) {
              this._storedError = (0, re.createResponseStatusError)(ye, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const me of this._requests)
                me.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(ye) {
              var me;
              (me = this.onProgress) == null || me.call(this, {
                loaded: ye.loaded,
                total: ye.lengthComputable ? ye.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const ye = new ne.PromiseCapability();
              return this._requests.push(ye), ye.promise;
            }
            cancel(ye) {
              this._done = !0, this._headersReceivedCapability.reject(ye);
              for (const me of this._requests)
                me.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class fe {
            constructor(ye, me, ve) {
              this._manager = ye;
              const ge = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = ye.url, this._requestId = ye.requestRange(me, ve, ge), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var ye;
              (ye = this.onClosed) == null || ye.call(this, this);
            }
            _onDone(ye) {
              const me = ye.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: me,
                done: !1
              }) : this._queuedChunk = me, this._done = !0;
              for (const ve of this._requests)
                ve.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(ye) {
              this._storedError = (0, re.createResponseStatusError)(ye, this._url);
              for (const me of this._requests)
                me.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(ye) {
              var me;
              this.isStreamingSupported || (me = this.onProgress) == null || me.call(this, {
                loaded: ye.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const me = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: me,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const ye = new ne.PromiseCapability();
              return this._requests.push(ye), ye.promise;
            }
            cancel(ye) {
              this._done = !0;
              for (const me of this._requests)
                me.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 23 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.PDFNodeStream = void 0;
          var ne = te(1), re = te(20);
          const se = /^file:\/\/\/[a-zA-Z]:\//;
          function ie(ve) {
            const ge = require$$5$2, xe = ge.parse(ve);
            return xe.protocol === "file:" || xe.host ? xe : /^[a-z]:[/\\]/i.test(ve) ? ge.parse(`file:///${ve}`) : (xe.host || (xe.protocol = "file:"), xe);
          }
          class oe {
            constructor(ge) {
              this.source = ge, this.url = ie(ge.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && ge.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var ge;
              return ((ge = this._fullRequestReader) == null ? void 0 : ge._loaded) ?? 0;
            }
            getFullReader() {
              return (0, ne.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new ye(this) : new fe(this), this._fullRequestReader;
            }
            getRangeReader(ge, xe) {
              if (xe <= this._progressiveDataLength)
                return null;
              const Ee = this.isFsUrl ? new me(this, ge, xe) : new pe(this, ge, xe);
              return this._rangeRequestReaders.push(Ee), Ee;
            }
            cancelAllRequests(ge) {
              var xe;
              (xe = this._fullRequestReader) == null || xe.cancel(ge);
              for (const Ee of this._rangeRequestReaders.slice(0))
                Ee.cancel(ge);
            }
          }
          ee.PDFNodeStream = oe;
          class le {
            constructor(ge) {
              this._url = ge.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const xe = ge.source;
              this._contentLength = xe.length, this._loaded = 0, this._filename = null, this._disableRange = xe.disableRange || !1, this._rangeChunkSize = xe.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !xe.disableStream, this._isRangeSupported = !xe.disableRange, this._readableStream = null, this._readCapability = new ne.PromiseCapability(), this._headersCapability = new ne.PromiseCapability();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var Ee;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const ge = this._readableStream.read();
              return ge === null ? (this._readCapability = new ne.PromiseCapability(), this.read()) : (this._loaded += ge.length, (Ee = this.onProgress) == null || Ee.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(ge).buffer,
                done: !1
              });
            }
            cancel(ge) {
              if (!this._readableStream) {
                this._error(ge);
                return;
              }
              this._readableStream.destroy(ge);
            }
            _error(ge) {
              this._storedError = ge, this._readCapability.resolve();
            }
            _setReadableStream(ge) {
              this._readableStream = ge, ge.on("readable", () => {
                this._readCapability.resolve();
              }), ge.on("end", () => {
                ge.destroy(), this._done = !0, this._readCapability.resolve();
              }), ge.on("error", (xe) => {
                this._error(xe);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ne.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class ue {
            constructor(ge) {
              this._url = ge.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new ne.PromiseCapability();
              const xe = ge.source;
              this._isStreamingSupported = !xe.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var Ee;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const ge = this._readableStream.read();
              return ge === null ? (this._readCapability = new ne.PromiseCapability(), this.read()) : (this._loaded += ge.length, (Ee = this.onProgress) == null || Ee.call(this, {
                loaded: this._loaded
              }), {
                value: new Uint8Array(ge).buffer,
                done: !1
              });
            }
            cancel(ge) {
              if (!this._readableStream) {
                this._error(ge);
                return;
              }
              this._readableStream.destroy(ge);
            }
            _error(ge) {
              this._storedError = ge, this._readCapability.resolve();
            }
            _setReadableStream(ge) {
              this._readableStream = ge, ge.on("readable", () => {
                this._readCapability.resolve();
              }), ge.on("end", () => {
                ge.destroy(), this._done = !0, this._readCapability.resolve();
              }), ge.on("error", (xe) => {
                this._error(xe);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function de(ve, ge) {
            return {
              protocol: ve.protocol,
              auth: ve.auth,
              host: ve.hostname,
              port: ve.port,
              path: ve.path,
              method: "GET",
              headers: ge
            };
          }
          class fe extends le {
            constructor(ge) {
              super(ge);
              const xe = (Ee) => {
                if (Ee.statusCode === 404) {
                  const Pe = new ne.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = Pe, this._headersCapability.reject(Pe);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(Ee);
                const Te = (Pe) => this._readableStream.headers[Pe.toLowerCase()], {
                  allowRangeRequests: Se,
                  suggestedLength: he
                } = (0, re.validateRangeRequestCapabilities)({
                  getResponseHeader: Te,
                  isHttp: ge.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = Se, this._contentLength = he || this._contentLength, this._filename = (0, re.extractFilenameFromHeader)(Te);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const Ee = require$$5$2;
                this._request = Ee.request(de(this._url, ge.httpHeaders), xe);
              } else {
                const Ee = require$$5$2;
                this._request = Ee.request(de(this._url, ge.httpHeaders), xe);
              }
              this._request.on("error", (Ee) => {
                this._storedError = Ee, this._headersCapability.reject(Ee);
              }), this._request.end();
            }
          }
          class pe extends ue {
            constructor(ge, xe, Ee) {
              super(ge), this._httpHeaders = {};
              for (const Se in ge.httpHeaders) {
                const he = ge.httpHeaders[Se];
                he !== void 0 && (this._httpHeaders[Se] = he);
              }
              this._httpHeaders.Range = `bytes=${xe}-${Ee - 1}`;
              const Te = (Se) => {
                if (Se.statusCode === 404) {
                  const he = new ne.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = he;
                  return;
                }
                this._setReadableStream(Se);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const Se = require$$5$2;
                this._request = Se.request(de(this._url, this._httpHeaders), Te);
              } else {
                const Se = require$$5$2;
                this._request = Se.request(de(this._url, this._httpHeaders), Te);
              }
              this._request.on("error", (Se) => {
                this._storedError = Se;
              }), this._request.end();
            }
          }
          class ye extends le {
            constructor(ge) {
              super(ge);
              let xe = decodeURIComponent(this._url.path);
              se.test(this._url.href) && (xe = xe.replace(/^\//, ""));
              const Ee = require$$5$2;
              Ee.lstat(xe, (Te, Se) => {
                if (Te) {
                  Te.code === "ENOENT" && (Te = new ne.MissingPDFException(`Missing PDF "${xe}".`)), this._storedError = Te, this._headersCapability.reject(Te);
                  return;
                }
                this._contentLength = Se.size, this._setReadableStream(Ee.createReadStream(xe)), this._headersCapability.resolve();
              });
            }
          }
          class me extends ue {
            constructor(ge, xe, Ee) {
              super(ge);
              let Te = decodeURIComponent(this._url.path);
              se.test(this._url.href) && (Te = Te.replace(/^\//, ""));
              const Se = require$$5$2;
              this._setReadableStream(Se.createReadStream(Te, {
                start: xe,
                end: Ee - 1
              }));
            }
          }
        },
        /* 24 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.SVGGraphics = void 0;
          var ne = te(6), re = te(1);
          const se = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          }, ie = "http://www.w3.org/XML/1998/namespace", oe = "http://www.w3.org/1999/xlink", le = ["butt", "round", "square"], ue = ["miter", "round", "bevel"], de = function(Se, he = "", Pe = !1) {
            if (URL.createObjectURL && typeof Blob < "u" && !Pe)
              return URL.createObjectURL(new Blob([Se], {
                type: he
              }));
            const Ie = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let De = `data:${he};base64,`;
            for (let Ce = 0, Ne = Se.length; Ce < Ne; Ce += 3) {
              const Me = Se[Ce] & 255, Be = Se[Ce + 1] & 255, We = Se[Ce + 2] & 255, Le = Me >> 2, He = (Me & 3) << 4 | Be >> 4, Ge = Ce + 1 < Ne ? (Be & 15) << 2 | We >> 6 : 64, Ze = Ce + 2 < Ne ? We & 63 : 64;
              De += Ie[Le] + Ie[He] + Ie[Ge] + Ie[Ze];
            }
            return De;
          }, fe = function() {
            const Se = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), he = 12, Pe = new Int32Array(256);
            for (let We = 0; We < 256; We++) {
              let Le = We;
              for (let He = 0; He < 8; He++)
                Le = Le & 1 ? 3988292384 ^ Le >> 1 & 2147483647 : Le >> 1 & 2147483647;
              Pe[We] = Le;
            }
            function Ie(We, Le, He) {
              let Ge = -1;
              for (let Ze = Le; Ze < He; Ze++) {
                const Ue = (Ge ^ We[Ze]) & 255, Qe = Pe[Ue];
                Ge = Ge >>> 8 ^ Qe;
              }
              return Ge ^ -1;
            }
            function De(We, Le, He, Ge) {
              let Ze = Ge;
              const Ue = Le.length;
              He[Ze] = Ue >> 24 & 255, He[Ze + 1] = Ue >> 16 & 255, He[Ze + 2] = Ue >> 8 & 255, He[Ze + 3] = Ue & 255, Ze += 4, He[Ze] = We.charCodeAt(0) & 255, He[Ze + 1] = We.charCodeAt(1) & 255, He[Ze + 2] = We.charCodeAt(2) & 255, He[Ze + 3] = We.charCodeAt(3) & 255, Ze += 4, He.set(Le, Ze), Ze += Le.length;
              const Qe = Ie(He, Ge + 4, Ze);
              He[Ze] = Qe >> 24 & 255, He[Ze + 1] = Qe >> 16 & 255, He[Ze + 2] = Qe >> 8 & 255, He[Ze + 3] = Qe & 255;
            }
            function Ce(We, Le, He) {
              let Ge = 1, Ze = 0;
              for (let Ue = Le; Ue < He; ++Ue)
                Ge = (Ge + (We[Ue] & 255)) % 65521, Ze = (Ze + Ge) % 65521;
              return Ze << 16 | Ge;
            }
            function Ne(We) {
              if (!re.isNodeJS)
                return Me(We);
              try {
                const Le = parseInt(process.versions.node) >= 8 ? We : Buffer.from(We), He = require$$5$2.deflateSync(Le, {
                  level: 9
                });
                return He instanceof Uint8Array ? He : new Uint8Array(He);
              } catch (Le) {
                (0, re.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + Le);
              }
              return Me(We);
            }
            function Me(We) {
              let Le = We.length;
              const He = 65535, Ge = Math.ceil(Le / He), Ze = new Uint8Array(2 + Le + Ge * 5 + 4);
              let Ue = 0;
              Ze[Ue++] = 120, Ze[Ue++] = 156;
              let Qe = 0;
              for (; Le > He; )
                Ze[Ue++] = 0, Ze[Ue++] = 255, Ze[Ue++] = 255, Ze[Ue++] = 0, Ze[Ue++] = 0, Ze.set(We.subarray(Qe, Qe + He), Ue), Ue += He, Qe += He, Le -= He;
              Ze[Ue++] = 1, Ze[Ue++] = Le & 255, Ze[Ue++] = Le >> 8 & 255, Ze[Ue++] = ~Le & 65535 & 255, Ze[Ue++] = (~Le & 65535) >> 8 & 255, Ze.set(We.subarray(Qe), Ue), Ue += We.length - Qe;
              const Je = Ce(We, 0, We.length);
              return Ze[Ue++] = Je >> 24 & 255, Ze[Ue++] = Je >> 16 & 255, Ze[Ue++] = Je >> 8 & 255, Ze[Ue++] = Je & 255, Ze;
            }
            function Be(We, Le, He, Ge) {
              const Ze = We.width, Ue = We.height;
              let Qe, Je, Ot;
              const At = We.data;
              switch (Le) {
                case re.ImageKind.GRAYSCALE_1BPP:
                  Je = 0, Qe = 1, Ot = Ze + 7 >> 3;
                  break;
                case re.ImageKind.RGB_24BPP:
                  Je = 2, Qe = 8, Ot = Ze * 3;
                  break;
                case re.ImageKind.RGBA_32BPP:
                  Je = 6, Qe = 8, Ot = Ze * 4;
                  break;
                default:
                  throw new Error("invalid format");
              }
              const ze = new Uint8Array((1 + Ot) * Ue);
              let we = 0, Ae = 0;
              for (let Ye = 0; Ye < Ue; ++Ye)
                ze[we++] = 0, ze.set(At.subarray(Ae, Ae + Ot), we), Ae += Ot, we += Ot;
              if (Le === re.ImageKind.GRAYSCALE_1BPP && Ge) {
                we = 0;
                for (let Ye = 0; Ye < Ue; Ye++) {
                  we++;
                  for (let Ke = 0; Ke < Ot; Ke++)
                    ze[we++] ^= 255;
                }
              }
              const Re = new Uint8Array([Ze >> 24 & 255, Ze >> 16 & 255, Ze >> 8 & 255, Ze & 255, Ue >> 24 & 255, Ue >> 16 & 255, Ue >> 8 & 255, Ue & 255, Qe, Je, 0, 0, 0]), je = Ne(ze), Fe = Se.length + he * 3 + Re.length + je.length, $e = new Uint8Array(Fe);
              let qe = 0;
              return $e.set(Se, qe), qe += Se.length, De("IHDR", Re, $e, qe), qe += he + Re.length, De("IDATA", je, $e, qe), qe += he + je.length, De("IEND", new Uint8Array(0), $e, qe), de($e, "image/png", He);
            }
            return function(Le, He, Ge) {
              const Ze = Le.kind === void 0 ? re.ImageKind.GRAYSCALE_1BPP : Le.kind;
              return Be(Le, Ze, He, Ge);
            };
          }();
          class pe {
            constructor() {
              this.fontSizeScale = 1, this.fontWeight = se.fontWeight, this.fontSize = 0, this.textMatrix = re.IDENTITY_MATRIX, this.fontMatrix = re.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = re.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = se.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
            }
            clone() {
              return Object.create(this);
            }
            setCurrentPoint(he, Pe) {
              this.x = he, this.y = Pe;
            }
          }
          function ye(Se) {
            let he = [];
            const Pe = [];
            for (const Ie of Se) {
              if (Ie.fn === "save") {
                he.push({
                  fnId: 92,
                  fn: "group",
                  items: []
                }), Pe.push(he), he = he.at(-1).items;
                continue;
              }
              Ie.fn === "restore" ? he = Pe.pop() : he.push(Ie);
            }
            return he;
          }
          function me(Se) {
            if (Number.isInteger(Se))
              return Se.toString();
            const he = Se.toFixed(10);
            let Pe = he.length - 1;
            if (he[Pe] !== "0")
              return he;
            do
              Pe--;
            while (he[Pe] === "0");
            return he.substring(0, he[Pe] === "." ? Pe : Pe + 1);
          }
          function ve(Se) {
            if (Se[4] === 0 && Se[5] === 0) {
              if (Se[1] === 0 && Se[2] === 0)
                return Se[0] === 1 && Se[3] === 1 ? "" : `scale(${me(Se[0])} ${me(Se[3])})`;
              if (Se[0] === Se[3] && Se[1] === -Se[2]) {
                const he = Math.acos(Se[0]) * 180 / Math.PI;
                return `rotate(${me(he)})`;
              }
            } else if (Se[0] === 1 && Se[1] === 0 && Se[2] === 0 && Se[3] === 1)
              return `translate(${me(Se[4])} ${me(Se[5])})`;
            return `matrix(${me(Se[0])} ${me(Se[1])} ${me(Se[2])} ${me(Se[3])} ${me(Se[4])} ${me(Se[5])})`;
          }
          let ge = 0, xe = 0, Ee = 0;
          class Te {
            constructor(he, Pe, Ie = !1) {
              (0, ne.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new ne.DOMSVGFactory(), this.current = new pe(), this.transformMatrix = re.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = he, this.objs = Pe, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!Ie, this._operatorIdMapping = [];
              for (const De in re.OPS)
                this._operatorIdMapping[re.OPS[De]] = De;
            }
            getObject(he, Pe = null) {
              return typeof he == "string" ? he.startsWith("g_") ? this.commonObjs.get(he) : this.objs.get(he) : Pe;
            }
            save() {
              this.transformStack.push(this.transformMatrix);
              const he = this.current;
              this.extraStack.push(he), this.current = he.clone();
            }
            restore() {
              this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
            }
            group(he) {
              this.save(), this.executeOpTree(he), this.restore();
            }
            loadDependencies(he) {
              const Pe = he.fnArray, Ie = he.argsArray;
              for (let De = 0, Ce = Pe.length; De < Ce; De++)
                if (Pe[De] === re.OPS.dependency)
                  for (const Ne of Ie[De]) {
                    const Me = Ne.startsWith("g_") ? this.commonObjs : this.objs, Be = new Promise((We) => {
                      Me.get(Ne, We);
                    });
                    this.current.dependencies.push(Be);
                  }
              return Promise.all(this.current.dependencies);
            }
            transform(he, Pe, Ie, De, Ce, Ne) {
              const Me = [he, Pe, Ie, De, Ce, Ne];
              this.transformMatrix = re.Util.transform(this.transformMatrix, Me), this.tgrp = null;
            }
            getSVG(he, Pe) {
              this.viewport = Pe;
              const Ie = this._initialize(Pe);
              return this.loadDependencies(he).then(() => (this.transformMatrix = re.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(he)), Ie));
            }
            convertOpList(he) {
              const Pe = this._operatorIdMapping, Ie = he.argsArray, De = he.fnArray, Ce = [];
              for (let Ne = 0, Me = De.length; Ne < Me; Ne++) {
                const Be = De[Ne];
                Ce.push({
                  fnId: Be,
                  fn: Pe[Be],
                  args: Ie[Ne]
                });
              }
              return ye(Ce);
            }
            executeOpTree(he) {
              for (const Pe of he) {
                const Ie = Pe.fn, De = Pe.fnId, Ce = Pe.args;
                switch (De | 0) {
                  case re.OPS.beginText:
                    this.beginText();
                    break;
                  case re.OPS.dependency:
                    break;
                  case re.OPS.setLeading:
                    this.setLeading(Ce);
                    break;
                  case re.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(Ce[0], Ce[1]);
                    break;
                  case re.OPS.setFont:
                    this.setFont(Ce);
                    break;
                  case re.OPS.showText:
                    this.showText(Ce[0]);
                    break;
                  case re.OPS.showSpacedText:
                    this.showText(Ce[0]);
                    break;
                  case re.OPS.endText:
                    this.endText();
                    break;
                  case re.OPS.moveText:
                    this.moveText(Ce[0], Ce[1]);
                    break;
                  case re.OPS.setCharSpacing:
                    this.setCharSpacing(Ce[0]);
                    break;
                  case re.OPS.setWordSpacing:
                    this.setWordSpacing(Ce[0]);
                    break;
                  case re.OPS.setHScale:
                    this.setHScale(Ce[0]);
                    break;
                  case re.OPS.setTextMatrix:
                    this.setTextMatrix(Ce[0], Ce[1], Ce[2], Ce[3], Ce[4], Ce[5]);
                    break;
                  case re.OPS.setTextRise:
                    this.setTextRise(Ce[0]);
                    break;
                  case re.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(Ce[0]);
                    break;
                  case re.OPS.setLineWidth:
                    this.setLineWidth(Ce[0]);
                    break;
                  case re.OPS.setLineJoin:
                    this.setLineJoin(Ce[0]);
                    break;
                  case re.OPS.setLineCap:
                    this.setLineCap(Ce[0]);
                    break;
                  case re.OPS.setMiterLimit:
                    this.setMiterLimit(Ce[0]);
                    break;
                  case re.OPS.setFillRGBColor:
                    this.setFillRGBColor(Ce[0], Ce[1], Ce[2]);
                    break;
                  case re.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(Ce[0], Ce[1], Ce[2]);
                    break;
                  case re.OPS.setStrokeColorN:
                    this.setStrokeColorN(Ce);
                    break;
                  case re.OPS.setFillColorN:
                    this.setFillColorN(Ce);
                    break;
                  case re.OPS.shadingFill:
                    this.shadingFill(Ce[0]);
                    break;
                  case re.OPS.setDash:
                    this.setDash(Ce[0], Ce[1]);
                    break;
                  case re.OPS.setRenderingIntent:
                    this.setRenderingIntent(Ce[0]);
                    break;
                  case re.OPS.setFlatness:
                    this.setFlatness(Ce[0]);
                    break;
                  case re.OPS.setGState:
                    this.setGState(Ce[0]);
                    break;
                  case re.OPS.fill:
                    this.fill();
                    break;
                  case re.OPS.eoFill:
                    this.eoFill();
                    break;
                  case re.OPS.stroke:
                    this.stroke();
                    break;
                  case re.OPS.fillStroke:
                    this.fillStroke();
                    break;
                  case re.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;
                  case re.OPS.clip:
                    this.clip("nonzero");
                    break;
                  case re.OPS.eoClip:
                    this.clip("evenodd");
                    break;
                  case re.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;
                  case re.OPS.paintImageXObject:
                    this.paintImageXObject(Ce[0]);
                    break;
                  case re.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(Ce[0]);
                    break;
                  case re.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(Ce[0]);
                    break;
                  case re.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(Ce[0], Ce[1]);
                    break;
                  case re.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;
                  case re.OPS.closePath:
                    this.closePath();
                    break;
                  case re.OPS.closeStroke:
                    this.closeStroke();
                    break;
                  case re.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;
                  case re.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;
                  case re.OPS.nextLine:
                    this.nextLine();
                    break;
                  case re.OPS.transform:
                    this.transform(Ce[0], Ce[1], Ce[2], Ce[3], Ce[4], Ce[5]);
                    break;
                  case re.OPS.constructPath:
                    this.constructPath(Ce[0], Ce[1]);
                    break;
                  case re.OPS.endPath:
                    this.endPath();
                    break;
                  case 92:
                    this.group(Pe.items);
                    break;
                  default:
                    (0, re.warn)(`Unimplemented operator ${Ie}`);
                    break;
                }
              }
            }
            setWordSpacing(he) {
              this.current.wordSpacing = he;
            }
            setCharSpacing(he) {
              this.current.charSpacing = he;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            setTextMatrix(he, Pe, Ie, De, Ce, Ne) {
              const Me = this.current;
              Me.textMatrix = Me.lineMatrix = [he, Pe, Ie, De, Ce, Ne], Me.textMatrixScale = Math.hypot(he, Pe), Me.x = Me.lineX = 0, Me.y = Me.lineY = 0, Me.xcoords = [], Me.ycoords = [], Me.tspan = this.svgFactory.createElement("svg:tspan"), Me.tspan.setAttributeNS(null, "font-family", Me.fontFamily), Me.tspan.setAttributeNS(null, "font-size", `${me(Me.fontSize)}px`), Me.tspan.setAttributeNS(null, "y", me(-Me.y)), Me.txtElement = this.svgFactory.createElement("svg:text"), Me.txtElement.append(Me.tspan);
            }
            beginText() {
              const he = this.current;
              he.x = he.lineX = 0, he.y = he.lineY = 0, he.textMatrix = re.IDENTITY_MATRIX, he.lineMatrix = re.IDENTITY_MATRIX, he.textMatrixScale = 1, he.tspan = this.svgFactory.createElement("svg:tspan"), he.txtElement = this.svgFactory.createElement("svg:text"), he.txtgrp = this.svgFactory.createElement("svg:g"), he.xcoords = [], he.ycoords = [];
            }
            moveText(he, Pe) {
              const Ie = this.current;
              Ie.x = Ie.lineX += he, Ie.y = Ie.lineY += Pe, Ie.xcoords = [], Ie.ycoords = [], Ie.tspan = this.svgFactory.createElement("svg:tspan"), Ie.tspan.setAttributeNS(null, "font-family", Ie.fontFamily), Ie.tspan.setAttributeNS(null, "font-size", `${me(Ie.fontSize)}px`), Ie.tspan.setAttributeNS(null, "y", me(-Ie.y));
            }
            showText(he) {
              const Pe = this.current, Ie = Pe.font, De = Pe.fontSize;
              if (De === 0)
                return;
              const Ce = Pe.fontSizeScale, Ne = Pe.charSpacing, Me = Pe.wordSpacing, Be = Pe.fontDirection, We = Pe.textHScale * Be, Le = Ie.vertical, He = Le ? 1 : -1, Ge = Ie.defaultVMetrics, Ze = De * Pe.fontMatrix[0];
              let Ue = 0;
              for (const Ot of he) {
                if (Ot === null) {
                  Ue += Be * Me;
                  continue;
                } else if (typeof Ot == "number") {
                  Ue += He * Ot * De / 1e3;
                  continue;
                }
                const At = (Ot.isSpace ? Me : 0) + Ne, ze = Ot.fontChar;
                let we, Ae, Re = Ot.width;
                if (Le) {
                  let Fe;
                  const $e = Ot.vmetric || Ge;
                  Fe = Ot.vmetric ? $e[1] : Re * 0.5, Fe = -Fe * Ze;
                  const qe = $e[2] * Ze;
                  Re = $e ? -$e[0] : Re, we = Fe / Ce, Ae = (Ue + qe) / Ce;
                } else
                  we = Ue / Ce, Ae = 0;
                (Ot.isInFont || Ie.missingFile) && (Pe.xcoords.push(Pe.x + we), Le && Pe.ycoords.push(-Pe.y + Ae), Pe.tspan.textContent += ze);
                const je = Le ? Re * Ze - At * Be : Re * Ze + At * Be;
                Ue += je;
              }
              Pe.tspan.setAttributeNS(null, "x", Pe.xcoords.map(me).join(" ")), Le ? Pe.tspan.setAttributeNS(null, "y", Pe.ycoords.map(me).join(" ")) : Pe.tspan.setAttributeNS(null, "y", me(-Pe.y)), Le ? Pe.y -= Ue : Pe.x += Ue * We, Pe.tspan.setAttributeNS(null, "font-family", Pe.fontFamily), Pe.tspan.setAttributeNS(null, "font-size", `${me(Pe.fontSize)}px`), Pe.fontStyle !== se.fontStyle && Pe.tspan.setAttributeNS(null, "font-style", Pe.fontStyle), Pe.fontWeight !== se.fontWeight && Pe.tspan.setAttributeNS(null, "font-weight", Pe.fontWeight);
              const Qe = Pe.textRenderingMode & re.TextRenderingMode.FILL_STROKE_MASK;
              if (Qe === re.TextRenderingMode.FILL || Qe === re.TextRenderingMode.FILL_STROKE ? (Pe.fillColor !== se.fillColor && Pe.tspan.setAttributeNS(null, "fill", Pe.fillColor), Pe.fillAlpha < 1 && Pe.tspan.setAttributeNS(null, "fill-opacity", Pe.fillAlpha)) : Pe.textRenderingMode === re.TextRenderingMode.ADD_TO_PATH ? Pe.tspan.setAttributeNS(null, "fill", "transparent") : Pe.tspan.setAttributeNS(null, "fill", "none"), Qe === re.TextRenderingMode.STROKE || Qe === re.TextRenderingMode.FILL_STROKE) {
                const Ot = 1 / (Pe.textMatrixScale || 1);
                this._setStrokeAttributes(Pe.tspan, Ot);
              }
              let Je = Pe.textMatrix;
              Pe.textRise !== 0 && (Je = Je.slice(), Je[5] += Pe.textRise), Pe.txtElement.setAttributeNS(null, "transform", `${ve(Je)} scale(${me(We)}, -1)`), Pe.txtElement.setAttributeNS(ie, "xml:space", "preserve"), Pe.txtElement.append(Pe.tspan), Pe.txtgrp.append(Pe.txtElement), this._ensureTransformGroup().append(Pe.txtElement);
            }
            setLeadingMoveText(he, Pe) {
              this.setLeading(-Pe), this.moveText(he, Pe);
            }
            addFontStyle(he) {
              if (!he.data)
                throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
              this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
              const Pe = de(he.data, he.mimetype, this.forceDataSchema);
              this.cssStyle.textContent += `@font-face { font-family: "${he.loadedName}"; src: url(${Pe}); }
`;
            }
            setFont(he) {
              const Pe = this.current, Ie = this.commonObjs.get(he[0]);
              let De = he[1];
              Pe.font = Ie, this.embedFonts && !Ie.missingFile && !this.embeddedFonts[Ie.loadedName] && (this.addFontStyle(Ie), this.embeddedFonts[Ie.loadedName] = Ie), Pe.fontMatrix = Ie.fontMatrix || re.FONT_IDENTITY_MATRIX;
              let Ce = "normal";
              Ie.black ? Ce = "900" : Ie.bold && (Ce = "bold");
              const Ne = Ie.italic ? "italic" : "normal";
              De < 0 ? (De = -De, Pe.fontDirection = -1) : Pe.fontDirection = 1, Pe.fontSize = De, Pe.fontFamily = Ie.loadedName, Pe.fontWeight = Ce, Pe.fontStyle = Ne, Pe.tspan = this.svgFactory.createElement("svg:tspan"), Pe.tspan.setAttributeNS(null, "y", me(-Pe.y)), Pe.xcoords = [], Pe.ycoords = [];
            }
            endText() {
              var Pe;
              const he = this.current;
              he.textRenderingMode & re.TextRenderingMode.ADD_TO_PATH_FLAG && ((Pe = he.txtElement) != null && Pe.hasChildNodes()) && (he.element = he.txtElement, this.clip("nonzero"), this.endPath());
            }
            setLineWidth(he) {
              he > 0 && (this.current.lineWidth = he);
            }
            setLineCap(he) {
              this.current.lineCap = le[he];
            }
            setLineJoin(he) {
              this.current.lineJoin = ue[he];
            }
            setMiterLimit(he) {
              this.current.miterLimit = he;
            }
            setStrokeAlpha(he) {
              this.current.strokeAlpha = he;
            }
            setStrokeRGBColor(he, Pe, Ie) {
              this.current.strokeColor = re.Util.makeHexColor(he, Pe, Ie);
            }
            setFillAlpha(he) {
              this.current.fillAlpha = he;
            }
            setFillRGBColor(he, Pe, Ie) {
              this.current.fillColor = re.Util.makeHexColor(he, Pe, Ie), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
            }
            setStrokeColorN(he) {
              this.current.strokeColor = this._makeColorN_Pattern(he);
            }
            setFillColorN(he) {
              this.current.fillColor = this._makeColorN_Pattern(he);
            }
            shadingFill(he) {
              const {
                width: Pe,
                height: Ie
              } = this.viewport, De = re.Util.inverseTransform(this.transformMatrix), [Ce, Ne, Me, Be] = re.Util.getAxialAlignedBoundingBox([0, 0, Pe, Ie], De), We = this.svgFactory.createElement("svg:rect");
              We.setAttributeNS(null, "x", Ce), We.setAttributeNS(null, "y", Ne), We.setAttributeNS(null, "width", Me - Ce), We.setAttributeNS(null, "height", Be - Ne), We.setAttributeNS(null, "fill", this._makeShadingPattern(he)), this.current.fillAlpha < 1 && We.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(We);
            }
            _makeColorN_Pattern(he) {
              return he[0] === "TilingPattern" ? this._makeTilingPattern(he) : this._makeShadingPattern(he);
            }
            _makeTilingPattern(he) {
              const Pe = he[1], Ie = he[2], De = he[3] || re.IDENTITY_MATRIX, [Ce, Ne, Me, Be] = he[4], We = he[5], Le = he[6], He = he[7], Ge = `shading${Ee++}`, [Ze, Ue, Qe, Je] = re.Util.normalizeRect([...re.Util.applyTransform([Ce, Ne], De), ...re.Util.applyTransform([Me, Be], De)]), [Ot, At] = re.Util.singularValueDecompose2dScale(De), ze = We * Ot, we = Le * At, Ae = this.svgFactory.createElement("svg:pattern");
              Ae.setAttributeNS(null, "id", Ge), Ae.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), Ae.setAttributeNS(null, "width", ze), Ae.setAttributeNS(null, "height", we), Ae.setAttributeNS(null, "x", `${Ze}`), Ae.setAttributeNS(null, "y", `${Ue}`);
              const Re = this.svg, je = this.transformMatrix, Fe = this.current.fillColor, $e = this.current.strokeColor, qe = this.svgFactory.create(Qe - Ze, Je - Ue);
              if (this.svg = qe, this.transformMatrix = De, He === 2) {
                const Ye = re.Util.makeHexColor(...Pe);
                this.current.fillColor = Ye, this.current.strokeColor = Ye;
              }
              return this.executeOpTree(this.convertOpList(Ie)), this.svg = Re, this.transformMatrix = je, this.current.fillColor = Fe, this.current.strokeColor = $e, Ae.append(qe.childNodes[0]), this.defs.append(Ae), `url(#${Ge})`;
            }
            _makeShadingPattern(he) {
              switch (typeof he == "string" && (he = this.objs.get(he)), he[0]) {
                case "RadialAxial":
                  const Pe = `shading${Ee++}`, Ie = he[3];
                  let De;
                  switch (he[1]) {
                    case "axial":
                      const Ce = he[4], Ne = he[5];
                      De = this.svgFactory.createElement("svg:linearGradient"), De.setAttributeNS(null, "id", Pe), De.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), De.setAttributeNS(null, "x1", Ce[0]), De.setAttributeNS(null, "y1", Ce[1]), De.setAttributeNS(null, "x2", Ne[0]), De.setAttributeNS(null, "y2", Ne[1]);
                      break;
                    case "radial":
                      const Me = he[4], Be = he[5], We = he[6], Le = he[7];
                      De = this.svgFactory.createElement("svg:radialGradient"), De.setAttributeNS(null, "id", Pe), De.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), De.setAttributeNS(null, "cx", Be[0]), De.setAttributeNS(null, "cy", Be[1]), De.setAttributeNS(null, "r", Le), De.setAttributeNS(null, "fx", Me[0]), De.setAttributeNS(null, "fy", Me[1]), De.setAttributeNS(null, "fr", We);
                      break;
                    default:
                      throw new Error(`Unknown RadialAxial type: ${he[1]}`);
                  }
                  for (const Ce of Ie) {
                    const Ne = this.svgFactory.createElement("svg:stop");
                    Ne.setAttributeNS(null, "offset", Ce[0]), Ne.setAttributeNS(null, "stop-color", Ce[1]), De.append(Ne);
                  }
                  return this.defs.append(De), `url(#${Pe})`;
                case "Mesh":
                  return (0, re.warn)("Unimplemented pattern Mesh"), null;
                case "Dummy":
                  return "hotpink";
                default:
                  throw new Error(`Unknown IR type: ${he[0]}`);
              }
            }
            setDash(he, Pe) {
              this.current.dashArray = he, this.current.dashPhase = Pe;
            }
            constructPath(he, Pe) {
              const Ie = this.current;
              let De = Ie.x, Ce = Ie.y, Ne = [], Me = 0;
              for (const Be of he)
                switch (Be | 0) {
                  case re.OPS.rectangle:
                    De = Pe[Me++], Ce = Pe[Me++];
                    const We = Pe[Me++], Le = Pe[Me++], He = De + We, Ge = Ce + Le;
                    Ne.push("M", me(De), me(Ce), "L", me(He), me(Ce), "L", me(He), me(Ge), "L", me(De), me(Ge), "Z");
                    break;
                  case re.OPS.moveTo:
                    De = Pe[Me++], Ce = Pe[Me++], Ne.push("M", me(De), me(Ce));
                    break;
                  case re.OPS.lineTo:
                    De = Pe[Me++], Ce = Pe[Me++], Ne.push("L", me(De), me(Ce));
                    break;
                  case re.OPS.curveTo:
                    De = Pe[Me + 4], Ce = Pe[Me + 5], Ne.push("C", me(Pe[Me]), me(Pe[Me + 1]), me(Pe[Me + 2]), me(Pe[Me + 3]), me(De), me(Ce)), Me += 6;
                    break;
                  case re.OPS.curveTo2:
                    Ne.push("C", me(De), me(Ce), me(Pe[Me]), me(Pe[Me + 1]), me(Pe[Me + 2]), me(Pe[Me + 3])), De = Pe[Me + 2], Ce = Pe[Me + 3], Me += 4;
                    break;
                  case re.OPS.curveTo3:
                    De = Pe[Me + 2], Ce = Pe[Me + 3], Ne.push("C", me(Pe[Me]), me(Pe[Me + 1]), me(De), me(Ce), me(De), me(Ce)), Me += 4;
                    break;
                  case re.OPS.closePath:
                    Ne.push("Z");
                    break;
                }
              Ne = Ne.join(" "), Ie.path && he.length > 0 && he[0] !== re.OPS.rectangle && he[0] !== re.OPS.moveTo ? Ne = Ie.path.getAttributeNS(null, "d") + Ne : (Ie.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(Ie.path)), Ie.path.setAttributeNS(null, "d", Ne), Ie.path.setAttributeNS(null, "fill", "none"), Ie.element = Ie.path, Ie.setCurrentPoint(De, Ce);
            }
            endPath() {
              const he = this.current;
              if (he.path = null, !this.pendingClip)
                return;
              if (!he.element) {
                this.pendingClip = null;
                return;
              }
              const Pe = `clippath${ge++}`, Ie = this.svgFactory.createElement("svg:clipPath");
              Ie.setAttributeNS(null, "id", Pe), Ie.setAttributeNS(null, "transform", ve(this.transformMatrix));
              const De = he.element.cloneNode(!0);
              if (this.pendingClip === "evenodd" ? De.setAttributeNS(null, "clip-rule", "evenodd") : De.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, Ie.append(De), this.defs.append(Ie), he.activeClipUrl) {
                he.clipGroup = null;
                for (const Ce of this.extraStack)
                  Ce.clipGroup = null;
                Ie.setAttributeNS(null, "clip-path", he.activeClipUrl);
              }
              he.activeClipUrl = `url(#${Pe})`, this.tgrp = null;
            }
            clip(he) {
              this.pendingClip = he;
            }
            closePath() {
              const he = this.current;
              if (he.path) {
                const Pe = `${he.path.getAttributeNS(null, "d")}Z`;
                he.path.setAttributeNS(null, "d", Pe);
              }
            }
            setLeading(he) {
              this.current.leading = -he;
            }
            setTextRise(he) {
              this.current.textRise = he;
            }
            setTextRenderingMode(he) {
              this.current.textRenderingMode = he;
            }
            setHScale(he) {
              this.current.textHScale = he / 100;
            }
            setRenderingIntent(he) {
            }
            setFlatness(he) {
            }
            setGState(he) {
              for (const [Pe, Ie] of he)
                switch (Pe) {
                  case "LW":
                    this.setLineWidth(Ie);
                    break;
                  case "LC":
                    this.setLineCap(Ie);
                    break;
                  case "LJ":
                    this.setLineJoin(Ie);
                    break;
                  case "ML":
                    this.setMiterLimit(Ie);
                    break;
                  case "D":
                    this.setDash(Ie[0], Ie[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(Ie);
                    break;
                  case "FL":
                    this.setFlatness(Ie);
                    break;
                  case "Font":
                    this.setFont(Ie);
                    break;
                  case "CA":
                    this.setStrokeAlpha(Ie);
                    break;
                  case "ca":
                    this.setFillAlpha(Ie);
                    break;
                  default:
                    (0, re.warn)(`Unimplemented graphic state operator ${Pe}`);
                    break;
                }
            }
            fill() {
              const he = this.current;
              he.element && (he.element.setAttributeNS(null, "fill", he.fillColor), he.element.setAttributeNS(null, "fill-opacity", he.fillAlpha), this.endPath());
            }
            stroke() {
              const he = this.current;
              he.element && (this._setStrokeAttributes(he.element), he.element.setAttributeNS(null, "fill", "none"), this.endPath());
            }
            _setStrokeAttributes(he, Pe = 1) {
              const Ie = this.current;
              let De = Ie.dashArray;
              Pe !== 1 && De.length > 0 && (De = De.map(function(Ce) {
                return Pe * Ce;
              })), he.setAttributeNS(null, "stroke", Ie.strokeColor), he.setAttributeNS(null, "stroke-opacity", Ie.strokeAlpha), he.setAttributeNS(null, "stroke-miterlimit", me(Ie.miterLimit)), he.setAttributeNS(null, "stroke-linecap", Ie.lineCap), he.setAttributeNS(null, "stroke-linejoin", Ie.lineJoin), he.setAttributeNS(null, "stroke-width", me(Pe * Ie.lineWidth) + "px"), he.setAttributeNS(null, "stroke-dasharray", De.map(me).join(" ")), he.setAttributeNS(null, "stroke-dashoffset", me(Pe * Ie.dashPhase) + "px");
            }
            eoFill() {
              var he;
              (he = this.current.element) == null || he.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
            }
            fillStroke() {
              this.stroke(), this.fill();
            }
            eoFillStroke() {
              var he;
              (he = this.current.element) == null || he.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.closePath(), this.eoFillStroke();
            }
            paintSolidColorImageMask() {
              const he = this.svgFactory.createElement("svg:rect");
              he.setAttributeNS(null, "x", "0"), he.setAttributeNS(null, "y", "0"), he.setAttributeNS(null, "width", "1px"), he.setAttributeNS(null, "height", "1px"), he.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(he);
            }
            paintImageXObject(he) {
              const Pe = this.getObject(he);
              if (!Pe) {
                (0, re.warn)(`Dependent image with object ID ${he} is not ready yet`);
                return;
              }
              this.paintInlineImageXObject(Pe);
            }
            paintInlineImageXObject(he, Pe) {
              const Ie = he.width, De = he.height, Ce = fe(he, this.forceDataSchema, !!Pe), Ne = this.svgFactory.createElement("svg:rect");
              Ne.setAttributeNS(null, "x", "0"), Ne.setAttributeNS(null, "y", "0"), Ne.setAttributeNS(null, "width", me(Ie)), Ne.setAttributeNS(null, "height", me(De)), this.current.element = Ne, this.clip("nonzero");
              const Me = this.svgFactory.createElement("svg:image");
              Me.setAttributeNS(oe, "xlink:href", Ce), Me.setAttributeNS(null, "x", "0"), Me.setAttributeNS(null, "y", me(-De)), Me.setAttributeNS(null, "width", me(Ie) + "px"), Me.setAttributeNS(null, "height", me(De) + "px"), Me.setAttributeNS(null, "transform", `scale(${me(1 / Ie)} ${me(-1 / De)})`), Pe ? Pe.append(Me) : this._ensureTransformGroup().append(Me);
            }
            paintImageMaskXObject(he) {
              const Pe = this.getObject(he.data, he);
              if (Pe.bitmap) {
                (0, re.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                return;
              }
              const Ie = this.current, De = Pe.width, Ce = Pe.height, Ne = Ie.fillColor;
              Ie.maskId = `mask${xe++}`;
              const Me = this.svgFactory.createElement("svg:mask");
              Me.setAttributeNS(null, "id", Ie.maskId);
              const Be = this.svgFactory.createElement("svg:rect");
              Be.setAttributeNS(null, "x", "0"), Be.setAttributeNS(null, "y", "0"), Be.setAttributeNS(null, "width", me(De)), Be.setAttributeNS(null, "height", me(Ce)), Be.setAttributeNS(null, "fill", Ne), Be.setAttributeNS(null, "mask", `url(#${Ie.maskId})`), this.defs.append(Me), this._ensureTransformGroup().append(Be), this.paintInlineImageXObject(Pe, Me);
            }
            paintFormXObjectBegin(he, Pe) {
              if (Array.isArray(he) && he.length === 6 && this.transform(he[0], he[1], he[2], he[3], he[4], he[5]), Pe) {
                const Ie = Pe[2] - Pe[0], De = Pe[3] - Pe[1], Ce = this.svgFactory.createElement("svg:rect");
                Ce.setAttributeNS(null, "x", Pe[0]), Ce.setAttributeNS(null, "y", Pe[1]), Ce.setAttributeNS(null, "width", me(Ie)), Ce.setAttributeNS(null, "height", me(De)), this.current.element = Ce, this.clip("nonzero"), this.endPath();
              }
            }
            paintFormXObjectEnd() {
            }
            _initialize(he) {
              const Pe = this.svgFactory.create(he.width, he.height), Ie = this.svgFactory.createElement("svg:defs");
              Pe.append(Ie), this.defs = Ie;
              const De = this.svgFactory.createElement("svg:g");
              return De.setAttributeNS(null, "transform", ve(he.transform)), Pe.append(De), this.svg = De, Pe;
            }
            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const he = this.svgFactory.createElement("svg:g");
                he.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(he), this.current.clipGroup = he;
              }
              return this.current.clipGroup;
            }
            _ensureTransformGroup() {
              return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", ve(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
            }
          }
          ee.SVGGraphics = Te;
        },
        /* 25 */
        /***/
        ($, ee) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.XfaText = void 0;
          class te {
            static textContent(re) {
              const se = [], ie = {
                items: se,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function oe(le) {
                var fe;
                if (!le)
                  return;
                let ue = null;
                const de = le.name;
                if (de === "#text")
                  ue = le.value;
                else if (te.shouldBuildText(de))
                  (fe = le == null ? void 0 : le.attributes) != null && fe.textContent ? ue = le.attributes.textContent : le.value && (ue = le.value);
                else
                  return;
                if (ue !== null && se.push({
                  str: ue
                }), !!le.children)
                  for (const pe of le.children)
                    oe(pe);
              }
              return oe(re), ie;
            }
            static shouldBuildText(re) {
              return !(re === "textarea" || re === "input" || re === "option" || re === "select");
            }
          }
          ee.XfaText = te;
        },
        /* 26 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.TextLayerRenderTask = void 0, ee.renderTextLayer = ve, ee.updateTextLayer = ge;
          var ne = te(1), re = te(6);
          const se = 1e5, ie = 30, oe = 0.8, le = /* @__PURE__ */ new Map();
          function ue(xe, Ee) {
            let Te;
            if (Ee && ne.FeatureTest.isOffscreenCanvasSupported)
              Te = new OffscreenCanvas(xe, xe).getContext("2d", {
                alpha: !1
              });
            else {
              const Se = document.createElement("canvas");
              Se.width = Se.height = xe, Te = Se.getContext("2d", {
                alpha: !1
              });
            }
            return Te;
          }
          function de(xe, Ee) {
            const Te = le.get(xe);
            if (Te)
              return Te;
            const Se = ue(ie, Ee);
            Se.font = `${ie}px ${xe}`;
            const he = Se.measureText("");
            let Pe = he.fontBoundingBoxAscent, Ie = Math.abs(he.fontBoundingBoxDescent);
            if (Pe) {
              const Ce = Pe / (Pe + Ie);
              return le.set(xe, Ce), Se.canvas.width = Se.canvas.height = 0, Ce;
            }
            Se.strokeStyle = "red", Se.clearRect(0, 0, ie, ie), Se.strokeText("g", 0, 0);
            let De = Se.getImageData(0, 0, ie, ie).data;
            Ie = 0;
            for (let Ce = De.length - 1 - 3; Ce >= 0; Ce -= 4)
              if (De[Ce] > 0) {
                Ie = Math.ceil(Ce / 4 / ie);
                break;
              }
            Se.clearRect(0, 0, ie, ie), Se.strokeText("A", 0, ie), De = Se.getImageData(0, 0, ie, ie).data, Pe = 0;
            for (let Ce = 0, Ne = De.length; Ce < Ne; Ce += 4)
              if (De[Ce] > 0) {
                Pe = ie - Math.floor(Ce / 4 / ie);
                break;
              }
            if (Se.canvas.width = Se.canvas.height = 0, Pe) {
              const Ce = Pe / (Pe + Ie);
              return le.set(xe, Ce), Ce;
            }
            return le.set(xe, oe), oe;
          }
          function fe(xe, Ee, Te) {
            const Se = document.createElement("span"), he = {
              angle: 0,
              canvasWidth: 0,
              hasText: Ee.str !== "",
              hasEOL: Ee.hasEOL,
              fontSize: 0
            };
            xe._textDivs.push(Se);
            const Pe = ne.Util.transform(xe._transform, Ee.transform);
            let Ie = Math.atan2(Pe[1], Pe[0]);
            const De = Te[Ee.fontName];
            De.vertical && (Ie += Math.PI / 2);
            const Ce = Math.hypot(Pe[2], Pe[3]), Ne = Ce * de(De.fontFamily, xe._isOffscreenCanvasSupported);
            let Me, Be;
            Ie === 0 ? (Me = Pe[4], Be = Pe[5] - Ne) : (Me = Pe[4] + Ne * Math.sin(Ie), Be = Pe[5] - Ne * Math.cos(Ie));
            const We = "calc(var(--scale-factor)*", Le = Se.style;
            xe._container === xe._rootContainer ? (Le.left = `${(100 * Me / xe._pageWidth).toFixed(2)}%`, Le.top = `${(100 * Be / xe._pageHeight).toFixed(2)}%`) : (Le.left = `${We}${Me.toFixed(2)}px)`, Le.top = `${We}${Be.toFixed(2)}px)`), Le.fontSize = `${We}${Ce.toFixed(2)}px)`, Le.fontFamily = De.fontFamily, he.fontSize = Ce, Se.setAttribute("role", "presentation"), Se.textContent = Ee.str, Se.dir = Ee.dir, xe._fontInspectorEnabled && (Se.dataset.fontName = Ee.fontName), Ie !== 0 && (he.angle = Ie * (180 / Math.PI));
            let He = !1;
            if (Ee.str.length > 1)
              He = !0;
            else if (Ee.str !== " " && Ee.transform[0] !== Ee.transform[3]) {
              const Ge = Math.abs(Ee.transform[0]), Ze = Math.abs(Ee.transform[3]);
              Ge !== Ze && Math.max(Ge, Ze) / Math.min(Ge, Ze) > 1.5 && (He = !0);
            }
            He && (he.canvasWidth = De.vertical ? Ee.height : Ee.width), xe._textDivProperties.set(Se, he), xe._isReadableStream && xe._layoutText(Se);
          }
          function pe(xe) {
            const {
              div: Ee,
              scale: Te,
              properties: Se,
              ctx: he,
              prevFontSize: Pe,
              prevFontFamily: Ie
            } = xe, {
              style: De
            } = Ee;
            let Ce = "";
            if (Se.canvasWidth !== 0 && Se.hasText) {
              const {
                fontFamily: Ne
              } = De, {
                canvasWidth: Me,
                fontSize: Be
              } = Se;
              (Pe !== Be || Ie !== Ne) && (he.font = `${Be * Te}px ${Ne}`, xe.prevFontSize = Be, xe.prevFontFamily = Ne);
              const {
                width: We
              } = he.measureText(Ee.textContent);
              We > 0 && (Ce = `scaleX(${Me * Te / We})`);
            }
            Se.angle !== 0 && (Ce = `rotate(${Se.angle}deg) ${Ce}`), Ce.length > 0 && (De.transform = Ce);
          }
          function ye(xe) {
            if (xe._canceled)
              return;
            const Ee = xe._textDivs, Te = xe._capability;
            if (Ee.length > se) {
              Te.resolve();
              return;
            }
            if (!xe._isReadableStream)
              for (const he of Ee)
                xe._layoutText(he);
            Te.resolve();
          }
          class me {
            constructor({
              textContentSource: Ee,
              container: Te,
              viewport: Se,
              textDivs: he,
              textDivProperties: Pe,
              textContentItemsStr: Ie,
              isOffscreenCanvasSupported: De
            }) {
              var We;
              this._textContentSource = Ee, this._isReadableStream = Ee instanceof ReadableStream, this._container = this._rootContainer = Te, this._textDivs = he || [], this._textContentItemsStr = Ie || [], this._isOffscreenCanvasSupported = De, this._fontInspectorEnabled = !!((We = globalThis.FontInspector) != null && We.enabled), this._reader = null, this._textDivProperties = Pe || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new ne.PromiseCapability(), this._layoutTextParams = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: Se.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: ue(0, De)
              };
              const {
                pageWidth: Ce,
                pageHeight: Ne,
                pageX: Me,
                pageY: Be
              } = Se.rawDims;
              this._transform = [1, 0, 0, -1, -Me, Be + Ne], this._pageWidth = Ce, this._pageHeight = Ne, (0, re.setLayerDimensions)(Te, Se), this._capability.promise.finally(() => {
                this._layoutTextParams = null;
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new ne.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._capability.reject(new ne.AbortException("TextLayer task cancelled."));
            }
            _processItems(Ee, Te) {
              for (const Se of Ee) {
                if (Se.str === void 0) {
                  if (Se.type === "beginMarkedContentProps" || Se.type === "beginMarkedContent") {
                    const he = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), Se.id !== null && this._container.setAttribute("id", `${Se.id}`), he.append(this._container);
                  } else
                    Se.type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(Se.str), fe(this, Se, Te);
              }
            }
            _layoutText(Ee) {
              const Te = this._layoutTextParams.properties = this._textDivProperties.get(Ee);
              if (this._layoutTextParams.div = Ee, pe(this._layoutTextParams), Te.hasText && this._container.append(Ee), Te.hasEOL) {
                const Se = document.createElement("br");
                Se.setAttribute("role", "presentation"), this._container.append(Se);
              }
            }
            _render() {
              const Ee = new ne.PromiseCapability();
              let Te = /* @__PURE__ */ Object.create(null);
              if (this._isReadableStream) {
                const Se = () => {
                  this._reader.read().then(({
                    value: he,
                    done: Pe
                  }) => {
                    if (Pe) {
                      Ee.resolve();
                      return;
                    }
                    Object.assign(Te, he.styles), this._processItems(he.items, Te), Se();
                  }, Ee.reject);
                };
                this._reader = this._textContentSource.getReader(), Se();
              } else if (this._textContentSource) {
                const {
                  items: Se,
                  styles: he
                } = this._textContentSource;
                this._processItems(Se, he), Ee.resolve();
              } else
                throw new Error('No "textContentSource" parameter specified.');
              Ee.promise.then(() => {
                Te = null, ye(this);
              }, this._capability.reject);
            }
          }
          ee.TextLayerRenderTask = me;
          function ve(xe) {
            !xe.textContentSource && (xe.textContent || xe.textContentStream) && ((0, re.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), xe.textContentSource = xe.textContent || xe.textContentStream);
            const {
              container: Ee,
              viewport: Te
            } = xe, Se = getComputedStyle(Ee), he = Se.getPropertyValue("visibility"), Pe = parseFloat(Se.getPropertyValue("--scale-factor"));
            he === "visible" && (!Pe || Math.abs(Pe - Te.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
            const Ie = new me(xe);
            return Ie._render(), Ie;
          }
          function ge({
            container: xe,
            viewport: Ee,
            textDivs: Te,
            textDivProperties: Se,
            isOffscreenCanvasSupported: he,
            mustRotate: Pe = !0,
            mustRescale: Ie = !0
          }) {
            if (Pe && (0, re.setLayerDimensions)(xe, {
              rotation: Ee.rotation
            }), Ie) {
              const De = ue(0, he), Ne = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: Ee.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: De
              };
              for (const Me of Te)
                Ne.properties = Se.get(Me), Ne.div = Me, pe(Ne);
            }
          }
        },
        /* 27 */
        /***/
        ($, ee, te) => {
          var de, fe, pe, ye, me, ve, ge, xe, Ee, Te, Se, Ur, Pe, fr, De, Br, Ne, Hr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.AnnotationEditorLayer = void 0;
          var ne = te(1), re = te(4), se = te(28), ie = te(33), oe = te(6), le = te(34);
          const Be = class Be {
            constructor({
              uiManager: Le,
              pageIndex: He,
              div: Ge,
              accessibilityManager: Ze,
              annotationLayer: Ue,
              viewport: Qe,
              l10n: Je
            }) {
              Rt(this, Se);
              Rt(this, Pe);
              Rt(this, De);
              Rt(this, Ne);
              Rt(this, de, void 0);
              Rt(this, fe, !1);
              Rt(this, pe, null);
              Rt(this, ye, this.pointerup.bind(this));
              Rt(this, me, this.pointerdown.bind(this));
              Rt(this, ve, /* @__PURE__ */ new Map());
              Rt(this, ge, !1);
              Rt(this, xe, !1);
              Rt(this, Ee, !1);
              Rt(this, Te, void 0);
              const Ot = [se.FreeTextEditor, ie.InkEditor, le.StampEditor];
              if (!Be._initialized) {
                Be._initialized = !0;
                for (const At of Ot)
                  At.initialize(Je);
              }
              Le.registerEditorTypes(Ot), zt(this, Te, Le), this.pageIndex = He, this.div = Ge, zt(this, de, Ze), zt(this, pe, Ue), this.viewport = Qe, Oe(this, Te).addLayer(this);
            }
            get isEmpty() {
              return Oe(this, ve).size === 0;
            }
            updateToolbar(Le) {
              Oe(this, Te).updateToolbar(Le);
            }
            updateMode(Le = Oe(this, Te).getMode()) {
              Nt(this, Ne, Hr).call(this), Le === ne.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), Le !== ne.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", Le === ne.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", Le === ne.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", Le === ne.AnnotationEditorType.STAMP), this.div.hidden = !1);
            }
            addInkEditorIfNeeded(Le) {
              if (!Le && Oe(this, Te).getMode() !== ne.AnnotationEditorType.INK)
                return;
              if (!Le) {
                for (const Ge of Oe(this, ve).values())
                  if (Ge.isEmpty()) {
                    Ge.setInBackground();
                    return;
                  }
              }
              Nt(this, Pe, fr).call(this, {
                offsetX: 0,
                offsetY: 0
              }, !1).setInBackground();
            }
            setEditingState(Le) {
              Oe(this, Te).setEditingState(Le);
            }
            addCommands(Le) {
              Oe(this, Te).addCommands(Le);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              const Le = /* @__PURE__ */ new Set();
              for (const Ge of Oe(this, ve).values())
                Ge.enableEditing(), Ge.annotationElementId && Le.add(Ge.annotationElementId);
              if (!Oe(this, pe))
                return;
              const He = Oe(this, pe).getEditableAnnotations();
              for (const Ge of He) {
                if (Ge.hide(), Oe(this, Te).isDeletedAnnotationElement(Ge.data.id) || Le.has(Ge.data.id))
                  continue;
                const Ze = this.deserialize(Ge);
                Ze && (this.addOrRebuild(Ze), Ze.enableEditing());
              }
            }
            disable() {
              var He;
              zt(this, Ee, !0), this.div.style.pointerEvents = "none";
              const Le = /* @__PURE__ */ new Set();
              for (const Ge of Oe(this, ve).values()) {
                if (Ge.disableEditing(), !Ge.annotationElementId || Ge.serialize() !== null) {
                  Le.add(Ge.annotationElementId);
                  continue;
                }
                (He = this.getEditableAnnotation(Ge.annotationElementId)) == null || He.show(), Ge.remove();
              }
              if (Oe(this, pe)) {
                const Ge = Oe(this, pe).getEditableAnnotations();
                for (const Ze of Ge) {
                  const {
                    id: Ue
                  } = Ze.data;
                  Le.has(Ue) || Oe(this, Te).isDeletedAnnotationElement(Ue) || Ze.show();
                }
              }
              Nt(this, Ne, Hr).call(this), this.isEmpty && (this.div.hidden = !0), zt(this, Ee, !1);
            }
            getEditableAnnotation(Le) {
              var He;
              return ((He = Oe(this, pe)) == null ? void 0 : He.getEditableAnnotation(Le)) || null;
            }
            setActiveEditor(Le) {
              Oe(this, Te).getActive() !== Le && Oe(this, Te).setActiveEditor(Le);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", Oe(this, me)), this.div.addEventListener("pointerup", Oe(this, ye));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", Oe(this, me)), this.div.removeEventListener("pointerup", Oe(this, ye));
            }
            attach(Le) {
              Oe(this, ve).set(Le.id, Le);
              const {
                annotationElementId: He
              } = Le;
              He && Oe(this, Te).isDeletedAnnotationElement(He) && Oe(this, Te).removeDeletedAnnotationElement(Le);
            }
            detach(Le) {
              var He;
              Oe(this, ve).delete(Le.id), (He = Oe(this, de)) == null || He.removePointerInTextLayer(Le.contentDiv), !Oe(this, Ee) && Le.annotationElementId && Oe(this, Te).addDeletedAnnotationElement(Le);
            }
            remove(Le) {
              this.detach(Le), Oe(this, Te).removeEditor(Le), Le.div.contains(document.activeElement) && setTimeout(() => {
                Oe(this, Te).focusMainContainer();
              }, 0), Le.div.remove(), Le.isAttachedToDOM = !1, Oe(this, xe) || this.addInkEditorIfNeeded(!1);
            }
            changeParent(Le) {
              var He;
              Le.parent !== this && (Le.annotationElementId && (Oe(this, Te).addDeletedAnnotationElement(Le.annotationElementId), re.AnnotationEditor.deleteAnnotationElement(Le), Le.annotationElementId = null), this.attach(Le), (He = Le.parent) == null || He.detach(Le), Le.setParent(this), Le.div && Le.isAttachedToDOM && (Le.div.remove(), this.div.append(Le.div)));
            }
            add(Le) {
              if (this.changeParent(Le), Oe(this, Te).addEditor(Le), this.attach(Le), !Le.isAttachedToDOM) {
                const He = Le.render();
                this.div.append(He), Le.isAttachedToDOM = !0;
              }
              Le.fixAndSetPosition(), Le.onceAdded(), Oe(this, Te).addToAnnotationStorage(Le);
            }
            moveEditorInDOM(Le) {
              var Ge;
              if (!Le.isAttachedToDOM)
                return;
              const {
                activeElement: He
              } = document;
              Le.div.contains(He) && (Le._focusEventsAllowed = !1, setTimeout(() => {
                Le.div.contains(document.activeElement) ? Le._focusEventsAllowed = !0 : (Le.div.addEventListener("focusin", () => {
                  Le._focusEventsAllowed = !0;
                }, {
                  once: !0
                }), He.focus());
              }, 0)), Le._structTreeParentId = (Ge = Oe(this, de)) == null ? void 0 : Ge.moveElementInDOM(this.div, Le.div, Le.contentDiv, !0);
            }
            addOrRebuild(Le) {
              Le.needsToBeRebuilt() ? Le.rebuild() : this.add(Le);
            }
            addUndoableEditor(Le) {
              const He = () => Le._uiManager.rebuild(Le), Ge = () => {
                Le.remove();
              };
              this.addCommands({
                cmd: He,
                undo: Ge,
                mustExec: !1
              });
            }
            getNextId() {
              return Oe(this, Te).getId();
            }
            pasteEditor(Le, He) {
              Oe(this, Te).updateToolbar(Le), Oe(this, Te).updateMode(Le);
              const {
                offsetX: Ge,
                offsetY: Ze
              } = Nt(this, De, Br).call(this), Ue = this.getNextId(), Qe = Nt(this, Se, Ur).call(this, {
                parent: this,
                id: Ue,
                x: Ge,
                y: Ze,
                uiManager: Oe(this, Te),
                isCentered: !0,
                ...He
              });
              Qe && this.add(Qe);
            }
            deserialize(Le) {
              switch (Le.annotationType ?? Le.annotationEditorType) {
                case ne.AnnotationEditorType.FREETEXT:
                  return se.FreeTextEditor.deserialize(Le, this, Oe(this, Te));
                case ne.AnnotationEditorType.INK:
                  return ie.InkEditor.deserialize(Le, this, Oe(this, Te));
                case ne.AnnotationEditorType.STAMP:
                  return le.StampEditor.deserialize(Le, this, Oe(this, Te));
              }
              return null;
            }
            addNewEditor() {
              Nt(this, Pe, fr).call(this, Nt(this, De, Br).call(this), !0);
            }
            setSelected(Le) {
              Oe(this, Te).setSelected(Le);
            }
            toggleSelected(Le) {
              Oe(this, Te).toggleSelected(Le);
            }
            isSelected(Le) {
              return Oe(this, Te).isSelected(Le);
            }
            unselect(Le) {
              Oe(this, Te).unselect(Le);
            }
            pointerup(Le) {
              const {
                isMac: He
              } = ne.FeatureTest.platform;
              if (!(Le.button !== 0 || Le.ctrlKey && He) && Le.target === this.div && Oe(this, ge)) {
                if (zt(this, ge, !1), !Oe(this, fe)) {
                  zt(this, fe, !0);
                  return;
                }
                if (Oe(this, Te).getMode() === ne.AnnotationEditorType.STAMP) {
                  Oe(this, Te).unselectAll();
                  return;
                }
                Nt(this, Pe, fr).call(this, Le, !1);
              }
            }
            pointerdown(Le) {
              if (Oe(this, ge)) {
                zt(this, ge, !1);
                return;
              }
              const {
                isMac: He
              } = ne.FeatureTest.platform;
              if (Le.button !== 0 || Le.ctrlKey && He || Le.target !== this.div)
                return;
              zt(this, ge, !0);
              const Ge = Oe(this, Te).getActive();
              zt(this, fe, !Ge || Ge.isEmpty());
            }
            findNewParent(Le, He, Ge) {
              const Ze = Oe(this, Te).findParent(He, Ge);
              return Ze === null || Ze === this ? !1 : (Ze.changeParent(Le), !0);
            }
            destroy() {
              var Le, He;
              ((Le = Oe(this, Te).getActive()) == null ? void 0 : Le.parent) === this && (Oe(this, Te).commitOrRemove(), Oe(this, Te).setActiveEditor(null));
              for (const Ge of Oe(this, ve).values())
                (He = Oe(this, de)) == null || He.removePointerInTextLayer(Ge.contentDiv), Ge.setParent(null), Ge.isAttachedToDOM = !1, Ge.div.remove();
              this.div = null, Oe(this, ve).clear(), Oe(this, Te).removeLayer(this);
            }
            render({
              viewport: Le
            }) {
              this.viewport = Le, (0, oe.setLayerDimensions)(this.div, Le);
              for (const He of Oe(this, Te).getEditors(this.pageIndex))
                this.add(He);
              this.updateMode();
            }
            update({
              viewport: Le
            }) {
              Oe(this, Te).commitOrRemove(), this.viewport = Le, (0, oe.setLayerDimensions)(this.div, {
                rotation: Le.rotation
              }), this.updateMode();
            }
            get pageDimensions() {
              const {
                pageWidth: Le,
                pageHeight: He
              } = this.viewport.rawDims;
              return [Le, He];
            }
          };
          de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakMap(), Ee = new WeakMap(), Te = new WeakMap(), Se = new WeakSet(), Ur = function(Le) {
            switch (Oe(this, Te).getMode()) {
              case ne.AnnotationEditorType.FREETEXT:
                return new se.FreeTextEditor(Le);
              case ne.AnnotationEditorType.INK:
                return new ie.InkEditor(Le);
              case ne.AnnotationEditorType.STAMP:
                return new le.StampEditor(Le);
            }
            return null;
          }, Pe = new WeakSet(), fr = function(Le, He) {
            const Ge = this.getNextId(), Ze = Nt(this, Se, Ur).call(this, {
              parent: this,
              id: Ge,
              x: Le.offsetX,
              y: Le.offsetY,
              uiManager: Oe(this, Te),
              isCentered: He
            });
            return Ze && this.add(Ze), Ze;
          }, De = new WeakSet(), Br = function() {
            const {
              x: Le,
              y: He,
              width: Ge,
              height: Ze
            } = this.div.getBoundingClientRect(), Ue = Math.max(0, Le), Qe = Math.max(0, He), Je = Math.min(window.innerWidth, Le + Ge), Ot = Math.min(window.innerHeight, He + Ze), At = (Ue + Je) / 2 - Le, ze = (Qe + Ot) / 2 - He, [we, Ae] = this.viewport.rotation % 180 === 0 ? [At, ze] : [ze, At];
            return {
              offsetX: we,
              offsetY: Ae
            };
          }, Ne = new WeakSet(), Hr = function() {
            zt(this, xe, !0);
            for (const Le of Oe(this, ve).values())
              Le.isEmpty() && Le.remove();
            zt(this, xe, !1);
          }, On(Be, "_initialized", !1);
          let ue = Be;
          ee.AnnotationEditorLayer = ue;
        },
        /* 28 */
        /***/
        ($, ee, te) => {
          var le, ue, de, fe, pe, ye, me, ve, ge, xe, gs, Te, ys, he, vs, Ie, er, Ce, zr, Me, xs, We, qr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.FreeTextEditor = void 0;
          var ne = te(1), re = te(5), se = te(4), ie = te(29);
          const He = class He extends se.AnnotationEditor {
            constructor(Ue) {
              super({
                ...Ue,
                name: "freeTextEditor"
              });
              Rt(this, xe);
              Rt(this, Te);
              Rt(this, he);
              Rt(this, Ie);
              Rt(this, Ce);
              Rt(this, Me);
              Rt(this, We);
              Rt(this, le, this.editorDivBlur.bind(this));
              Rt(this, ue, this.editorDivFocus.bind(this));
              Rt(this, de, this.editorDivInput.bind(this));
              Rt(this, fe, this.editorDivKeydown.bind(this));
              Rt(this, pe, void 0);
              Rt(this, ye, "");
              Rt(this, me, `${this.id}-editor`);
              Rt(this, ve, void 0);
              Rt(this, ge, null);
              zt(this, pe, Ue.color || He._defaultColor || se.AnnotationEditor._defaultLineColor), zt(this, ve, Ue.fontSize || He._defaultFontSize);
            }
            static get _keyboardManager() {
              const Ue = He.prototype, Qe = (At) => At.isEmpty(), Je = re.AnnotationEditorUIManager.TRANSLATE_SMALL, Ot = re.AnnotationEditorUIManager.TRANSLATE_BIG;
              return (0, ne.shadow)(this, "_keyboardManager", new re.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], Ue.commitOrRemove, {
                bubbles: !0
              }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], Ue.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], Ue._translateEmpty, {
                args: [-Je, 0],
                checker: Qe
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], Ue._translateEmpty, {
                args: [-Ot, 0],
                checker: Qe
              }], [["ArrowRight", "mac+ArrowRight"], Ue._translateEmpty, {
                args: [Je, 0],
                checker: Qe
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], Ue._translateEmpty, {
                args: [Ot, 0],
                checker: Qe
              }], [["ArrowUp", "mac+ArrowUp"], Ue._translateEmpty, {
                args: [0, -Je],
                checker: Qe
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], Ue._translateEmpty, {
                args: [0, -Ot],
                checker: Qe
              }], [["ArrowDown", "mac+ArrowDown"], Ue._translateEmpty, {
                args: [0, Je],
                checker: Qe
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], Ue._translateEmpty, {
                args: [0, Ot],
                checker: Qe
              }]]));
            }
            static initialize(Ue) {
              se.AnnotationEditor.initialize(Ue, {
                strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
              });
              const Qe = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(Qe.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(Ue, Qe) {
              switch (Ue) {
                case ne.AnnotationEditorParamsType.FREETEXT_SIZE:
                  He._defaultFontSize = Qe;
                  break;
                case ne.AnnotationEditorParamsType.FREETEXT_COLOR:
                  He._defaultColor = Qe;
                  break;
              }
            }
            updateParams(Ue, Qe) {
              switch (Ue) {
                case ne.AnnotationEditorParamsType.FREETEXT_SIZE:
                  Nt(this, xe, gs).call(this, Qe);
                  break;
                case ne.AnnotationEditorParamsType.FREETEXT_COLOR:
                  Nt(this, Te, ys).call(this, Qe);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ne.AnnotationEditorParamsType.FREETEXT_SIZE, He._defaultFontSize], [ne.AnnotationEditorParamsType.FREETEXT_COLOR, He._defaultColor || se.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[ne.AnnotationEditorParamsType.FREETEXT_SIZE, Oe(this, ve)], [ne.AnnotationEditorParamsType.FREETEXT_COLOR, Oe(this, pe)]];
            }
            _translateEmpty(Ue, Qe) {
              this._uiManager.translateSelectedEditors(Ue, Qe, !0);
            }
            getInitialTranslation() {
              const Ue = this.parentScale;
              return [-He._internalPadding * Ue, -(He._internalPadding + Oe(this, ve)) * Ue];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(ne.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", Oe(this, fe)), this.editorDiv.addEventListener("focus", Oe(this, ue)), this.editorDiv.addEventListener("blur", Oe(this, le)), this.editorDiv.addEventListener("input", Oe(this, de)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", Oe(this, me)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", Oe(this, fe)), this.editorDiv.removeEventListener("focus", Oe(this, ue)), this.editorDiv.removeEventListener("blur", Oe(this, le)), this.editorDiv.removeEventListener("input", Oe(this, de)), this.div.focus({
                preventScroll: !0
              }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
            }
            focusin(Ue) {
              this._focusEventsAllowed && (super.focusin(Ue), Ue.target !== this.editorDiv && this.editorDiv.focus());
            }
            onceAdded() {
              var Ue;
              if (this.width) {
                Nt(this, We, qr).call(this);
                return;
              }
              this.enableEditMode(), this.editorDiv.focus(), (Ue = this._initialOptions) != null && Ue.isCentered && this.center(), this._initialOptions = null;
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
            }
            commit() {
              if (!this.isInEditMode())
                return;
              super.commit(), this.disableEditMode();
              const Ue = Oe(this, ye), Qe = zt(this, ye, Nt(this, he, vs).call(this).trimEnd());
              if (Ue === Qe)
                return;
              const Je = (Ot) => {
                if (zt(this, ye, Ot), !Ot) {
                  this.remove();
                  return;
                }
                Nt(this, Ce, zr).call(this), this._uiManager.rebuild(this), Nt(this, Ie, er).call(this);
              };
              this.addCommands({
                cmd: () => {
                  Je(Qe);
                },
                undo: () => {
                  Je(Ue);
                },
                mustExec: !1
              }), Nt(this, Ie, er).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            enterInEditMode() {
              this.enableEditMode(), this.editorDiv.focus();
            }
            dblclick(Ue) {
              this.enterInEditMode();
            }
            keydown(Ue) {
              Ue.target === this.div && Ue.key === "Enter" && (this.enterInEditMode(), Ue.preventDefault());
            }
            editorDivKeydown(Ue) {
              He._keyboardManager.exec(this, Ue);
            }
            editorDivFocus(Ue) {
              this.isEditing = !0;
            }
            editorDivBlur(Ue) {
              this.isEditing = !1;
            }
            editorDivInput(Ue) {
              this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let Ue, Qe;
              this.width && (Ue = this.x, Qe = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", Oe(this, me)), this.enableEditing(), se.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((Ot) => {
                var At;
                return (At = this.editorDiv) == null ? void 0 : At.setAttribute("aria-label", Ot);
              }), se.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((Ot) => {
                var At;
                return (At = this.editorDiv) == null ? void 0 : At.setAttribute("default-content", Ot);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: Je
              } = this.editorDiv;
              if (Je.fontSize = `calc(${Oe(this, ve)}px * var(--scale-factor))`, Je.color = Oe(this, pe), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, re.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [Ot, At] = this.parentDimensions;
                if (this.annotationElementId) {
                  const {
                    position: ze
                  } = Oe(this, ge);
                  let [we, Ae] = this.getInitialTranslation();
                  [we, Ae] = this.pageTranslationToScreen(we, Ae);
                  const [Re, je] = this.pageDimensions, [Fe, $e] = this.pageTranslation;
                  let qe, Ye;
                  switch (this.rotation) {
                    case 0:
                      qe = Ue + (ze[0] - Fe) / Re, Ye = Qe + this.height - (ze[1] - $e) / je;
                      break;
                    case 90:
                      qe = Ue + (ze[0] - Fe) / Re, Ye = Qe - (ze[1] - $e) / je, [we, Ae] = [Ae, -we];
                      break;
                    case 180:
                      qe = Ue - this.width + (ze[0] - Fe) / Re, Ye = Qe - (ze[1] - $e) / je, [we, Ae] = [-we, -Ae];
                      break;
                    case 270:
                      qe = Ue + (ze[0] - Fe - this.height * je) / Re, Ye = Qe + (ze[1] - $e - this.width * Re) / je, [we, Ae] = [-Ae, we];
                      break;
                  }
                  this.setAt(qe * Ot, Ye * At, we, Ae);
                } else
                  this.setAt(Ue * Ot, Qe * At, this.width * Ot, this.height * At);
                Nt(this, Ce, zr).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this._isDraggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(Ue, Qe, Je) {
              let Ot = null;
              if (Ue instanceof ie.FreeTextAnnotationElement) {
                const {
                  data: {
                    defaultAppearanceData: {
                      fontSize: ze,
                      fontColor: we
                    },
                    rect: Ae,
                    rotation: Re,
                    id: je
                  },
                  textContent: Fe,
                  textPosition: $e,
                  parent: {
                    page: {
                      pageNumber: qe
                    }
                  }
                } = Ue;
                if (!Fe || Fe.length === 0)
                  return null;
                Ot = Ue = {
                  annotationType: ne.AnnotationEditorType.FREETEXT,
                  color: Array.from(we),
                  fontSize: ze,
                  value: Fe.join(`
`),
                  position: $e,
                  pageIndex: qe - 1,
                  rect: Ae,
                  rotation: Re,
                  id: je,
                  deleted: !1
                };
              }
              const At = super.deserialize(Ue, Qe, Je);
              return zt(At, ve, Ue.fontSize), zt(At, pe, ne.Util.makeHexColor(...Ue.color)), zt(At, ye, Ue.value), At.annotationElementId = Ue.id || null, zt(At, ge, Ot), At;
            }
            serialize(Ue = !1) {
              if (this.isEmpty())
                return null;
              if (this.deleted)
                return {
                  pageIndex: this.pageIndex,
                  id: this.annotationElementId,
                  deleted: !0
                };
              const Qe = He._internalPadding * this.parentScale, Je = this.getRect(Qe, Qe), Ot = se.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : Oe(this, pe)), At = {
                annotationType: ne.AnnotationEditorType.FREETEXT,
                color: Ot,
                fontSize: Oe(this, ve),
                value: Oe(this, ye),
                pageIndex: this.pageIndex,
                rect: Je,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
              return Ue ? At : this.annotationElementId && !Nt(this, Me, xs).call(this, At) ? null : (At.id = this.annotationElementId, At);
            }
          };
          le = new WeakMap(), ue = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakSet(), gs = function(Ue) {
            const Qe = (Ot) => {
              this.editorDiv.style.fontSize = `calc(${Ot}px * var(--scale-factor))`, this.translate(0, -(Ot - Oe(this, ve)) * this.parentScale), zt(this, ve, Ot), Nt(this, Ie, er).call(this);
            }, Je = Oe(this, ve);
            this.addCommands({
              cmd: () => {
                Qe(Ue);
              },
              undo: () => {
                Qe(Je);
              },
              mustExec: !0,
              type: ne.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, Te = new WeakSet(), ys = function(Ue) {
            const Qe = Oe(this, pe);
            this.addCommands({
              cmd: () => {
                zt(this, pe, this.editorDiv.style.color = Ue);
              },
              undo: () => {
                zt(this, pe, this.editorDiv.style.color = Qe);
              },
              mustExec: !0,
              type: ne.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, he = new WeakSet(), vs = function() {
            const Ue = this.editorDiv.getElementsByTagName("div");
            if (Ue.length === 0)
              return this.editorDiv.innerText;
            const Qe = [];
            for (const Je of Ue)
              Qe.push(Je.innerText.replace(/\r\n?|\n/, ""));
            return Qe.join(`
`);
          }, Ie = new WeakSet(), er = function() {
            const [Ue, Qe] = this.parentDimensions;
            let Je;
            if (this.isAttachedToDOM)
              Je = this.div.getBoundingClientRect();
            else {
              const {
                currentLayer: Ot,
                div: At
              } = this, ze = At.style.display;
              At.style.display = "hidden", Ot.div.append(this.div), Je = At.getBoundingClientRect(), At.remove(), At.style.display = ze;
            }
            this.rotation % 180 === this.parentRotation % 180 ? (this.width = Je.width / Ue, this.height = Je.height / Qe) : (this.width = Je.height / Ue, this.height = Je.width / Qe), this.fixAndSetPosition();
          }, Ce = new WeakSet(), zr = function() {
            if (this.editorDiv.replaceChildren(), !!Oe(this, ye))
              for (const Ue of Oe(this, ye).split(`
`)) {
                const Qe = document.createElement("div");
                Qe.append(Ue ? document.createTextNode(Ue) : document.createElement("br")), this.editorDiv.append(Qe);
              }
          }, Me = new WeakSet(), xs = function(Ue) {
            const {
              value: Qe,
              fontSize: Je,
              color: Ot,
              rect: At,
              pageIndex: ze
            } = Oe(this, ge);
            return Ue.value !== Qe || Ue.fontSize !== Je || Ue.rect.some((we, Ae) => Math.abs(we - At[Ae]) >= 1) || Ue.color.some((we, Ae) => we !== Ot[Ae]) || Ue.pageIndex !== ze;
          }, We = new WeakSet(), qr = function(Ue = !1) {
            if (!this.annotationElementId)
              return;
            if (Nt(this, Ie, er).call(this), !Ue && (this.width === 0 || this.height === 0)) {
              setTimeout(() => Nt(this, We, qr).call(this, !0), 0);
              return;
            }
            const Qe = He._internalPadding * this.parentScale;
            Oe(this, ge).rect = this.getRect(Qe, Qe);
          }, On(He, "_freeTextDefaultContent", ""), On(He, "_internalPadding", 0), On(He, "_defaultColor", null), On(He, "_defaultFontSize", 10), On(He, "_type", "freetext");
          let oe = He;
          ee.FreeTextEditor = oe;
        },
        /* 29 */
        /***/
        ($, ee, te) => {
          var Ae, je, Hn, $e, Es, Ye, Ke, Tt, pt, Bt, Vt, qt, nn, mn, en, pn, Yt, Ut, jt, Gt, ln, sn, _n, Ss, En, pr, Tn, Vr, Rn, Wr, Ht, Lt, Zt, Jt, Dn, kn, $t, Gr, gn, dn, vn, xn, Ts, Qt, Kr;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.StampAnnotationElement = ee.InkAnnotationElement = ee.FreeTextAnnotationElement = ee.AnnotationLayer = void 0;
          var ne = te(1), re = te(6), se = te(3), ie = te(30), oe = te(31), le = te(32);
          const ue = 1e3, de = 9, fe = /* @__PURE__ */ new WeakSet();
          function pe(yn) {
            return {
              width: yn[2] - yn[0],
              height: yn[3] - yn[1]
            };
          }
          class ye {
            static create(xt) {
              switch (xt.data.annotationType) {
                case ne.AnnotationType.LINK:
                  return new ve(xt);
                case ne.AnnotationType.TEXT:
                  return new ge(xt);
                case ne.AnnotationType.WIDGET:
                  switch (xt.data.fieldType) {
                    case "Tx":
                      return new Ee(xt);
                    case "Btn":
                      return xt.data.radioButton ? new he(xt) : xt.data.checkBox ? new Se(xt) : new Pe(xt);
                    case "Ch":
                      return new Ie(xt);
                    case "Sig":
                      return new Te(xt);
                  }
                  return new xe(xt);
                case ne.AnnotationType.POPUP:
                  return new De(xt);
                case ne.AnnotationType.FREETEXT:
                  return new Ne(xt);
                case ne.AnnotationType.LINE:
                  return new Me(xt);
                case ne.AnnotationType.SQUARE:
                  return new Be(xt);
                case ne.AnnotationType.CIRCLE:
                  return new We(xt);
                case ne.AnnotationType.POLYLINE:
                  return new Le(xt);
                case ne.AnnotationType.CARET:
                  return new Ge(xt);
                case ne.AnnotationType.INK:
                  return new Ze(xt);
                case ne.AnnotationType.POLYGON:
                  return new He(xt);
                case ne.AnnotationType.HIGHLIGHT:
                  return new Ue(xt);
                case ne.AnnotationType.UNDERLINE:
                  return new Qe(xt);
                case ne.AnnotationType.SQUIGGLY:
                  return new Je(xt);
                case ne.AnnotationType.STRIKEOUT:
                  return new Ot(xt);
                case ne.AnnotationType.STAMP:
                  return new At(xt);
                case ne.AnnotationType.FILEATTACHMENT:
                  return new ze(xt);
                default:
                  return new me(xt);
              }
            }
          }
          const Re = class Re {
            constructor(xt, {
              isRenderable: ke = !1,
              ignoreBorder: Xe = !1,
              createQuadrilaterals: Et = !1
            } = {}) {
              Rt(this, Ae, !1);
              this.isRenderable = ke, this.data = xt.data, this.layer = xt.layer, this.linkService = xt.linkService, this.downloadManager = xt.downloadManager, this.imageResourcesPath = xt.imageResourcesPath, this.renderForms = xt.renderForms, this.svgFactory = xt.svgFactory, this.annotationStorage = xt.annotationStorage, this.enableScripting = xt.enableScripting, this.hasJSActions = xt.hasJSActions, this._fieldObjects = xt.fieldObjects, this.parent = xt.parent, ke && (this.container = this._createContainer(Xe)), Et && this._createQuadrilaterals();
            }
            static _hasPopupData({
              titleObj: xt,
              contentsObj: ke,
              richText: Xe
            }) {
              return !!(xt != null && xt.str || ke != null && ke.str || Xe != null && Xe.str);
            }
            get hasPopupData() {
              return Re._hasPopupData(this.data);
            }
            _createContainer(xt) {
              const {
                data: ke,
                parent: {
                  page: Xe,
                  viewport: Et
                }
              } = this, Mt = document.createElement("section");
              Mt.setAttribute("data-annotation-id", ke.id), this instanceof xe || (Mt.tabIndex = ue), Mt.style.zIndex = this.parent.zIndex++, this.data.popupRef && Mt.setAttribute("aria-haspopup", "dialog"), ke.noRotate && Mt.classList.add("norotate");
              const {
                pageWidth: Ft,
                pageHeight: Ve,
                pageX: Dt,
                pageY: Wt
              } = Et.rawDims;
              if (!ke.rect || this instanceof De) {
                const {
                  rotation: fn
                } = ke;
                return !ke.hasOwnCanvas && fn !== 0 && this.setRotation(fn, Mt), Mt;
              }
              const {
                width: Xt,
                height: hn
              } = pe(ke.rect), rn = ne.Util.normalizeRect([ke.rect[0], Xe.view[3] - ke.rect[1] + Xe.view[1], ke.rect[2], Xe.view[3] - ke.rect[3] + Xe.view[1]]);
              if (!xt && ke.borderStyle.width > 0) {
                Mt.style.borderWidth = `${ke.borderStyle.width}px`;
                const fn = ke.borderStyle.horizontalCornerRadius, Sn = ke.borderStyle.verticalCornerRadius;
                if (fn > 0 || Sn > 0) {
                  const An = `calc(${fn}px * var(--scale-factor)) / calc(${Sn}px * var(--scale-factor))`;
                  Mt.style.borderRadius = An;
                } else if (this instanceof he) {
                  const An = `calc(${Xt}px * var(--scale-factor)) / calc(${hn}px * var(--scale-factor))`;
                  Mt.style.borderRadius = An;
                }
                switch (ke.borderStyle.style) {
                  case ne.AnnotationBorderStyleType.SOLID:
                    Mt.style.borderStyle = "solid";
                    break;
                  case ne.AnnotationBorderStyleType.DASHED:
                    Mt.style.borderStyle = "dashed";
                    break;
                  case ne.AnnotationBorderStyleType.BEVELED:
                    (0, ne.warn)("Unimplemented border style: beveled");
                    break;
                  case ne.AnnotationBorderStyleType.INSET:
                    (0, ne.warn)("Unimplemented border style: inset");
                    break;
                  case ne.AnnotationBorderStyleType.UNDERLINE:
                    Mt.style.borderBottomStyle = "solid";
                    break;
                }
                const Cn = ke.borderColor || null;
                Cn ? (zt(this, Ae, !0), Mt.style.borderColor = ne.Util.makeHexColor(Cn[0] | 0, Cn[1] | 0, Cn[2] | 0)) : Mt.style.borderWidth = 0;
              }
              Mt.style.left = `${100 * (rn[0] - Dt) / Ft}%`, Mt.style.top = `${100 * (rn[1] - Wt) / Ve}%`;
              const {
                rotation: tn
              } = ke;
              return ke.hasOwnCanvas || tn === 0 ? (Mt.style.width = `${100 * Xt / Ft}%`, Mt.style.height = `${100 * hn / Ve}%`) : this.setRotation(tn, Mt), Mt;
            }
            setRotation(xt, ke = this.container) {
              if (!this.data.rect)
                return;
              const {
                pageWidth: Xe,
                pageHeight: Et
              } = this.parent.viewport.rawDims, {
                width: Mt,
                height: Ft
              } = pe(this.data.rect);
              let Ve, Dt;
              xt % 180 === 0 ? (Ve = 100 * Mt / Xe, Dt = 100 * Ft / Et) : (Ve = 100 * Ft / Xe, Dt = 100 * Mt / Et), ke.style.width = `${Ve}%`, ke.style.height = `${Dt}%`, ke.setAttribute("data-main-rotation", (360 - xt) % 360);
            }
            get _commonActions() {
              const xt = (ke, Xe, Et) => {
                const Mt = Et.detail[ke], Ft = Mt[0], Ve = Mt.slice(1);
                Et.target.style[Xe] = ie.ColorConverters[`${Ft}_HTML`](Ve), this.annotationStorage.setValue(this.data.id, {
                  [Xe]: ie.ColorConverters[`${Ft}_rgb`](Ve)
                });
              };
              return (0, ne.shadow)(this, "_commonActions", {
                display: (ke) => {
                  const {
                    display: Xe
                  } = ke.detail, Et = Xe % 2 === 1;
                  this.container.style.visibility = Et ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noView: Et,
                    noPrint: Xe === 1 || Xe === 2
                  });
                },
                print: (ke) => {
                  this.annotationStorage.setValue(this.data.id, {
                    noPrint: !ke.detail.print
                  });
                },
                hidden: (ke) => {
                  const {
                    hidden: Xe
                  } = ke.detail;
                  this.container.style.visibility = Xe ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noPrint: Xe,
                    noView: Xe
                  });
                },
                focus: (ke) => {
                  setTimeout(() => ke.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (ke) => {
                  ke.target.title = ke.detail.userName;
                },
                readonly: (ke) => {
                  ke.target.disabled = ke.detail.readonly;
                },
                required: (ke) => {
                  this._setRequired(ke.target, ke.detail.required);
                },
                bgColor: (ke) => {
                  xt("bgColor", "backgroundColor", ke);
                },
                fillColor: (ke) => {
                  xt("fillColor", "backgroundColor", ke);
                },
                fgColor: (ke) => {
                  xt("fgColor", "color", ke);
                },
                textColor: (ke) => {
                  xt("textColor", "color", ke);
                },
                borderColor: (ke) => {
                  xt("borderColor", "borderColor", ke);
                },
                strokeColor: (ke) => {
                  xt("strokeColor", "borderColor", ke);
                },
                rotation: (ke) => {
                  const Xe = ke.detail.rotation;
                  this.setRotation(Xe), this.annotationStorage.setValue(this.data.id, {
                    rotation: Xe
                  });
                }
              });
            }
            _dispatchEventFromSandbox(xt, ke) {
              const Xe = this._commonActions;
              for (const Et of Object.keys(ke.detail)) {
                const Mt = xt[Et] || Xe[Et];
                Mt == null || Mt(ke);
              }
            }
            _setDefaultPropertiesFromJS(xt) {
              if (!this.enableScripting)
                return;
              const ke = this.annotationStorage.getRawValue(this.data.id);
              if (!ke)
                return;
              const Xe = this._commonActions;
              for (const [Et, Mt] of Object.entries(ke)) {
                const Ft = Xe[Et];
                if (Ft) {
                  const Ve = {
                    detail: {
                      [Et]: Mt
                    },
                    target: xt
                  };
                  Ft(Ve), delete ke[Et];
                }
              }
            }
            _createQuadrilaterals() {
              if (!this.container)
                return;
              const {
                quadPoints: xt
              } = this.data;
              if (!xt)
                return;
              const [ke, Xe, Et, Mt] = this.data.rect;
              if (xt.length === 1) {
                const [, {
                  x: Sn,
                  y: Cn
                }, {
                  x: An,
                  y: Nn
                }] = xt[0];
                if (Et === Sn && Mt === Cn && ke === An && Xe === Nn)
                  return;
              }
              const {
                style: Ft
              } = this.container;
              let Ve;
              if (Oe(this, Ae)) {
                const {
                  borderColor: Sn,
                  borderWidth: Cn
                } = Ft;
                Ft.borderWidth = 0, Ve = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${Sn}" stroke-width="${Cn}">`], this.container.classList.add("hasBorder");
              }
              const Dt = Et - ke, Wt = Mt - Xe, {
                svgFactory: Xt
              } = this, hn = Xt.createElement("svg");
              hn.classList.add("quadrilateralsContainer"), hn.setAttribute("width", 0), hn.setAttribute("height", 0);
              const rn = Xt.createElement("defs");
              hn.append(rn);
              const tn = Xt.createElement("clipPath"), fn = `clippath_${this.data.id}`;
              tn.setAttribute("id", fn), tn.setAttribute("clipPathUnits", "objectBoundingBox"), rn.append(tn);
              for (const [, {
                x: Sn,
                y: Cn
              }, {
                x: An,
                y: Nn
              }] of xt) {
                const Ln = Xt.createElement("rect"), Fn = (An - ke) / Dt, jn = (Mt - Cn) / Wt, $n = (Sn - An) / Dt, rr = (Cn - Nn) / Wt;
                Ln.setAttribute("x", Fn), Ln.setAttribute("y", jn), Ln.setAttribute("width", $n), Ln.setAttribute("height", rr), tn.append(Ln), Ve == null || Ve.push(`<rect vector-effect="non-scaling-stroke" x="${Fn}" y="${jn}" width="${$n}" height="${rr}"/>`);
              }
              Oe(this, Ae) && (Ve.push("</g></svg>')"), Ft.backgroundImage = Ve.join("")), this.container.append(hn), this.container.style.clipPath = `url(#${fn})`;
            }
            _createPopup() {
              const {
                container: xt,
                data: ke
              } = this;
              xt.setAttribute("aria-haspopup", "dialog");
              const Xe = new De({
                data: {
                  color: ke.color,
                  titleObj: ke.titleObj,
                  modificationDate: ke.modificationDate,
                  contentsObj: ke.contentsObj,
                  richText: ke.richText,
                  parentRect: ke.rect,
                  borderStyle: 0,
                  id: `popup_${ke.id}`,
                  rotation: ke.rotation
                },
                parent: this.parent,
                elements: [this]
              });
              this.parent.div.append(Xe.render());
            }
            render() {
              (0, ne.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(xt, ke = null) {
              const Xe = [];
              if (this._fieldObjects) {
                const Et = this._fieldObjects[xt];
                if (Et)
                  for (const {
                    page: Mt,
                    id: Ft,
                    exportValues: Ve
                  } of Et) {
                    if (Mt === -1 || Ft === ke)
                      continue;
                    const Dt = typeof Ve == "string" ? Ve : null, Wt = document.querySelector(`[data-element-id="${Ft}"]`);
                    if (Wt && !fe.has(Wt)) {
                      (0, ne.warn)(`_getElementsByName - element not allowed: ${Ft}`);
                      continue;
                    }
                    Xe.push({
                      id: Ft,
                      exportValue: Dt,
                      domElement: Wt
                    });
                  }
                return Xe;
              }
              for (const Et of document.getElementsByName(xt)) {
                const {
                  exportValue: Mt
                } = Et, Ft = Et.getAttribute("data-element-id");
                Ft !== ke && fe.has(Et) && Xe.push({
                  id: Ft,
                  exportValue: Mt,
                  domElement: Et
                });
              }
              return Xe;
            }
            show() {
              var xt;
              this.container && (this.container.hidden = !1), (xt = this.popup) == null || xt.maybeShow();
            }
            hide() {
              var xt;
              this.container && (this.container.hidden = !0), (xt = this.popup) == null || xt.forceHide();
            }
            getElementsToTriggerPopup() {
              return this.container;
            }
            addHighlightArea() {
              const xt = this.getElementsToTriggerPopup();
              if (Array.isArray(xt))
                for (const ke of xt)
                  ke.classList.add("highlightArea");
              else
                xt.classList.add("highlightArea");
            }
            _editOnDoubleClick() {
              const {
                annotationEditorType: xt,
                data: {
                  id: ke
                }
              } = this;
              this.container.addEventListener("dblclick", () => {
                var Xe;
                (Xe = this.linkService.eventBus) == null || Xe.dispatch("switchannotationeditormode", {
                  source: this,
                  mode: xt,
                  editId: ke
                });
              });
            }
          };
          Ae = new WeakMap();
          let me = Re;
          class ve extends me {
            constructor(ke, Xe = null) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !!(Xe != null && Xe.ignoreBorder),
                createQuadrilaterals: !0
              });
              Rt(this, je);
              Rt(this, $e);
              this.isTooltipOnly = ke.data.isTooltipOnly;
            }
            render() {
              const {
                data: ke,
                linkService: Xe
              } = this, Et = document.createElement("a");
              Et.setAttribute("data-element-id", ke.id);
              let Mt = !1;
              return ke.url ? (Xe.addLinkAttributes(Et, ke.url, ke.newWindow), Mt = !0) : ke.action ? (this._bindNamedAction(Et, ke.action), Mt = !0) : ke.attachment ? (this._bindAttachment(Et, ke.attachment), Mt = !0) : ke.setOCGState ? (Nt(this, $e, Es).call(this, Et, ke.setOCGState), Mt = !0) : ke.dest ? (this._bindLink(Et, ke.dest), Mt = !0) : (ke.actions && (ke.actions.Action || ke.actions["Mouse Up"] || ke.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(Et, ke), Mt = !0), ke.resetForm ? (this._bindResetFormAction(Et, ke.resetForm), Mt = !0) : this.isTooltipOnly && !Mt && (this._bindLink(Et, ""), Mt = !0)), this.container.classList.add("linkAnnotation"), Mt && this.container.append(Et), this.container;
            }
            _bindLink(ke, Xe) {
              ke.href = this.linkService.getDestinationHash(Xe), ke.onclick = () => (Xe && this.linkService.goToDestination(Xe), !1), (Xe || Xe === "") && Nt(this, je, Hn).call(this);
            }
            _bindNamedAction(ke, Xe) {
              ke.href = this.linkService.getAnchorUrl(""), ke.onclick = () => (this.linkService.executeNamedAction(Xe), !1), Nt(this, je, Hn).call(this);
            }
            _bindAttachment(ke, Xe) {
              ke.href = this.linkService.getAnchorUrl(""), ke.onclick = () => {
                var Et;
                return (Et = this.downloadManager) == null || Et.openOrDownloadData(this.container, Xe.content, Xe.filename), !1;
              }, Nt(this, je, Hn).call(this);
            }
            _bindJSAction(ke, Xe) {
              ke.href = this.linkService.getAnchorUrl("");
              const Et = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const Mt of Object.keys(Xe.actions)) {
                const Ft = Et.get(Mt);
                Ft && (ke[Ft] = () => {
                  var Ve;
                  return (Ve = this.linkService.eventBus) == null || Ve.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: Xe.id,
                      name: Mt
                    }
                  }), !1;
                });
              }
              ke.onclick || (ke.onclick = () => !1), Nt(this, je, Hn).call(this);
            }
            _bindResetFormAction(ke, Xe) {
              const Et = ke.onclick;
              if (Et || (ke.href = this.linkService.getAnchorUrl("")), Nt(this, je, Hn).call(this), !this._fieldObjects) {
                (0, ne.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), Et || (ke.onclick = () => !1);
                return;
              }
              ke.onclick = () => {
                var hn;
                Et == null || Et();
                const {
                  fields: Mt,
                  refs: Ft,
                  include: Ve
                } = Xe, Dt = [];
                if (Mt.length !== 0 || Ft.length !== 0) {
                  const rn = new Set(Ft);
                  for (const tn of Mt) {
                    const fn = this._fieldObjects[tn] || [];
                    for (const {
                      id: Sn
                    } of fn)
                      rn.add(Sn);
                  }
                  for (const tn of Object.values(this._fieldObjects))
                    for (const fn of tn)
                      rn.has(fn.id) === Ve && Dt.push(fn);
                } else
                  for (const rn of Object.values(this._fieldObjects))
                    Dt.push(...rn);
                const Wt = this.annotationStorage, Xt = [];
                for (const rn of Dt) {
                  const {
                    id: tn
                  } = rn;
                  switch (Xt.push(tn), rn.type) {
                    case "text": {
                      const Sn = rn.defaultValue || "";
                      Wt.setValue(tn, {
                        value: Sn
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const Sn = rn.defaultValue === rn.exportValues;
                      Wt.setValue(tn, {
                        value: Sn
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const Sn = rn.defaultValue || "";
                      Wt.setValue(tn, {
                        value: Sn
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const fn = document.querySelector(`[data-element-id="${tn}"]`);
                  if (fn) {
                    if (!fe.has(fn)) {
                      (0, ne.warn)(`_bindResetFormAction - element not allowed: ${tn}`);
                      continue;
                    }
                  } else
                    continue;
                  fn.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((hn = this.linkService.eventBus) == null || hn.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: Xt,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          je = new WeakSet(), Hn = function() {
            this.container.setAttribute("data-internal-link", "");
          }, $e = new WeakSet(), Es = function(ke, Xe) {
            ke.href = this.linkService.getAnchorUrl(""), ke.onclick = () => (this.linkService.executeSetOCGState(Xe), !1), Nt(this, je, Hn).call(this);
          };
          class ge extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0
              });
            }
            render() {
              this.container.classList.add("textAnnotation");
              const xt = document.createElement("img");
              return xt.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", xt.alt = "[{{type}} Annotation]", xt.dataset.l10nId = "text_annotation_type", xt.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(xt), this.container;
            }
          }
          class xe extends me {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            showElementAndHideCanvas(xt) {
              var ke;
              this.data.hasOwnCanvas && (((ke = xt.previousSibling) == null ? void 0 : ke.nodeName) === "CANVAS" && (xt.previousSibling.hidden = !0), xt.hidden = !1);
            }
            _getKeyModifier(xt) {
              const {
                isWin: ke,
                isMac: Xe
              } = ne.FeatureTest.platform;
              return ke && xt.ctrlKey || Xe && xt.metaKey;
            }
            _setEventListener(xt, ke, Xe, Et, Mt) {
              Xe.includes("mouse") ? xt.addEventListener(Xe, (Ft) => {
                var Ve;
                (Ve = this.linkService.eventBus) == null || Ve.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Et,
                    value: Mt(Ft),
                    shift: Ft.shiftKey,
                    modifier: this._getKeyModifier(Ft)
                  }
                });
              }) : xt.addEventListener(Xe, (Ft) => {
                var Ve;
                if (Xe === "blur") {
                  if (!ke.focused || !Ft.relatedTarget)
                    return;
                  ke.focused = !1;
                } else if (Xe === "focus") {
                  if (ke.focused)
                    return;
                  ke.focused = !0;
                }
                Mt && ((Ve = this.linkService.eventBus) == null || Ve.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Et,
                    value: Mt(Ft)
                  }
                }));
              });
            }
            _setEventListeners(xt, ke, Xe, Et) {
              var Mt, Ft, Ve;
              for (const [Dt, Wt] of Xe)
                (Wt === "Action" || (Mt = this.data.actions) != null && Mt[Wt]) && ((Wt === "Focus" || Wt === "Blur") && (ke || (ke = {
                  focused: !1
                })), this._setEventListener(xt, ke, Dt, Wt, Et), Wt === "Focus" && !((Ft = this.data.actions) != null && Ft.Blur) ? this._setEventListener(xt, ke, "blur", "Blur", null) : Wt === "Blur" && !((Ve = this.data.actions) != null && Ve.Focus) && this._setEventListener(xt, ke, "focus", "Focus", null));
            }
            _setBackgroundColor(xt) {
              const ke = this.data.backgroundColor || null;
              xt.style.backgroundColor = ke === null ? "transparent" : ne.Util.makeHexColor(ke[0], ke[1], ke[2]);
            }
            _setTextStyle(xt) {
              const ke = ["left", "center", "right"], {
                fontColor: Xe
              } = this.data.defaultAppearanceData, Et = this.data.defaultAppearanceData.fontSize || de, Mt = xt.style;
              let Ft;
              const Ve = 2, Dt = (Wt) => Math.round(10 * Wt) / 10;
              if (this.data.multiLine) {
                const Wt = Math.abs(this.data.rect[3] - this.data.rect[1] - Ve), Xt = Math.round(Wt / (ne.LINE_FACTOR * Et)) || 1, hn = Wt / Xt;
                Ft = Math.min(Et, Dt(hn / ne.LINE_FACTOR));
              } else {
                const Wt = Math.abs(this.data.rect[3] - this.data.rect[1] - Ve);
                Ft = Math.min(Et, Dt(Wt / ne.LINE_FACTOR));
              }
              Mt.fontSize = `calc(${Ft}px * var(--scale-factor))`, Mt.color = ne.Util.makeHexColor(Xe[0], Xe[1], Xe[2]), this.data.textAlignment !== null && (Mt.textAlign = ke[this.data.textAlignment]);
            }
            _setRequired(xt, ke) {
              ke ? xt.setAttribute("required", !0) : xt.removeAttribute("required"), xt.setAttribute("aria-required", ke);
            }
          }
          class Ee extends xe {
            constructor(xt) {
              const ke = xt.renderForms || !xt.data.hasAppearance && !!xt.data.fieldValue;
              super(xt, {
                isRenderable: ke
              });
            }
            setPropertyOnSiblings(xt, ke, Xe, Et) {
              const Mt = this.annotationStorage;
              for (const Ft of this._getElementsByName(xt.name, xt.id))
                Ft.domElement && (Ft.domElement[ke] = Xe), Mt.setValue(Ft.id, {
                  [Et]: Xe
                });
            }
            render() {
              var Et, Mt;
              const xt = this.annotationStorage, ke = this.data.id;
              this.container.classList.add("textWidgetAnnotation");
              let Xe = null;
              if (this.renderForms) {
                const Ft = xt.getValue(ke, {
                  value: this.data.fieldValue
                });
                let Ve = Ft.value || "";
                const Dt = xt.getValue(ke, {
                  charLimit: this.data.maxLen
                }).charLimit;
                Dt && Ve.length > Dt && (Ve = Ve.slice(0, Dt));
                let Wt = Ft.formattedValue || ((Et = this.data.textContent) == null ? void 0 : Et.join(`
`)) || null;
                Wt && this.data.comb && (Wt = Wt.replaceAll(/\s+/g, ""));
                const Xt = {
                  userValue: Ve,
                  formattedValue: Wt,
                  lastCommittedValue: null,
                  commitKey: 1,
                  focused: !1
                };
                this.data.multiLine ? (Xe = document.createElement("textarea"), Xe.textContent = Wt ?? Ve, this.data.doNotScroll && (Xe.style.overflowY = "hidden")) : (Xe = document.createElement("input"), Xe.type = "text", Xe.setAttribute("value", Wt ?? Ve), this.data.doNotScroll && (Xe.style.overflowX = "hidden")), this.data.hasOwnCanvas && (Xe.hidden = !0), fe.add(Xe), Xe.setAttribute("data-element-id", ke), Xe.disabled = this.data.readOnly, Xe.name = this.data.fieldName, Xe.tabIndex = ue, this._setRequired(Xe, this.data.required), Dt && (Xe.maxLength = Dt), Xe.addEventListener("input", (rn) => {
                  xt.setValue(ke, {
                    value: rn.target.value
                  }), this.setPropertyOnSiblings(Xe, "value", rn.target.value, "value"), Xt.formattedValue = null;
                }), Xe.addEventListener("resetform", (rn) => {
                  const tn = this.data.defaultFieldValue ?? "";
                  Xe.value = Xt.userValue = tn, Xt.formattedValue = null;
                });
                let hn = (rn) => {
                  const {
                    formattedValue: tn
                  } = Xt;
                  tn != null && (rn.target.value = tn), rn.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  Xe.addEventListener("focus", (tn) => {
                    if (Xt.focused)
                      return;
                    const {
                      target: fn
                    } = tn;
                    Xt.userValue && (fn.value = Xt.userValue), Xt.lastCommittedValue = fn.value, Xt.commitKey = 1, Xt.focused = !0;
                  }), Xe.addEventListener("updatefromsandbox", (tn) => {
                    this.showElementAndHideCanvas(tn.target);
                    const fn = {
                      value(Sn) {
                        Xt.userValue = Sn.detail.value ?? "", xt.setValue(ke, {
                          value: Xt.userValue.toString()
                        }), Sn.target.value = Xt.userValue;
                      },
                      formattedValue(Sn) {
                        const {
                          formattedValue: Cn
                        } = Sn.detail;
                        Xt.formattedValue = Cn, Cn != null && Sn.target !== document.activeElement && (Sn.target.value = Cn), xt.setValue(ke, {
                          formattedValue: Cn
                        });
                      },
                      selRange(Sn) {
                        Sn.target.setSelectionRange(...Sn.detail.selRange);
                      },
                      charLimit: (Sn) => {
                        var Ln;
                        const {
                          charLimit: Cn
                        } = Sn.detail, {
                          target: An
                        } = Sn;
                        if (Cn === 0) {
                          An.removeAttribute("maxLength");
                          return;
                        }
                        An.setAttribute("maxLength", Cn);
                        let Nn = Xt.userValue;
                        !Nn || Nn.length <= Cn || (Nn = Nn.slice(0, Cn), An.value = Xt.userValue = Nn, xt.setValue(ke, {
                          value: Nn
                        }), (Ln = this.linkService.eventBus) == null || Ln.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: ke,
                            name: "Keystroke",
                            value: Nn,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: An.selectionStart,
                            selEnd: An.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(fn, tn);
                  }), Xe.addEventListener("keydown", (tn) => {
                    var Cn;
                    Xt.commitKey = 1;
                    let fn = -1;
                    if (tn.key === "Escape" ? fn = 0 : tn.key === "Enter" && !this.data.multiLine ? fn = 2 : tn.key === "Tab" && (Xt.commitKey = 3), fn === -1)
                      return;
                    const {
                      value: Sn
                    } = tn.target;
                    Xt.lastCommittedValue !== Sn && (Xt.lastCommittedValue = Sn, Xt.userValue = Sn, (Cn = this.linkService.eventBus) == null || Cn.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ke,
                        name: "Keystroke",
                        value: Sn,
                        willCommit: !0,
                        commitKey: fn,
                        selStart: tn.target.selectionStart,
                        selEnd: tn.target.selectionEnd
                      }
                    }));
                  });
                  const rn = hn;
                  hn = null, Xe.addEventListener("blur", (tn) => {
                    var Sn;
                    if (!Xt.focused || !tn.relatedTarget)
                      return;
                    Xt.focused = !1;
                    const {
                      value: fn
                    } = tn.target;
                    Xt.userValue = fn, Xt.lastCommittedValue !== fn && ((Sn = this.linkService.eventBus) == null || Sn.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ke,
                        name: "Keystroke",
                        value: fn,
                        willCommit: !0,
                        commitKey: Xt.commitKey,
                        selStart: tn.target.selectionStart,
                        selEnd: tn.target.selectionEnd
                      }
                    })), rn(tn);
                  }), (Mt = this.data.actions) != null && Mt.Keystroke && Xe.addEventListener("beforeinput", (tn) => {
                    var jn;
                    Xt.lastCommittedValue = null;
                    const {
                      data: fn,
                      target: Sn
                    } = tn, {
                      value: Cn,
                      selectionStart: An,
                      selectionEnd: Nn
                    } = Sn;
                    let Ln = An, Fn = Nn;
                    switch (tn.inputType) {
                      case "deleteWordBackward": {
                        const $n = Cn.substring(0, An).match(/\w*[^\w]*$/);
                        $n && (Ln -= $n[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const $n = Cn.substring(An).match(/^[^\w]*\w*/);
                        $n && (Fn += $n[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        An === Nn && (Ln -= 1);
                        break;
                      case "deleteContentForward":
                        An === Nn && (Fn += 1);
                        break;
                    }
                    tn.preventDefault(), (jn = this.linkService.eventBus) == null || jn.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ke,
                        name: "Keystroke",
                        value: Cn,
                        change: fn || "",
                        willCommit: !1,
                        selStart: Ln,
                        selEnd: Fn
                      }
                    });
                  }), this._setEventListeners(Xe, Xt, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (tn) => tn.target.value);
                }
                if (hn && Xe.addEventListener("blur", hn), this.data.comb) {
                  const tn = (this.data.rect[2] - this.data.rect[0]) / Dt;
                  Xe.classList.add("comb"), Xe.style.letterSpacing = `calc(${tn}px * var(--scale-factor) - 1ch)`;
                }
              } else
                Xe = document.createElement("div"), Xe.textContent = this.data.fieldValue, Xe.style.verticalAlign = "middle", Xe.style.display = "table-cell";
              return this._setTextStyle(Xe), this._setBackgroundColor(Xe), this._setDefaultPropertiesFromJS(Xe), this.container.append(Xe), this.container;
            }
          }
          class Te extends xe {
            constructor(xt) {
              super(xt, {
                isRenderable: !!xt.data.hasOwnCanvas
              });
            }
          }
          class Se extends xe {
            constructor(xt) {
              super(xt, {
                isRenderable: xt.renderForms
              });
            }
            render() {
              const xt = this.annotationStorage, ke = this.data, Xe = ke.id;
              let Et = xt.getValue(Xe, {
                value: ke.exportValue === ke.fieldValue
              }).value;
              typeof Et == "string" && (Et = Et !== "Off", xt.setValue(Xe, {
                value: Et
              })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
              const Mt = document.createElement("input");
              return fe.add(Mt), Mt.setAttribute("data-element-id", Xe), Mt.disabled = ke.readOnly, this._setRequired(Mt, this.data.required), Mt.type = "checkbox", Mt.name = ke.fieldName, Et && Mt.setAttribute("checked", !0), Mt.setAttribute("exportValue", ke.exportValue), Mt.tabIndex = ue, Mt.addEventListener("change", (Ft) => {
                const {
                  name: Ve,
                  checked: Dt
                } = Ft.target;
                for (const Wt of this._getElementsByName(Ve, Xe)) {
                  const Xt = Dt && Wt.exportValue === ke.exportValue;
                  Wt.domElement && (Wt.domElement.checked = Xt), xt.setValue(Wt.id, {
                    value: Xt
                  });
                }
                xt.setValue(Xe, {
                  value: Dt
                });
              }), Mt.addEventListener("resetform", (Ft) => {
                const Ve = ke.defaultFieldValue || "Off";
                Ft.target.checked = Ve === ke.exportValue;
              }), this.enableScripting && this.hasJSActions && (Mt.addEventListener("updatefromsandbox", (Ft) => {
                const Ve = {
                  value(Dt) {
                    Dt.target.checked = Dt.detail.value !== "Off", xt.setValue(Xe, {
                      value: Dt.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(Ve, Ft);
              }), this._setEventListeners(Mt, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ft) => Ft.target.checked)), this._setBackgroundColor(Mt), this._setDefaultPropertiesFromJS(Mt), this.container.append(Mt), this.container;
            }
          }
          class he extends xe {
            constructor(xt) {
              super(xt, {
                isRenderable: xt.renderForms
              });
            }
            render() {
              this.container.classList.add("buttonWidgetAnnotation", "radioButton");
              const xt = this.annotationStorage, ke = this.data, Xe = ke.id;
              let Et = xt.getValue(Xe, {
                value: ke.fieldValue === ke.buttonValue
              }).value;
              typeof Et == "string" && (Et = Et !== ke.buttonValue, xt.setValue(Xe, {
                value: Et
              }));
              const Mt = document.createElement("input");
              if (fe.add(Mt), Mt.setAttribute("data-element-id", Xe), Mt.disabled = ke.readOnly, this._setRequired(Mt, this.data.required), Mt.type = "radio", Mt.name = ke.fieldName, Et && Mt.setAttribute("checked", !0), Mt.tabIndex = ue, Mt.addEventListener("change", (Ft) => {
                const {
                  name: Ve,
                  checked: Dt
                } = Ft.target;
                for (const Wt of this._getElementsByName(Ve, Xe))
                  xt.setValue(Wt.id, {
                    value: !1
                  });
                xt.setValue(Xe, {
                  value: Dt
                });
              }), Mt.addEventListener("resetform", (Ft) => {
                const Ve = ke.defaultFieldValue;
                Ft.target.checked = Ve != null && Ve === ke.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const Ft = ke.buttonValue;
                Mt.addEventListener("updatefromsandbox", (Ve) => {
                  const Dt = {
                    value: (Wt) => {
                      const Xt = Ft === Wt.detail.value;
                      for (const hn of this._getElementsByName(Wt.target.name)) {
                        const rn = Xt && hn.id === Xe;
                        hn.domElement && (hn.domElement.checked = rn), xt.setValue(hn.id, {
                          value: rn
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Dt, Ve);
                }), this._setEventListeners(Mt, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ve) => Ve.target.checked);
              }
              return this._setBackgroundColor(Mt), this._setDefaultPropertiesFromJS(Mt), this.container.append(Mt), this.container;
            }
          }
          class Pe extends ve {
            constructor(xt) {
              super(xt, {
                ignoreBorder: xt.data.hasAppearance
              });
            }
            render() {
              const xt = super.render();
              xt.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (xt.title = this.data.alternativeText);
              const ke = xt.lastChild;
              return this.enableScripting && this.hasJSActions && ke && (this._setDefaultPropertiesFromJS(ke), ke.addEventListener("updatefromsandbox", (Xe) => {
                this._dispatchEventFromSandbox({}, Xe);
              })), xt;
            }
          }
          class Ie extends xe {
            constructor(xt) {
              super(xt, {
                isRenderable: xt.renderForms
              });
            }
            render() {
              this.container.classList.add("choiceWidgetAnnotation");
              const xt = this.annotationStorage, ke = this.data.id, Xe = xt.getValue(ke, {
                value: this.data.fieldValue
              }), Et = document.createElement("select");
              fe.add(Et), Et.setAttribute("data-element-id", ke), Et.disabled = this.data.readOnly, this._setRequired(Et, this.data.required), Et.name = this.data.fieldName, Et.tabIndex = ue;
              let Mt = this.data.combo && this.data.options.length > 0;
              this.data.combo || (Et.size = this.data.options.length, this.data.multiSelect && (Et.multiple = !0)), Et.addEventListener("resetform", (Xt) => {
                const hn = this.data.defaultFieldValue;
                for (const rn of Et.options)
                  rn.selected = rn.value === hn;
              });
              for (const Xt of this.data.options) {
                const hn = document.createElement("option");
                hn.textContent = Xt.displayValue, hn.value = Xt.exportValue, Xe.value.includes(Xt.exportValue) && (hn.setAttribute("selected", !0), Mt = !1), Et.append(hn);
              }
              let Ft = null;
              if (Mt) {
                const Xt = document.createElement("option");
                Xt.value = " ", Xt.setAttribute("hidden", !0), Xt.setAttribute("selected", !0), Et.prepend(Xt), Ft = () => {
                  Xt.remove(), Et.removeEventListener("input", Ft), Ft = null;
                }, Et.addEventListener("input", Ft);
              }
              const Ve = (Xt) => {
                const hn = Xt ? "value" : "textContent", {
                  options: rn,
                  multiple: tn
                } = Et;
                return tn ? Array.prototype.filter.call(rn, (fn) => fn.selected).map((fn) => fn[hn]) : rn.selectedIndex === -1 ? null : rn[rn.selectedIndex][hn];
              };
              let Dt = Ve(!1);
              const Wt = (Xt) => {
                const hn = Xt.target.options;
                return Array.prototype.map.call(hn, (rn) => ({
                  displayValue: rn.textContent,
                  exportValue: rn.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (Et.addEventListener("updatefromsandbox", (Xt) => {
                const hn = {
                  value(rn) {
                    Ft == null || Ft();
                    const tn = rn.detail.value, fn = new Set(Array.isArray(tn) ? tn : [tn]);
                    for (const Sn of Et.options)
                      Sn.selected = fn.has(Sn.value);
                    xt.setValue(ke, {
                      value: Ve(!0)
                    }), Dt = Ve(!1);
                  },
                  multipleSelection(rn) {
                    Et.multiple = !0;
                  },
                  remove(rn) {
                    const tn = Et.options, fn = rn.detail.remove;
                    tn[fn].selected = !1, Et.remove(fn), tn.length > 0 && Array.prototype.findIndex.call(tn, (Cn) => Cn.selected) === -1 && (tn[0].selected = !0), xt.setValue(ke, {
                      value: Ve(!0),
                      items: Wt(rn)
                    }), Dt = Ve(!1);
                  },
                  clear(rn) {
                    for (; Et.length !== 0; )
                      Et.remove(0);
                    xt.setValue(ke, {
                      value: null,
                      items: []
                    }), Dt = Ve(!1);
                  },
                  insert(rn) {
                    const {
                      index: tn,
                      displayValue: fn,
                      exportValue: Sn
                    } = rn.detail.insert, Cn = Et.children[tn], An = document.createElement("option");
                    An.textContent = fn, An.value = Sn, Cn ? Cn.before(An) : Et.append(An), xt.setValue(ke, {
                      value: Ve(!0),
                      items: Wt(rn)
                    }), Dt = Ve(!1);
                  },
                  items(rn) {
                    const {
                      items: tn
                    } = rn.detail;
                    for (; Et.length !== 0; )
                      Et.remove(0);
                    for (const fn of tn) {
                      const {
                        displayValue: Sn,
                        exportValue: Cn
                      } = fn, An = document.createElement("option");
                      An.textContent = Sn, An.value = Cn, Et.append(An);
                    }
                    Et.options.length > 0 && (Et.options[0].selected = !0), xt.setValue(ke, {
                      value: Ve(!0),
                      items: Wt(rn)
                    }), Dt = Ve(!1);
                  },
                  indices(rn) {
                    const tn = new Set(rn.detail.indices);
                    for (const fn of rn.target.options)
                      fn.selected = tn.has(fn.index);
                    xt.setValue(ke, {
                      value: Ve(!0)
                    }), Dt = Ve(!1);
                  },
                  editable(rn) {
                    rn.target.disabled = !rn.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(hn, Xt);
              }), Et.addEventListener("input", (Xt) => {
                var rn;
                const hn = Ve(!0);
                xt.setValue(ke, {
                  value: hn
                }), Xt.preventDefault(), (rn = this.linkService.eventBus) == null || rn.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: ke,
                    name: "Keystroke",
                    value: Dt,
                    changeEx: hn,
                    willCommit: !1,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(Et, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (Xt) => Xt.target.value)) : Et.addEventListener("input", function(Xt) {
                xt.setValue(ke, {
                  value: Ve(!0)
                });
              }), this.data.combo && this._setTextStyle(Et), this._setBackgroundColor(Et), this._setDefaultPropertiesFromJS(Et), this.container.append(Et), this.container;
            }
          }
          class De extends me {
            constructor(xt) {
              const {
                data: ke,
                elements: Xe
              } = xt;
              super(xt, {
                isRenderable: me._hasPopupData(ke)
              }), this.elements = Xe;
            }
            render() {
              this.container.classList.add("popupAnnotation");
              const xt = new Ce({
                container: this.container,
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText,
                rect: this.data.rect,
                parentRect: this.data.parentRect || null,
                parent: this.parent,
                elements: this.elements,
                open: this.data.open
              }), ke = [];
              for (const Xe of this.elements)
                Xe.popup = xt, ke.push(Xe.data.id), Xe.addHighlightArea();
              return this.container.setAttribute("aria-controls", ke.map((Xe) => `${ne.AnnotationPrefix}${Xe}`).join(",")), this.container;
            }
          }
          class Ce {
            constructor({
              container: xt,
              color: ke,
              elements: Xe,
              titleObj: Et,
              modificationDate: Mt,
              contentsObj: Ft,
              richText: Ve,
              parent: Dt,
              rect: Wt,
              parentRect: Xt,
              open: hn
            }) {
              Rt(this, _n);
              Rt(this, En);
              Rt(this, Tn);
              Rt(this, Rn);
              Rt(this, Ye, null);
              Rt(this, Ke, Nt(this, _n, Ss).bind(this));
              Rt(this, Tt, Nt(this, Rn, Wr).bind(this));
              Rt(this, pt, Nt(this, Tn, Vr).bind(this));
              Rt(this, Bt, Nt(this, En, pr).bind(this));
              Rt(this, Vt, null);
              Rt(this, qt, null);
              Rt(this, nn, null);
              Rt(this, mn, null);
              Rt(this, en, null);
              Rt(this, pn, null);
              Rt(this, Yt, !1);
              Rt(this, Ut, null);
              Rt(this, jt, null);
              Rt(this, Gt, null);
              Rt(this, ln, null);
              Rt(this, sn, !1);
              var tn;
              zt(this, qt, xt), zt(this, ln, Et), zt(this, nn, Ft), zt(this, Gt, Ve), zt(this, en, Dt), zt(this, Vt, ke), zt(this, jt, Wt), zt(this, pn, Xt), zt(this, mn, Xe);
              const rn = re.PDFDateString.toDateObject(Mt);
              rn && zt(this, Ye, Dt.l10n.get("annotation_date_string", {
                date: rn.toLocaleDateString(),
                time: rn.toLocaleTimeString()
              })), this.trigger = Xe.flatMap((fn) => fn.getElementsToTriggerPopup());
              for (const fn of this.trigger)
                fn.addEventListener("click", Oe(this, Bt)), fn.addEventListener("mouseenter", Oe(this, pt)), fn.addEventListener("mouseleave", Oe(this, Tt)), fn.classList.add("popupTriggerArea");
              for (const fn of Xe)
                (tn = fn.container) == null || tn.addEventListener("keydown", Oe(this, Ke));
              Oe(this, qt).hidden = !0, hn && Nt(this, En, pr).call(this);
            }
            render() {
              if (Oe(this, Ut))
                return;
              const {
                page: {
                  view: xt
                },
                viewport: {
                  rawDims: {
                    pageWidth: ke,
                    pageHeight: Xe,
                    pageX: Et,
                    pageY: Mt
                  }
                }
              } = Oe(this, en), Ft = zt(this, Ut, document.createElement("div"));
              if (Ft.className = "popup", Oe(this, Vt)) {
                const Ln = Ft.style.outlineColor = ne.Util.makeHexColor(...Oe(this, Vt));
                CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Ft.style.backgroundColor = `color-mix(in srgb, ${Ln} 30%, white)` : Ft.style.backgroundColor = ne.Util.makeHexColor(...Oe(this, Vt).map((jn) => Math.floor(0.7 * (255 - jn) + jn)));
              }
              const Ve = document.createElement("span");
              Ve.className = "header";
              const Dt = document.createElement("h1");
              if (Ve.append(Dt), {
                dir: Dt.dir,
                str: Dt.textContent
              } = Oe(this, ln), Ft.append(Ve), Oe(this, Ye)) {
                const Ln = document.createElement("span");
                Ln.classList.add("popupDate"), Oe(this, Ye).then((Fn) => {
                  Ln.textContent = Fn;
                }), Ve.append(Ln);
              }
              const Wt = Oe(this, nn), Xt = Oe(this, Gt);
              if (Xt != null && Xt.str && (!(Wt != null && Wt.str) || Wt.str === Xt.str))
                le.XfaLayer.render({
                  xfaHtml: Xt.html,
                  intent: "richText",
                  div: Ft
                }), Ft.lastChild.classList.add("richText", "popupContent");
              else {
                const Ln = this._formatContents(Wt);
                Ft.append(Ln);
              }
              let hn = !!Oe(this, pn), rn = hn ? Oe(this, pn) : Oe(this, jt);
              for (const Ln of Oe(this, mn))
                if (!rn || ne.Util.intersect(Ln.data.rect, rn) !== null) {
                  rn = Ln.data.rect, hn = !0;
                  break;
                }
              const tn = ne.Util.normalizeRect([rn[0], xt[3] - rn[1] + xt[1], rn[2], xt[3] - rn[3] + xt[1]]), Sn = hn ? rn[2] - rn[0] + 5 : 0, Cn = tn[0] + Sn, An = tn[1], {
                style: Nn
              } = Oe(this, qt);
              Nn.left = `${100 * (Cn - Et) / ke}%`, Nn.top = `${100 * (An - Mt) / Xe}%`, Oe(this, qt).append(Ft);
            }
            _formatContents({
              str: xt,
              dir: ke
            }) {
              const Xe = document.createElement("p");
              Xe.classList.add("popupContent"), Xe.dir = ke;
              const Et = xt.split(/(?:\r\n?|\n)/);
              for (let Mt = 0, Ft = Et.length; Mt < Ft; ++Mt) {
                const Ve = Et[Mt];
                Xe.append(document.createTextNode(Ve)), Mt < Ft - 1 && Xe.append(document.createElement("br"));
              }
              return Xe;
            }
            forceHide() {
              zt(this, sn, this.isVisible), Oe(this, sn) && (Oe(this, qt).hidden = !0);
            }
            maybeShow() {
              Oe(this, sn) && (zt(this, sn, !1), Oe(this, qt).hidden = !1);
            }
            get isVisible() {
              return Oe(this, qt).hidden === !1;
            }
          }
          Ye = new WeakMap(), Ke = new WeakMap(), Tt = new WeakMap(), pt = new WeakMap(), Bt = new WeakMap(), Vt = new WeakMap(), qt = new WeakMap(), nn = new WeakMap(), mn = new WeakMap(), en = new WeakMap(), pn = new WeakMap(), Yt = new WeakMap(), Ut = new WeakMap(), jt = new WeakMap(), Gt = new WeakMap(), ln = new WeakMap(), sn = new WeakMap(), _n = new WeakSet(), Ss = function(xt) {
            xt.altKey || xt.shiftKey || xt.ctrlKey || xt.metaKey || (xt.key === "Enter" || xt.key === "Escape" && Oe(this, Yt)) && Nt(this, En, pr).call(this);
          }, En = new WeakSet(), pr = function() {
            zt(this, Yt, !Oe(this, Yt)), Oe(this, Yt) ? (Nt(this, Tn, Vr).call(this), Oe(this, qt).addEventListener("click", Oe(this, Bt)), Oe(this, qt).addEventListener("keydown", Oe(this, Ke))) : (Nt(this, Rn, Wr).call(this), Oe(this, qt).removeEventListener("click", Oe(this, Bt)), Oe(this, qt).removeEventListener("keydown", Oe(this, Ke)));
          }, Tn = new WeakSet(), Vr = function() {
            Oe(this, Ut) || this.render(), this.isVisible ? Oe(this, Yt) && Oe(this, qt).classList.add("focused") : (Oe(this, qt).hidden = !1, Oe(this, qt).style.zIndex = parseInt(Oe(this, qt).style.zIndex) + 1e3);
          }, Rn = new WeakSet(), Wr = function() {
            Oe(this, qt).classList.remove("focused"), !(Oe(this, Yt) || !this.isVisible) && (Oe(this, qt).hidden = !0, Oe(this, qt).style.zIndex = parseInt(Oe(this, qt).style.zIndex) - 1e3);
          };
          class Ne extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0
              }), this.textContent = xt.data.textContent, this.textPosition = xt.data.textPosition, this.annotationEditorType = ne.AnnotationEditorType.FREETEXT;
            }
            render() {
              if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                const xt = document.createElement("div");
                xt.classList.add("annotationTextContent"), xt.setAttribute("role", "comment");
                for (const ke of this.textContent) {
                  const Xe = document.createElement("span");
                  Xe.textContent = ke, xt.append(Xe);
                }
                this.container.append(xt);
              }
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
            }
          }
          ee.FreeTextAnnotationElement = Ne;
          class Me extends me {
            constructor(ke) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Rt(this, Ht, null);
            }
            render() {
              this.container.classList.add("lineAnnotation");
              const ke = this.data, {
                width: Xe,
                height: Et
              } = pe(ke.rect), Mt = this.svgFactory.create(Xe, Et, !0), Ft = zt(this, Ht, this.svgFactory.createElement("svg:line"));
              return Ft.setAttribute("x1", ke.rect[2] - ke.lineCoordinates[0]), Ft.setAttribute("y1", ke.rect[3] - ke.lineCoordinates[1]), Ft.setAttribute("x2", ke.rect[2] - ke.lineCoordinates[2]), Ft.setAttribute("y2", ke.rect[3] - ke.lineCoordinates[3]), Ft.setAttribute("stroke-width", ke.borderStyle.width || 1), Ft.setAttribute("stroke", "transparent"), Ft.setAttribute("fill", "transparent"), Mt.append(Ft), this.container.append(Mt), !ke.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return Oe(this, Ht);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Ht = new WeakMap();
          class Be extends me {
            constructor(ke) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Rt(this, Lt, null);
            }
            render() {
              this.container.classList.add("squareAnnotation");
              const ke = this.data, {
                width: Xe,
                height: Et
              } = pe(ke.rect), Mt = this.svgFactory.create(Xe, Et, !0), Ft = ke.borderStyle.width, Ve = zt(this, Lt, this.svgFactory.createElement("svg:rect"));
              return Ve.setAttribute("x", Ft / 2), Ve.setAttribute("y", Ft / 2), Ve.setAttribute("width", Xe - Ft), Ve.setAttribute("height", Et - Ft), Ve.setAttribute("stroke-width", Ft || 1), Ve.setAttribute("stroke", "transparent"), Ve.setAttribute("fill", "transparent"), Mt.append(Ve), this.container.append(Mt), !ke.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return Oe(this, Lt);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Lt = new WeakMap();
          class We extends me {
            constructor(ke) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Rt(this, Zt, null);
            }
            render() {
              this.container.classList.add("circleAnnotation");
              const ke = this.data, {
                width: Xe,
                height: Et
              } = pe(ke.rect), Mt = this.svgFactory.create(Xe, Et, !0), Ft = ke.borderStyle.width, Ve = zt(this, Zt, this.svgFactory.createElement("svg:ellipse"));
              return Ve.setAttribute("cx", Xe / 2), Ve.setAttribute("cy", Et / 2), Ve.setAttribute("rx", Xe / 2 - Ft / 2), Ve.setAttribute("ry", Et / 2 - Ft / 2), Ve.setAttribute("stroke-width", Ft || 1), Ve.setAttribute("stroke", "transparent"), Ve.setAttribute("fill", "transparent"), Mt.append(Ve), this.container.append(Mt), !ke.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return Oe(this, Zt);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Zt = new WeakMap();
          class Le extends me {
            constructor(ke) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Rt(this, Jt, null);
              this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const ke = this.data, {
                width: Xe,
                height: Et
              } = pe(ke.rect), Mt = this.svgFactory.create(Xe, Et, !0);
              let Ft = [];
              for (const Dt of ke.vertices) {
                const Wt = Dt.x - ke.rect[0], Xt = ke.rect[3] - Dt.y;
                Ft.push(Wt + "," + Xt);
              }
              Ft = Ft.join(" ");
              const Ve = zt(this, Jt, this.svgFactory.createElement(this.svgElementName));
              return Ve.setAttribute("points", Ft), Ve.setAttribute("stroke-width", ke.borderStyle.width || 1), Ve.setAttribute("stroke", "transparent"), Ve.setAttribute("fill", "transparent"), Mt.append(Ve), this.container.append(Mt), !ke.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return Oe(this, Jt);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Jt = new WeakMap();
          class He extends Le {
            constructor(xt) {
              super(xt), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class Ge extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          class Ze extends me {
            constructor(ke) {
              super(ke, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Rt(this, Dn, []);
              this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = ne.AnnotationEditorType.INK;
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const ke = this.data, {
                width: Xe,
                height: Et
              } = pe(ke.rect), Mt = this.svgFactory.create(Xe, Et, !0);
              for (const Ft of ke.inkLists) {
                let Ve = [];
                for (const Wt of Ft) {
                  const Xt = Wt.x - ke.rect[0], hn = ke.rect[3] - Wt.y;
                  Ve.push(`${Xt},${hn}`);
                }
                Ve = Ve.join(" ");
                const Dt = this.svgFactory.createElement(this.svgElementName);
                Oe(this, Dn).push(Dt), Dt.setAttribute("points", Ve), Dt.setAttribute("stroke-width", ke.borderStyle.width || 1), Dt.setAttribute("stroke", "transparent"), Dt.setAttribute("fill", "transparent"), !ke.popupRef && this.hasPopupData && this._createPopup(), Mt.append(Dt);
              }
              return this.container.append(Mt), this.container;
            }
            getElementsToTriggerPopup() {
              return Oe(this, Dn);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Dn = new WeakMap(), ee.InkAnnotationElement = Ze;
          class Ue extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
            }
          }
          class Qe extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
            }
          }
          class Je extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
            }
          }
          class Ot extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
            }
          }
          class At extends me {
            constructor(xt) {
              super(xt, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          ee.StampAnnotationElement = At;
          class ze extends me {
            constructor(ke) {
              var Mt;
              super(ke, {
                isRenderable: !0
              });
              Rt(this, $t);
              Rt(this, kn, null);
              const {
                filename: Xe,
                content: Et
              } = this.data.file;
              this.filename = (0, re.getFilenameFromUrl)(Xe, !0), this.content = Et, (Mt = this.linkService.eventBus) == null || Mt.dispatch("fileattachmentannotation", {
                source: this,
                filename: Xe,
                content: Et
              });
            }
            render() {
              this.container.classList.add("fileAttachmentAnnotation");
              const {
                container: ke,
                data: Xe
              } = this;
              let Et;
              Xe.hasAppearance || Xe.fillAlpha === 0 ? Et = document.createElement("div") : (Et = document.createElement("img"), Et.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(Xe.name) ? "paperclip" : "pushpin"}.svg`, Xe.fillAlpha && Xe.fillAlpha < 1 && (Et.style = `filter: opacity(${Math.round(Xe.fillAlpha * 100)}%);`)), Et.addEventListener("dblclick", Nt(this, $t, Gr).bind(this)), zt(this, kn, Et);
              const {
                isMac: Mt
              } = ne.FeatureTest.platform;
              return ke.addEventListener("keydown", (Ft) => {
                Ft.key === "Enter" && (Mt ? Ft.metaKey : Ft.ctrlKey) && Nt(this, $t, Gr).call(this);
              }), !Xe.popupRef && this.hasPopupData ? this._createPopup() : Et.classList.add("popupTriggerArea"), ke.append(Et), ke;
            }
            getElementsToTriggerPopup() {
              return Oe(this, kn);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          kn = new WeakMap(), $t = new WeakSet(), Gr = function() {
            var ke;
            (ke = this.downloadManager) == null || ke.openOrDownloadData(this.container, this.content, this.filename);
          };
          class we {
            constructor({
              div: xt,
              accessibilityManager: ke,
              annotationCanvasMap: Xe,
              l10n: Et,
              page: Mt,
              viewport: Ft
            }) {
              Rt(this, xn);
              Rt(this, Qt);
              Rt(this, gn, null);
              Rt(this, dn, null);
              Rt(this, vn, /* @__PURE__ */ new Map());
              this.div = xt, zt(this, gn, ke), zt(this, dn, Xe), this.l10n = Et, this.page = Mt, this.viewport = Ft, this.zIndex = 0, this.l10n || (this.l10n = oe.NullL10n);
            }
            async render(xt) {
              const {
                annotations: ke
              } = xt, Xe = this.div;
              (0, re.setLayerDimensions)(Xe, this.viewport);
              const Et = /* @__PURE__ */ new Map(), Mt = {
                data: null,
                layer: Xe,
                linkService: xt.linkService,
                downloadManager: xt.downloadManager,
                imageResourcesPath: xt.imageResourcesPath || "",
                renderForms: xt.renderForms !== !1,
                svgFactory: new re.DOMSVGFactory(),
                annotationStorage: xt.annotationStorage || new se.AnnotationStorage(),
                enableScripting: xt.enableScripting === !0,
                hasJSActions: xt.hasJSActions,
                fieldObjects: xt.fieldObjects,
                parent: this,
                elements: null
              };
              for (const Ft of ke) {
                if (Ft.noHTML)
                  continue;
                const Ve = Ft.annotationType === ne.AnnotationType.POPUP;
                if (Ve) {
                  const Xt = Et.get(Ft.id);
                  if (!Xt)
                    continue;
                  Mt.elements = Xt;
                } else {
                  const {
                    width: Xt,
                    height: hn
                  } = pe(Ft.rect);
                  if (Xt <= 0 || hn <= 0)
                    continue;
                }
                Mt.data = Ft;
                const Dt = ye.create(Mt);
                if (!Dt.isRenderable)
                  continue;
                if (!Ve && Ft.popupRef) {
                  const Xt = Et.get(Ft.popupRef);
                  Xt ? Xt.push(Dt) : Et.set(Ft.popupRef, [Dt]);
                }
                Dt.annotationEditorType > 0 && Oe(this, vn).set(Dt.data.id, Dt);
                const Wt = Dt.render();
                Ft.hidden && (Wt.style.visibility = "hidden"), Nt(this, xn, Ts).call(this, Wt, Ft.id);
              }
              Nt(this, Qt, Kr).call(this), await this.l10n.translate(Xe);
            }
            update({
              viewport: xt
            }) {
              const ke = this.div;
              this.viewport = xt, (0, re.setLayerDimensions)(ke, {
                rotation: xt.rotation
              }), Nt(this, Qt, Kr).call(this), ke.hidden = !1;
            }
            getEditableAnnotations() {
              return Array.from(Oe(this, vn).values());
            }
            getEditableAnnotation(xt) {
              return Oe(this, vn).get(xt);
            }
          }
          gn = new WeakMap(), dn = new WeakMap(), vn = new WeakMap(), xn = new WeakSet(), Ts = function(xt, ke) {
            var Et;
            const Xe = xt.firstChild || xt;
            Xe.id = `${ne.AnnotationPrefix}${ke}`, this.div.append(xt), (Et = Oe(this, gn)) == null || Et.moveElementInDOM(this.div, xt, Xe, !1);
          }, Qt = new WeakSet(), Kr = function() {
            if (!Oe(this, dn))
              return;
            const xt = this.div;
            for (const [ke, Xe] of Oe(this, dn)) {
              const Et = xt.querySelector(`[data-annotation-id="${ke}"]`);
              if (!Et)
                continue;
              const {
                firstChild: Mt
              } = Et;
              Mt ? Mt.nodeName === "CANVAS" ? Mt.replaceWith(Xe) : Mt.before(Xe) : Et.append(Xe);
            }
            Oe(this, dn).clear();
          }, ee.AnnotationLayer = we;
        },
        /* 30 */
        /***/
        ($, ee) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.ColorConverters = void 0;
          function te(se) {
            return Math.floor(Math.max(0, Math.min(1, se)) * 255).toString(16).padStart(2, "0");
          }
          function ne(se) {
            return Math.max(0, Math.min(255, 255 * se));
          }
          class re {
            static CMYK_G([ie, oe, le, ue]) {
              return ["G", 1 - Math.min(1, 0.3 * ie + 0.59 * le + 0.11 * oe + ue)];
            }
            static G_CMYK([ie]) {
              return ["CMYK", 0, 0, 0, 1 - ie];
            }
            static G_RGB([ie]) {
              return ["RGB", ie, ie, ie];
            }
            static G_rgb([ie]) {
              return ie = ne(ie), [ie, ie, ie];
            }
            static G_HTML([ie]) {
              const oe = te(ie);
              return `#${oe}${oe}${oe}`;
            }
            static RGB_G([ie, oe, le]) {
              return ["G", 0.3 * ie + 0.59 * oe + 0.11 * le];
            }
            static RGB_rgb(ie) {
              return ie.map(ne);
            }
            static RGB_HTML(ie) {
              return `#${ie.map(te).join("")}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static T_rgb() {
              return [null];
            }
            static CMYK_RGB([ie, oe, le, ue]) {
              return ["RGB", 1 - Math.min(1, ie + ue), 1 - Math.min(1, le + ue), 1 - Math.min(1, oe + ue)];
            }
            static CMYK_rgb([ie, oe, le, ue]) {
              return [ne(1 - Math.min(1, ie + ue)), ne(1 - Math.min(1, le + ue)), ne(1 - Math.min(1, oe + ue))];
            }
            static CMYK_HTML(ie) {
              const oe = this.CMYK_RGB(ie).slice(1);
              return this.RGB_HTML(oe);
            }
            static RGB_CMYK([ie, oe, le]) {
              const ue = 1 - ie, de = 1 - oe, fe = 1 - le, pe = Math.min(ue, de, fe);
              return ["CMYK", ue, de, fe, pe];
            }
          }
          ee.ColorConverters = re;
        },
        /* 31 */
        /***/
        ($, ee) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.NullL10n = void 0, ee.getL10nFallback = ne;
          const te = {
            of_pages: "of {{pagesCount}}",
            page_of_pages: "({{pageNumber}} of {{pagesCount}})",
            document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
            document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
            document_properties_date_string: "{{date}}, {{time}}",
            document_properties_page_size_unit_inches: "in",
            document_properties_page_size_unit_millimeters: "mm",
            document_properties_page_size_orientation_portrait: "portrait",
            document_properties_page_size_orientation_landscape: "landscape",
            document_properties_page_size_name_a3: "A3",
            document_properties_page_size_name_a4: "A4",
            document_properties_page_size_name_letter: "Letter",
            document_properties_page_size_name_legal: "Legal",
            document_properties_page_size_dimension_string: "{{width}}  {{height}} {{unit}} ({{orientation}})",
            document_properties_page_size_dimension_name_string: "{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})",
            document_properties_linearized_yes: "Yes",
            document_properties_linearized_no: "No",
            additional_layers: "Additional Layers",
            page_landmark: "Page {{page}}",
            thumb_page_title: "Page {{page}}",
            thumb_page_canvas: "Thumbnail of Page {{page}}",
            find_reached_top: "Reached top of document, continued from bottom",
            find_reached_bottom: "Reached end of document, continued from top",
            "find_match_count[one]": "{{current}} of {{total}} match",
            "find_match_count[other]": "{{current}} of {{total}} matches",
            "find_match_count_limit[one]": "More than {{limit}} match",
            "find_match_count_limit[other]": "More than {{limit}} matches",
            find_not_found: "Phrase not found",
            page_scale_width: "Page Width",
            page_scale_fit: "Page Fit",
            page_scale_auto: "Automatic Zoom",
            page_scale_actual: "Actual Size",
            page_scale_percent: "{{scale}}%",
            loading_error: "An error occurred while loading the PDF.",
            invalid_file_error: "Invalid or corrupted PDF file.",
            missing_file_error: "Missing PDF file.",
            unexpected_response_error: "Unexpected server response.",
            rendering_error: "An error occurred while rendering the page.",
            annotation_date_string: "{{date}}, {{time}}",
            printing_not_supported: "Warning: Printing is not fully supported by this browser.",
            printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
            web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
            free_text2_default_content: "Start typing",
            editor_free_text2_aria_label: "Text Editor",
            editor_ink2_aria_label: "Draw Editor",
            editor_ink_canvas_aria_label: "User-created image",
            editor_alt_text_button_label: "Alt text",
            editor_alt_text_edit_button_label: "Edit alt text",
            editor_alt_text_decorative_tooltip: "Marked as decorative"
          };
          te.print_progress_percent = "{{progress}}%";
          function ne(ie, oe) {
            switch (ie) {
              case "find_match_count":
                ie = `find_match_count[${oe.total === 1 ? "one" : "other"}]`;
                break;
              case "find_match_count_limit":
                ie = `find_match_count_limit[${oe.limit === 1 ? "one" : "other"}]`;
                break;
            }
            return te[ie] || "";
          }
          function re(ie, oe) {
            return oe ? ie.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (le, ue) => ue in oe ? oe[ue] : "{{" + ue + "}}") : ie;
          }
          const se = {
            async getLanguage() {
              return "en-us";
            },
            async getDirection() {
              return "ltr";
            },
            async get(ie, oe = null, le = ne(ie, oe)) {
              return re(le, oe);
            },
            async translate(ie) {
            }
          };
          ee.NullL10n = se;
        },
        /* 32 */
        /***/
        ($, ee, te) => {
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.XfaLayer = void 0;
          var ne = te(25);
          class re {
            static setupStorage(ie, oe, le, ue, de) {
              const fe = ue.getValue(oe, {
                value: null
              });
              switch (le.name) {
                case "textarea":
                  if (fe.value !== null && (ie.textContent = fe.value), de === "print")
                    break;
                  ie.addEventListener("input", (pe) => {
                    ue.setValue(oe, {
                      value: pe.target.value
                    });
                  });
                  break;
                case "input":
                  if (le.attributes.type === "radio" || le.attributes.type === "checkbox") {
                    if (fe.value === le.attributes.xfaOn ? ie.setAttribute("checked", !0) : fe.value === le.attributes.xfaOff && ie.removeAttribute("checked"), de === "print")
                      break;
                    ie.addEventListener("change", (pe) => {
                      ue.setValue(oe, {
                        value: pe.target.checked ? pe.target.getAttribute("xfaOn") : pe.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (fe.value !== null && ie.setAttribute("value", fe.value), de === "print")
                      break;
                    ie.addEventListener("input", (pe) => {
                      ue.setValue(oe, {
                        value: pe.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (fe.value !== null) {
                    ie.setAttribute("value", fe.value);
                    for (const pe of le.children)
                      pe.attributes.value === fe.value ? pe.attributes.selected = !0 : pe.attributes.hasOwnProperty("selected") && delete pe.attributes.selected;
                  }
                  ie.addEventListener("input", (pe) => {
                    const ye = pe.target.options, me = ye.selectedIndex === -1 ? "" : ye[ye.selectedIndex].value;
                    ue.setValue(oe, {
                      value: me
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: ie,
              element: oe,
              storage: le = null,
              intent: ue,
              linkService: de
            }) {
              const {
                attributes: fe
              } = oe, pe = ie instanceof HTMLAnchorElement;
              fe.type === "radio" && (fe.name = `${fe.name}-${ue}`);
              for (const [ye, me] of Object.entries(fe))
                if (me != null)
                  switch (ye) {
                    case "class":
                      me.length && ie.setAttribute(ye, me.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      ie.setAttribute("data-element-id", me);
                      break;
                    case "style":
                      Object.assign(ie.style, me);
                      break;
                    case "textContent":
                      ie.textContent = me;
                      break;
                    default:
                      (!pe || ye !== "href" && ye !== "newWindow") && ie.setAttribute(ye, me);
                  }
              pe && de.addLinkAttributes(ie, fe.href, fe.newWindow), le && fe.dataId && this.setupStorage(ie, fe.dataId, oe, le);
            }
            static render(ie) {
              var ve;
              const oe = ie.annotationStorage, le = ie.linkService, ue = ie.xfaHtml, de = ie.intent || "display", fe = document.createElement(ue.name);
              ue.attributes && this.setAttributes({
                html: fe,
                element: ue,
                intent: de,
                linkService: le
              });
              const pe = [[ue, -1, fe]], ye = ie.div;
              if (ye.append(fe), ie.viewport) {
                const ge = `matrix(${ie.viewport.transform.join(",")})`;
                ye.style.transform = ge;
              }
              de !== "richText" && ye.setAttribute("class", "xfaLayer xfaFont");
              const me = [];
              for (; pe.length > 0; ) {
                const [ge, xe, Ee] = pe.at(-1);
                if (xe + 1 === ge.children.length) {
                  pe.pop();
                  continue;
                }
                const Te = ge.children[++pe.at(-1)[1]];
                if (Te === null)
                  continue;
                const {
                  name: Se
                } = Te;
                if (Se === "#text") {
                  const Pe = document.createTextNode(Te.value);
                  me.push(Pe), Ee.append(Pe);
                  continue;
                }
                const he = (ve = Te == null ? void 0 : Te.attributes) != null && ve.xmlns ? document.createElementNS(Te.attributes.xmlns, Se) : document.createElement(Se);
                if (Ee.append(he), Te.attributes && this.setAttributes({
                  html: he,
                  element: Te,
                  storage: oe,
                  intent: de,
                  linkService: le
                }), Te.children && Te.children.length > 0)
                  pe.push([Te, -1, he]);
                else if (Te.value) {
                  const Pe = document.createTextNode(Te.value);
                  ne.XfaText.shouldBuildText(Se) && me.push(Pe), he.append(Pe);
                }
              }
              for (const ge of ye.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                ge.setAttribute("readOnly", !0);
              return {
                textDivs: me
              };
            }
            static update(ie) {
              const oe = `matrix(${ie.viewport.transform.join(",")})`;
              ie.div.style.transform = oe, ie.div.hidden = !1;
            }
          }
          ee.XfaLayer = re;
        },
        /* 33 */
        /***/
        ($, ee, te) => {
          var ue, de, fe, pe, ye, me, ve, ge, xe, Ee, Te, Se, he, Pe, Ie, Ps, Ce, Cs, Me, ws, We, Rs, He, Xr, Ze, As, Qe, Yr, Ot, Os, ze, Ms, Ae, Is, je, ks, $e, Ds, Ye, Bn, Tt, Zr, Bt, hr, qt, mr, mn, Wn, pn, Jr, Ut, gr, Gt, Ns, sn, Qr, un, Ls, wn, js, Pn, es, Kt, yr, Lt, Gn;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.InkEditor = void 0;
          var ne = te(1), re = te(4), se = te(29), ie = te(6), oe = te(5);
          const Jt = class Jt extends re.AnnotationEditor {
            constructor($t) {
              super({
                ...$t,
                name: "inkEditor"
              });
              Rt(this, Ie);
              Rt(this, Ce);
              Rt(this, Me);
              Rt(this, We);
              Rt(this, He);
              Rt(this, Ze);
              Rt(this, Qe);
              Rt(this, Ot);
              Rt(this, ze);
              Rt(this, Ae);
              Rt(this, je);
              Rt(this, $e);
              Rt(this, Ye);
              Rt(this, Tt);
              Rt(this, Bt);
              Rt(this, qt);
              Rt(this, mn);
              Rt(this, pn);
              Rt(this, Ut);
              Rt(this, wn);
              Rt(this, Pn);
              Rt(this, Kt);
              Rt(this, Lt);
              Rt(this, ue, 0);
              Rt(this, de, 0);
              Rt(this, fe, this.canvasPointermove.bind(this));
              Rt(this, pe, this.canvasPointerleave.bind(this));
              Rt(this, ye, this.canvasPointerup.bind(this));
              Rt(this, me, this.canvasPointerdown.bind(this));
              Rt(this, ve, new Path2D());
              Rt(this, ge, !1);
              Rt(this, xe, !1);
              Rt(this, Ee, !1);
              Rt(this, Te, null);
              Rt(this, Se, 0);
              Rt(this, he, 0);
              Rt(this, Pe, null);
              this.color = $t.color || null, this.thickness = $t.thickness || null, this.opacity = $t.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
            }
            static initialize($t) {
              re.AnnotationEditor.initialize($t, {
                strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
              });
            }
            static updateDefaultParams($t, on) {
              switch ($t) {
                case ne.AnnotationEditorParamsType.INK_THICKNESS:
                  Jt._defaultThickness = on;
                  break;
                case ne.AnnotationEditorParamsType.INK_COLOR:
                  Jt._defaultColor = on;
                  break;
                case ne.AnnotationEditorParamsType.INK_OPACITY:
                  Jt._defaultOpacity = on / 100;
                  break;
              }
            }
            updateParams($t, on) {
              switch ($t) {
                case ne.AnnotationEditorParamsType.INK_THICKNESS:
                  Nt(this, Ie, Ps).call(this, on);
                  break;
                case ne.AnnotationEditorParamsType.INK_COLOR:
                  Nt(this, Ce, Cs).call(this, on);
                  break;
                case ne.AnnotationEditorParamsType.INK_OPACITY:
                  Nt(this, Me, ws).call(this, on);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[ne.AnnotationEditorParamsType.INK_THICKNESS, Jt._defaultThickness], [ne.AnnotationEditorParamsType.INK_COLOR, Jt._defaultColor || re.AnnotationEditor._defaultLineColor], [ne.AnnotationEditorParamsType.INK_OPACITY, Math.round(Jt._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[ne.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Jt._defaultThickness], [ne.AnnotationEditorParamsType.INK_COLOR, this.color || Jt._defaultColor || re.AnnotationEditor._defaultLineColor], [ne.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Jt._defaultOpacity))]];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.canvas || (Nt(this, Bt, hr).call(this), Nt(this, qt, mr).call(this)), this.isAttachedToDOM || (this.parent.add(this), Nt(this, mn, Wn).call(this)), Nt(this, Lt, Gn).call(this)));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, Oe(this, Te).disconnect(), zt(this, Te, null), super.remove());
            }
            setParent($t) {
              !this.parent && $t ? this._uiManager.removeShouldRescale(this) : this.parent && $t === null && this._uiManager.addShouldRescale(this), super.setParent($t);
            }
            onScaleChanging() {
              const [$t, on] = this.parentDimensions, gn = this.width * $t, dn = this.height * on;
              this.setDimensions(gn, dn);
            }
            enableEditMode() {
              Oe(this, ge) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", Oe(this, me)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", Oe(this, me)));
            }
            onceAdded() {
              this._isDraggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              Oe(this, ge) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), zt(this, ge, !0), this.div.classList.add("disabled"), Nt(this, Lt, Gn).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                preventScroll: !0
              }));
            }
            focusin($t) {
              this._focusEventsAllowed && (super.focusin($t), this.enableEditMode());
            }
            canvasPointerdown($t) {
              $t.button !== 0 || !this.isInEditMode() || Oe(this, ge) || (this.setInForeground(), $t.preventDefault(), $t.type !== "mouse" && this.div.focus(), Nt(this, Ze, As).call(this, $t.offsetX, $t.offsetY));
            }
            canvasPointermove($t) {
              $t.preventDefault(), Nt(this, Qe, Yr).call(this, $t.offsetX, $t.offsetY);
            }
            canvasPointerup($t) {
              $t.preventDefault(), Nt(this, Tt, Zr).call(this, $t);
            }
            canvasPointerleave($t) {
              Nt(this, Tt, Zr).call(this, $t);
            }
            get isResizable() {
              return !this.isEmpty() && Oe(this, ge);
            }
            render() {
              if (this.div)
                return this.div;
              let $t, on;
              this.width && ($t = this.x, on = this.y), super.render(), re.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((In) => {
                var Qt;
                return (Qt = this.div) == null ? void 0 : Qt.setAttribute("aria-label", In);
              });
              const [gn, dn, vn, xn] = Nt(this, We, Rs).call(this);
              if (this.setAt(gn, dn, 0, 0), this.setDims(vn, xn), Nt(this, Bt, hr).call(this), this.width) {
                const [In, Qt] = this.parentDimensions;
                this.setAspectRatio(this.width * In, this.height * Qt), this.setAt($t * In, on * Qt, this.width * In, this.height * Qt), zt(this, Ee, !0), Nt(this, mn, Wn).call(this), this.setDims(this.width * In, this.height * Qt), Nt(this, Ye, Bn).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return Nt(this, qt, mr).call(this), this.div;
            }
            setDimensions($t, on) {
              const gn = Math.round($t), dn = Math.round(on);
              if (Oe(this, Se) === gn && Oe(this, he) === dn)
                return;
              zt(this, Se, gn), zt(this, he, dn), this.canvas.style.visibility = "hidden";
              const [vn, xn] = this.parentDimensions;
              this.width = $t / vn, this.height = on / xn, this.fixAndSetPosition(), Oe(this, ge) && Nt(this, pn, Jr).call(this, $t, on), Nt(this, mn, Wn).call(this), Nt(this, Ye, Bn).call(this), this.canvas.style.visibility = "visible", this.fixDims();
            }
            static deserialize($t, on, gn) {
              var Mt, Ft, Ve;
              if ($t instanceof se.InkAnnotationElement)
                return null;
              const dn = super.deserialize($t, on, gn);
              dn.thickness = $t.thickness, dn.color = ne.Util.makeHexColor(...$t.color), dn.opacity = $t.opacity;
              const [vn, xn] = dn.pageDimensions, In = dn.width * vn, Qt = dn.height * xn, Mn = dn.parentScale, yn = $t.thickness / 2;
              zt(dn, ge, !0), zt(dn, Se, Math.round(In)), zt(dn, he, Math.round(Qt));
              const {
                paths: xt,
                rect: ke,
                rotation: Xe
              } = $t;
              for (let {
                bezier: Dt
              } of xt) {
                Dt = Nt(Mt = Jt, un, Ls).call(Mt, Dt, ke, Xe);
                const Wt = [];
                dn.paths.push(Wt);
                let Xt = Mn * (Dt[0] - yn), hn = Mn * (Dt[1] - yn);
                for (let tn = 2, fn = Dt.length; tn < fn; tn += 6) {
                  const Sn = Mn * (Dt[tn] - yn), Cn = Mn * (Dt[tn + 1] - yn), An = Mn * (Dt[tn + 2] - yn), Nn = Mn * (Dt[tn + 3] - yn), Ln = Mn * (Dt[tn + 4] - yn), Fn = Mn * (Dt[tn + 5] - yn);
                  Wt.push([[Xt, hn], [Sn, Cn], [An, Nn], [Ln, Fn]]), Xt = Ln, hn = Fn;
                }
                const rn = Nt(this, Gt, Ns).call(this, Wt);
                dn.bezierPath2D.push(rn);
              }
              const Et = Nt(Ft = dn, Pn, es).call(Ft);
              return zt(dn, de, Math.max(re.AnnotationEditor.MIN_SIZE, Et[2] - Et[0])), zt(dn, ue, Math.max(re.AnnotationEditor.MIN_SIZE, Et[3] - Et[1])), Nt(Ve = dn, pn, Jr).call(Ve, In, Qt), dn;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const $t = this.getRect(0, 0), on = re.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: ne.AnnotationEditorType.INK,
                color: on,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: Nt(this, wn, js).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, $t),
                pageIndex: this.pageIndex,
                rect: $t,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
            }
          };
          ue = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakMap(), Ee = new WeakMap(), Te = new WeakMap(), Se = new WeakMap(), he = new WeakMap(), Pe = new WeakMap(), Ie = new WeakSet(), Ps = function($t) {
            const on = this.thickness;
            this.addCommands({
              cmd: () => {
                this.thickness = $t, Nt(this, Lt, Gn).call(this);
              },
              undo: () => {
                this.thickness = on, Nt(this, Lt, Gn).call(this);
              },
              mustExec: !0,
              type: ne.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, Ce = new WeakSet(), Cs = function($t) {
            const on = this.color;
            this.addCommands({
              cmd: () => {
                this.color = $t, Nt(this, Ye, Bn).call(this);
              },
              undo: () => {
                this.color = on, Nt(this, Ye, Bn).call(this);
              },
              mustExec: !0,
              type: ne.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, Me = new WeakSet(), ws = function($t) {
            $t /= 100;
            const on = this.opacity;
            this.addCommands({
              cmd: () => {
                this.opacity = $t, Nt(this, Ye, Bn).call(this);
              },
              undo: () => {
                this.opacity = on, Nt(this, Ye, Bn).call(this);
              },
              mustExec: !0,
              type: ne.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, We = new WeakSet(), Rs = function() {
            const {
              parentRotation: $t,
              parentDimensions: [on, gn]
            } = this;
            switch ($t) {
              case 90:
                return [0, gn, gn, on];
              case 180:
                return [on, gn, on, gn];
              case 270:
                return [on, 0, gn, on];
              default:
                return [0, 0, on, gn];
            }
          }, He = new WeakSet(), Xr = function() {
            const {
              ctx: $t,
              color: on,
              opacity: gn,
              thickness: dn,
              parentScale: vn,
              scaleFactor: xn
            } = this;
            $t.lineWidth = dn * vn / xn, $t.lineCap = "round", $t.lineJoin = "round", $t.miterLimit = 10, $t.strokeStyle = `${on}${(0, oe.opacityToHex)(gn)}`;
          }, Ze = new WeakSet(), As = function($t, on) {
            this.canvas.addEventListener("contextmenu", ie.noContextMenu), this.canvas.addEventListener("pointerleave", Oe(this, pe)), this.canvas.addEventListener("pointermove", Oe(this, fe)), this.canvas.addEventListener("pointerup", Oe(this, ye)), this.canvas.removeEventListener("pointerdown", Oe(this, me)), this.isEditing = !0, Oe(this, Ee) || (zt(this, Ee, !0), Nt(this, mn, Wn).call(this), this.thickness || (this.thickness = Jt._defaultThickness), this.color || (this.color = Jt._defaultColor || re.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Jt._defaultOpacity)), this.currentPath.push([$t, on]), zt(this, xe, !1), Nt(this, He, Xr).call(this), zt(this, Pe, () => {
              Nt(this, Ae, Is).call(this), Oe(this, Pe) && window.requestAnimationFrame(Oe(this, Pe));
            }), window.requestAnimationFrame(Oe(this, Pe));
          }, Qe = new WeakSet(), Yr = function($t, on) {
            const [gn, dn] = this.currentPath.at(-1);
            if (this.currentPath.length > 1 && $t === gn && on === dn)
              return;
            const vn = this.currentPath;
            let xn = Oe(this, ve);
            if (vn.push([$t, on]), zt(this, xe, !0), vn.length <= 2) {
              xn.moveTo(...vn[0]), xn.lineTo($t, on);
              return;
            }
            vn.length === 3 && (zt(this, ve, xn = new Path2D()), xn.moveTo(...vn[0])), Nt(this, je, ks).call(this, xn, ...vn.at(-3), ...vn.at(-2), $t, on);
          }, Ot = new WeakSet(), Os = function() {
            if (this.currentPath.length === 0)
              return;
            const $t = this.currentPath.at(-1);
            Oe(this, ve).lineTo(...$t);
          }, ze = new WeakSet(), Ms = function($t, on) {
            zt(this, Pe, null), $t = Math.min(Math.max($t, 0), this.canvas.width), on = Math.min(Math.max(on, 0), this.canvas.height), Nt(this, Qe, Yr).call(this, $t, on), Nt(this, Ot, Os).call(this);
            let gn;
            if (this.currentPath.length !== 1)
              gn = Nt(this, $e, Ds).call(this);
            else {
              const Qt = [$t, on];
              gn = [[Qt, Qt.slice(), Qt.slice(), Qt]];
            }
            const dn = Oe(this, ve), vn = this.currentPath;
            this.currentPath = [], zt(this, ve, new Path2D());
            const xn = () => {
              this.allRawPaths.push(vn), this.paths.push(gn), this.bezierPath2D.push(dn), this.rebuild();
            }, In = () => {
              this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (Nt(this, Bt, hr).call(this), Nt(this, qt, mr).call(this)), Nt(this, Lt, Gn).call(this));
            };
            this.addCommands({
              cmd: xn,
              undo: In,
              mustExec: !0
            });
          }, Ae = new WeakSet(), Is = function() {
            if (!Oe(this, xe))
              return;
            zt(this, xe, !1);
            const $t = Math.ceil(this.thickness * this.parentScale), on = this.currentPath.slice(-3), gn = on.map((xn) => xn[0]), dn = on.map((xn) => xn[1]);
            Math.min(...gn) - $t, Math.max(...gn) + $t, Math.min(...dn) - $t, Math.max(...dn) + $t;
            const {
              ctx: vn
            } = this;
            vn.save(), vn.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (const xn of this.bezierPath2D)
              vn.stroke(xn);
            vn.stroke(Oe(this, ve)), vn.restore();
          }, je = new WeakSet(), ks = function($t, on, gn, dn, vn, xn, In) {
            const Qt = (on + dn) / 2, Mn = (gn + vn) / 2, yn = (dn + xn) / 2, xt = (vn + In) / 2;
            $t.bezierCurveTo(Qt + 2 * (dn - Qt) / 3, Mn + 2 * (vn - Mn) / 3, yn + 2 * (dn - yn) / 3, xt + 2 * (vn - xt) / 3, yn, xt);
          }, $e = new WeakSet(), Ds = function() {
            const $t = this.currentPath;
            if ($t.length <= 2)
              return [[$t[0], $t[0], $t.at(-1), $t.at(-1)]];
            const on = [];
            let gn, [dn, vn] = $t[0];
            for (gn = 1; gn < $t.length - 2; gn++) {
              const [ke, Xe] = $t[gn], [Et, Mt] = $t[gn + 1], Ft = (ke + Et) / 2, Ve = (Xe + Mt) / 2, Dt = [dn + 2 * (ke - dn) / 3, vn + 2 * (Xe - vn) / 3], Wt = [Ft + 2 * (ke - Ft) / 3, Ve + 2 * (Xe - Ve) / 3];
              on.push([[dn, vn], Dt, Wt, [Ft, Ve]]), [dn, vn] = [Ft, Ve];
            }
            const [xn, In] = $t[gn], [Qt, Mn] = $t[gn + 1], yn = [dn + 2 * (xn - dn) / 3, vn + 2 * (In - vn) / 3], xt = [Qt + 2 * (xn - Qt) / 3, Mn + 2 * (In - Mn) / 3];
            return on.push([[dn, vn], yn, xt, [Qt, Mn]]), on;
          }, Ye = new WeakSet(), Bn = function() {
            if (this.isEmpty()) {
              Nt(this, Ut, gr).call(this);
              return;
            }
            Nt(this, He, Xr).call(this);
            const {
              canvas: $t,
              ctx: on
            } = this;
            on.setTransform(1, 0, 0, 1, 0, 0), on.clearRect(0, 0, $t.width, $t.height), Nt(this, Ut, gr).call(this);
            for (const gn of this.bezierPath2D)
              on.stroke(gn);
          }, Tt = new WeakSet(), Zr = function($t) {
            this.canvas.removeEventListener("pointerleave", Oe(this, pe)), this.canvas.removeEventListener("pointermove", Oe(this, fe)), this.canvas.removeEventListener("pointerup", Oe(this, ye)), this.canvas.addEventListener("pointerdown", Oe(this, me)), setTimeout(() => {
              this.canvas.removeEventListener("contextmenu", ie.noContextMenu);
            }, 10), Nt(this, ze, Ms).call(this, $t.offsetX, $t.offsetY), this.addToAnnotationStorage(), this.setInBackground();
          }, Bt = new WeakSet(), hr = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", re.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(($t) => {
              var on;
              return (on = this.canvas) == null ? void 0 : on.setAttribute("aria-label", $t);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, qt = new WeakSet(), mr = function() {
            zt(this, Te, new ResizeObserver(($t) => {
              const on = $t[0].contentRect;
              on.width && on.height && this.setDimensions(on.width, on.height);
            })), Oe(this, Te).observe(this.div);
          }, mn = new WeakSet(), Wn = function() {
            if (!Oe(this, Ee))
              return;
            const [$t, on] = this.parentDimensions;
            this.canvas.width = Math.ceil(this.width * $t), this.canvas.height = Math.ceil(this.height * on), Nt(this, Ut, gr).call(this);
          }, pn = new WeakSet(), Jr = function($t, on) {
            const gn = Nt(this, Kt, yr).call(this), dn = ($t - gn) / Oe(this, de), vn = (on - gn) / Oe(this, ue);
            this.scaleFactor = Math.min(dn, vn);
          }, Ut = new WeakSet(), gr = function() {
            const $t = Nt(this, Kt, yr).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + $t, this.translationY * this.scaleFactor + $t);
          }, Gt = new WeakSet(), Ns = function($t) {
            const on = new Path2D();
            for (let gn = 0, dn = $t.length; gn < dn; gn++) {
              const [vn, xn, In, Qt] = $t[gn];
              gn === 0 && on.moveTo(...vn), on.bezierCurveTo(xn[0], xn[1], In[0], In[1], Qt[0], Qt[1]);
            }
            return on;
          }, sn = new WeakSet(), Qr = function($t, on, gn) {
            const [dn, vn, xn, In] = on;
            switch (gn) {
              case 0:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2)
                  $t[Qt] += dn, $t[Qt + 1] = In - $t[Qt + 1];
                break;
              case 90:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2) {
                  const yn = $t[Qt];
                  $t[Qt] = $t[Qt + 1] + dn, $t[Qt + 1] = yn + vn;
                }
                break;
              case 180:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2)
                  $t[Qt] = xn - $t[Qt], $t[Qt + 1] += vn;
                break;
              case 270:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2) {
                  const yn = $t[Qt];
                  $t[Qt] = xn - $t[Qt + 1], $t[Qt + 1] = In - yn;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return $t;
          }, un = new WeakSet(), Ls = function($t, on, gn) {
            const [dn, vn, xn, In] = on;
            switch (gn) {
              case 0:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2)
                  $t[Qt] -= dn, $t[Qt + 1] = In - $t[Qt + 1];
                break;
              case 90:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2) {
                  const yn = $t[Qt];
                  $t[Qt] = $t[Qt + 1] - vn, $t[Qt + 1] = yn - dn;
                }
                break;
              case 180:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2)
                  $t[Qt] = xn - $t[Qt], $t[Qt + 1] -= vn;
                break;
              case 270:
                for (let Qt = 0, Mn = $t.length; Qt < Mn; Qt += 2) {
                  const yn = $t[Qt];
                  $t[Qt] = In - $t[Qt + 1], $t[Qt + 1] = xn - yn;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return $t;
          }, wn = new WeakSet(), js = function($t, on, gn, dn) {
            var Mn, yn;
            const vn = [], xn = this.thickness / 2, In = $t * on + xn, Qt = $t * gn + xn;
            for (const xt of this.paths) {
              const ke = [], Xe = [];
              for (let Et = 0, Mt = xt.length; Et < Mt; Et++) {
                const [Ft, Ve, Dt, Wt] = xt[Et], Xt = $t * Ft[0] + In, hn = $t * Ft[1] + Qt, rn = $t * Ve[0] + In, tn = $t * Ve[1] + Qt, fn = $t * Dt[0] + In, Sn = $t * Dt[1] + Qt, Cn = $t * Wt[0] + In, An = $t * Wt[1] + Qt;
                Et === 0 && (ke.push(Xt, hn), Xe.push(Xt, hn)), ke.push(rn, tn, fn, Sn, Cn, An), Xe.push(rn, tn), Et === Mt - 1 && Xe.push(Cn, An);
              }
              vn.push({
                bezier: Nt(Mn = Jt, sn, Qr).call(Mn, ke, dn, this.rotation),
                points: Nt(yn = Jt, sn, Qr).call(yn, Xe, dn, this.rotation)
              });
            }
            return vn;
          }, Pn = new WeakSet(), es = function() {
            let $t = 1 / 0, on = -1 / 0, gn = 1 / 0, dn = -1 / 0;
            for (const vn of this.paths)
              for (const [xn, In, Qt, Mn] of vn) {
                const yn = ne.Util.bezierBoundingBox(...xn, ...In, ...Qt, ...Mn);
                $t = Math.min($t, yn[0]), gn = Math.min(gn, yn[1]), on = Math.max(on, yn[2]), dn = Math.max(dn, yn[3]);
              }
            return [$t, gn, on, dn];
          }, Kt = new WeakSet(), yr = function() {
            return Oe(this, ge) ? Math.ceil(this.thickness * this.parentScale) : 0;
          }, Lt = new WeakSet(), Gn = function($t = !1) {
            if (this.isEmpty())
              return;
            if (!Oe(this, ge)) {
              Nt(this, Ye, Bn).call(this);
              return;
            }
            const on = Nt(this, Pn, es).call(this), gn = Nt(this, Kt, yr).call(this);
            zt(this, de, Math.max(re.AnnotationEditor.MIN_SIZE, on[2] - on[0])), zt(this, ue, Math.max(re.AnnotationEditor.MIN_SIZE, on[3] - on[1]));
            const dn = Math.ceil(gn + Oe(this, de) * this.scaleFactor), vn = Math.ceil(gn + Oe(this, ue) * this.scaleFactor), [xn, In] = this.parentDimensions;
            this.width = dn / xn, this.height = vn / In, this.setAspectRatio(dn, vn);
            const Qt = this.translationX, Mn = this.translationY;
            this.translationX = -on[0], this.translationY = -on[1], Nt(this, mn, Wn).call(this), Nt(this, Ye, Bn).call(this), zt(this, Se, dn), zt(this, he, vn), this.setDims(dn, vn);
            const yn = $t ? gn / this.scaleFactor / 2 : 0;
            this.translate(Qt - this.translationX - yn, Mn - this.translationY - yn);
          }, Rt(Jt, Gt), Rt(Jt, sn), Rt(Jt, un), On(Jt, "_defaultColor", null), On(Jt, "_defaultOpacity", 1), On(Jt, "_defaultThickness", 1), On(Jt, "_type", "ink");
          let le = Jt;
          ee.InkEditor = le;
        },
        /* 34 */
        /***/
        ($, ee, te) => {
          var le, ue, de, fe, pe, ye, me, ve, ge, xe, Ee, tr, Se, nr, Pe, vr, De, ts, Ne, Fs, Be, $s, Le, ns, Ge, xr, Ue, Us;
          Object.defineProperty(ee, "__esModule", {
            value: !0
          }), ee.StampEditor = void 0;
          var ne = te(1), re = te(4), se = te(6), ie = te(29);
          const Je = class Je extends re.AnnotationEditor {
            constructor(ze) {
              super({
                ...ze,
                name: "stampEditor"
              });
              Rt(this, Ee);
              Rt(this, Se);
              Rt(this, Pe);
              Rt(this, De);
              Rt(this, Ne);
              Rt(this, Be);
              Rt(this, Le);
              Rt(this, Ge);
              Rt(this, Ue);
              Rt(this, le, null);
              Rt(this, ue, null);
              Rt(this, de, null);
              Rt(this, fe, null);
              Rt(this, pe, null);
              Rt(this, ye, null);
              Rt(this, me, null);
              Rt(this, ve, null);
              Rt(this, ge, !1);
              Rt(this, xe, !1);
              zt(this, fe, ze.bitmapUrl), zt(this, pe, ze.bitmapFile);
            }
            static initialize(ze) {
              re.AnnotationEditor.initialize(ze);
            }
            static get supportedTypes() {
              const ze = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
              return (0, ne.shadow)(this, "supportedTypes", ze.map((we) => `image/${we}`));
            }
            static get supportedTypesStr() {
              return (0, ne.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
            }
            static isHandlingMimeForPasting(ze) {
              return this.supportedTypes.includes(ze);
            }
            static paste(ze, we) {
              we.pasteEditor(ne.AnnotationEditorType.STAMP, {
                bitmapFile: ze.getAsFile()
              });
            }
            remove() {
              var ze, we;
              Oe(this, ue) && (zt(this, le, null), this._uiManager.imageManager.deleteId(Oe(this, ue)), (ze = Oe(this, ye)) == null || ze.remove(), zt(this, ye, null), (we = Oe(this, me)) == null || we.disconnect(), zt(this, me, null)), super.remove();
            }
            rebuild() {
              if (!this.parent) {
                Oe(this, ue) && Nt(this, Pe, vr).call(this);
                return;
              }
              super.rebuild(), this.div !== null && (Oe(this, ue) && Nt(this, Pe, vr).call(this), this.isAttachedToDOM || this.parent.add(this));
            }
            onceAdded() {
              this._isDraggable = !0, this.div.focus();
            }
            isEmpty() {
              return !(Oe(this, de) || Oe(this, le) || Oe(this, fe) || Oe(this, pe));
            }
            get isResizable() {
              return !0;
            }
            render() {
              if (this.div)
                return this.div;
              let ze, we;
              if (this.width && (ze = this.x, we = this.y), super.render(), this.div.hidden = !0, Oe(this, le) ? Nt(this, De, ts).call(this) : Nt(this, Pe, vr).call(this), this.width) {
                const [Ae, Re] = this.parentDimensions;
                this.setAt(ze * Ae, we * Re, this.width * Ae, this.height * Re);
              }
              return this.div;
            }
            static deserialize(ze, we, Ae) {
              if (ze instanceof ie.StampAnnotationElement)
                return null;
              const Re = super.deserialize(ze, we, Ae), {
                rect: je,
                bitmapUrl: Fe,
                bitmapId: $e,
                isSvg: qe,
                accessibilityData: Ye
              } = ze;
              $e && Ae.imageManager.isValidId($e) ? zt(Re, ue, $e) : zt(Re, fe, Fe), zt(Re, ge, qe);
              const [Ke, Tt] = Re.pageDimensions;
              return Re.width = (je[2] - je[0]) / Ke, Re.height = (je[3] - je[1]) / Tt, Ye && (Re.altTextData = Ye), Re;
            }
            serialize(ze = !1, we = null) {
              if (this.isEmpty())
                return null;
              const Ae = {
                annotationType: ne.AnnotationEditorType.STAMP,
                bitmapId: Oe(this, ue),
                pageIndex: this.pageIndex,
                rect: this.getRect(0, 0),
                rotation: this.rotation,
                isSvg: Oe(this, ge),
                structTreeParentId: this._structTreeParentId
              };
              if (ze)
                return Ae.bitmapUrl = Nt(this, Ge, xr).call(this, !0), Ae.accessibilityData = this.altTextData, Ae;
              const {
                decorative: Re,
                altText: je
              } = this.altTextData;
              if (!Re && je && (Ae.accessibilityData = {
                type: "Figure",
                alt: je
              }), we === null)
                return Ae;
              we.stamps || (we.stamps = /* @__PURE__ */ new Map());
              const Fe = Oe(this, ge) ? (Ae.rect[2] - Ae.rect[0]) * (Ae.rect[3] - Ae.rect[1]) : null;
              if (!we.stamps.has(Oe(this, ue)))
                we.stamps.set(Oe(this, ue), {
                  area: Fe,
                  serialized: Ae
                }), Ae.bitmap = Nt(this, Ge, xr).call(this, !1);
              else if (Oe(this, ge)) {
                const $e = we.stamps.get(Oe(this, ue));
                Fe > $e.area && ($e.area = Fe, $e.serialized.bitmap.close(), $e.serialized.bitmap = Nt(this, Ge, xr).call(this, !1));
              }
              return Ae;
            }
          };
          le = new WeakMap(), ue = new WeakMap(), de = new WeakMap(), fe = new WeakMap(), pe = new WeakMap(), ye = new WeakMap(), me = new WeakMap(), ve = new WeakMap(), ge = new WeakMap(), xe = new WeakMap(), Ee = new WeakSet(), tr = function(ze, we = !1) {
            if (!ze) {
              this.remove();
              return;
            }
            zt(this, le, ze.bitmap), we || (zt(this, ue, ze.id), zt(this, ge, ze.isSvg)), Nt(this, De, ts).call(this);
          }, Se = new WeakSet(), nr = function() {
            zt(this, de, null), this._uiManager.enableWaiting(!1), Oe(this, ye) && this.div.focus();
          }, Pe = new WeakSet(), vr = function() {
            if (Oe(this, ue)) {
              this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(Oe(this, ue)).then((we) => Nt(this, Ee, tr).call(this, we, !0)).finally(() => Nt(this, Se, nr).call(this));
              return;
            }
            if (Oe(this, fe)) {
              const we = Oe(this, fe);
              zt(this, fe, null), this._uiManager.enableWaiting(!0), zt(this, de, this._uiManager.imageManager.getFromUrl(we).then((Ae) => Nt(this, Ee, tr).call(this, Ae)).finally(() => Nt(this, Se, nr).call(this)));
              return;
            }
            if (Oe(this, pe)) {
              const we = Oe(this, pe);
              zt(this, pe, null), this._uiManager.enableWaiting(!0), zt(this, de, this._uiManager.imageManager.getFromFile(we).then((Ae) => Nt(this, Ee, tr).call(this, Ae)).finally(() => Nt(this, Se, nr).call(this)));
              return;
            }
            const ze = document.createElement("input");
            ze.type = "file", ze.accept = Je.supportedTypesStr, zt(this, de, new Promise((we) => {
              ze.addEventListener("change", async () => {
                if (!ze.files || ze.files.length === 0)
                  this.remove();
                else {
                  this._uiManager.enableWaiting(!0);
                  const Ae = await this._uiManager.imageManager.getFromFile(ze.files[0]);
                  Nt(this, Ee, tr).call(this, Ae);
                }
                we();
              }), ze.addEventListener("cancel", () => {
                this.remove(), we();
              });
            }).finally(() => Nt(this, Se, nr).call(this))), ze.click();
          }, De = new WeakSet(), ts = function() {
            const {
              div: ze
            } = this;
            let {
              width: we,
              height: Ae
            } = Oe(this, le);
            const [Re, je] = this.pageDimensions, Fe = 0.75;
            if (this.width)
              we = this.width * Re, Ae = this.height * je;
            else if (we > Fe * Re || Ae > Fe * je) {
              const Ke = Math.min(Fe * Re / we, Fe * je / Ae);
              we *= Ke, Ae *= Ke;
            }
            const [$e, qe] = this.parentDimensions;
            this.setDims(we * $e / Re, Ae * qe / je), this._uiManager.enableWaiting(!1);
            const Ye = zt(this, ye, document.createElement("canvas"));
            ze.append(Ye), ze.hidden = !1, Nt(this, Le, ns).call(this, we, Ae), Nt(this, Ue, Us).call(this), Oe(this, xe) || (this.parent.addUndoableEditor(this), zt(this, xe, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                subtype: this.editorType,
                data: {
                  action: "inserted_image"
                }
              }
            }), this.addAltTextButton();
          }, Ne = new WeakSet(), Fs = function(ze, we) {
            var Fe;
            const [Ae, Re] = this.parentDimensions;
            this.width = ze / Ae, this.height = we / Re, this.setDims(ze, we), (Fe = this._initialOptions) != null && Fe.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, Oe(this, ve) !== null && clearTimeout(Oe(this, ve)), zt(this, ve, setTimeout(() => {
              zt(this, ve, null), Nt(this, Le, ns).call(this, ze, we);
            }, 200));
          }, Be = new WeakSet(), $s = function(ze, we) {
            const {
              width: Ae,
              height: Re
            } = Oe(this, le);
            let je = Ae, Fe = Re, $e = Oe(this, le);
            for (; je > 2 * ze || Fe > 2 * we; ) {
              const qe = je, Ye = Fe;
              je > 2 * ze && (je = je >= 16384 ? Math.floor(je / 2) - 1 : Math.ceil(je / 2)), Fe > 2 * we && (Fe = Fe >= 16384 ? Math.floor(Fe / 2) - 1 : Math.ceil(Fe / 2));
              const Ke = new OffscreenCanvas(je, Fe);
              Ke.getContext("2d").drawImage($e, 0, 0, qe, Ye, 0, 0, je, Fe), $e = Ke.transferToImageBitmap();
            }
            return $e;
          }, Le = new WeakSet(), ns = function(ze, we) {
            ze = Math.ceil(ze), we = Math.ceil(we);
            const Ae = Oe(this, ye);
            if (!Ae || Ae.width === ze && Ae.height === we)
              return;
            Ae.width = ze, Ae.height = we;
            const Re = Oe(this, ge) ? Oe(this, le) : Nt(this, Be, $s).call(this, ze, we), je = Ae.getContext("2d");
            je.filter = this._uiManager.hcmFilter, je.drawImage(Re, 0, 0, Re.width, Re.height, 0, 0, ze, we);
          }, Ge = new WeakSet(), xr = function(ze) {
            if (ze) {
              if (Oe(this, ge)) {
                const Re = this._uiManager.imageManager.getSvgUrl(Oe(this, ue));
                if (Re)
                  return Re;
              }
              const we = document.createElement("canvas");
              return {
                width: we.width,
                height: we.height
              } = Oe(this, le), we.getContext("2d").drawImage(Oe(this, le), 0, 0), we.toDataURL();
            }
            if (Oe(this, ge)) {
              const [we, Ae] = this.pageDimensions, Re = Math.round(this.width * we * se.PixelsPerInch.PDF_TO_CSS_UNITS), je = Math.round(this.height * Ae * se.PixelsPerInch.PDF_TO_CSS_UNITS), Fe = new OffscreenCanvas(Re, je);
              return Fe.getContext("2d").drawImage(Oe(this, le), 0, 0, Oe(this, le).width, Oe(this, le).height, 0, 0, Re, je), Fe.transferToImageBitmap();
            }
            return structuredClone(Oe(this, le));
          }, Ue = new WeakSet(), Us = function() {
            zt(this, me, new ResizeObserver((ze) => {
              const we = ze[0].contentRect;
              we.width && we.height && Nt(this, Ne, Fs).call(this, we.width, we.height);
            })), Oe(this, me).observe(this.div);
          }, On(Je, "_type", "stamp");
          let oe = Je;
          ee.StampEditor = oe;
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__($) {
        var ee = __webpack_module_cache__[$];
        if (ee !== void 0)
          return ee.exports;
        var te = __webpack_module_cache__[$] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[$](te, te.exports, __w_pdfjs_require__), te.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var $ = __webpack_exports__;
        Object.defineProperty($, "__esModule", {
          value: !0
        }), Object.defineProperty($, "AbortException", {
          enumerable: !0,
          get: function() {
            return ee.AbortException;
          }
        }), Object.defineProperty($, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return se.AnnotationEditorLayer;
          }
        }), Object.defineProperty($, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return ee.AnnotationEditorParamsType;
          }
        }), Object.defineProperty($, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return ee.AnnotationEditorType;
          }
        }), Object.defineProperty($, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return ie.AnnotationEditorUIManager;
          }
        }), Object.defineProperty($, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return oe.AnnotationLayer;
          }
        }), Object.defineProperty($, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return ee.AnnotationMode;
          }
        }), Object.defineProperty($, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return ee.CMapCompressionType;
          }
        }), Object.defineProperty($, "DOMSVGFactory", {
          enumerable: !0,
          get: function() {
            return ne.DOMSVGFactory;
          }
        }), Object.defineProperty($, "FeatureTest", {
          enumerable: !0,
          get: function() {
            return ee.FeatureTest;
          }
        }), Object.defineProperty($, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return le.GlobalWorkerOptions;
          }
        }), Object.defineProperty($, "ImageKind", {
          enumerable: !0,
          get: function() {
            return ee.ImageKind;
          }
        }), Object.defineProperty($, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return ee.InvalidPDFException;
          }
        }), Object.defineProperty($, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return ee.MissingPDFException;
          }
        }), Object.defineProperty($, "OPS", {
          enumerable: !0,
          get: function() {
            return ee.OPS;
          }
        }), Object.defineProperty($, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return te.PDFDataRangeTransport;
          }
        }), Object.defineProperty($, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return ne.PDFDateString;
          }
        }), Object.defineProperty($, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return te.PDFWorker;
          }
        }), Object.defineProperty($, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return ee.PasswordResponses;
          }
        }), Object.defineProperty($, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return ee.PermissionFlag;
          }
        }), Object.defineProperty($, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return ne.PixelsPerInch;
          }
        }), Object.defineProperty($, "PromiseCapability", {
          enumerable: !0,
          get: function() {
            return ee.PromiseCapability;
          }
        }), Object.defineProperty($, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return ne.RenderingCancelledException;
          }
        }), Object.defineProperty($, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return te.SVGGraphics;
          }
        }), Object.defineProperty($, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return ee.UnexpectedResponseException;
          }
        }), Object.defineProperty($, "Util", {
          enumerable: !0,
          get: function() {
            return ee.Util;
          }
        }), Object.defineProperty($, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return ee.VerbosityLevel;
          }
        }), Object.defineProperty($, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return ue.XfaLayer;
          }
        }), Object.defineProperty($, "build", {
          enumerable: !0,
          get: function() {
            return te.build;
          }
        }), Object.defineProperty($, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return ee.createValidAbsoluteUrl;
          }
        }), Object.defineProperty($, "getDocument", {
          enumerable: !0,
          get: function() {
            return te.getDocument;
          }
        }), Object.defineProperty($, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ne.getFilenameFromUrl;
          }
        }), Object.defineProperty($, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return ne.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty($, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return ne.getXfaPageViewport;
          }
        }), Object.defineProperty($, "isDataScheme", {
          enumerable: !0,
          get: function() {
            return ne.isDataScheme;
          }
        }), Object.defineProperty($, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return ne.isPdfFile;
          }
        }), Object.defineProperty($, "loadScript", {
          enumerable: !0,
          get: function() {
            return ne.loadScript;
          }
        }), Object.defineProperty($, "noContextMenu", {
          enumerable: !0,
          get: function() {
            return ne.noContextMenu;
          }
        }), Object.defineProperty($, "normalizeUnicode", {
          enumerable: !0,
          get: function() {
            return ee.normalizeUnicode;
          }
        }), Object.defineProperty($, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return re.renderTextLayer;
          }
        }), Object.defineProperty($, "setLayerDimensions", {
          enumerable: !0,
          get: function() {
            return ne.setLayerDimensions;
          }
        }), Object.defineProperty($, "shadow", {
          enumerable: !0,
          get: function() {
            return ee.shadow;
          }
        }), Object.defineProperty($, "updateTextLayer", {
          enumerable: !0,
          get: function() {
            return re.updateTextLayer;
          }
        }), Object.defineProperty($, "version", {
          enumerable: !0,
          get: function() {
            return te.version;
          }
        });
        var ee = __w_pdfjs_require__(1), te = __w_pdfjs_require__(2), ne = __w_pdfjs_require__(6), re = __w_pdfjs_require__(26), se = __w_pdfjs_require__(27), ie = __w_pdfjs_require__(5), oe = __w_pdfjs_require__(29), le = __w_pdfjs_require__(14), ue = __w_pdfjs_require__(32);
      })(), __webpack_exports__;
    })()
  ));
})(pdf$2);
var pdfExports = pdf$2.exports;
const pdf$1 = /* @__PURE__ */ getDefaultExportFromCjs(pdfExports), pdfjsModule = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: pdf$1
}, [pdfExports]), pdfjs = "default" in pdfjsModule ? pdf$1 : pdfjsModule;
var propTypes = { exports: {} }, reactIs$3 = { exports: {} }, reactIs_production_min$2 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$2;
function requireReactIs_production_min$2() {
  if (hasRequiredReactIs_production_min$2)
    return reactIs_production_min$2;
  hasRequiredReactIs_production_min$2 = 1;
  var $ = typeof Symbol == "function" && Symbol.for, ee = $ ? Symbol.for("react.element") : 60103, te = $ ? Symbol.for("react.portal") : 60106, ne = $ ? Symbol.for("react.fragment") : 60107, re = $ ? Symbol.for("react.strict_mode") : 60108, se = $ ? Symbol.for("react.profiler") : 60114, ie = $ ? Symbol.for("react.provider") : 60109, oe = $ ? Symbol.for("react.context") : 60110, le = $ ? Symbol.for("react.async_mode") : 60111, ue = $ ? Symbol.for("react.concurrent_mode") : 60111, de = $ ? Symbol.for("react.forward_ref") : 60112, fe = $ ? Symbol.for("react.suspense") : 60113, pe = $ ? Symbol.for("react.suspense_list") : 60120, ye = $ ? Symbol.for("react.memo") : 60115, me = $ ? Symbol.for("react.lazy") : 60116, ve = $ ? Symbol.for("react.block") : 60121, ge = $ ? Symbol.for("react.fundamental") : 60117, xe = $ ? Symbol.for("react.responder") : 60118, Ee = $ ? Symbol.for("react.scope") : 60119;
  function Te(he) {
    if (typeof he == "object" && he !== null) {
      var Pe = he.$$typeof;
      switch (Pe) {
        case ee:
          switch (he = he.type, he) {
            case le:
            case ue:
            case ne:
            case se:
            case re:
            case fe:
              return he;
            default:
              switch (he = he && he.$$typeof, he) {
                case oe:
                case de:
                case me:
                case ye:
                case ie:
                  return he;
                default:
                  return Pe;
              }
          }
        case te:
          return Pe;
      }
    }
  }
  function Se(he) {
    return Te(he) === ue;
  }
  return reactIs_production_min$2.AsyncMode = le, reactIs_production_min$2.ConcurrentMode = ue, reactIs_production_min$2.ContextConsumer = oe, reactIs_production_min$2.ContextProvider = ie, reactIs_production_min$2.Element = ee, reactIs_production_min$2.ForwardRef = de, reactIs_production_min$2.Fragment = ne, reactIs_production_min$2.Lazy = me, reactIs_production_min$2.Memo = ye, reactIs_production_min$2.Portal = te, reactIs_production_min$2.Profiler = se, reactIs_production_min$2.StrictMode = re, reactIs_production_min$2.Suspense = fe, reactIs_production_min$2.isAsyncMode = function(he) {
    return Se(he) || Te(he) === le;
  }, reactIs_production_min$2.isConcurrentMode = Se, reactIs_production_min$2.isContextConsumer = function(he) {
    return Te(he) === oe;
  }, reactIs_production_min$2.isContextProvider = function(he) {
    return Te(he) === ie;
  }, reactIs_production_min$2.isElement = function(he) {
    return typeof he == "object" && he !== null && he.$$typeof === ee;
  }, reactIs_production_min$2.isForwardRef = function(he) {
    return Te(he) === de;
  }, reactIs_production_min$2.isFragment = function(he) {
    return Te(he) === ne;
  }, reactIs_production_min$2.isLazy = function(he) {
    return Te(he) === me;
  }, reactIs_production_min$2.isMemo = function(he) {
    return Te(he) === ye;
  }, reactIs_production_min$2.isPortal = function(he) {
    return Te(he) === te;
  }, reactIs_production_min$2.isProfiler = function(he) {
    return Te(he) === se;
  }, reactIs_production_min$2.isStrictMode = function(he) {
    return Te(he) === re;
  }, reactIs_production_min$2.isSuspense = function(he) {
    return Te(he) === fe;
  }, reactIs_production_min$2.isValidElementType = function(he) {
    return typeof he == "string" || typeof he == "function" || he === ne || he === ue || he === se || he === re || he === fe || he === pe || typeof he == "object" && he !== null && (he.$$typeof === me || he.$$typeof === ye || he.$$typeof === ie || he.$$typeof === oe || he.$$typeof === de || he.$$typeof === ge || he.$$typeof === xe || he.$$typeof === Ee || he.$$typeof === ve);
  }, reactIs_production_min$2.typeOf = Te, reactIs_production_min$2;
}
var reactIs_development$2 = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$2;
function requireReactIs_development$2() {
  return hasRequiredReactIs_development$2 || (hasRequiredReactIs_development$2 = 1, process.env.NODE_ENV !== "production" && function() {
    var $ = typeof Symbol == "function" && Symbol.for, ee = $ ? Symbol.for("react.element") : 60103, te = $ ? Symbol.for("react.portal") : 60106, ne = $ ? Symbol.for("react.fragment") : 60107, re = $ ? Symbol.for("react.strict_mode") : 60108, se = $ ? Symbol.for("react.profiler") : 60114, ie = $ ? Symbol.for("react.provider") : 60109, oe = $ ? Symbol.for("react.context") : 60110, le = $ ? Symbol.for("react.async_mode") : 60111, ue = $ ? Symbol.for("react.concurrent_mode") : 60111, de = $ ? Symbol.for("react.forward_ref") : 60112, fe = $ ? Symbol.for("react.suspense") : 60113, pe = $ ? Symbol.for("react.suspense_list") : 60120, ye = $ ? Symbol.for("react.memo") : 60115, me = $ ? Symbol.for("react.lazy") : 60116, ve = $ ? Symbol.for("react.block") : 60121, ge = $ ? Symbol.for("react.fundamental") : 60117, xe = $ ? Symbol.for("react.responder") : 60118, Ee = $ ? Symbol.for("react.scope") : 60119;
    function Te(Ke) {
      return typeof Ke == "string" || typeof Ke == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Ke === ne || Ke === ue || Ke === se || Ke === re || Ke === fe || Ke === pe || typeof Ke == "object" && Ke !== null && (Ke.$$typeof === me || Ke.$$typeof === ye || Ke.$$typeof === ie || Ke.$$typeof === oe || Ke.$$typeof === de || Ke.$$typeof === ge || Ke.$$typeof === xe || Ke.$$typeof === Ee || Ke.$$typeof === ve);
    }
    function Se(Ke) {
      if (typeof Ke == "object" && Ke !== null) {
        var Tt = Ke.$$typeof;
        switch (Tt) {
          case ee:
            var pt = Ke.type;
            switch (pt) {
              case le:
              case ue:
              case ne:
              case se:
              case re:
              case fe:
                return pt;
              default:
                var Bt = pt && pt.$$typeof;
                switch (Bt) {
                  case oe:
                  case de:
                  case me:
                  case ye:
                  case ie:
                    return Bt;
                  default:
                    return Tt;
                }
            }
          case te:
            return Tt;
        }
      }
    }
    var he = le, Pe = ue, Ie = oe, De = ie, Ce = ee, Ne = de, Me = ne, Be = me, We = ye, Le = te, He = se, Ge = re, Ze = fe, Ue = !1;
    function Qe(Ke) {
      return Ue || (Ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Je(Ke) || Se(Ke) === le;
    }
    function Je(Ke) {
      return Se(Ke) === ue;
    }
    function Ot(Ke) {
      return Se(Ke) === oe;
    }
    function At(Ke) {
      return Se(Ke) === ie;
    }
    function ze(Ke) {
      return typeof Ke == "object" && Ke !== null && Ke.$$typeof === ee;
    }
    function we(Ke) {
      return Se(Ke) === de;
    }
    function Ae(Ke) {
      return Se(Ke) === ne;
    }
    function Re(Ke) {
      return Se(Ke) === me;
    }
    function je(Ke) {
      return Se(Ke) === ye;
    }
    function Fe(Ke) {
      return Se(Ke) === te;
    }
    function $e(Ke) {
      return Se(Ke) === se;
    }
    function qe(Ke) {
      return Se(Ke) === re;
    }
    function Ye(Ke) {
      return Se(Ke) === fe;
    }
    reactIs_development$2.AsyncMode = he, reactIs_development$2.ConcurrentMode = Pe, reactIs_development$2.ContextConsumer = Ie, reactIs_development$2.ContextProvider = De, reactIs_development$2.Element = Ce, reactIs_development$2.ForwardRef = Ne, reactIs_development$2.Fragment = Me, reactIs_development$2.Lazy = Be, reactIs_development$2.Memo = We, reactIs_development$2.Portal = Le, reactIs_development$2.Profiler = He, reactIs_development$2.StrictMode = Ge, reactIs_development$2.Suspense = Ze, reactIs_development$2.isAsyncMode = Qe, reactIs_development$2.isConcurrentMode = Je, reactIs_development$2.isContextConsumer = Ot, reactIs_development$2.isContextProvider = At, reactIs_development$2.isElement = ze, reactIs_development$2.isForwardRef = we, reactIs_development$2.isFragment = Ae, reactIs_development$2.isLazy = Re, reactIs_development$2.isMemo = je, reactIs_development$2.isPortal = Fe, reactIs_development$2.isProfiler = $e, reactIs_development$2.isStrictMode = qe, reactIs_development$2.isSuspense = Ye, reactIs_development$2.isValidElementType = Te, reactIs_development$2.typeOf = Se;
  }()), reactIs_development$2;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === "production" ? reactIs$3.exports = requireReactIs_production_min$2() : reactIs$3.exports = requireReactIs_development$2()), reactIs$3.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var $ = Object.getOwnPropertySymbols, ee = Object.prototype.hasOwnProperty, te = Object.prototype.propertyIsEnumerable;
  function ne(se) {
    if (se == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(se);
  }
  function re() {
    try {
      if (!Object.assign)
        return !1;
      var se = new String("abc");
      if (se[5] = "de", Object.getOwnPropertyNames(se)[0] === "5")
        return !1;
      for (var ie = {}, oe = 0; oe < 10; oe++)
        ie["_" + String.fromCharCode(oe)] = oe;
      var le = Object.getOwnPropertyNames(ie).map(function(de) {
        return ie[de];
      });
      if (le.join("") !== "0123456789")
        return !1;
      var ue = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(de) {
        ue[de] = de;
      }), Object.keys(Object.assign({}, ue)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = re() ? Object.assign : function(se, ie) {
    for (var oe, le = ne(se), ue, de = 1; de < arguments.length; de++) {
      oe = Object(arguments[de]);
      for (var fe in oe)
        ee.call(oe, fe) && (le[fe] = oe[fe]);
      if ($) {
        ue = $(oe);
        for (var pe = 0; pe < ue.length; pe++)
          te.call(oe, ue[pe]) && (le[ue[pe]] = oe[ue[pe]]);
      }
    }
    return le;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var $ = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = $, ReactPropTypesSecret_1;
}
var has$1, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has$1 = Function.call.bind(Object.prototype.hasOwnProperty)), has$1;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var $ = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var ee = requireReactPropTypesSecret(), te = {}, ne = requireHas();
    $ = function(se) {
      var ie = "Warning: " + se;
      typeof console < "u" && console.error(ie);
      try {
        throw new Error(ie);
      } catch {
      }
    };
  }
  function re(se, ie, oe, le, ue) {
    if (process.env.NODE_ENV !== "production") {
      for (var de in se)
        if (ne(se, de)) {
          var fe;
          try {
            if (typeof se[de] != "function") {
              var pe = Error(
                (le || "React class") + ": " + oe + " type `" + de + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof se[de] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw pe.name = "Invariant Violation", pe;
            }
            fe = se[de](ie, de, le, oe, null, ee);
          } catch (me) {
            fe = me;
          }
          if (fe && !(fe instanceof Error) && $(
            (le || "React class") + ": type specification of " + oe + " `" + de + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof fe + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), fe instanceof Error && !(fe.message in te)) {
            te[fe.message] = !0;
            var ye = ue ? ue() : "";
            $(
              "Failed " + oe + " type: " + fe.message + (ye ?? "")
            );
          }
        }
    }
  }
  return re.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (te = {});
  }, checkPropTypes_1 = re, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var $ = requireReactIs(), ee = requireObjectAssign(), te = requireReactPropTypesSecret(), ne = requireHas(), re = requireCheckPropTypes(), se = function() {
  };
  process.env.NODE_ENV !== "production" && (se = function(oe) {
    var le = "Warning: " + oe;
    typeof console < "u" && console.error(le);
    try {
      throw new Error(le);
    } catch {
    }
  });
  function ie() {
    return null;
  }
  return factoryWithTypeCheckers = function(oe, le) {
    var ue = typeof Symbol == "function" && Symbol.iterator, de = "@@iterator";
    function fe(Je) {
      var Ot = Je && (ue && Je[ue] || Je[de]);
      if (typeof Ot == "function")
        return Ot;
    }
    var pe = "<<anonymous>>", ye = {
      array: xe("array"),
      bigint: xe("bigint"),
      bool: xe("boolean"),
      func: xe("function"),
      number: xe("number"),
      object: xe("object"),
      string: xe("string"),
      symbol: xe("symbol"),
      any: Ee(),
      arrayOf: Te,
      element: Se(),
      elementType: he(),
      instanceOf: Pe,
      node: Ne(),
      objectOf: De,
      oneOf: Ie,
      oneOfType: Ce,
      shape: Be,
      exact: We
    };
    function me(Je, Ot) {
      return Je === Ot ? Je !== 0 || 1 / Je === 1 / Ot : Je !== Je && Ot !== Ot;
    }
    function ve(Je, Ot) {
      this.message = Je, this.data = Ot && typeof Ot == "object" ? Ot : {}, this.stack = "";
    }
    ve.prototype = Error.prototype;
    function ge(Je) {
      if (process.env.NODE_ENV !== "production")
        var Ot = {}, At = 0;
      function ze(Ae, Re, je, Fe, $e, qe, Ye) {
        if (Fe = Fe || pe, qe = qe || je, Ye !== te) {
          if (le) {
            var Ke = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Ke.name = "Invariant Violation", Ke;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Tt = Fe + ":" + je;
            !Ot[Tt] && // Avoid spamming the console because they are often not actionable except for lib authors
            At < 3 && (se(
              "You are manually calling a React.PropTypes validation function for the `" + qe + "` prop on `" + Fe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Ot[Tt] = !0, At++);
          }
        }
        return Re[je] == null ? Ae ? Re[je] === null ? new ve("The " + $e + " `" + qe + "` is marked as required " + ("in `" + Fe + "`, but its value is `null`.")) : new ve("The " + $e + " `" + qe + "` is marked as required in " + ("`" + Fe + "`, but its value is `undefined`.")) : null : Je(Re, je, Fe, $e, qe);
      }
      var we = ze.bind(null, !1);
      return we.isRequired = ze.bind(null, !0), we;
    }
    function xe(Je) {
      function Ot(At, ze, we, Ae, Re, je) {
        var Fe = At[ze], $e = Ge(Fe);
        if ($e !== Je) {
          var qe = Ze(Fe);
          return new ve(
            "Invalid " + Ae + " `" + Re + "` of type " + ("`" + qe + "` supplied to `" + we + "`, expected ") + ("`" + Je + "`."),
            { expectedType: Je }
          );
        }
        return null;
      }
      return ge(Ot);
    }
    function Ee() {
      return ge(ie);
    }
    function Te(Je) {
      function Ot(At, ze, we, Ae, Re) {
        if (typeof Je != "function")
          return new ve("Property `" + Re + "` of component `" + we + "` has invalid PropType notation inside arrayOf.");
        var je = At[ze];
        if (!Array.isArray(je)) {
          var Fe = Ge(je);
          return new ve("Invalid " + Ae + " `" + Re + "` of type " + ("`" + Fe + "` supplied to `" + we + "`, expected an array."));
        }
        for (var $e = 0; $e < je.length; $e++) {
          var qe = Je(je, $e, we, Ae, Re + "[" + $e + "]", te);
          if (qe instanceof Error)
            return qe;
        }
        return null;
      }
      return ge(Ot);
    }
    function Se() {
      function Je(Ot, At, ze, we, Ae) {
        var Re = Ot[At];
        if (!oe(Re)) {
          var je = Ge(Re);
          return new ve("Invalid " + we + " `" + Ae + "` of type " + ("`" + je + "` supplied to `" + ze + "`, expected a single ReactElement."));
        }
        return null;
      }
      return ge(Je);
    }
    function he() {
      function Je(Ot, At, ze, we, Ae) {
        var Re = Ot[At];
        if (!$.isValidElementType(Re)) {
          var je = Ge(Re);
          return new ve("Invalid " + we + " `" + Ae + "` of type " + ("`" + je + "` supplied to `" + ze + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return ge(Je);
    }
    function Pe(Je) {
      function Ot(At, ze, we, Ae, Re) {
        if (!(At[ze] instanceof Je)) {
          var je = Je.name || pe, Fe = Qe(At[ze]);
          return new ve("Invalid " + Ae + " `" + Re + "` of type " + ("`" + Fe + "` supplied to `" + we + "`, expected ") + ("instance of `" + je + "`."));
        }
        return null;
      }
      return ge(Ot);
    }
    function Ie(Je) {
      if (!Array.isArray(Je))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? se(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : se("Invalid argument supplied to oneOf, expected an array.")), ie;
      function Ot(At, ze, we, Ae, Re) {
        for (var je = At[ze], Fe = 0; Fe < Je.length; Fe++)
          if (me(je, Je[Fe]))
            return null;
        var $e = JSON.stringify(Je, function(Ye, Ke) {
          var Tt = Ze(Ke);
          return Tt === "symbol" ? String(Ke) : Ke;
        });
        return new ve("Invalid " + Ae + " `" + Re + "` of value `" + String(je) + "` " + ("supplied to `" + we + "`, expected one of " + $e + "."));
      }
      return ge(Ot);
    }
    function De(Je) {
      function Ot(At, ze, we, Ae, Re) {
        if (typeof Je != "function")
          return new ve("Property `" + Re + "` of component `" + we + "` has invalid PropType notation inside objectOf.");
        var je = At[ze], Fe = Ge(je);
        if (Fe !== "object")
          return new ve("Invalid " + Ae + " `" + Re + "` of type " + ("`" + Fe + "` supplied to `" + we + "`, expected an object."));
        for (var $e in je)
          if (ne(je, $e)) {
            var qe = Je(je, $e, we, Ae, Re + "." + $e, te);
            if (qe instanceof Error)
              return qe;
          }
        return null;
      }
      return ge(Ot);
    }
    function Ce(Je) {
      if (!Array.isArray(Je))
        return process.env.NODE_ENV !== "production" && se("Invalid argument supplied to oneOfType, expected an instance of array."), ie;
      for (var Ot = 0; Ot < Je.length; Ot++) {
        var At = Je[Ot];
        if (typeof At != "function")
          return se(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Ue(At) + " at index " + Ot + "."
          ), ie;
      }
      function ze(we, Ae, Re, je, Fe) {
        for (var $e = [], qe = 0; qe < Je.length; qe++) {
          var Ye = Je[qe], Ke = Ye(we, Ae, Re, je, Fe, te);
          if (Ke == null)
            return null;
          Ke.data && ne(Ke.data, "expectedType") && $e.push(Ke.data.expectedType);
        }
        var Tt = $e.length > 0 ? ", expected one of type [" + $e.join(", ") + "]" : "";
        return new ve("Invalid " + je + " `" + Fe + "` supplied to " + ("`" + Re + "`" + Tt + "."));
      }
      return ge(ze);
    }
    function Ne() {
      function Je(Ot, At, ze, we, Ae) {
        return Le(Ot[At]) ? null : new ve("Invalid " + we + " `" + Ae + "` supplied to " + ("`" + ze + "`, expected a ReactNode."));
      }
      return ge(Je);
    }
    function Me(Je, Ot, At, ze, we) {
      return new ve(
        (Je || "React class") + ": " + Ot + " type `" + At + "." + ze + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + we + "`."
      );
    }
    function Be(Je) {
      function Ot(At, ze, we, Ae, Re) {
        var je = At[ze], Fe = Ge(je);
        if (Fe !== "object")
          return new ve("Invalid " + Ae + " `" + Re + "` of type `" + Fe + "` " + ("supplied to `" + we + "`, expected `object`."));
        for (var $e in Je) {
          var qe = Je[$e];
          if (typeof qe != "function")
            return Me(we, Ae, Re, $e, Ze(qe));
          var Ye = qe(je, $e, we, Ae, Re + "." + $e, te);
          if (Ye)
            return Ye;
        }
        return null;
      }
      return ge(Ot);
    }
    function We(Je) {
      function Ot(At, ze, we, Ae, Re) {
        var je = At[ze], Fe = Ge(je);
        if (Fe !== "object")
          return new ve("Invalid " + Ae + " `" + Re + "` of type `" + Fe + "` " + ("supplied to `" + we + "`, expected `object`."));
        var $e = ee({}, At[ze], Je);
        for (var qe in $e) {
          var Ye = Je[qe];
          if (ne(Je, qe) && typeof Ye != "function")
            return Me(we, Ae, Re, qe, Ze(Ye));
          if (!Ye)
            return new ve(
              "Invalid " + Ae + " `" + Re + "` key `" + qe + "` supplied to `" + we + "`.\nBad object: " + JSON.stringify(At[ze], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(Je), null, "  ")
            );
          var Ke = Ye(je, qe, we, Ae, Re + "." + qe, te);
          if (Ke)
            return Ke;
        }
        return null;
      }
      return ge(Ot);
    }
    function Le(Je) {
      switch (typeof Je) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !Je;
        case "object":
          if (Array.isArray(Je))
            return Je.every(Le);
          if (Je === null || oe(Je))
            return !0;
          var Ot = fe(Je);
          if (Ot) {
            var At = Ot.call(Je), ze;
            if (Ot !== Je.entries) {
              for (; !(ze = At.next()).done; )
                if (!Le(ze.value))
                  return !1;
            } else
              for (; !(ze = At.next()).done; ) {
                var we = ze.value;
                if (we && !Le(we[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function He(Je, Ot) {
      return Je === "symbol" ? !0 : Ot ? Ot["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Ot instanceof Symbol : !1;
    }
    function Ge(Je) {
      var Ot = typeof Je;
      return Array.isArray(Je) ? "array" : Je instanceof RegExp ? "object" : He(Ot, Je) ? "symbol" : Ot;
    }
    function Ze(Je) {
      if (typeof Je > "u" || Je === null)
        return "" + Je;
      var Ot = Ge(Je);
      if (Ot === "object") {
        if (Je instanceof Date)
          return "date";
        if (Je instanceof RegExp)
          return "regexp";
      }
      return Ot;
    }
    function Ue(Je) {
      var Ot = Ze(Je);
      switch (Ot) {
        case "array":
        case "object":
          return "an " + Ot;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Ot;
        default:
          return Ot;
      }
    }
    function Qe(Je) {
      return !Je.constructor || !Je.constructor.name ? pe : Je.constructor.name;
    }
    return ye.checkPropTypes = re, ye.resetWarningCache = re.resetWarningCache, ye.PropTypes = ye, ye;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var $ = requireReactPropTypesSecret();
  function ee() {
  }
  function te() {
  }
  return te.resetWarningCache = ee, factoryWithThrowingShims = function() {
    function ne(ie, oe, le, ue, de, fe) {
      if (fe !== $) {
        var pe = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw pe.name = "Invariant Violation", pe;
      }
    }
    ne.isRequired = ne;
    function re() {
      return ne;
    }
    var se = {
      array: ne,
      bigint: ne,
      bool: ne,
      func: ne,
      number: ne,
      object: ne,
      string: ne,
      symbol: ne,
      any: ne,
      arrayOf: re,
      element: ne,
      elementType: ne,
      instanceOf: re,
      node: ne,
      objectOf: re,
      oneOf: re,
      oneOfType: re,
      shape: re,
      exact: re,
      checkPropTypes: te,
      resetWarningCache: ee
    };
    return se.PropTypes = se, se;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var __spreadArray = function($, ee, te) {
  if (te || arguments.length === 2)
    for (var ne = 0, re = ee.length, se; ne < re; ne++)
      (se || !(ne in ee)) && (se || (se = Array.prototype.slice.call(ee, 0, ne)), se[ne] = ee[ne]);
  return $.concat(se || Array.prototype.slice.call(ee));
}, clipboardEvents = ["onCopy", "onCut", "onPaste"], compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], focusEvents = ["onFocus", "onBlur"], formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"], imageEvents = ["onLoad", "onError"], keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"], mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], dragEvents = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
], selectionEvents = ["onSelect"], touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], uiEvents = ["onScroll"], wheelEvents = ["onWheel"], animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], transitionEvents = ["onTransitionEnd"], otherEvents = ["onToggle"], changeEvents = ["onChange"], allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, !0), compositionEvents, !0), focusEvents, !0), formEvents, !0), imageEvents, !0), keyboardEvents, !0), mediaEvents, !0), mouseEvents, !0), dragEvents, !0), selectionEvents, !0), touchEvents, !0), pointerEvents, !0), uiEvents, !0), wheelEvents, !0), animationEvents, !0), transitionEvents, !0), changeEvents, !0), otherEvents, !0);
function makeEventProps($, ee) {
  var te = {};
  return allEvents.forEach(function(ne) {
    var re = $[ne];
    re && (ee ? te[ne] = function(se) {
      return re(se, ee(ne));
    } : te[ne] = re);
  }), te;
}
function makeCancellablePromise($) {
  var ee = !1, te = new Promise(function(ne, re) {
    $.then(function(se) {
      return !ee && ne(se);
    }).catch(function(se) {
      return !ee && re(se);
    });
  });
  return {
    promise: te,
    cancel: function() {
      ee = !0;
    }
  };
}
function r$1($) {
  var ee, te, ne = "";
  if (typeof $ == "string" || typeof $ == "number")
    ne += $;
  else if (typeof $ == "object")
    if (Array.isArray($)) {
      var re = $.length;
      for (ee = 0; ee < re; ee++)
        $[ee] && (te = r$1($[ee])) && (ne && (ne += " "), ne += te);
    } else
      for (te in $)
        $[te] && (ne && (ne += " "), ne += te);
  return ne;
}
function clsx() {
  for (var $, ee, te = 0, ne = "", re = arguments.length; te < re; te++)
    ($ = arguments[te]) && (ee = r$1($)) && (ne && (ne += " "), ne += ee);
  return ne;
}
var isProduction = process.env.NODE_ENV === "production", prefix$1 = "Invariant failed";
function invariant$3($, ee) {
  if (!$) {
    if (isProduction)
      throw new Error(prefix$1);
    var te = typeof ee == "function" ? ee() : ee, ne = te ? "".concat(prefix$1, ": ").concat(te) : prefix$1;
    throw new Error(ne);
  }
}
var __DEV__ = process.env.NODE_ENV !== "production", warning$1 = function() {
};
if (__DEV__) {
  var printWarning = function(ee, te) {
    var ne = arguments.length;
    te = new Array(ne > 1 ? ne - 1 : 0);
    for (var re = 1; re < ne; re++)
      te[re - 1] = arguments[re];
    var se = 0, ie = "Warning: " + ee.replace(/%s/g, function() {
      return te[se++];
    });
    typeof console < "u" && console.error(ie);
    try {
      throw new Error(ie);
    } catch {
    }
  };
  warning$1 = function($, ee, te) {
    var ne = arguments.length;
    te = new Array(ne > 2 ? ne - 2 : 0);
    for (var re = 2; re < ne; re++)
      te[re - 2] = arguments[re];
    if (ee === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    $ || printWarning.apply(null, [ee].concat(te));
  };
}
var warning_1 = warning$1;
const warning$2 = /* @__PURE__ */ getDefaultExportFromCjs(warning_1);
var has = Object.prototype.hasOwnProperty;
function find($, ee, te) {
  for (te of $.keys())
    if (dequal(te, ee))
      return te;
}
function dequal($, ee) {
  var te, ne, re;
  if ($ === ee)
    return !0;
  if ($ && ee && (te = $.constructor) === ee.constructor) {
    if (te === Date)
      return $.getTime() === ee.getTime();
    if (te === RegExp)
      return $.toString() === ee.toString();
    if (te === Array) {
      if ((ne = $.length) === ee.length)
        for (; ne-- && dequal($[ne], ee[ne]); )
          ;
      return ne === -1;
    }
    if (te === Set) {
      if ($.size !== ee.size)
        return !1;
      for (ne of $)
        if (re = ne, re && typeof re == "object" && (re = find(ee, re), !re) || !ee.has(re))
          return !1;
      return !0;
    }
    if (te === Map) {
      if ($.size !== ee.size)
        return !1;
      for (ne of $)
        if (re = ne[0], re && typeof re == "object" && (re = find(ee, re), !re) || !dequal(ne[1], ee.get(re)))
          return !1;
      return !0;
    }
    if (te === ArrayBuffer)
      $ = new Uint8Array($), ee = new Uint8Array(ee);
    else if (te === DataView) {
      if ((ne = $.byteLength) === ee.byteLength)
        for (; ne-- && $.getInt8(ne) === ee.getInt8(ne); )
          ;
      return ne === -1;
    }
    if (ArrayBuffer.isView($)) {
      if ((ne = $.byteLength) === ee.byteLength)
        for (; ne-- && $[ne] === ee[ne]; )
          ;
      return ne === -1;
    }
    if (!te || typeof $ == "object") {
      ne = 0;
      for (te in $)
        if (has.call($, te) && ++ne && !has.call(ee, te) || !(te in ee) || !dequal($[te], ee[te]))
          return !1;
      return Object.keys(ee).length === ne;
    }
  }
  return $ !== $ && ee !== ee;
}
const DocumentContext = createContext(null);
function Message({ children: $, type: ee }) {
  return React__default.createElement("div", { className: `react-pdf__message react-pdf__message--${ee}` }, $);
}
const DEFAULT_LINK_REL = "noopener noreferrer nofollow";
class LinkService {
  constructor() {
    this.externalLinkEnabled = !0, this.externalLinkRel = void 0, this.externalLinkTarget = void 0, this.isInPresentationMode = !1, this.pdfDocument = void 0, this.pdfViewer = void 0;
  }
  setDocument(ee) {
    this.pdfDocument = ee;
  }
  setViewer(ee) {
    this.pdfViewer = ee;
  }
  setExternalLinkRel(ee) {
    this.externalLinkRel = ee;
  }
  setExternalLinkTarget(ee) {
    this.externalLinkTarget = ee;
  }
  setHistory() {
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return invariant$3(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber || 0;
  }
  set page(ee) {
    invariant$3(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber = ee;
  }
  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
  get rotation() {
    return 0;
  }
  set rotation(ee) {
  }
  goToDestination(ee) {
    return new Promise((te) => {
      invariant$3(this.pdfDocument, "PDF document not loaded."), invariant$3(ee, "Destination is not specified."), typeof ee == "string" ? this.pdfDocument.getDestination(ee).then(te) : Array.isArray(ee) ? te(ee) : ee.then(te);
    }).then((te) => {
      invariant$3(Array.isArray(te), `"${te}" is not a valid destination array.`);
      const ne = te[0];
      new Promise((re) => {
        invariant$3(this.pdfDocument, "PDF document not loaded."), ne instanceof Object ? this.pdfDocument.getPageIndex(ne).then((se) => {
          re(se);
        }).catch(() => {
          invariant$3(!1, `"${ne}" is not a valid page reference.`);
        }) : typeof ne == "number" ? re(ne) : invariant$3(!1, `"${ne}" is not a valid destination reference.`);
      }).then((re) => {
        const se = re + 1;
        invariant$3(this.pdfViewer, "PDF viewer is not initialized."), invariant$3(se >= 1 && se <= this.pagesCount, `"${se}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
          dest: te,
          pageIndex: re,
          pageNumber: se
        });
      });
    });
  }
  navigateTo(ee) {
    this.goToDestination(ee);
  }
  goToPage(ee) {
    const te = ee - 1;
    invariant$3(this.pdfViewer, "PDF viewer is not initialized."), invariant$3(ee >= 1 && ee <= this.pagesCount, `"${ee}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
      pageIndex: te,
      pageNumber: ee
    });
  }
  addLinkAttributes(ee, te, ne) {
    ee.href = te, ee.rel = this.externalLinkRel || DEFAULT_LINK_REL, ee.target = ne ? "_blank" : this.externalLinkTarget || "";
  }
  getDestinationHash() {
    return "#";
  }
  getAnchorUrl() {
    return "#";
  }
  setHash() {
  }
  executeNamedAction() {
  }
  cachePageRef() {
  }
  isPageVisible() {
    return !0;
  }
  isPageCached() {
    return !0;
  }
  executeSetOCGState() {
  }
}
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
}, isBrowser$4 = typeof document < "u", isLocalFileSystem = isBrowser$4 && window.location.protocol === "file:";
function isDefined($) {
  return typeof $ < "u";
}
function isProvided($) {
  return isDefined($) && $ !== null;
}
function isString($) {
  return typeof $ == "string";
}
function isArrayBuffer$1($) {
  return $ instanceof ArrayBuffer;
}
function isBlob($) {
  return invariant$3(isBrowser$4, "isBlob can only be used in a browser environment"), $ instanceof Blob;
}
function isDataURI($) {
  return isString($) && /^data:/.test($);
}
function dataURItoByteString($) {
  invariant$3(isDataURI($), "Invalid data URI.");
  const [ee = "", te = ""] = $.split(",");
  return ee.split(";").indexOf("base64") !== -1 ? atob(te) : unescape(te);
}
function getDevicePixelRatio() {
  return isBrowser$4 && window.devicePixelRatio || 1;
}
const allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayCORSWarning() {
  warning$2(!isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function displayWorkerWarning() {
  warning$2(!isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function cancelRunningTask($) {
  $ && $.cancel && $.cancel();
}
function makePageCallback($, ee) {
  return Object.defineProperty($, "width", {
    get() {
      return this.view[2] * ee;
    },
    configurable: !0
  }), Object.defineProperty($, "height", {
    get() {
      return this.view[3] * ee;
    },
    configurable: !0
  }), Object.defineProperty($, "originalWidth", {
    get() {
      return this.view[2];
    },
    configurable: !0
  }), Object.defineProperty($, "originalHeight", {
    get() {
      return this.view[3];
    },
    configurable: !0
  }), $;
}
function isCancelException($) {
  return $.name === "RenderingCancelledException";
}
function loadFromFile($) {
  return new Promise((ee, te) => {
    const ne = new FileReader();
    ne.onload = () => {
      if (!ne.result)
        return te(new Error("Error while reading a file."));
      ee(ne.result);
    }, ne.onerror = (re) => {
      if (!re.target)
        return te(new Error("Error while reading a file."));
      const { error: se } = re.target;
      if (!se)
        return te(new Error("Error while reading a file."));
      switch (se.code) {
        case se.NOT_FOUND_ERR:
          return te(new Error("Error while reading a file: File not found."));
        case se.SECURITY_ERR:
          return te(new Error("Error while reading a file: Security error."));
        case se.ABORT_ERR:
          return te(new Error("Error while reading a file: Aborted."));
        default:
          return te(new Error("Error while reading a file."));
      }
    }, ne.readAsArrayBuffer($);
  });
}
function reducer($, ee) {
  switch (ee.type) {
    case "RESOLVE":
      return { value: ee.value, error: void 0 };
    case "REJECT":
      return { value: !1, error: ee.error };
    case "RESET":
      return { value: void 0, error: void 0 };
    default:
      return $;
  }
}
function useResolver() {
  return useReducer(reducer, { value: void 0, error: void 0 });
}
const { PDFDataRangeTransport: PDFDataRangeTransport$1 } = pdfjs, eventProps = (() => {
  const $ = {};
  return allEvents.forEach((ee) => {
    $[ee] = PropTypes.func;
  }), $;
})(), isTypedArray = PropTypes.oneOfType([
  PropTypes.instanceOf(Int8Array),
  PropTypes.instanceOf(Uint8Array),
  PropTypes.instanceOf(Uint8ClampedArray),
  PropTypes.instanceOf(Int16Array),
  PropTypes.instanceOf(Uint16Array),
  PropTypes.instanceOf(Int32Array),
  PropTypes.instanceOf(Uint32Array),
  PropTypes.instanceOf(Float32Array),
  PropTypes.instanceOf(Float64Array)
]), fileTypes = [
  PropTypes.string,
  PropTypes.instanceOf(ArrayBuffer),
  PropTypes.shape({
    data: PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.instanceOf(ArrayBuffer),
      PropTypes.arrayOf(PropTypes.number.isRequired),
      isTypedArray
    ]).isRequired
  }),
  PropTypes.shape({
    range: PropTypes.instanceOf(PDFDataRangeTransport$1).isRequired
  }),
  PropTypes.shape({
    url: PropTypes.string.isRequired
  })
];
typeof Blob < "u" && fileTypes.push(PropTypes.instanceOf(Blob));
const isClassName = PropTypes.oneOfType([
  PropTypes.string,
  PropTypes.arrayOf(PropTypes.string)
]), isFile = PropTypes.oneOfType(fileTypes);
PropTypes.instanceOf(LinkService);
PropTypes.oneOf(["_self", "_blank", "_parent", "_top"]);
PropTypes.shape({
  commonObjs: PropTypes.shape({}).isRequired,
  getAnnotations: PropTypes.func.isRequired,
  getTextContent: PropTypes.func.isRequired,
  getViewport: PropTypes.func.isRequired,
  render: PropTypes.func.isRequired
});
const isPageIndex = function $(ee, te, ne) {
  const { [te]: re, pageNumber: se, pdf: ie } = ee;
  if (!isDefined(ie))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error(`\`${te}\` of type \`${typeof re}\` supplied to \`${ne}\`, expected \`number\`.`);
    if (re < 0)
      return new Error(`Expected \`${te}\` to be greater or equal to 0.`);
    const { numPages: oe } = ie;
    if (re + 1 > oe)
      return new Error(`Expected \`${te}\` to be less or equal to ${oe - 1}.`);
  } else if (!isDefined(se))
    return new Error(`\`${te}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${ne}\`.`);
  return null;
}, isPageNumber = function $(ee, te, ne) {
  const { [te]: re, pageIndex: se, pdf: ie } = ee;
  if (!isDefined(ie))
    return null;
  if (isDefined(re)) {
    if (typeof re != "number")
      return new Error(`\`${te}\` of type \`${typeof re}\` supplied to \`${ne}\`, expected \`number\`.`);
    if (re < 1)
      return new Error(`Expected \`${te}\` to be greater or equal to 1.`);
    const { numPages: oe } = ie;
    if (re > oe)
      return new Error(`Expected \`${te}\` to be less or equal to ${oe}.`);
  } else if (!isDefined(se))
    return new Error(`\`${te}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${ne}\`.`);
  return null;
}, isPdf = PropTypes.oneOfType([
  // Ideally, this would be `PropTypes.instanceOf(PDFDocumentProxy)`, but it can't be imported.
  PropTypes.any,
  PropTypes.oneOf([!1])
]), isRef = PropTypes.oneOfType([
  PropTypes.func,
  PropTypes.exact({
    current: PropTypes.any
  })
]), isRenderMode = PropTypes.oneOf(["canvas", "custom", "none", "svg"]), isRotate = PropTypes.oneOf([0, 90, 180, 270]);
var __awaiter$7 = function($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}, __rest$8 = function($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
};
const { PDFDataRangeTransport } = pdfjs, defaultOnPassword = ($, ee) => {
  switch (ee) {
    case PasswordResponses.NEED_PASSWORD: {
      const te = prompt("Enter the password to open this PDF file.");
      $(te);
      break;
    }
    case PasswordResponses.INCORRECT_PASSWORD: {
      const te = prompt("Invalid password. Please try again.");
      $(te);
      break;
    }
  }
};
function isParameterObject($) {
  return typeof $ == "object" && $ !== null && ("data" in $ || "range" in $ || "url" in $);
}
const Document = forwardRef(function $(ee, te) {
  var { children: ne, className: re, error: se = "Failed to load PDF file.", externalLinkRel: ie, externalLinkTarget: oe, file: le, inputRef: ue, imageResourcesPath: de, loading: fe = "Loading PDF", noData: pe = "No PDF file specified.", onItemClick: ye, onLoadError: me, onLoadProgress: ve, onLoadSuccess: ge, onPassword: xe = defaultOnPassword, onSourceError: Ee, onSourceSuccess: Te, options: Se, renderMode: he, rotate: Pe } = ee, Ie = __rest$8(ee, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]);
  const [De, Ce] = useResolver(), { value: Ne, error: Me } = De, [Be, We] = useResolver(), { value: Le, error: He } = Be, Ge = useRef(new LinkService()), Ze = useRef([]), Ue = useRef(), Qe = useRef();
  useEffect(() => {
    le && le !== Ue.current && isParameterObject(le) && (warning$2(!dequal(le, Ue.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`), Ue.current = le);
  }, [le]), useEffect(() => {
    Se && Se !== Qe.current && (warning$2(!dequal(Se, Qe.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`), Qe.current = Se);
  }, [Se]);
  const Je = useRef({
    // Handling jumping to internal links target
    scrollPageIntoView: (Vt) => {
      const { dest: qt, pageNumber: nn, pageIndex: mn = nn - 1 } = Vt;
      if (ye) {
        ye({ dest: qt, pageIndex: mn, pageNumber: nn });
        return;
      }
      const en = Ze.current[mn];
      if (en) {
        en.scrollIntoView();
        return;
      }
      warning$2(!1, `An internal link leading to page ${nn} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
    }
  });
  useImperativeHandle(te, () => ({
    linkService: Ge,
    pages: Ze,
    viewer: Je
  }), []);
  function Ot() {
    Te && Te();
  }
  function At() {
    Me && (warning$2(!1, Me.toString()), Ee && Ee(Me));
  }
  function ze() {
    Ce({ type: "RESET" });
  }
  useEffect(ze, [le, Ce]);
  const we = useCallback(() => __awaiter$7(this, void 0, void 0, function* () {
    if (!le)
      return null;
    if (typeof le == "string")
      return isDataURI(le) ? { data: dataURItoByteString(le) } : (displayCORSWarning(), { url: le });
    if (le instanceof PDFDataRangeTransport)
      return { range: le };
    if (isArrayBuffer$1(le))
      return { data: le };
    if (isBrowser$4 && isBlob(le))
      return { data: yield loadFromFile(le) };
    if (invariant$3(typeof le == "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object"), invariant$3(isParameterObject(le), "Invalid parameter object: need either .data, .range or .url"), "url" in le && typeof le.url == "string") {
      if (isDataURI(le.url)) {
        const { url: Vt } = le, qt = __rest$8(le, ["url"]), nn = dataURItoByteString(Vt);
        return Object.assign({ data: nn }, qt);
      }
      displayCORSWarning();
    }
    return le;
  }), [le]);
  useEffect(() => {
    const Vt = makeCancellablePromise(we());
    return Vt.promise.then((qt) => {
      Ce({ type: "RESOLVE", value: qt });
    }).catch((qt) => {
      Ce({ type: "REJECT", error: qt });
    }), () => {
      cancelRunningTask(Vt);
    };
  }, [we, Ce]), useEffect(
    () => {
      if (!(typeof Ne > "u")) {
        if (Ne === !1) {
          At();
          return;
        }
        Ot();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Ne]
  );
  function Ae() {
    Le && (ge && ge(Le), Ze.current = new Array(Le.numPages), Ge.current.setDocument(Le));
  }
  function Re() {
    He && (warning$2(!1, He.toString()), me && me(He));
  }
  function je() {
    We({ type: "RESET" });
  }
  useEffect(je, [We, Ne]);
  function Fe() {
    if (!Ne)
      return;
    const Vt = Se ? Object.assign(Object.assign({}, Ne), Se) : Ne, qt = pdfjs.getDocument(Vt);
    ve && (qt.onProgress = ve), xe && (qt.onPassword = xe);
    const nn = qt;
    return nn.promise.then((mn) => {
      We({ type: "RESOLVE", value: mn });
    }).catch((mn) => {
      nn.destroyed || We({ type: "REJECT", error: mn });
    }), () => {
      nn.destroy();
    };
  }
  useEffect(
    Fe,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Se, We, Ne]
  ), useEffect(
    () => {
      if (!(typeof Le > "u")) {
        if (Le === !1) {
          Re();
          return;
        }
        Ae();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Le]
  );
  function $e() {
    Ge.current.setViewer(Je.current), Ge.current.setExternalLinkRel(ie), Ge.current.setExternalLinkTarget(oe);
  }
  useEffect($e, [ie, oe]);
  function qe(Vt, qt) {
    Ze.current[Vt] = qt;
  }
  function Ye(Vt) {
    delete Ze.current[Vt];
  }
  const Ke = useMemo(() => ({
    imageResourcesPath: de,
    linkService: Ge.current,
    onItemClick: ye,
    pdf: Le,
    registerPage: qe,
    renderMode: he,
    rotate: Pe,
    unregisterPage: Ye
  }), [de, ye, Le, he, Pe]), Tt = useMemo(() => makeEventProps(Ie, () => Le), [Ie, Le]);
  function pt() {
    return React__default.createElement(DocumentContext.Provider, { value: Ke }, ne);
  }
  function Bt() {
    return le ? Le == null ? React__default.createElement(Message, { type: "loading" }, typeof fe == "function" ? fe() : fe) : Le === !1 ? React__default.createElement(Message, { type: "error" }, typeof se == "function" ? se() : se) : pt() : React__default.createElement(Message, { type: "no-data" }, typeof pe == "function" ? pe() : pe);
  }
  return React__default.createElement("div", Object.assign({ className: clsx("react-pdf__Document", re), ref: ue, style: {
    "--scale-factor": "1"
  } }, Tt), Bt());
}), isFunctionOrNode$1 = PropTypes.oneOfType([PropTypes.func, PropTypes.node]);
Document.propTypes = Object.assign(Object.assign({}, eventProps), { children: PropTypes.node, className: isClassName, error: isFunctionOrNode$1, externalLinkRel: PropTypes.string, externalLinkTarget: PropTypes.oneOf(["_self", "_blank", "_parent", "_top"]), file: isFile, imageResourcesPath: PropTypes.string, inputRef: isRef, loading: isFunctionOrNode$1, noData: isFunctionOrNode$1, onItemClick: PropTypes.func, onLoadError: PropTypes.func, onLoadProgress: PropTypes.func, onLoadSuccess: PropTypes.func, onPassword: PropTypes.func, onSourceError: PropTypes.func, onSourceSuccess: PropTypes.func, options: PropTypes.shape({
  canvasFactory: PropTypes.any,
  canvasMaxAreaInBytes: PropTypes.number,
  cMapPacked: PropTypes.bool,
  CMapReaderFactory: PropTypes.any,
  cMapUrl: PropTypes.string,
  disableAutoFetch: PropTypes.bool,
  disableFontFace: PropTypes.bool,
  disableRange: PropTypes.bool,
  disableStream: PropTypes.bool,
  docBaseUrl: PropTypes.string,
  enableXfa: PropTypes.bool,
  filterFactory: PropTypes.any,
  fontExtraProperties: PropTypes.bool,
  httpHeaders: PropTypes.object,
  isEvalSupported: PropTypes.bool,
  isOffscreenCanvasSupported: PropTypes.bool,
  length: PropTypes.number,
  maxImageSize: PropTypes.number,
  ownerDocument: PropTypes.any,
  password: PropTypes.string,
  pdfBug: PropTypes.bool,
  rangeChunkSize: PropTypes.number,
  StandardFontDataFactory: PropTypes.any,
  standardFontDataUrl: PropTypes.string,
  stopAtErrors: PropTypes.bool,
  useSystemFonts: PropTypes.bool,
  useWorkerFetch: PropTypes.bool,
  verbosity: PropTypes.number,
  withCredentials: PropTypes.bool,
  worker: PropTypes.any
}), rotate: PropTypes.number });
const Document$1 = Document;
function useDocumentContext() {
  return useContext(DocumentContext);
}
function mergeRefs() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $[ee] = arguments[ee];
  var te = $.filter(Boolean);
  if (te.length <= 1) {
    var ne = te[0];
    return ne || null;
  }
  return function(se) {
    te.forEach(function(ie) {
      typeof ie == "function" ? ie(se) : ie && (ie.current = se);
    });
  };
}
const PageContext = createContext(null), PDF_ROLE_TO_HTML_ROLE = {
  // Document level structure types
  Document: null,
  // There's a "document" role, but it doesn't make sense here.
  DocumentFragment: null,
  // Grouping level structure types
  Part: "group",
  Sect: "group",
  // XXX: There's a "section" role, but it's abstract.
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  // Block level structure types
  P: null,
  // H<n>,
  H: "heading",
  Title: null,
  FENote: "note",
  // Sub-block level structure type
  Sub: "group",
  // General inline level structure types
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  // Ruby and Warichu structure types
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  // List standard structure types
  L: "list",
  LI: "listitem",
  LBody: null,
  // Table standard structure types
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  // Standard structure type Caption
  Caption: null,
  // Standard structure type Figure
  Figure: "figure",
  // Standard structure type Formula
  Formula: null,
  // standard structure type Artifact
  Artifact: null
}, HEADING_PATTERN = /^H(\d+)$/;
function isPdfRole($) {
  return $ in PDF_ROLE_TO_HTML_ROLE;
}
function isStructTreeNode($) {
  return "children" in $;
}
function isStructTreeNodeWithOnlyContentChild($) {
  return isStructTreeNode($) ? $.children.length === 1 && 0 in $.children && "id" in $.children[0] : !1;
}
function getRoleAttributes($) {
  const ee = {};
  if (isStructTreeNode($)) {
    const { role: te } = $, ne = te.match(HEADING_PATTERN);
    if (ne)
      ee.role = "heading", ee["aria-level"] = Number(ne[1]);
    else if (isPdfRole(te)) {
      const re = PDF_ROLE_TO_HTML_ROLE[te];
      re && (ee.role = re);
    }
  }
  return ee;
}
function getBaseAttributes($) {
  const ee = {};
  if (isStructTreeNode($)) {
    if ($.alt !== void 0 && (ee["aria-label"] = $.alt), $.lang !== void 0 && (ee.lang = $.lang), isStructTreeNodeWithOnlyContentChild($)) {
      const [te] = $.children;
      if (te) {
        const ne = getBaseAttributes(te);
        return Object.assign(Object.assign({}, ee), ne);
      }
    }
  } else
    "id" in $ && (ee["aria-owns"] = $.id);
  return ee;
}
function getAttributes($) {
  return $ ? Object.assign(Object.assign({}, getRoleAttributes($)), getBaseAttributes($)) : null;
}
function StructTreeItem({ className: $, node: ee }) {
  const te = useMemo(() => getAttributes(ee), [ee]), ne = useMemo(() => !isStructTreeNode(ee) || isStructTreeNodeWithOnlyContentChild(ee) ? null : ee.children.map((re, se) => (
    // eslint-disable-next-line react/no-array-index-key
    React__default.createElement(StructTreeItem, { key: se, node: re })
  )), [ee]);
  return React__default.createElement("span", Object.assign({ className: $ }, te), ne);
}
function usePageContext() {
  return useContext(PageContext);
}
function StructTree() {
  const $ = usePageContext();
  invariant$3($, "Unable to find Page context.");
  const { onGetStructTreeError: ee, onGetStructTreeSuccess: te } = $, [ne, re] = useResolver(), { value: se, error: ie } = ne, { customTextRenderer: oe, page: le } = $;
  function ue() {
    se && te && te(se);
  }
  function de() {
    ie && (warning$2(!1, ie.toString()), ee && ee(ie));
  }
  function fe() {
    re({ type: "RESET" });
  }
  useEffect(fe, [re, le]);
  function pe() {
    if (oe || !le)
      return;
    const ye = makeCancellablePromise(le.getStructTree()), me = ye;
    return ye.promise.then((ve) => {
      re({ type: "RESOLVE", value: ve });
    }).catch((ve) => {
      re({ type: "REJECT", error: ve });
    }), () => cancelRunningTask(me);
  }
  return useEffect(pe, [oe, le, re]), useEffect(
    () => {
      if (se !== void 0) {
        if (se === !1) {
          de();
          return;
        }
        ue();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [se]
  ), se ? React__default.createElement(StructTreeItem, { className: "react-pdf__Page__structTree structTree", node: se }) : null;
}
const ANNOTATION_MODE = pdfjs.AnnotationMode;
function PageCanvas($) {
  const ee = usePageContext();
  invariant$3(ee, "Unable to find Page context.");
  const te = Object.assign(Object.assign({}, ee), $), { _className: ne, canvasBackground: re, devicePixelRatio: se = getDevicePixelRatio(), onRenderError: ie, onRenderSuccess: oe, page: le, renderForms: ue, renderTextLayer: de, rotate: fe, scale: pe } = te, { canvasRef: ye } = $;
  invariant$3(le, "Attempted to render page canvas, but no page was specified.");
  const me = useRef(null);
  function ve() {
    le && oe && oe(makePageCallback(le, pe));
  }
  function ge(he) {
    isCancelException(he) || (warning$2(!1, he.toString()), ie && ie(he));
  }
  const xe = useMemo(() => le.getViewport({ scale: pe * se, rotation: fe }), [se, le, fe, pe]), Ee = useMemo(() => le.getViewport({ scale: pe, rotation: fe }), [le, fe, pe]);
  function Te() {
    if (!le)
      return;
    le.cleanup();
    const { current: he } = me;
    if (!he)
      return;
    he.width = xe.width, he.height = xe.height, he.style.width = `${Math.floor(Ee.width)}px`, he.style.height = `${Math.floor(Ee.height)}px`, he.style.visibility = "hidden";
    const Pe = {
      annotationMode: ue ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
      canvasContext: he.getContext("2d", { alpha: !1 }),
      viewport: xe
    };
    re && (Pe.background = re);
    const Ie = le.render(Pe), De = Ie;
    return Ie.promise.then(() => {
      he.style.visibility = "", ve();
    }).catch(ge), () => cancelRunningTask(De);
  }
  useEffect(
    Te,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      re,
      me,
      se,
      le,
      ue,
      xe,
      Ee
    ]
  );
  const Se = useCallback(() => {
    const { current: he } = me;
    he && (he.width = 0, he.height = 0);
  }, [me]);
  return useEffect(() => Se, [Se]), React__default.createElement("canvas", { className: `${ne}__canvas`, dir: "ltr", ref: mergeRefs(ye, me), style: {
    display: "block",
    userSelect: "none"
  } }, de ? React__default.createElement(StructTree, null) : null);
}
function PageSVG() {
  const $ = usePageContext();
  invariant$3($, "Unable to find Page context.");
  const { _className: ee, onRenderSuccess: te, onRenderError: ne, page: re, rotate: se, scale: ie } = $;
  invariant$3(re, "Attempted to render page SVG, but no page was specified.");
  const [oe, le] = useResolver(), { value: ue, error: de } = oe;
  function fe() {
    re && te && te(makePageCallback(re, ie));
  }
  function pe() {
    de && (isCancelException(de) || (warning$2(!1, de.toString()), ne && ne(de)));
  }
  const ye = useMemo(() => re.getViewport({ scale: ie, rotation: se }), [re, se, ie]);
  function me() {
    le({ type: "RESET" });
  }
  useEffect(me, [re, le, ye]);
  function ve() {
    if (!re)
      return;
    const Te = makeCancellablePromise(re.getOperatorList());
    return Te.promise.then((Se) => {
      new pdfjs.SVGGraphics(re.commonObjs, re.objs).getSVG(Se, ye).then((Pe) => {
        if (!(Pe instanceof SVGElement))
          throw new Error("getSVG returned unexpected result.");
        le({ type: "RESOLVE", value: Pe });
      }).catch((Pe) => {
        le({ type: "REJECT", error: Pe });
      });
    }).catch((Se) => {
      le({ type: "REJECT", error: Se });
    }), () => cancelRunningTask(Te);
  }
  useEffect(ve, [re, le, ye]), useEffect(
    () => {
      if (ue !== void 0) {
        if (ue === !1) {
          pe();
          return;
        }
        fe();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [ue]
  );
  function ge(Te) {
    if (!Te || !ue)
      return;
    Te.firstElementChild || Te.appendChild(ue);
    const { width: Se, height: he } = ye;
    ue.setAttribute("width", `${Se}`), ue.setAttribute("height", `${he}`);
  }
  const { width: xe, height: Ee } = ye;
  return React__default.createElement("div", {
    className: `${ee}__svg`,
    // Note: This cannot be shortened, as we need this function to be called with each render.
    ref: (Te) => ge(Te),
    style: {
      display: "block",
      backgroundColor: "white",
      overflow: "hidden",
      width: xe,
      height: Ee,
      userSelect: "none"
    }
  });
}
function isTextItem($) {
  return "str" in $;
}
function TextLayer() {
  const $ = usePageContext();
  invariant$3($, "Unable to find Page context.");
  const { customTextRenderer: ee, onGetTextError: te, onGetTextSuccess: ne, onRenderTextLayerError: re, onRenderTextLayerSuccess: se, page: ie, pageIndex: oe, pageNumber: le, rotate: ue, scale: de } = $;
  invariant$3(ie, "Attempted to load page text content, but no page was specified.");
  const [fe, pe] = useResolver(), { value: ye, error: me } = fe, ve = useRef(null), ge = useRef();
  warning$2(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
  function xe() {
    ye && ne && ne(ye);
  }
  function Ee() {
    me && (warning$2(!1, me.toString()), te && te(me));
  }
  function Te() {
    pe({ type: "RESET" });
  }
  useEffect(Te, [ie, pe]);
  function Se() {
    if (!ie)
      return;
    const Me = makeCancellablePromise(ie.getTextContent()), Be = Me;
    return Me.promise.then((We) => {
      pe({ type: "RESOLVE", value: We });
    }).catch((We) => {
      pe({ type: "REJECT", error: We });
    }), () => cancelRunningTask(Be);
  }
  useEffect(Se, [ie, pe]), useEffect(
    () => {
      if (ye !== void 0) {
        if (ye === !1) {
          Ee();
          return;
        }
        xe();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [ye]
  );
  const he = useCallback(() => {
    se && se();
  }, [se]), Pe = useCallback((Me) => {
    warning$2(!1, Me.toString()), re && re(Me);
  }, [re]);
  function Ie() {
    const Me = ge.current;
    Me && Me.classList.add("active");
  }
  function De() {
    const Me = ge.current;
    Me && Me.classList.remove("active");
  }
  const Ce = useMemo(() => ie.getViewport({ scale: de, rotation: ue }), [ie, ue, de]);
  function Ne() {
    if (!ie || !ye)
      return;
    const { current: Me } = ve;
    if (!Me)
      return;
    Me.innerHTML = "";
    const Be = ie.streamTextContent({ includeMarkedContent: !0 }), We = {
      container: Me,
      textContentSource: Be,
      viewport: Ce
    }, Le = pdfjs.renderTextLayer(We), He = Le;
    return Le.promise.then(() => {
      const Ge = document.createElement("div");
      Ge.className = "endOfContent", Me.append(Ge), ge.current = Ge;
      const Ze = Me.querySelectorAll('[role="presentation"]');
      if (ee) {
        let Ue = 0;
        ye.items.forEach((Qe, Je) => {
          if (!isTextItem(Qe))
            return;
          const Ot = Ze[Ue];
          if (!Ot)
            return;
          const At = ee(Object.assign({
            pageIndex: oe,
            pageNumber: le,
            itemIndex: Je
          }, Qe));
          Ot.innerHTML = At, Ue += Qe.str && Qe.hasEOL ? 2 : 1;
        });
      }
      he();
    }).catch(Pe), () => cancelRunningTask(He);
  }
  return useLayoutEffect(Ne, [
    ee,
    Pe,
    he,
    ie,
    oe,
    le,
    ye,
    Ce
  ]), // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  React__default.createElement("div", { className: clsx("react-pdf__Page__textContent", "textLayer"), onMouseUp: De, onMouseDown: Ie, ref: ve });
}
function AnnotationLayer() {
  const $ = useDocumentContext(), ee = usePageContext();
  invariant$3(ee, "Unable to find Page context.");
  const te = Object.assign(Object.assign({}, $), ee), { imageResourcesPath: ne, linkService: re, onGetAnnotationsError: se, onGetAnnotationsSuccess: ie, onRenderAnnotationLayerError: oe, onRenderAnnotationLayerSuccess: le, page: ue, pdf: de, renderForms: fe, rotate: pe, scale: ye = 1 } = te;
  invariant$3(de, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."), invariant$3(ue, "Attempted to load page annotations, but no page was specified."), invariant$3(re, "Attempted to load page annotations, but no linkService was specified.");
  const [me, ve] = useResolver(), { value: ge, error: xe } = me, Ee = useRef(null);
  warning$2(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
  function Te() {
    ge && ie && ie(ge);
  }
  function Se() {
    xe && (warning$2(!1, xe.toString()), se && se(xe));
  }
  function he() {
    ve({ type: "RESET" });
  }
  useEffect(he, [ve, ue]);
  function Pe() {
    if (!ue)
      return;
    const Me = makeCancellablePromise(ue.getAnnotations()), Be = Me;
    return Me.promise.then((We) => {
      ve({ type: "RESOLVE", value: We });
    }).catch((We) => {
      ve({ type: "REJECT", error: We });
    }), () => {
      cancelRunningTask(Be);
    };
  }
  useEffect(Pe, [ve, ue, fe]), useEffect(
    () => {
      if (ge !== void 0) {
        if (ge === !1) {
          Se();
          return;
        }
        Te();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [ge]
  );
  function Ie() {
    le && le();
  }
  function De(Me) {
    warning$2(!1, `${Me}`), oe && oe(Me);
  }
  const Ce = useMemo(() => ue.getViewport({ scale: ye, rotation: pe }), [ue, pe, ye]);
  function Ne() {
    if (!de || !ue || !re || !ge)
      return;
    const { current: Me } = Ee;
    if (!Me)
      return;
    const Be = Ce.clone({ dontFlip: !0 }), We = {
      accessibilityManager: null,
      // TODO: Implement this
      annotationCanvasMap: null,
      // TODO: Implement this
      div: Me,
      l10n: null,
      // TODO: Implement this
      page: ue,
      viewport: Be
    }, Le = {
      annotations: ge,
      annotationStorage: de.annotationStorage,
      div: Me,
      // See https://github.com/mozilla/pdf.js/issues/17029
      downloadManager: null,
      imageResourcesPath: ne,
      linkService: re,
      page: ue,
      renderForms: fe,
      viewport: Be
    };
    Me.innerHTML = "";
    try {
      new pdfjs.AnnotationLayer(We).render(Le), Ie();
    } catch (He) {
      De(He);
    }
    return () => {
    };
  }
  return useEffect(
    Ne,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [ge, ne, re, ue, fe, Ce]
  ), React__default.createElement("div", { className: clsx("react-pdf__Page__annotations", "annotationLayer"), ref: Ee });
}
var __rest$7 = function($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
};
const defaultScale = 1, Page = function $(ee) {
  const te = useDocumentContext(), ne = Object.assign(Object.assign({}, te), ee), { _className: re = "react-pdf__Page", _enableRegisterUnregisterPage: se = !0, canvasBackground: ie, canvasRef: oe, children: le, className: ue, customRenderer: de, customTextRenderer: fe, devicePixelRatio: pe, error: ye = "Failed to load the page.", height: me, inputRef: ve, loading: ge = "Loading page", noData: xe = "No page specified.", onGetAnnotationsError: Ee, onGetAnnotationsSuccess: Te, onGetStructTreeError: Se, onGetStructTreeSuccess: he, onGetTextError: Pe, onGetTextSuccess: Ie, onLoadError: De, onLoadSuccess: Ce, onRenderAnnotationLayerError: Ne, onRenderAnnotationLayerSuccess: Me, onRenderError: Be, onRenderSuccess: We, onRenderTextLayerError: Le, onRenderTextLayerSuccess: He, pageIndex: Ge, pageNumber: Ze, pdf: Ue, registerPage: Qe, renderAnnotationLayer: Je = !0, renderForms: Ot = !1, renderMode: At = "canvas", renderTextLayer: ze = !0, rotate: we, scale: Ae = defaultScale, unregisterPage: Re, width: je } = ne, Fe = __rest$7(ne, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]), [$e, qe] = useResolver(), { value: Ye, error: Ke } = $e, Tt = useRef(null);
  invariant$3(Ue, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  const pt = isProvided(Ze) ? Ze - 1 : Ge ?? null, Bt = Ze ?? (isProvided(Ge) ? Ge + 1 : null), Vt = we ?? (Ye ? Ye.rotate : null), qt = useMemo(() => {
    if (!Ye)
      return null;
    let Tn = 1;
    const Pn = Ae ?? defaultScale;
    if (je || me) {
      const Rn = Ye.getViewport({ scale: 1, rotation: Vt });
      je ? Tn = je / Rn.width : me && (Tn = me / Rn.height);
    }
    return Pn * Tn;
  }, [me, Ye, Vt, Ae, je]);
  function nn() {
    return () => {
      isProvided(pt) && se && Re && Re(pt);
    };
  }
  useEffect(nn, [se, Ue, pt, Re]);
  function mn() {
    if (Ce) {
      if (!Ye || !qt)
        return;
      Ce(makePageCallback(Ye, qt));
    }
    if (se && Qe) {
      if (!isProvided(pt) || !Tt.current)
        return;
      Qe(pt, Tt.current);
    }
  }
  function en() {
    Ke && (warning$2(!1, Ke.toString()), De && De(Ke));
  }
  function pn() {
    qe({ type: "RESET" });
  }
  useEffect(pn, [qe, Ue, pt]);
  function Yt() {
    if (!Ue || !Bt)
      return;
    const Tn = makeCancellablePromise(Ue.getPage(Bt)), Pn = Tn;
    return Tn.promise.then((Rn) => {
      qe({ type: "RESOLVE", value: Rn });
    }).catch((Rn) => {
      qe({ type: "REJECT", error: Rn });
    }), () => cancelRunningTask(Pn);
  }
  useEffect(Yt, [qe, Ue, pt, Bt, Qe]), useEffect(
    () => {
      if (Ye !== void 0) {
        if (Ye === !1) {
          en();
          return;
        }
        mn();
      }
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Ye, qt]
  );
  const Ut = useMemo(() => (
    // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
    Ye && isProvided(pt) && Bt && isProvided(Vt) && isProvided(qt) ? {
      _className: re,
      canvasBackground: ie,
      customTextRenderer: fe,
      devicePixelRatio: pe,
      onGetAnnotationsError: Ee,
      onGetAnnotationsSuccess: Te,
      onGetStructTreeError: Se,
      onGetStructTreeSuccess: he,
      onGetTextError: Pe,
      onGetTextSuccess: Ie,
      onRenderAnnotationLayerError: Ne,
      onRenderAnnotationLayerSuccess: Me,
      onRenderError: Be,
      onRenderSuccess: We,
      onRenderTextLayerError: Le,
      onRenderTextLayerSuccess: He,
      page: Ye,
      pageIndex: pt,
      pageNumber: Bt,
      renderForms: Ot,
      renderTextLayer: ze,
      rotate: Vt,
      scale: qt
    } : null
  ), [
    re,
    ie,
    fe,
    pe,
    Ee,
    Te,
    Se,
    he,
    Pe,
    Ie,
    Ne,
    Me,
    Be,
    We,
    Le,
    He,
    Ye,
    pt,
    Bt,
    Ot,
    ze,
    Vt,
    qt
  ]), jt = useMemo(() => makeEventProps(Fe, () => Ye && (qt ? makePageCallback(Ye, qt) : void 0)), [Fe, Ye, qt]), Gt = `${pt}@${qt}/${Vt}`, ln = `${pt}/${Vt}`;
  function sn() {
    switch (At) {
      case "custom":
        return invariant$3(de, 'renderMode was set to "custom", but no customRenderer was passed.'), React__default.createElement(de, { key: `${Gt}_custom` });
      case "none":
        return null;
      case "svg":
        return React__default.createElement(PageSVG, { key: `${ln}_svg` });
      case "canvas":
      default:
        return React__default.createElement(PageCanvas, { key: `${Gt}_canvas`, canvasRef: oe });
    }
  }
  function _n() {
    return ze ? React__default.createElement(TextLayer, { key: `${Gt}_text` }) : null;
  }
  function un() {
    return Je ? React__default.createElement(AnnotationLayer, { key: `${Gt}_annotations` }) : null;
  }
  function En() {
    return React__default.createElement(
      PageContext.Provider,
      { value: Ut },
      sn(),
      _n(),
      un(),
      le
    );
  }
  function wn() {
    return Bt ? Ue === null || Ye === void 0 || Ye === null ? React__default.createElement(Message, { type: "loading" }, typeof ge == "function" ? ge() : ge) : Ue === !1 || Ye === !1 ? React__default.createElement(Message, { type: "error" }, typeof ye == "function" ? ye() : ye) : En() : React__default.createElement(Message, { type: "no-data" }, typeof xe == "function" ? xe() : xe);
  }
  return React__default.createElement("div", Object.assign({ className: clsx(re, ue), "data-page-number": Bt, ref: mergeRefs(ve, Tt), style: {
    "--scale-factor": `${qt}`,
    backgroundColor: ie || "white",
    position: "relative",
    minWidth: "min-content",
    minHeight: "min-content"
  } }, jt), wn());
}, isFunctionOrNode = PropTypes.oneOfType([PropTypes.func, PropTypes.node]);
Page.propTypes = Object.assign(Object.assign({}, eventProps), { canvasBackground: PropTypes.string, canvasRef: isRef, children: PropTypes.node, className: isClassName, customRenderer: PropTypes.func, customTextRenderer: PropTypes.func, devicePixelRatio: PropTypes.number, error: isFunctionOrNode, height: PropTypes.number, imageResourcesPath: PropTypes.string, inputRef: isRef, loading: isFunctionOrNode, noData: isFunctionOrNode, onGetTextError: PropTypes.func, onGetTextSuccess: PropTypes.func, onLoadError: PropTypes.func, onLoadSuccess: PropTypes.func, onRenderError: PropTypes.func, onRenderSuccess: PropTypes.func, onRenderTextLayerError: PropTypes.func, onRenderTextLayerSuccess: PropTypes.func, pageIndex: isPageIndex, pageNumber: isPageNumber, pdf: isPdf, renderAnnotationLayer: PropTypes.bool, renderForms: PropTypes.bool, renderMode: isRenderMode, renderTextLayer: PropTypes.bool, rotate: isRotate, scale: PropTypes.number, width: PropTypes.number });
const Page$1 = Page;
displayWorkerWarning();
pdfjs.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
function useLMFeedGeneralContextProvider() {
  const [$, ee] = useState(!1), [te, ne] = useState("");
  function re(ie) {
    ee(!0), ne(ie);
  }
  function se() {
    ee(!1), ne("");
  }
  return {
    displaySnackbarMessage: re,
    closeSnackbar: se,
    message: te,
    showSnackbar: $
  };
}
const GeneralContext = createContext({});
var LMDisplayMessages = /* @__PURE__ */ (($) => ($.POST_DELETED_SUCCESSFULLY = "The post was deleted successfully", $.POST_PINNED_SUCCESS = "Post Pinned", $.PIN_REMOVED_SUCCESS = "Post Unpinned", $.POST_CREATED_SUCCESS = "Post Created", $.POST_EDIT_SUCCESS = "Post Edited", $.POST_LIKE_SUCCESS = "Post Liked", $.REPLY_DELETED_SUCCESS = "Reply deleted", $.COMMENT_DELETED_SUCCESS = "Comment deleted", $.ERROR_LOADING_POST = "ERROR LOADING POST", $))(LMDisplayMessages || {}), LMFeedPostMenuItems = /* @__PURE__ */ (($) => ($.DELETE_POST = "1", $.PIN_POST = "2", $.UNPIN_POST = "3", $.REPORT_POST = "4", $.EDIT_POST = "5", $))(LMFeedPostMenuItems || {});
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$7.apply(this, arguments);
}
var Action;
(function($) {
  $.Pop = "POP", $.Push = "PUSH", $.Replace = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory($) {
  $ === void 0 && ($ = {});
  function ee(ne, re) {
    let {
      pathname: se,
      search: ie,
      hash: oe
    } = ne.location;
    return createLocation(
      "",
      {
        pathname: se,
        search: ie,
        hash: oe
      },
      // state defaults to `null` because `window.history.state` does
      re.state && re.state.usr || null,
      re.state && re.state.key || "default"
    );
  }
  function te(ne, re) {
    return typeof re == "string" ? re : createPath(re);
  }
  return getUrlBasedHistory(ee, te, null, $);
}
function invariant$2($, ee) {
  if ($ === !1 || $ === null || typeof $ > "u")
    throw new Error(ee);
}
function warning($, ee) {
  if (!$) {
    typeof console < "u" && console.warn(ee);
    try {
      throw new Error(ee);
    } catch {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState($, ee) {
  return {
    usr: $.state,
    key: $.key,
    idx: ee
  };
}
function createLocation($, ee, te, ne) {
  return te === void 0 && (te = null), _extends$7({
    pathname: typeof $ == "string" ? $ : $.pathname,
    search: "",
    hash: ""
  }, typeof ee == "string" ? parsePath(ee) : ee, {
    state: te,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: ee && ee.key || ne || createKey()
  });
}
function createPath($) {
  let {
    pathname: ee = "/",
    search: te = "",
    hash: ne = ""
  } = $;
  return te && te !== "?" && (ee += te.charAt(0) === "?" ? te : "?" + te), ne && ne !== "#" && (ee += ne.charAt(0) === "#" ? ne : "#" + ne), ee;
}
function parsePath($) {
  let ee = {};
  if ($) {
    let te = $.indexOf("#");
    te >= 0 && (ee.hash = $.substr(te), $ = $.substr(0, te));
    let ne = $.indexOf("?");
    ne >= 0 && (ee.search = $.substr(ne), $ = $.substr(0, ne)), $ && (ee.pathname = $);
  }
  return ee;
}
function getUrlBasedHistory($, ee, te, ne) {
  ne === void 0 && (ne = {});
  let {
    window: re = document.defaultView,
    v5Compat: se = !1
  } = ne, ie = re.history, oe = Action.Pop, le = null, ue = de();
  ue == null && (ue = 0, ie.replaceState(_extends$7({}, ie.state, {
    idx: ue
  }), ""));
  function de() {
    return (ie.state || {
      idx: null
    }).idx;
  }
  function fe() {
    oe = Action.Pop;
    let ge = de(), xe = ge == null ? null : ge - ue;
    ue = ge, le && le({
      action: oe,
      location: ve.location,
      delta: xe
    });
  }
  function pe(ge, xe) {
    oe = Action.Push;
    let Ee = createLocation(ve.location, ge, xe);
    te && te(Ee, ge), ue = de() + 1;
    let Te = getHistoryState(Ee, ue), Se = ve.createHref(Ee);
    try {
      ie.pushState(Te, "", Se);
    } catch (he) {
      if (he instanceof DOMException && he.name === "DataCloneError")
        throw he;
      re.location.assign(Se);
    }
    se && le && le({
      action: oe,
      location: ve.location,
      delta: 1
    });
  }
  function ye(ge, xe) {
    oe = Action.Replace;
    let Ee = createLocation(ve.location, ge, xe);
    te && te(Ee, ge), ue = de();
    let Te = getHistoryState(Ee, ue), Se = ve.createHref(Ee);
    ie.replaceState(Te, "", Se), se && le && le({
      action: oe,
      location: ve.location,
      delta: 0
    });
  }
  function me(ge) {
    let xe = re.location.origin !== "null" ? re.location.origin : re.location.href, Ee = typeof ge == "string" ? ge : createPath(ge);
    return Ee = Ee.replace(/ $/, "%20"), invariant$2(xe, "No window.location.(origin|href) available to create URL for href: " + Ee), new URL(Ee, xe);
  }
  let ve = {
    get action() {
      return oe;
    },
    get location() {
      return $(re, ie);
    },
    listen(ge) {
      if (le)
        throw new Error("A history only accepts one active listener");
      return re.addEventListener(PopStateEventType, fe), le = ge, () => {
        re.removeEventListener(PopStateEventType, fe), le = null;
      };
    },
    createHref(ge) {
      return ee(re, ge);
    },
    createURL: me,
    encodeLocation(ge) {
      let xe = me(ge);
      return {
        pathname: xe.pathname,
        search: xe.search,
        hash: xe.hash
      };
    },
    push: pe,
    replace: ye,
    go(ge) {
      return ie.go(ge);
    }
  };
  return ve;
}
var ResultType;
(function($) {
  $.data = "data", $.deferred = "deferred", $.redirect = "redirect", $.error = "error";
})(ResultType || (ResultType = {}));
function matchRoutes($, ee, te) {
  te === void 0 && (te = "/");
  let ne = typeof ee == "string" ? parsePath(ee) : ee, re = stripBasename(ne.pathname || "/", te);
  if (re == null)
    return null;
  let se = flattenRoutes($);
  rankRouteBranches(se);
  let ie = null;
  for (let oe = 0; ie == null && oe < se.length; ++oe) {
    let le = decodePath(re);
    ie = matchRouteBranch(se[oe], le);
  }
  return ie;
}
function flattenRoutes($, ee, te, ne) {
  ee === void 0 && (ee = []), te === void 0 && (te = []), ne === void 0 && (ne = "");
  let re = (se, ie, oe) => {
    let le = {
      relativePath: oe === void 0 ? se.path || "" : oe,
      caseSensitive: se.caseSensitive === !0,
      childrenIndex: ie,
      route: se
    };
    le.relativePath.startsWith("/") && (invariant$2(le.relativePath.startsWith(ne), 'Absolute route path "' + le.relativePath + '" nested under path ' + ('"' + ne + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), le.relativePath = le.relativePath.slice(ne.length));
    let ue = joinPaths([ne, le.relativePath]), de = te.concat(le);
    se.children && se.children.length > 0 && (invariant$2(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      se.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + ue + '".')
    ), flattenRoutes(se.children, ee, de, ue)), !(se.path == null && !se.index) && ee.push({
      path: ue,
      score: computeScore(ue, se.index),
      routesMeta: de
    });
  };
  return $.forEach((se, ie) => {
    var oe;
    if (se.path === "" || !((oe = se.path) != null && oe.includes("?")))
      re(se, ie);
    else
      for (let le of explodeOptionalSegments(se.path))
        re(se, ie, le);
  }), ee;
}
function explodeOptionalSegments($) {
  let ee = $.split("/");
  if (ee.length === 0)
    return [];
  let [te, ...ne] = ee, re = te.endsWith("?"), se = te.replace(/\?$/, "");
  if (ne.length === 0)
    return re ? [se, ""] : [se];
  let ie = explodeOptionalSegments(ne.join("/")), oe = [];
  return oe.push(...ie.map((le) => le === "" ? se : [se, le].join("/"))), re && oe.push(...ie), oe.map((le) => $.startsWith("/") && le === "" ? "/" : le);
}
function rankRouteBranches($) {
  $.sort((ee, te) => ee.score !== te.score ? te.score - ee.score : compareIndexes(ee.routesMeta.map((ne) => ne.childrenIndex), te.routesMeta.map((ne) => ne.childrenIndex)));
}
const paramRe = /^:[\w-]+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = ($) => $ === "*";
function computeScore($, ee) {
  let te = $.split("/"), ne = te.length;
  return te.some(isSplat) && (ne += splatPenalty), ee && (ne += indexRouteValue), te.filter((re) => !isSplat(re)).reduce((re, se) => re + (paramRe.test(se) ? dynamicSegmentValue : se === "" ? emptySegmentValue : staticSegmentValue), ne);
}
function compareIndexes($, ee) {
  return $.length === ee.length && $.slice(0, -1).every((ne, re) => ne === ee[re]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    $[$.length - 1] - ee[ee.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch($, ee) {
  let {
    routesMeta: te
  } = $, ne = {}, re = "/", se = [];
  for (let ie = 0; ie < te.length; ++ie) {
    let oe = te[ie], le = ie === te.length - 1, ue = re === "/" ? ee : ee.slice(re.length) || "/", de = matchPath({
      path: oe.relativePath,
      caseSensitive: oe.caseSensitive,
      end: le
    }, ue);
    if (!de)
      return null;
    Object.assign(ne, de.params);
    let fe = oe.route;
    se.push({
      // TODO: Can this as be avoided?
      params: ne,
      pathname: joinPaths([re, de.pathname]),
      pathnameBase: normalizePathname(joinPaths([re, de.pathnameBase])),
      route: fe
    }), de.pathnameBase !== "/" && (re = joinPaths([re, de.pathnameBase]));
  }
  return se;
}
function matchPath($, ee) {
  typeof $ == "string" && ($ = {
    path: $,
    caseSensitive: !1,
    end: !0
  });
  let [te, ne] = compilePath($.path, $.caseSensitive, $.end), re = ee.match(te);
  if (!re)
    return null;
  let se = re[0], ie = se.replace(/(.)\/+$/, "$1"), oe = re.slice(1);
  return {
    params: ne.reduce((ue, de, fe) => {
      let {
        paramName: pe,
        isOptional: ye
      } = de;
      if (pe === "*") {
        let ve = oe[fe] || "";
        ie = se.slice(0, se.length - ve.length).replace(/(.)\/+$/, "$1");
      }
      const me = oe[fe];
      return ye && !me ? ue[pe] = void 0 : ue[pe] = (me || "").replace(/%2F/g, "/"), ue;
    }, {}),
    pathname: se,
    pathnameBase: ie,
    pattern: $
  };
}
function compilePath($, ee, te) {
  ee === void 0 && (ee = !1), te === void 0 && (te = !0), warning($ === "*" || !$.endsWith("*") || $.endsWith("/*"), 'Route path "' + $ + '" will be treated as if it were ' + ('"' + $.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + $.replace(/\*$/, "/*") + '".'));
  let ne = [], re = "^" + $.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (ie, oe, le) => (ne.push({
    paramName: oe,
    isOptional: le != null
  }), le ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return $.endsWith("*") ? (ne.push({
    paramName: "*"
  }), re += $ === "*" || $ === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : te ? re += "\\/*$" : $ !== "" && $ !== "/" && (re += "(?:(?=\\/|$))"), [new RegExp(re, ee ? void 0 : "i"), ne];
}
function decodePath($) {
  try {
    return $.split("/").map((ee) => decodeURIComponent(ee).replace(/\//g, "%2F")).join("/");
  } catch (ee) {
    return warning(!1, 'The URL path "' + $ + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + ee + ").")), $;
  }
}
function stripBasename($, ee) {
  if (ee === "/")
    return $;
  if (!$.toLowerCase().startsWith(ee.toLowerCase()))
    return null;
  let te = ee.endsWith("/") ? ee.length - 1 : ee.length, ne = $.charAt(te);
  return ne && ne !== "/" ? null : $.slice(te) || "/";
}
function resolvePath($, ee) {
  ee === void 0 && (ee = "/");
  let {
    pathname: te,
    search: ne = "",
    hash: re = ""
  } = typeof $ == "string" ? parsePath($) : $;
  return {
    pathname: te ? te.startsWith("/") ? te : resolvePathname(te, ee) : ee,
    search: normalizeSearch(ne),
    hash: normalizeHash(re)
  };
}
function resolvePathname($, ee) {
  let te = ee.replace(/\/+$/, "").split("/");
  return $.split("/").forEach((re) => {
    re === ".." ? te.length > 1 && te.pop() : re !== "." && te.push(re);
  }), te.length > 1 ? te.join("/") : "/";
}
function getInvalidPathError($, ee, te, ne) {
  return "Cannot include a '" + $ + "' character in a manually specified " + ("`to." + ee + "` field [" + JSON.stringify(ne) + "].  Please separate it out to the ") + ("`to." + te + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches($) {
  return $.filter((ee, te) => te === 0 || ee.route.path && ee.route.path.length > 0);
}
function getResolveToMatches($, ee) {
  let te = getPathContributingMatches($);
  return ee ? te.map((ne, re) => re === $.length - 1 ? ne.pathname : ne.pathnameBase) : te.map((ne) => ne.pathnameBase);
}
function resolveTo($, ee, te, ne) {
  ne === void 0 && (ne = !1);
  let re;
  typeof $ == "string" ? re = parsePath($) : (re = _extends$7({}, $), invariant$2(!re.pathname || !re.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", re)), invariant$2(!re.pathname || !re.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", re)), invariant$2(!re.search || !re.search.includes("#"), getInvalidPathError("#", "search", "hash", re)));
  let se = $ === "" || re.pathname === "", ie = se ? "/" : re.pathname, oe;
  if (ie == null)
    oe = te;
  else {
    let fe = ee.length - 1;
    if (!ne && ie.startsWith("..")) {
      let pe = ie.split("/");
      for (; pe[0] === ".."; )
        pe.shift(), fe -= 1;
      re.pathname = pe.join("/");
    }
    oe = fe >= 0 ? ee[fe] : "/";
  }
  let le = resolvePath(re, oe), ue = ie && ie !== "/" && ie.endsWith("/"), de = (se || ie === ".") && te.endsWith("/");
  return !le.pathname.endsWith("/") && (ue || de) && (le.pathname += "/"), le;
}
const joinPaths = ($) => $.join("/").replace(/\/\/+/g, "/"), normalizePathname = ($) => $.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = ($) => !$ || $ === "?" ? "" : $.startsWith("?") ? $ : "?" + $, normalizeHash = ($) => !$ || $ === "#" ? "" : $.startsWith("#") ? $ : "#" + $;
function isRouteErrorResponse($) {
  return $ != null && typeof $.status == "number" && typeof $.statusText == "string" && typeof $.internal == "boolean" && "data" in $;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$6.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (DataRouterContext.displayName = "DataRouter");
const DataRouterStateContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (DataRouterStateContext.displayName = "DataRouterState");
const AwaitContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (AwaitContext.displayName = "Await");
const NavigationContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (NavigationContext.displayName = "Navigation");
const LocationContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (LocationContext.displayName = "Location");
const RouteContext = /* @__PURE__ */ React.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (RouteContext.displayName = "Route");
const RouteErrorContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (RouteErrorContext.displayName = "RouteError");
function useHref($, ee) {
  let {
    relative: te
  } = ee === void 0 ? {} : ee;
  useInRouterContext() || (process.env.NODE_ENV !== "production" ? invariant$2(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant$2(!1));
  let {
    basename: ne,
    navigator: re
  } = React.useContext(NavigationContext), {
    hash: se,
    pathname: ie,
    search: oe
  } = useResolvedPath($, {
    relative: te
  }), le = ie;
  return ne !== "/" && (le = ie === "/" ? ne : joinPaths([ne, ie])), re.createHref({
    pathname: le,
    search: oe,
    hash: se
  });
}
function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
function useLocation() {
  return useInRouterContext() || (process.env.NODE_ENV !== "production" ? invariant$2(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant$2(!1)), React.useContext(LocationContext).location;
}
const navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect($) {
  React.useContext(NavigationContext).static || React.useLayoutEffect($);
}
function useNavigate() {
  let {
    isDataRoute: $
  } = React.useContext(RouteContext);
  return $ ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  useInRouterContext() || (process.env.NODE_ENV !== "production" ? invariant$2(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant$2(!1));
  let $ = React.useContext(DataRouterContext), {
    basename: ee,
    future: te,
    navigator: ne
  } = React.useContext(NavigationContext), {
    matches: re
  } = React.useContext(RouteContext), {
    pathname: se
  } = useLocation(), ie = JSON.stringify(getResolveToMatches(re, te.v7_relativeSplatPath)), oe = React.useRef(!1);
  return useIsomorphicLayoutEffect(() => {
    oe.current = !0;
  }), React.useCallback(function(ue, de) {
    if (de === void 0 && (de = {}), process.env.NODE_ENV !== "production" && warning(oe.current, navigateEffectWarning), !oe.current)
      return;
    if (typeof ue == "number") {
      ne.go(ue);
      return;
    }
    let fe = resolveTo(ue, JSON.parse(ie), se, de.relative === "path");
    $ == null && ee !== "/" && (fe.pathname = fe.pathname === "/" ? ee : joinPaths([ee, fe.pathname])), (de.replace ? ne.replace : ne.push)(fe, de.state, de);
  }, [ee, ne, ie, se, $]);
}
function useParams() {
  let {
    matches: $
  } = React.useContext(RouteContext), ee = $[$.length - 1];
  return ee ? ee.params : {};
}
function useResolvedPath($, ee) {
  let {
    relative: te
  } = ee === void 0 ? {} : ee, {
    future: ne
  } = React.useContext(NavigationContext), {
    matches: re
  } = React.useContext(RouteContext), {
    pathname: se
  } = useLocation(), ie = JSON.stringify(getResolveToMatches(re, ne.v7_relativeSplatPath));
  return React.useMemo(() => resolveTo($, JSON.parse(ie), se, te === "path"), [$, ie, se, te]);
}
function useRoutes($, ee) {
  return useRoutesImpl($, ee);
}
function useRoutesImpl($, ee, te, ne) {
  useInRouterContext() || (process.env.NODE_ENV !== "production" ? invariant$2(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : invariant$2(!1));
  let {
    navigator: re
  } = React.useContext(NavigationContext), {
    matches: se
  } = React.useContext(RouteContext), ie = se[se.length - 1], oe = ie ? ie.params : {}, le = ie ? ie.pathname : "/", ue = ie ? ie.pathnameBase : "/", de = ie && ie.route;
  if (process.env.NODE_ENV !== "production") {
    let Ee = de && de.path || "";
    warningOnce(le, !de || Ee.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + le + '" (under <Route path="' + Ee + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + Ee + '"> to <Route ') + ('path="' + (Ee === "/" ? "*" : Ee + "/*") + '">.'));
  }
  let fe = useLocation(), pe;
  if (ee) {
    var ye;
    let Ee = typeof ee == "string" ? parsePath(ee) : ee;
    ue === "/" || (ye = Ee.pathname) != null && ye.startsWith(ue) || (process.env.NODE_ENV !== "production" ? invariant$2(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + ue + '" ') + ('but pathname "' + Ee.pathname + '" was given in the `location` prop.')) : invariant$2(!1)), pe = Ee;
  } else
    pe = fe;
  let me = pe.pathname || "/", ve = me;
  if (ue !== "/") {
    let Ee = ue.replace(/^\//, "").split("/");
    ve = "/" + me.replace(/^\//, "").split("/").slice(Ee.length).join("/");
  }
  let ge = matchRoutes($, {
    pathname: ve
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && warning(de || ge != null, 'No routes matched location "' + pe.pathname + pe.search + pe.hash + '" '), process.env.NODE_ENV !== "production" && warning(ge == null || ge[ge.length - 1].route.element !== void 0 || ge[ge.length - 1].route.Component !== void 0 || ge[ge.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + pe.pathname + pe.search + pe.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let xe = _renderMatches(ge && ge.map((Ee) => Object.assign({}, Ee, {
    params: Object.assign({}, oe, Ee.params),
    pathname: joinPaths([
      ue,
      // Re-encode pathnames that were decoded inside matchRoutes
      re.encodeLocation ? re.encodeLocation(Ee.pathname).pathname : Ee.pathname
    ]),
    pathnameBase: Ee.pathnameBase === "/" ? ue : joinPaths([
      ue,
      // Re-encode pathnames that were decoded inside matchRoutes
      re.encodeLocation ? re.encodeLocation(Ee.pathnameBase).pathname : Ee.pathnameBase
    ])
  })), se, te, ne);
  return ee && xe ? /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    value: {
      location: _extends$6({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, pe),
      navigationType: Action.Pop
    }
  }, xe) : xe;
}
function DefaultErrorComponent() {
  let $ = useRouteError(), ee = isRouteErrorResponse($) ? $.status + " " + $.statusText : $ instanceof Error ? $.message : JSON.stringify($), te = $ instanceof Error ? $.stack : null, ne = "rgba(200,200,200, 0.5)", re = {
    padding: "0.5rem",
    backgroundColor: ne
  }, se = {
    padding: "2px 4px",
    backgroundColor: ne
  }, ie = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", $), ie = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, " Hey developer "), /* @__PURE__ */ React.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React.createElement("code", {
    style: se
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React.createElement("code", {
    style: se
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, ee), te ? /* @__PURE__ */ React.createElement("pre", {
    style: re
  }, te) : null, ie);
}
const defaultErrorElement = /* @__PURE__ */ React.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends React.Component {
  constructor(ee) {
    super(ee), this.state = {
      location: ee.location,
      revalidation: ee.revalidation,
      error: ee.error
    };
  }
  static getDerivedStateFromError(ee) {
    return {
      error: ee
    };
  }
  static getDerivedStateFromProps(ee, te) {
    return te.location !== ee.location || te.revalidation !== "idle" && ee.revalidation === "idle" ? {
      error: ee.error,
      location: ee.location,
      revalidation: ee.revalidation
    } : {
      error: ee.error !== void 0 ? ee.error : te.error,
      location: te.location,
      revalidation: ee.revalidation || te.revalidation
    };
  }
  componentDidCatch(ee, te) {
    console.error("React Router caught the following error during render", ee, te);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ React.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ React.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute($) {
  let {
    routeContext: ee,
    match: te,
    children: ne
  } = $, re = React.useContext(DataRouterContext);
  return re && re.static && re.staticContext && (te.route.errorElement || te.route.ErrorBoundary) && (re.staticContext._deepestRenderedBoundaryId = te.route.id), /* @__PURE__ */ React.createElement(RouteContext.Provider, {
    value: ee
  }, ne);
}
function _renderMatches($, ee, te, ne) {
  var re;
  if (ee === void 0 && (ee = []), te === void 0 && (te = null), ne === void 0 && (ne = null), $ == null) {
    var se;
    if ((se = te) != null && se.errors)
      $ = te.matches;
    else
      return null;
  }
  let ie = $, oe = (re = te) == null ? void 0 : re.errors;
  if (oe != null) {
    let de = ie.findIndex((fe) => fe.route.id && (oe == null ? void 0 : oe[fe.route.id]));
    de >= 0 || (process.env.NODE_ENV !== "production" ? invariant$2(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(oe).join(",")) : invariant$2(!1)), ie = ie.slice(0, Math.min(ie.length, de + 1));
  }
  let le = !1, ue = -1;
  if (te && ne && ne.v7_partialHydration)
    for (let de = 0; de < ie.length; de++) {
      let fe = ie[de];
      if ((fe.route.HydrateFallback || fe.route.hydrateFallbackElement) && (ue = de), fe.route.id) {
        let {
          loaderData: pe,
          errors: ye
        } = te, me = fe.route.loader && pe[fe.route.id] === void 0 && (!ye || ye[fe.route.id] === void 0);
        if (fe.route.lazy || me) {
          le = !0, ue >= 0 ? ie = ie.slice(0, ue + 1) : ie = [ie[0]];
          break;
        }
      }
    }
  return ie.reduceRight((de, fe, pe) => {
    let ye, me = !1, ve = null, ge = null;
    te && (ye = oe && fe.route.id ? oe[fe.route.id] : void 0, ve = fe.route.errorElement || defaultErrorElement, le && (ue < 0 && pe === 0 ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), me = !0, ge = null) : ue === pe && (me = !0, ge = fe.route.hydrateFallbackElement || null)));
    let xe = ee.concat(ie.slice(0, pe + 1)), Ee = () => {
      let Te;
      return ye ? Te = ve : me ? Te = ge : fe.route.Component ? Te = /* @__PURE__ */ React.createElement(fe.route.Component, null) : fe.route.element ? Te = fe.route.element : Te = de, /* @__PURE__ */ React.createElement(RenderedRoute, {
        match: fe,
        routeContext: {
          outlet: de,
          matches: xe,
          isDataRoute: te != null
        },
        children: Te
      });
    };
    return te && (fe.route.ErrorBoundary || fe.route.errorElement || pe === 0) ? /* @__PURE__ */ React.createElement(RenderErrorBoundary, {
      location: te.location,
      revalidation: te.revalidation,
      component: ve,
      error: ye,
      children: Ee(),
      routeContext: {
        outlet: null,
        matches: xe,
        isDataRoute: !0
      }
    }) : Ee();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function($) {
  return $.UseBlocker = "useBlocker", $.UseRevalidator = "useRevalidator", $.UseNavigateStable = "useNavigate", $;
}(DataRouterHook$1 || {}), DataRouterStateHook$1 = /* @__PURE__ */ function($) {
  return $.UseBlocker = "useBlocker", $.UseLoaderData = "useLoaderData", $.UseActionData = "useActionData", $.UseRouteError = "useRouteError", $.UseNavigation = "useNavigation", $.UseRouteLoaderData = "useRouteLoaderData", $.UseMatches = "useMatches", $.UseRevalidator = "useRevalidator", $.UseNavigateStable = "useNavigate", $.UseRouteId = "useRouteId", $;
}(DataRouterStateHook$1 || {});
function getDataRouterConsoleError$1($) {
  return $ + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext$1($) {
  let ee = React.useContext(DataRouterContext);
  return ee || (process.env.NODE_ENV !== "production" ? invariant$2(!1, getDataRouterConsoleError$1($)) : invariant$2(!1)), ee;
}
function useDataRouterState($) {
  let ee = React.useContext(DataRouterStateContext);
  return ee || (process.env.NODE_ENV !== "production" ? invariant$2(!1, getDataRouterConsoleError$1($)) : invariant$2(!1)), ee;
}
function useRouteContext($) {
  let ee = React.useContext(RouteContext);
  return ee || (process.env.NODE_ENV !== "production" ? invariant$2(!1, getDataRouterConsoleError$1($)) : invariant$2(!1)), ee;
}
function useCurrentRouteId($) {
  let ee = useRouteContext($), te = ee.matches[ee.matches.length - 1];
  return te.route.id || (process.env.NODE_ENV !== "production" ? invariant$2(!1, $ + ' can only be used on routes that contain a unique "id"') : invariant$2(!1)), te.route.id;
}
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook$1.UseRouteId);
}
function useRouteError() {
  var $;
  let ee = React.useContext(RouteErrorContext), te = useDataRouterState(DataRouterStateHook$1.UseRouteError), ne = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  return ee !== void 0 ? ee : ($ = te.errors) == null ? void 0 : $[ne];
}
function useNavigateStable() {
  let {
    router: $
  } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable), ee = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable), te = React.useRef(!1);
  return useIsomorphicLayoutEffect(() => {
    te.current = !0;
  }), React.useCallback(function(re, se) {
    se === void 0 && (se = {}), process.env.NODE_ENV !== "production" && warning(te.current, navigateEffectWarning), te.current && (typeof re == "number" ? $.navigate(re) : $.navigate(re, _extends$6({
      fromRouteId: ee
    }, se)));
  }, [$, ee]);
}
const alreadyWarned = {};
function warningOnce($, ee, te) {
  !ee && !alreadyWarned[$] && (alreadyWarned[$] = !0, process.env.NODE_ENV !== "production" && warning(!1, te));
}
function Route($) {
  process.env.NODE_ENV !== "production" ? invariant$2(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : invariant$2(!1);
}
function Router($) {
  let {
    basename: ee = "/",
    children: te = null,
    location: ne,
    navigationType: re = Action.Pop,
    navigator: se,
    static: ie = !1,
    future: oe
  } = $;
  useInRouterContext() && (process.env.NODE_ENV !== "production" ? invariant$2(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant$2(!1));
  let le = ee.replace(/^\/*/, "/"), ue = React.useMemo(() => ({
    basename: le,
    navigator: se,
    static: ie,
    future: _extends$6({
      v7_relativeSplatPath: !1
    }, oe)
  }), [le, oe, se, ie]);
  typeof ne == "string" && (ne = parsePath(ne));
  let {
    pathname: de = "/",
    search: fe = "",
    hash: pe = "",
    state: ye = null,
    key: me = "default"
  } = ne, ve = React.useMemo(() => {
    let ge = stripBasename(de, le);
    return ge == null ? null : {
      location: {
        pathname: ge,
        search: fe,
        hash: pe,
        state: ye,
        key: me
      },
      navigationType: re
    };
  }, [le, de, fe, pe, ye, me, re]);
  return process.env.NODE_ENV !== "production" && warning(ve != null, '<Router basename="' + le + '"> is not able to match the URL ' + ('"' + de + fe + pe + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), ve == null ? null : /* @__PURE__ */ React.createElement(NavigationContext.Provider, {
    value: ue
  }, /* @__PURE__ */ React.createElement(LocationContext.Provider, {
    children: te,
    value: ve
  }));
}
function Routes($) {
  let {
    children: ee,
    location: te
  } = $;
  return useRoutes(createRoutesFromChildren(ee), te);
}
new Promise(() => {
});
function createRoutesFromChildren($, ee) {
  ee === void 0 && (ee = []);
  let te = [];
  return React.Children.forEach($, (ne, re) => {
    if (!/* @__PURE__ */ React.isValidElement(ne))
      return;
    let se = [...ee, re];
    if (ne.type === React.Fragment) {
      te.push.apply(te, createRoutesFromChildren(ne.props.children, se));
      return;
    }
    ne.type !== Route && (process.env.NODE_ENV !== "production" ? invariant$2(!1, "[" + (typeof ne.type == "string" ? ne.type : ne.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : invariant$2(!1)), !ne.props.index || !ne.props.children || (process.env.NODE_ENV !== "production" ? invariant$2(!1, "An index route cannot have child routes.") : invariant$2(!1));
    let ie = {
      id: ne.props.id || se.join("-"),
      caseSensitive: ne.props.caseSensitive,
      element: ne.props.element,
      Component: ne.props.Component,
      index: ne.props.index,
      path: ne.props.path,
      loader: ne.props.loader,
      action: ne.props.action,
      errorElement: ne.props.errorElement,
      ErrorBoundary: ne.props.ErrorBoundary,
      hasErrorBoundary: ne.props.ErrorBoundary != null || ne.props.errorElement != null,
      shouldRevalidate: ne.props.shouldRevalidate,
      handle: ne.props.handle,
      lazy: ne.props.lazy
    };
    ne.props.children && (ie.children = createRoutesFromChildren(ne.props.children, se)), te.push(ie);
  }), te;
}
/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2($, ee) {
  if ($ == null)
    return {};
  var te = {}, ne = Object.keys($), re, se;
  for (se = 0; se < ne.length; se++)
    re = ne[se], !(ee.indexOf(re) >= 0) && (te[re] = $[re]);
  return te;
}
const defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement($) {
  return $ != null && typeof $.tagName == "string";
}
function isButtonElement($) {
  return isHtmlElement($) && $.tagName.toLowerCase() === "button";
}
function isFormElement($) {
  return isHtmlElement($) && $.tagName.toLowerCase() === "form";
}
function isInputElement($) {
  return isHtmlElement($) && $.tagName.toLowerCase() === "input";
}
function isModifiedEvent($) {
  return !!($.metaKey || $.altKey || $.ctrlKey || $.shiftKey);
}
function shouldProcessLinkClick($, ee) {
  return $.button === 0 && // Ignore everything but left clicks
  (!ee || ee === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent($);
}
let _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), _formDataSupportsSubmitter = !1;
    } catch {
      _formDataSupportsSubmitter = !0;
    }
  return _formDataSupportsSubmitter;
}
const supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType($) {
  return $ != null && !supportedFormEncTypes.has($) ? (process.env.NODE_ENV !== "production" && warning(!1, '"' + $ + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + defaultEncType + '"')), null) : $;
}
function getFormSubmissionInfo($, ee) {
  let te, ne, re, se, ie;
  if (isFormElement($)) {
    let oe = $.getAttribute("action");
    ne = oe ? stripBasename(oe, ee) : null, te = $.getAttribute("method") || defaultMethod, re = getFormEncType($.getAttribute("enctype")) || defaultEncType, se = new FormData($);
  } else if (isButtonElement($) || isInputElement($) && ($.type === "submit" || $.type === "image")) {
    let oe = $.form;
    if (oe == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let le = $.getAttribute("formaction") || oe.getAttribute("action");
    if (ne = le ? stripBasename(le, ee) : null, te = $.getAttribute("formmethod") || oe.getAttribute("method") || defaultMethod, re = getFormEncType($.getAttribute("formenctype")) || getFormEncType(oe.getAttribute("enctype")) || defaultEncType, se = new FormData(oe, $), !isFormDataSubmitterSupported()) {
      let {
        name: ue,
        type: de,
        value: fe
      } = $;
      if (de === "image") {
        let pe = ue ? ue + "." : "";
        se.append(pe + "x", "0"), se.append(pe + "y", "0");
      } else
        ue && se.append(ue, fe);
    }
  } else {
    if (isHtmlElement($))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    te = defaultMethod, ne = null, re = defaultEncType, ie = $;
  }
  return se && re === "text/plain" && (ie = se, se = void 0), {
    action: ne,
    method: te.toLowerCase(),
    encType: re,
    formData: se,
    body: ie
  };
}
const _excluded$w = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], _excluded2$5 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"], _excluded3$2 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"], REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch ($) {
}
const ViewTransitionContext = /* @__PURE__ */ React.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (ViewTransitionContext.displayName = "ViewTransition");
const FetchersContext = /* @__PURE__ */ React.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (FetchersContext.displayName = "Fetchers");
const START_TRANSITION = "startTransition", startTransitionImpl = React[START_TRANSITION];
function BrowserRouter($) {
  let {
    basename: ee,
    children: te,
    future: ne,
    window: re
  } = $, se = React.useRef();
  se.current == null && (se.current = createBrowserHistory({
    window: re,
    v5Compat: !0
  }));
  let ie = se.current, [oe, le] = React.useState({
    action: ie.action,
    location: ie.location
  }), {
    v7_startTransition: ue
  } = ne || {}, de = React.useCallback((fe) => {
    ue && startTransitionImpl ? startTransitionImpl(() => le(fe)) : le(fe);
  }, [le, ue]);
  return React.useLayoutEffect(() => ie.listen(de), [ie, de]), /* @__PURE__ */ React.createElement(Router, {
    basename: ee,
    children: te,
    location: oe.location,
    navigationType: oe.action,
    navigator: ie,
    future: ne
  });
}
process.env.NODE_ENV;
const isBrowser$3 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  let {
    onClick: ne,
    relative: re,
    reloadDocument: se,
    replace: ie,
    state: oe,
    target: le,
    to: ue,
    preventScrollReset: de,
    unstable_viewTransition: fe
  } = ee, pe = _objectWithoutPropertiesLoose$2(ee, _excluded$w), {
    basename: ye
  } = React.useContext(NavigationContext), me, ve = !1;
  if (typeof ue == "string" && ABSOLUTE_URL_REGEX.test(ue) && (me = ue, isBrowser$3))
    try {
      let Te = new URL(window.location.href), Se = ue.startsWith("//") ? new URL(Te.protocol + ue) : new URL(ue), he = stripBasename(Se.pathname, ye);
      Se.origin === Te.origin && he != null ? ue = he + Se.search + Se.hash : ve = !0;
    } catch {
      process.env.NODE_ENV !== "production" && warning(!1, '<Link to="' + ue + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let ge = useHref(ue, {
    relative: re
  }), xe = useLinkClickHandler(ue, {
    replace: ie,
    state: oe,
    target: le,
    preventScrollReset: de,
    relative: re,
    unstable_viewTransition: fe
  });
  function Ee(Te) {
    ne && ne(Te), Te.defaultPrevented || xe(Te);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ React.createElement("a", _extends$5({}, pe, {
      href: me || ge,
      onClick: ve || se ? ne : Ee,
      ref: te,
      target: le
    }))
  );
});
process.env.NODE_ENV !== "production" && (Link.displayName = "Link");
const NavLink = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  let {
    "aria-current": ne = "page",
    caseSensitive: re = !1,
    className: se = "",
    end: ie = !1,
    style: oe,
    to: le,
    unstable_viewTransition: ue,
    children: de
  } = ee, fe = _objectWithoutPropertiesLoose$2(ee, _excluded2$5), pe = useResolvedPath(le, {
    relative: fe.relative
  }), ye = useLocation(), me = React.useContext(DataRouterStateContext), {
    navigator: ve,
    basename: ge
  } = React.useContext(NavigationContext), xe = me != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(pe) && ue === !0, Ee = ve.encodeLocation ? ve.encodeLocation(pe).pathname : pe.pathname, Te = ye.pathname, Se = me && me.navigation && me.navigation.location ? me.navigation.location.pathname : null;
  re || (Te = Te.toLowerCase(), Se = Se ? Se.toLowerCase() : null, Ee = Ee.toLowerCase()), Se && ge && (Se = stripBasename(Se, ge) || Se);
  const he = Ee !== "/" && Ee.endsWith("/") ? Ee.length - 1 : Ee.length;
  let Pe = Te === Ee || !ie && Te.startsWith(Ee) && Te.charAt(he) === "/", Ie = Se != null && (Se === Ee || !ie && Se.startsWith(Ee) && Se.charAt(Ee.length) === "/"), De = {
    isActive: Pe,
    isPending: Ie,
    isTransitioning: xe
  }, Ce = Pe ? ne : void 0, Ne;
  typeof se == "function" ? Ne = se(De) : Ne = [se, Pe ? "active" : null, Ie ? "pending" : null, xe ? "transitioning" : null].filter(Boolean).join(" ");
  let Me = typeof oe == "function" ? oe(De) : oe;
  return /* @__PURE__ */ React.createElement(Link, _extends$5({}, fe, {
    "aria-current": Ce,
    className: Ne,
    ref: te,
    style: Me,
    to: le,
    unstable_viewTransition: ue
  }), typeof de == "function" ? de(De) : de);
});
process.env.NODE_ENV !== "production" && (NavLink.displayName = "NavLink");
const Form = /* @__PURE__ */ React.forwardRef(($, ee) => {
  let {
    fetcherKey: te,
    navigate: ne,
    reloadDocument: re,
    replace: se,
    state: ie,
    method: oe = defaultMethod,
    action: le,
    onSubmit: ue,
    relative: de,
    preventScrollReset: fe,
    unstable_viewTransition: pe
  } = $, ye = _objectWithoutPropertiesLoose$2($, _excluded3$2), me = useSubmit(), ve = useFormAction(le, {
    relative: de
  }), ge = oe.toLowerCase() === "get" ? "get" : "post", xe = (Ee) => {
    if (ue && ue(Ee), Ee.defaultPrevented)
      return;
    Ee.preventDefault();
    let Te = Ee.nativeEvent.submitter, Se = (Te == null ? void 0 : Te.getAttribute("formmethod")) || oe;
    me(Te || Ee.currentTarget, {
      fetcherKey: te,
      method: Se,
      navigate: ne,
      replace: se,
      state: ie,
      relative: de,
      preventScrollReset: fe,
      unstable_viewTransition: pe
    });
  };
  return /* @__PURE__ */ React.createElement("form", _extends$5({
    ref: ee,
    method: ge,
    action: ve,
    onSubmit: re ? ue : xe
  }, ye));
});
process.env.NODE_ENV !== "production" && (Form.displayName = "Form");
process.env.NODE_ENV;
var DataRouterHook;
(function($) {
  $.UseScrollRestoration = "useScrollRestoration", $.UseSubmit = "useSubmit", $.UseSubmitFetcher = "useSubmitFetcher", $.UseFetcher = "useFetcher", $.useViewTransitionState = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function($) {
  $.UseFetcher = "useFetcher", $.UseFetchers = "useFetchers", $.UseScrollRestoration = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError($) {
  return $ + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext($) {
  let ee = React.useContext(DataRouterContext);
  return ee || (process.env.NODE_ENV !== "production" ? invariant$2(!1, getDataRouterConsoleError($)) : invariant$2(!1)), ee;
}
function useLinkClickHandler($, ee) {
  let {
    target: te,
    replace: ne,
    state: re,
    preventScrollReset: se,
    relative: ie,
    unstable_viewTransition: oe
  } = ee === void 0 ? {} : ee, le = useNavigate(), ue = useLocation(), de = useResolvedPath($, {
    relative: ie
  });
  return React.useCallback((fe) => {
    if (shouldProcessLinkClick(fe, te)) {
      fe.preventDefault();
      let pe = ne !== void 0 ? ne : createPath(ue) === createPath(de);
      le($, {
        replace: pe,
        state: re,
        preventScrollReset: se,
        relative: ie,
        unstable_viewTransition: oe
      });
    }
  }, [ue, le, de, ne, re, te, $, se, ie, oe]);
}
function validateClientSideSubmission() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let fetcherId = 0, getUniqueFetcherId = () => "__" + String(++fetcherId) + "__";
function useSubmit() {
  let {
    router: $
  } = useDataRouterContext(DataRouterHook.UseSubmit), {
    basename: ee
  } = React.useContext(NavigationContext), te = useRouteId();
  return React.useCallback(function(ne, re) {
    re === void 0 && (re = {}), validateClientSideSubmission();
    let {
      action: se,
      method: ie,
      encType: oe,
      formData: le,
      body: ue
    } = getFormSubmissionInfo(ne, ee);
    if (re.navigate === !1) {
      let de = re.fetcherKey || getUniqueFetcherId();
      $.fetch(de, te, re.action || se, {
        preventScrollReset: re.preventScrollReset,
        formData: le,
        body: ue,
        formMethod: re.method || ie,
        formEncType: re.encType || oe,
        unstable_flushSync: re.unstable_flushSync
      });
    } else
      $.navigate(re.action || se, {
        preventScrollReset: re.preventScrollReset,
        formData: le,
        body: ue,
        formMethod: re.method || ie,
        formEncType: re.encType || oe,
        replace: re.replace,
        state: re.state,
        fromRouteId: te,
        unstable_flushSync: re.unstable_flushSync,
        unstable_viewTransition: re.unstable_viewTransition
      });
  }, [$, ee, te]);
}
function useFormAction($, ee) {
  let {
    relative: te
  } = ee === void 0 ? {} : ee, {
    basename: ne
  } = React.useContext(NavigationContext), re = React.useContext(RouteContext);
  re || (process.env.NODE_ENV !== "production" ? invariant$2(!1, "useFormAction must be used inside a RouteContext") : invariant$2(!1));
  let [se] = re.matches.slice(-1), ie = _extends$5({}, useResolvedPath($ || ".", {
    relative: te
  })), oe = useLocation();
  if ($ == null) {
    ie.search = oe.search;
    let le = new URLSearchParams(ie.search);
    le.has("index") && le.get("index") === "" && (le.delete("index"), ie.search = le.toString() ? "?" + le.toString() : "");
  }
  return (!$ || $ === ".") && se.route.index && (ie.search = ie.search ? ie.search.replace(/^\?/, "?index&") : "?index"), ne !== "/" && (ie.pathname = ie.pathname === "/" ? ne : joinPaths([ne, ie.pathname])), createPath(ie);
}
function useViewTransitionState($, ee) {
  ee === void 0 && (ee = {});
  let te = React.useContext(ViewTransitionContext);
  te == null && (process.env.NODE_ENV !== "production" ? invariant$2(!1, "`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : invariant$2(!1));
  let {
    basename: ne
  } = useDataRouterContext(DataRouterHook.useViewTransitionState), re = useResolvedPath($, {
    relative: ee.relative
  });
  if (!te.isTransitioning)
    return !1;
  let se = stripBasename(te.currentLocation.pathname, ne) || te.currentLocation.pathname, ie = stripBasename(te.nextLocation.pathname, ne) || te.nextLocation.pathname;
  return matchPath(re.pathname, ie) != null || matchPath(re.pathname, se) != null;
}
const ROUTES = {
  ROOT_PATH: "/community",
  POST: "/post",
  POST_DETAIL: "community/post/:id",
  PAGE_NOT_FOUND_PATH: "404",
  TOPIC: "/topic/:topicId"
};
var LMAppRoutesConstant = /* @__PURE__ */ (($) => ($.ROOT_PATHNAME = "community", $.POST_DETAILS_PATHNAME = "community/post", $))(LMAppRoutesConstant || {});
function useFetchFeeds($) {
  const { lmFeedclient: ee, customEventClient: te, lmfeedAnalyticsClient: ne } = useContext(
    GlobalClientProviderContext
  ), { routes: re } = useContext(GeneralContext), { currentCommunity: se, currentUser: ie, logoutUser: oe } = useContext(
    UserProviderContext
  ), { displaySnackbarMessage: le, closeSnackbar: ue, showSnackbar: de, message: fe } = useContext(GeneralContext), { FeedListCustomActions: pe = {}, postComponentClickCustomCallback: ye } = useContext(CustomAgentProviderContext), {
    deletePostCustomAction: me,
    pinPostCustomAction: ve,
    likePostCustomAction: ge,
    clickNavigationCustomAction: xe
  } = pe, Ee = useNavigate(), [Te, Se] = useState([]), [he, Pe] = useState({}), [Ie, De] = useState(!0), [Ce, Ne] = useState(1), [Me, Be] = useState([]), [We, Le] = useState({}), He = useCallback(
    async function() {
      try {
        const At = await (ee == null ? void 0 : ee.getFeed(
          H$1.builder().setTopicIds($ ? [$] : Te).setpage(1).setpageSize(10).build()
        ));
        At.success && (Ne(2), Be([...At.data.posts]), Le({ ...At.data.users }), Pe({ ...At.data.topics })), At.data.posts.length || De(!1);
      } catch (At) {
        console.log(At);
      }
    },
    [ee, $, Te]
  ), Ge = useCallback(
    async function() {
      try {
        const At = await (ee == null ? void 0 : ee.getFeed(
          H$1.builder().setTopicIds(Te).setpage(Ce).setpageSize(10).build()
        ));
        At.success && (Ne((ze) => ze + 1), Be([...Me, ...At.data.posts]), Le({ ...We, ...At.data.users }), Pe({ ...he, ...At.data.topics })), At.data.posts.length || De(!1);
      } catch (At) {
        console.log(At);
      }
    },
    [
      Ce,
      Me,
      We,
      ee,
      Te,
      he
    ]
  ), Ze = useCallback(
    async function(At) {
      try {
        if ((await (ee == null ? void 0 : ee.deletePost(
          R$1.builder().setpostId(At).build()
        ))).success) {
          const we = [...Me], Ae = we.findIndex((je) => je.Id === At), Re = we[Ae];
          ne == null || ne.sendPostDeletedEvent(
            Re,
            he,
            (ie == null ? void 0 : ie.state) === 4 ? "member" : "CM"
          ), we.splice(Ae, 1), Be(we), le && le(LMDisplayMessages.POST_DELETED_SUCCESSFULLY);
        }
      } catch (ze) {
        console.log(ze);
      }
    },
    [le, Me, ee]
  ), Ue = useCallback(
    async function(At) {
      try {
        if ((await (ee == null ? void 0 : ee.pinPost(
          K$1.builder().setpostId(At).build()
        ))).success) {
          const we = [...Me], Ae = we.findIndex((je) => je.Id === At), Re = we[Ae];
          Re.isPinned ? (Re.isPinned = !1, Re.menuItems = Re.menuItems.map((je) => je.id.toString() === LMFeedPostMenuItems.UNPIN_POST ? {
            id: parseInt(LMFeedPostMenuItems.PIN_POST),
            title: "Pin Post"
          } : je)) : (Re.isPinned = !0, Re.menuItems = Re.menuItems.map((je) => je.id.toString() === LMFeedPostMenuItems.PIN_POST ? {
            id: parseInt(LMFeedPostMenuItems.UNPIN_POST),
            title: "Unpin This Post"
          } : je)), Be(we), le && (Re.isPinned ? le(LMDisplayMessages.POST_PINNED_SUCCESS) : le(LMDisplayMessages.PIN_REMOVED_SUCCESS));
        }
      } catch (ze) {
        console.log(ze);
      }
    },
    [le, Me, ee]
  ), Qe = useCallback(
    async function(At) {
      try {
        if ((await (ee == null ? void 0 : ee.likePost(
          j$1.builder().setpostId(At).build()
        ))).success) {
          const we = [...Me], Ae = we.findIndex((je) => je.Id === At), Re = we[Ae];
          we[Ae].isLiked = !we[Ae].isLiked, we[Ae].isLiked ? (ne == null || ne.sendPostLikedEvent(Re, he), we[Ae].likesCount++) : (ne == null || ne.sendPostUnLikedEvent(Re, he), we[Ae].likesCount--), Be(we);
        }
      } catch (ze) {
        console.log(ze);
      }
    },
    [Me, ee]
  ), Je = useCallback(
    (At) => {
      sessionStorage.setItem("scroll-pos", At.Id || "");
      let ze = "";
      re ? ze = re == null ? void 0 : re.feedDetailsRoute.pathname : ze = LMAppRoutesConstant.POST_DETAILS_PATHNAME, Ee(
        `/${ze}/${`${At.Id}-${At == null ? void 0 : At.heading}`.substring(0, 59)}`
      );
    },
    [Ee, re]
  );
  useEffect(() => (te == null || te.listen(LMFeedCustomActionEvents.POST_CREATED, () => {
    He(), le && le(LMDisplayMessages.POST_CREATED_SUCCESS);
  }), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.POST_CREATED))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.POST_EDITED,
    (At) => {
      const ze = At.detail, { post: we, usersMap: Ae, topicsMap: Re } = ze, je = [...Me].map((qe) => qe.Id === we.Id ? we : qe), Fe = { ...We, ...Ae }, $e = { ...he, ...Re };
      Be(je), Pe($e), Le(Fe), le && le(LMDisplayMessages.POST_EDIT_SUCCESS);
    }
  ), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.POST_EDITED))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.LIKE_POST_CALLED,
    (At) => {
      const ze = At.detail.postId, we = [...Me].map((Ae) => (Ae.Id === ze && (Ae.isLiked ? (Ae.isLiked = !1, Ae.likesCount--) : (Ae.isLiked = !0, Ae.likesCount++)), Ae));
      Be(we);
    }
  ), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.LIKE_POST_CALLED))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.COMMENT_ADDED,
    (At) => {
      const ze = At.detail.postId, we = [...Me].map((Ae) => (Ae.Id === ze && Ae.commentsCount++, Ae));
      Be(we);
    }
  ), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.COMMENT_ADDED))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.COMMENT_REMOVED,
    (At) => {
      const ze = At.detail.postId, we = [...Me].map((Ae) => (Ae.Id === ze && Ae.commentsCount--, Ae));
      Be(we);
    }
  ), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.COMMENT_REMOVED))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.PINNED_ON_DETAIL,
    (At) => {
      const ze = At.detail.id, we = [...Me].map((Ae) => (Ae.Id === ze && (Ae.menuItems = Ae.menuItems.map((Re) => (Re.id.toString() === LMFeedPostMenuItems.PIN_POST && (Re.id = parseInt(LMFeedPostMenuItems.UNPIN_POST), Re.title = "Unpin This Post"), Re)), Ae.isPinned = !Ae.isPinned), Ae));
      Be(we);
    }
  ), () => te == null ? void 0 : te.remove(LMFeedCustomActionEvents.PINNED_ON_DETAIL))), useEffect(() => (te == null || te.listen(
    LMFeedCustomActionEvents.DELETE_POST_ON_DETAILS,
    async (At) => {
      const ze = At.detail.postId;
      await Ze(ze), window.history.back();
    }
  ), () => te == null ? void 0 : te.remove(
    LMFeedCustomActionEvents.DELETE_POST_ON_DETAILS
  ))), useEffect(() => {
    He();
  }, [He]);
  const Ot = useMemo(() => ({
    feedListDataStore: {
      selectedTopics: Te,
      setSelectedTopics: Se,
      topics: he,
      setTopics: Pe,
      loadMoreFeeds: Ie,
      setLoadMoreFeeds: De,
      currentPageCount: Ce,
      setCurrentPageCount: Ne,
      feedList: Me,
      setFeedList: Be,
      feedUsersList: We,
      setFeedUsersList: Le
    },
    applicationGeneralsStore: {
      userDataStore: {
        lmFeedUser: ie,
        lmFeedUserCurrentCommunity: se,
        logOutUser: oe
      },
      generalDataStore: {
        displaySnackbarMessage: le,
        closeSnackbar: ue,
        showSnackbar: de,
        message: fe
      }
    },
    defaultActions: {
      deletePost: Ze,
      pinPost: Ue,
      likePost: Qe,
      getNextPage: Ge,
      clickNavigator: Je
    },
    navigate: Ee
  }), [
    Te,
    he,
    Ie,
    Ce,
    Me,
    We,
    ie,
    se,
    oe,
    le,
    ue,
    de,
    fe,
    Ze,
    Ue,
    Qe,
    Ge,
    Je,
    Ee
  ]);
  return {
    topics: he,
    selectedTopics: Te,
    setSelectedTopics: Se,
    loadMoreFeeds: Ie,
    feedList: Me,
    feedUsersList: We,
    getNextPage: Ge,
    deletePost: me ? me.bind(null, Ot) : Ze,
    pinPost: ve ? ve.bind(null, Ot) : Ue,
    likePost: ge ? ge.bind(null, Ot) : Qe,
    postComponentClickCustomCallback: ye ? ye.bind(null, Ot) : void 0,
    clickNavigator: xe ? xe.bind(null, Ot) : Je
  };
}
const LMFeedDataContext = createContext({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$7 = function($, ee) {
  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$7($, ee);
};
function __extends$7($, ee) {
  extendStatics$7($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$7 = function() {
  return __assign$7 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$7.apply(this, arguments);
};
function throttle$1($, ee, te, ne) {
  var re, se = !1, ie = 0;
  function oe() {
    re && clearTimeout(re);
  }
  function le() {
    oe(), se = !0;
  }
  typeof ee != "boolean" && (ne = te, te = ee, ee = void 0);
  function ue() {
    var de = this, fe = Date.now() - ie, pe = arguments;
    if (se)
      return;
    function ye() {
      ie = Date.now(), te.apply(de, pe);
    }
    function me() {
      re = void 0;
    }
    ne && !re && ye(), oe(), ne === void 0 && fe > $ ? ye() : ee !== !0 && (re = setTimeout(ne ? me : ye, ne === void 0 ? $ - fe : $));
  }
  return ue.cancel = le, ue;
}
var ThresholdUnits = {
  Pixel: "Pixel",
  Percent: "Percent"
}, defaultThreshold = {
  unit: ThresholdUnits.Percent,
  value: 0.8
};
function parseThreshold($) {
  return typeof $ == "number" ? {
    unit: ThresholdUnits.Percent,
    value: $ * 100
  } : typeof $ == "string" ? $.match(/^(\d*(\.\d+)?)px$/) ? {
    unit: ThresholdUnits.Pixel,
    value: parseFloat($)
  } : $.match(/^(\d*(\.\d+)?)%$/) ? {
    unit: ThresholdUnits.Percent,
    value: parseFloat($)
  } : (console.warn('scrollThreshold format is invalid. Valid formats: "120px", "50%"...'), defaultThreshold) : (console.warn("scrollThreshold should be string or number"), defaultThreshold);
}
var InfiniteScroll = (
  /** @class */
  function($) {
    __extends$7(ee, $);
    function ee(te) {
      var ne = $.call(this, te) || this;
      return ne.lastScrollTop = 0, ne.actionTriggered = !1, ne.startY = 0, ne.currentY = 0, ne.dragging = !1, ne.maxPullDownDistance = 0, ne.getScrollableTarget = function() {
        return ne.props.scrollableTarget instanceof HTMLElement ? ne.props.scrollableTarget : typeof ne.props.scrollableTarget == "string" ? document.getElementById(ne.props.scrollableTarget) : (ne.props.scrollableTarget === null && console.warn(`You are trying to pass scrollableTarget but it is null. This might
        happen because the element may not have been added to DOM yet.
        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.
      `), null);
      }, ne.onStart = function(re) {
        ne.lastScrollTop || (ne.dragging = !0, re instanceof MouseEvent ? ne.startY = re.pageY : re instanceof TouchEvent && (ne.startY = re.touches[0].pageY), ne.currentY = ne.startY, ne._infScroll && (ne._infScroll.style.willChange = "transform", ne._infScroll.style.transition = "transform 0.2s cubic-bezier(0,0,0.31,1)"));
      }, ne.onMove = function(re) {
        ne.dragging && (re instanceof MouseEvent ? ne.currentY = re.pageY : re instanceof TouchEvent && (ne.currentY = re.touches[0].pageY), !(ne.currentY < ne.startY) && (ne.currentY - ne.startY >= Number(ne.props.pullDownToRefreshThreshold) && ne.setState({
          pullToRefreshThresholdBreached: !0
        }), !(ne.currentY - ne.startY > ne.maxPullDownDistance * 1.5) && ne._infScroll && (ne._infScroll.style.overflow = "visible", ne._infScroll.style.transform = "translate3d(0px, " + (ne.currentY - ne.startY) + "px, 0px)")));
      }, ne.onEnd = function() {
        ne.startY = 0, ne.currentY = 0, ne.dragging = !1, ne.state.pullToRefreshThresholdBreached && (ne.props.refreshFunction && ne.props.refreshFunction(), ne.setState({
          pullToRefreshThresholdBreached: !1
        })), requestAnimationFrame(function() {
          ne._infScroll && (ne._infScroll.style.overflow = "auto", ne._infScroll.style.transform = "none", ne._infScroll.style.willChange = "unset");
        });
      }, ne.onScrollListener = function(re) {
        typeof ne.props.onScroll == "function" && setTimeout(function() {
          return ne.props.onScroll && ne.props.onScroll(re);
        }, 0);
        var se = ne.props.height || ne._scrollableNode ? re.target : document.documentElement.scrollTop ? document.documentElement : document.body;
        if (!ne.actionTriggered) {
          var ie = ne.props.inverse ? ne.isElementAtTop(se, ne.props.scrollThreshold) : ne.isElementAtBottom(se, ne.props.scrollThreshold);
          ie && ne.props.hasMore && (ne.actionTriggered = !0, ne.setState({ showLoader: !0 }), ne.props.next && ne.props.next()), ne.lastScrollTop = se.scrollTop;
        }
      }, ne.state = {
        showLoader: !1,
        pullToRefreshThresholdBreached: !1,
        prevDataLength: te.dataLength
      }, ne.throttledOnScrollListener = throttle$1(150, ne.onScrollListener).bind(ne), ne.onStart = ne.onStart.bind(ne), ne.onMove = ne.onMove.bind(ne), ne.onEnd = ne.onEnd.bind(ne), ne;
    }
    return ee.prototype.componentDidMount = function() {
      if (typeof this.props.dataLength > "u")
        throw new Error('mandatory prop "dataLength" is missing. The prop is needed when loading more content. Check README.md for usage');
      if (this._scrollableNode = this.getScrollableTarget(), this.el = this.props.height ? this._infScroll : this._scrollableNode || window, this.el && this.el.addEventListener("scroll", this.throttledOnScrollListener), typeof this.props.initialScrollY == "number" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY && this.el.scrollTo(0, this.props.initialScrollY), this.props.pullDownToRefresh && this.el && (this.el.addEventListener("touchstart", this.onStart), this.el.addEventListener("touchmove", this.onMove), this.el.addEventListener("touchend", this.onEnd), this.el.addEventListener("mousedown", this.onStart), this.el.addEventListener("mousemove", this.onMove), this.el.addEventListener("mouseup", this.onEnd), this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0, this.forceUpdate(), typeof this.props.refreshFunction != "function"))
        throw new Error(`Mandatory prop "refreshFunction" missing.
          Pull Down To Refresh functionality will not work
          as expected. Check README.md for usage'`);
    }, ee.prototype.componentWillUnmount = function() {
      this.el && (this.el.removeEventListener("scroll", this.throttledOnScrollListener), this.props.pullDownToRefresh && (this.el.removeEventListener("touchstart", this.onStart), this.el.removeEventListener("touchmove", this.onMove), this.el.removeEventListener("touchend", this.onEnd), this.el.removeEventListener("mousedown", this.onStart), this.el.removeEventListener("mousemove", this.onMove), this.el.removeEventListener("mouseup", this.onEnd)));
    }, ee.prototype.componentDidUpdate = function(te) {
      this.props.dataLength !== te.dataLength && (this.actionTriggered = !1, this.setState({
        showLoader: !1
      }));
    }, ee.getDerivedStateFromProps = function(te, ne) {
      var re = te.dataLength !== ne.prevDataLength;
      return re ? __assign$7(__assign$7({}, ne), { prevDataLength: te.dataLength }) : null;
    }, ee.prototype.isElementAtTop = function(te, ne) {
      ne === void 0 && (ne = 0.8);
      var re = te === document.body || te === document.documentElement ? window.screen.availHeight : te.clientHeight, se = parseThreshold(ne);
      return se.unit === ThresholdUnits.Pixel ? te.scrollTop <= se.value + re - te.scrollHeight + 1 : te.scrollTop <= se.value / 100 + re - te.scrollHeight + 1;
    }, ee.prototype.isElementAtBottom = function(te, ne) {
      ne === void 0 && (ne = 0.8);
      var re = te === document.body || te === document.documentElement ? window.screen.availHeight : te.clientHeight, se = parseThreshold(ne);
      return se.unit === ThresholdUnits.Pixel ? te.scrollTop + re >= te.scrollHeight - se.value : te.scrollTop + re >= se.value / 100 * te.scrollHeight;
    }, ee.prototype.render = function() {
      var te = this, ne = __assign$7({ height: this.props.height || "auto", overflow: "auto", WebkitOverflowScrolling: "touch" }, this.props.style), re = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length), se = this.props.pullDownToRefresh && this.props.height ? { overflow: "auto" } : {};
      return React__default.createElement(
        "div",
        { style: se, className: "infinite-scroll-component__outerdiv" },
        React__default.createElement(
          "div",
          { className: "infinite-scroll-component " + (this.props.className || ""), ref: function(ie) {
            return te._infScroll = ie;
          }, style: ne },
          this.props.pullDownToRefresh && React__default.createElement(
            "div",
            { style: { position: "relative" }, ref: function(ie) {
              return te._pullDown = ie;
            } },
            React__default.createElement("div", { style: {
              position: "absolute",
              left: 0,
              right: 0,
              top: -1 * this.maxPullDownDistance
            } }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)
          ),
          this.props.children,
          !this.state.showLoader && !re && this.props.hasMore && this.props.loader,
          this.state.showLoader && this.props.hasMore && this.props.loader,
          !this.props.hasMore && this.props.endMessage
        )
      );
    }, ee;
  }(Component)
), LMTopicsDropdownMode = /* @__PURE__ */ (($) => ($.modify = "MODIFY", $.view = "VIEW", $.edit = "EDIT", $))(LMTopicsDropdownMode || {});
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$4.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1($, ee) {
  if ($ == null)
    return {};
  var te = {}, ne = Object.keys($), re, se;
  for (se = 0; se < ne.length; se++)
    re = ne[se], !(ee.indexOf(re) >= 0) && (te[re] = $[re]);
  return te;
}
var reactIs$2 = { exports: {} }, reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1)
    return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var $ = Symbol.for("react.element"), ee = Symbol.for("react.portal"), te = Symbol.for("react.fragment"), ne = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), ie = Symbol.for("react.context"), oe = Symbol.for("react.server_context"), le = Symbol.for("react.forward_ref"), ue = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), pe = Symbol.for("react.lazy"), ye = Symbol.for("react.offscreen"), me;
  me = Symbol.for("react.module.reference");
  function ve(ge) {
    if (typeof ge == "object" && ge !== null) {
      var xe = ge.$$typeof;
      switch (xe) {
        case $:
          switch (ge = ge.type, ge) {
            case te:
            case re:
            case ne:
            case ue:
            case de:
              return ge;
            default:
              switch (ge = ge && ge.$$typeof, ge) {
                case oe:
                case ie:
                case le:
                case pe:
                case fe:
                case se:
                  return ge;
                default:
                  return xe;
              }
          }
        case ee:
          return xe;
      }
    }
  }
  return reactIs_production_min$1.ContextConsumer = ie, reactIs_production_min$1.ContextProvider = se, reactIs_production_min$1.Element = $, reactIs_production_min$1.ForwardRef = le, reactIs_production_min$1.Fragment = te, reactIs_production_min$1.Lazy = pe, reactIs_production_min$1.Memo = fe, reactIs_production_min$1.Portal = ee, reactIs_production_min$1.Profiler = re, reactIs_production_min$1.StrictMode = ne, reactIs_production_min$1.Suspense = ue, reactIs_production_min$1.SuspenseList = de, reactIs_production_min$1.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min$1.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min$1.isContextConsumer = function(ge) {
    return ve(ge) === ie;
  }, reactIs_production_min$1.isContextProvider = function(ge) {
    return ve(ge) === se;
  }, reactIs_production_min$1.isElement = function(ge) {
    return typeof ge == "object" && ge !== null && ge.$$typeof === $;
  }, reactIs_production_min$1.isForwardRef = function(ge) {
    return ve(ge) === le;
  }, reactIs_production_min$1.isFragment = function(ge) {
    return ve(ge) === te;
  }, reactIs_production_min$1.isLazy = function(ge) {
    return ve(ge) === pe;
  }, reactIs_production_min$1.isMemo = function(ge) {
    return ve(ge) === fe;
  }, reactIs_production_min$1.isPortal = function(ge) {
    return ve(ge) === ee;
  }, reactIs_production_min$1.isProfiler = function(ge) {
    return ve(ge) === re;
  }, reactIs_production_min$1.isStrictMode = function(ge) {
    return ve(ge) === ne;
  }, reactIs_production_min$1.isSuspense = function(ge) {
    return ve(ge) === ue;
  }, reactIs_production_min$1.isSuspenseList = function(ge) {
    return ve(ge) === de;
  }, reactIs_production_min$1.isValidElementType = function(ge) {
    return typeof ge == "string" || typeof ge == "function" || ge === te || ge === re || ge === ne || ge === ue || ge === de || ge === ye || typeof ge == "object" && ge !== null && (ge.$$typeof === pe || ge.$$typeof === fe || ge.$$typeof === se || ge.$$typeof === ie || ge.$$typeof === le || ge.$$typeof === me || ge.getModuleId !== void 0);
  }, reactIs_production_min$1.typeOf = ve, reactIs_production_min$1;
}
var reactIs_development$1 = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, process.env.NODE_ENV !== "production" && function() {
    var $ = Symbol.for("react.element"), ee = Symbol.for("react.portal"), te = Symbol.for("react.fragment"), ne = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), ie = Symbol.for("react.context"), oe = Symbol.for("react.server_context"), le = Symbol.for("react.forward_ref"), ue = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), fe = Symbol.for("react.memo"), pe = Symbol.for("react.lazy"), ye = Symbol.for("react.offscreen"), me = !1, ve = !1, ge = !1, xe = !1, Ee = !1, Te;
    Te = Symbol.for("react.module.reference");
    function Se(pt) {
      return !!(typeof pt == "string" || typeof pt == "function" || pt === te || pt === re || Ee || pt === ne || pt === ue || pt === de || xe || pt === ye || me || ve || ge || typeof pt == "object" && pt !== null && (pt.$$typeof === pe || pt.$$typeof === fe || pt.$$typeof === se || pt.$$typeof === ie || pt.$$typeof === le || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      pt.$$typeof === Te || pt.getModuleId !== void 0));
    }
    function he(pt) {
      if (typeof pt == "object" && pt !== null) {
        var Bt = pt.$$typeof;
        switch (Bt) {
          case $:
            var Vt = pt.type;
            switch (Vt) {
              case te:
              case re:
              case ne:
              case ue:
              case de:
                return Vt;
              default:
                var qt = Vt && Vt.$$typeof;
                switch (qt) {
                  case oe:
                  case ie:
                  case le:
                  case pe:
                  case fe:
                  case se:
                    return qt;
                  default:
                    return Bt;
                }
            }
          case ee:
            return Bt;
        }
      }
    }
    var Pe = ie, Ie = se, De = $, Ce = le, Ne = te, Me = pe, Be = fe, We = ee, Le = re, He = ne, Ge = ue, Ze = de, Ue = !1, Qe = !1;
    function Je(pt) {
      return Ue || (Ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function Ot(pt) {
      return Qe || (Qe = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function At(pt) {
      return he(pt) === ie;
    }
    function ze(pt) {
      return he(pt) === se;
    }
    function we(pt) {
      return typeof pt == "object" && pt !== null && pt.$$typeof === $;
    }
    function Ae(pt) {
      return he(pt) === le;
    }
    function Re(pt) {
      return he(pt) === te;
    }
    function je(pt) {
      return he(pt) === pe;
    }
    function Fe(pt) {
      return he(pt) === fe;
    }
    function $e(pt) {
      return he(pt) === ee;
    }
    function qe(pt) {
      return he(pt) === re;
    }
    function Ye(pt) {
      return he(pt) === ne;
    }
    function Ke(pt) {
      return he(pt) === ue;
    }
    function Tt(pt) {
      return he(pt) === de;
    }
    reactIs_development$1.ContextConsumer = Pe, reactIs_development$1.ContextProvider = Ie, reactIs_development$1.Element = De, reactIs_development$1.ForwardRef = Ce, reactIs_development$1.Fragment = Ne, reactIs_development$1.Lazy = Me, reactIs_development$1.Memo = Be, reactIs_development$1.Portal = We, reactIs_development$1.Profiler = Le, reactIs_development$1.StrictMode = He, reactIs_development$1.Suspense = Ge, reactIs_development$1.SuspenseList = Ze, reactIs_development$1.isAsyncMode = Je, reactIs_development$1.isConcurrentMode = Ot, reactIs_development$1.isContextConsumer = At, reactIs_development$1.isContextProvider = ze, reactIs_development$1.isElement = we, reactIs_development$1.isForwardRef = Ae, reactIs_development$1.isFragment = Re, reactIs_development$1.isLazy = je, reactIs_development$1.isMemo = Fe, reactIs_development$1.isPortal = $e, reactIs_development$1.isProfiler = qe, reactIs_development$1.isStrictMode = Ye, reactIs_development$1.isSuspense = Ke, reactIs_development$1.isSuspenseList = Tt, reactIs_development$1.isValidElementType = Se, reactIs_development$1.typeOf = he;
  }()), reactIs_development$1;
}
process.env.NODE_ENV === "production" ? reactIs$2.exports = requireReactIs_production_min$1() : reactIs$2.exports = requireReactIs_development$1();
var reactIsExports$1 = reactIs$2.exports;
function composeClasses($, ee, te = void 0) {
  const ne = {};
  return Object.keys($).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (re) => {
      ne[re] = $[re].reduce((se, ie) => {
        if (ie) {
          const oe = ee(ie);
          oe !== "" && se.push(oe), te && te[ie] && se.push(te[ie]);
        }
        return se;
      }, []).join(" ");
    }
  ), ne;
}
function isHostComponent($) {
  return typeof $ == "string";
}
function appendOwnerState($, ee, te) {
  return $ === void 0 || isHostComponent($) ? ee : _extends$4({}, ee, {
    ownerState: _extends$4({}, ee.ownerState, te)
  });
}
function extractEventHandlers($, ee = []) {
  if ($ === void 0)
    return {};
  const te = {};
  return Object.keys($).filter((ne) => ne.match(/^on[A-Z]/) && typeof $[ne] == "function" && !ee.includes(ne)).forEach((ne) => {
    te[ne] = $[ne];
  }), te;
}
function resolveComponentProps($, ee, te) {
  return typeof $ == "function" ? $(ee, te) : $;
}
function chainPropTypes($, ee) {
  return process.env.NODE_ENV === "production" ? () => null : function(...ne) {
    return $(...ne) || ee(...ne);
  };
}
function isPlainObject($) {
  if (typeof $ != "object" || $ === null)
    return !1;
  const ee = Object.getPrototypeOf($);
  return (ee === null || ee === Object.prototype || Object.getPrototypeOf(ee) === null) && !(Symbol.toStringTag in $) && !(Symbol.iterator in $);
}
function deepClone($) {
  if (!isPlainObject($))
    return $;
  const ee = {};
  return Object.keys($).forEach((te) => {
    ee[te] = deepClone($[te]);
  }), ee;
}
function deepmerge$1($, ee, te = {
  clone: !0
}) {
  const ne = te.clone ? _extends$4({}, $) : $;
  return isPlainObject($) && isPlainObject(ee) && Object.keys(ee).forEach((re) => {
    re !== "__proto__" && (isPlainObject(ee[re]) && re in $ && isPlainObject($[re]) ? ne[re] = deepmerge$1($[re], ee[re], te) : te.clone ? ne[re] = isPlainObject(ee[re]) ? deepClone(ee[re]) : ee[re] : ne[re] = ee[re]);
  }), ne;
}
const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: deepmerge$1,
  isPlainObject
}, Symbol.toStringTag, { value: "Module" }));
function isClassComponent$1($) {
  const {
    prototype: ee = {}
  } = $;
  return !!ee.isReactComponent;
}
function acceptingRef($, ee, te, ne, re) {
  const se = $[ee], ie = re || ee;
  if (se == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for Emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let oe;
  const le = se.type;
  return typeof le == "function" && !isClassComponent$1(le) && (oe = "Did you accidentally use a plain function component for an element instead?"), oe !== void 0 ? new Error(`Invalid ${ne} \`${ie}\` supplied to \`${te}\`. Expected an element that can hold a ref. ${oe} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const elementAcceptingRef = chainPropTypes(PropTypes.element, acceptingRef);
elementAcceptingRef.isRequired = chainPropTypes(PropTypes.element.isRequired, acceptingRef);
const elementAcceptingRef$1 = elementAcceptingRef;
function isClassComponent($) {
  const {
    prototype: ee = {}
  } = $;
  return !!ee.isReactComponent;
}
function elementTypeAcceptingRef($, ee, te, ne, re) {
  const se = $[ee], ie = re || ee;
  if (se == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let oe;
  return typeof se == "function" && !isClassComponent(se) && (oe = "Did you accidentally provide a plain function component instead?"), oe !== void 0 ? new Error(`Invalid ${ne} \`${ie}\` supplied to \`${te}\`. Expected an element type that can hold a ref. ${oe} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const elementTypeAcceptingRef$1 = chainPropTypes(PropTypes.elementType, elementTypeAcceptingRef), specialProperty = "exact-prop: ";
function exactProp($) {
  return process.env.NODE_ENV === "production" ? $ : _extends$4({}, $, {
    [specialProperty]: (ee) => {
      const te = Object.keys(ee).filter((ne) => !$.hasOwnProperty(ne));
      return te.length > 0 ? new Error(`The following props are not supported: ${te.map((ne) => `\`${ne}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
function formatMuiErrorMessage$1($) {
  let ee = "https://mui.com/production-error/?code=" + $;
  for (let te = 1; te < arguments.length; te += 1)
    ee += "&args[]=" + encodeURIComponent(arguments[te]);
  return "Minified MUI error #" + $ + "; visit " + ee + " for the full message.";
}
const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: formatMuiErrorMessage$1
}, Symbol.toStringTag, { value: "Module" })), fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName($) {
  const ee = `${$}`.match(fnNameMatchRegex);
  return ee && ee[1] || "";
}
function getFunctionComponentName($, ee = "") {
  return $.displayName || $.name || getFunctionName($) || ee;
}
function getWrappedName($, ee, te) {
  const ne = getFunctionComponentName(ee);
  return $.displayName || (ne !== "" ? `${te}(${ne})` : te);
}
function getDisplayName$1($) {
  if ($ != null) {
    if (typeof $ == "string")
      return $;
    if (typeof $ == "function")
      return getFunctionComponentName($, "Component");
    if (typeof $ == "object")
      switch ($.$$typeof) {
        case reactIsExports$1.ForwardRef:
          return getWrappedName($, $.render, "ForwardRef");
        case reactIsExports$1.Memo:
          return getWrappedName($, $.type, "memo");
        default:
          return;
      }
  }
}
const getDisplayName = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: getDisplayName$1,
  getFunctionName
}, Symbol.toStringTag, { value: "Module" }));
function HTMLElementType($, ee, te, ne, re) {
  if (process.env.NODE_ENV === "production")
    return null;
  const se = $[ee], ie = re || ee;
  return se == null ? null : se && se.nodeType !== 1 ? new Error(`Invalid ${ne} \`${ie}\` supplied to \`${te}\`. Expected an HTMLElement.`) : null;
}
const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]), refType$1 = refType;
function capitalize$1($) {
  if (typeof $ != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : formatMuiErrorMessage$1(7));
  return $.charAt(0).toUpperCase() + $.slice(1);
}
const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: capitalize$1
}, Symbol.toStringTag, { value: "Module" }));
function createChainedFunction(...$) {
  return $.reduce((ee, te) => te == null ? ee : function(...re) {
    ee.apply(this, re), te.apply(this, re);
  }, () => {
  });
}
function debounce$1($, ee = 166) {
  let te;
  function ne(...re) {
    const se = () => {
      $.apply(this, re);
    };
    clearTimeout(te), te = setTimeout(se, ee);
  }
  return ne.clear = () => {
    clearTimeout(te);
  }, ne;
}
function ownerDocument($) {
  return $ && $.ownerDocument || document;
}
function ownerWindow($) {
  return ownerDocument($).defaultView || window;
}
function setRef($, ee) {
  typeof $ == "function" ? $(ee) : $ && ($.current = ee);
}
const useEnhancedEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
let globalId = 0;
function useGlobalId($) {
  const [ee, te] = React.useState($), ne = $ || ee;
  return React.useEffect(() => {
    ee == null && (globalId += 1, te(`mui-${globalId}`));
  }, [ee]), ne;
}
const maybeReactUseId = React.useId;
function useId($) {
  if (maybeReactUseId !== void 0) {
    const ee = maybeReactUseId();
    return $ ?? ee;
  }
  return useGlobalId($);
}
function useControlled({
  controlled: $,
  default: ee,
  name: te,
  state: ne = "value"
}) {
  const {
    current: re
  } = React.useRef($ !== void 0), [se, ie] = React.useState(ee), oe = re ? $ : se;
  if (process.env.NODE_ENV !== "production") {
    React.useEffect(() => {
      re !== ($ !== void 0) && console.error([`MUI: A component is changing the ${re ? "" : "un"}controlled ${ne} state of ${te} to be ${re ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${te} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join(`
`));
    }, [ne, te, $]);
    const {
      current: ue
    } = React.useRef(ee);
    React.useEffect(() => {
      !re && ue !== ee && console.error([`MUI: A component is changing the default ${ne} state of an uncontrolled ${te} after being initialized. To suppress this warning opt to use a controlled ${te}.`].join(`
`));
    }, [JSON.stringify(ee)]);
  }
  const le = React.useCallback((ue) => {
    re || ie(ue);
  }, []);
  return [oe, le];
}
function useEventCallback($) {
  const ee = React.useRef($);
  return useEnhancedEffect(() => {
    ee.current = $;
  }), React.useRef((...te) => (
    // @ts-expect-error hide `this`
    (0, ee.current)(...te)
  )).current;
}
function useForkRef(...$) {
  return React.useMemo(() => $.every((ee) => ee == null) ? null : (ee) => {
    $.forEach((te) => {
      setRef(te, ee);
    });
  }, $);
}
const UNINITIALIZED = {};
function useLazyRef($, ee) {
  const te = React.useRef(UNINITIALIZED);
  return te.current === UNINITIALIZED && (te.current = $(ee)), te;
}
const EMPTY = [];
function useOnMount($) {
  React.useEffect($, EMPTY);
}
class Timeout {
  constructor() {
    this.currentId = null, this.clear = () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    }, this.disposeEffect = () => this.clear;
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(ee, te) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, te();
    }, ee);
  }
}
function useTimeout() {
  const $ = useLazyRef(Timeout.create).current;
  return useOnMount($.disposeEffect), $;
}
let hadKeyboardEvent = !0, hadFocusVisibleRecently = !1;
const hadFocusVisibleRecentlyTimeout = new Timeout(), inputTypesWhitelist = {
  text: !0,
  search: !0,
  url: !0,
  tel: !0,
  email: !0,
  password: !0,
  number: !0,
  date: !0,
  month: !0,
  week: !0,
  time: !0,
  datetime: !0,
  "datetime-local": !0
};
function focusTriggersKeyboardModality($) {
  const {
    type: ee,
    tagName: te
  } = $;
  return !!(te === "INPUT" && inputTypesWhitelist[ee] && !$.readOnly || te === "TEXTAREA" && !$.readOnly || $.isContentEditable);
}
function handleKeyDown($) {
  $.metaKey || $.altKey || $.ctrlKey || (hadKeyboardEvent = !0);
}
function handlePointerDown() {
  hadKeyboardEvent = !1;
}
function handleVisibilityChange() {
  this.visibilityState === "hidden" && hadFocusVisibleRecently && (hadKeyboardEvent = !0);
}
function prepare($) {
  $.addEventListener("keydown", handleKeyDown, !0), $.addEventListener("mousedown", handlePointerDown, !0), $.addEventListener("pointerdown", handlePointerDown, !0), $.addEventListener("touchstart", handlePointerDown, !0), $.addEventListener("visibilitychange", handleVisibilityChange, !0);
}
function isFocusVisible($) {
  const {
    target: ee
  } = $;
  try {
    return ee.matches(":focus-visible");
  } catch {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(ee);
}
function useIsFocusVisible() {
  const $ = React.useCallback((re) => {
    re != null && prepare(re.ownerDocument);
  }, []), ee = React.useRef(!1);
  function te() {
    return ee.current ? (hadFocusVisibleRecently = !0, hadFocusVisibleRecentlyTimeout.start(100, () => {
      hadFocusVisibleRecently = !1;
    }), ee.current = !1, !0) : !1;
  }
  function ne(re) {
    return isFocusVisible(re) ? (ee.current = !0, !0) : !1;
  }
  return {
    isFocusVisibleRef: ee,
    onFocus: ne,
    onBlur: te,
    ref: $
  };
}
function getScrollbarSize($) {
  const ee = $.documentElement.clientWidth;
  return Math.abs(window.innerWidth - ee);
}
const usePreviousProps = ($) => {
  const ee = React.useRef({});
  return React.useEffect(() => {
    ee.current = $;
  }), ee.current;
};
function getTypeByValue($) {
  const ee = typeof $;
  switch (ee) {
    case "number":
      return Number.isNaN($) ? "NaN" : Number.isFinite($) ? $ !== Math.floor($) ? "float" : "number" : "Infinity";
    case "object":
      return $ === null ? "null" : $.constructor.name;
    default:
      return ee;
  }
}
function ponyfillIsInteger($) {
  return typeof $ == "number" && isFinite($) && Math.floor($) === $;
}
const isInteger = Number.isInteger || ponyfillIsInteger;
function requiredInteger($, ee, te, ne) {
  const re = $[ee];
  if (re == null || !isInteger(re)) {
    const se = getTypeByValue(re);
    return new RangeError(`Invalid ${ne} \`${ee}\` of type \`${se}\` supplied to \`${te}\`, expected \`integer\`.`);
  }
  return null;
}
function validator$3($, ee, ...te) {
  return $[ee] === void 0 ? null : requiredInteger($, ee, ...te);
}
function validatorNoop() {
  return null;
}
validator$3.isRequired = requiredInteger;
validatorNoop.isRequired = validatorNoop;
const integerPropType = process.env.NODE_ENV === "production" ? validatorNoop : validator$3;
function resolveProps($, ee) {
  const te = _extends$4({}, ee);
  return Object.keys($).forEach((ne) => {
    if (ne.toString().match(/^(components|slots)$/))
      te[ne] = _extends$4({}, $[ne], te[ne]);
    else if (ne.toString().match(/^(componentsProps|slotProps)$/)) {
      const re = $[ne] || {}, se = ee[ne];
      te[ne] = {}, !se || !Object.keys(se) ? te[ne] = re : !re || !Object.keys(re) ? te[ne] = se : (te[ne] = _extends$4({}, se), Object.keys(re).forEach((ie) => {
        te[ne][ie] = resolveProps(re[ie], se[ie]);
      }));
    } else
      te[ne] === void 0 && (te[ne] = $[ne]);
  }), te;
}
const defaultGenerator = ($) => $, createClassNameGenerator = () => {
  let $ = defaultGenerator;
  return {
    configure(ee) {
      $ = ee;
    },
    generate(ee) {
      return $(ee);
    },
    reset() {
      $ = defaultGenerator;
    }
  };
}, ClassNameGenerator = createClassNameGenerator(), globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass($, ee, te = "Mui") {
  const ne = globalStateClasses[ee];
  return ne ? `${te}-${ne}` : `${ClassNameGenerator.generate($)}-${ee}`;
}
function generateUtilityClasses($, ee, te = "Mui") {
  const ne = {};
  return ee.forEach((re) => {
    ne[re] = generateUtilityClass($, re, te);
  }), ne;
}
function clamp$2($, ee = Number.MIN_SAFE_INTEGER, te = Number.MAX_SAFE_INTEGER) {
  return Math.max(ee, Math.min($, te));
}
const clamp$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clamp$2
}, Symbol.toStringTag, { value: "Module" }));
function omitEventHandlers($) {
  if ($ === void 0)
    return {};
  const ee = {};
  return Object.keys($).filter((te) => !(te.match(/^on[A-Z]/) && typeof $[te] == "function")).forEach((te) => {
    ee[te] = $[te];
  }), ee;
}
function mergeSlotProps($) {
  const {
    getSlotProps: ee,
    additionalProps: te,
    externalSlotProps: ne,
    externalForwardedProps: re,
    className: se
  } = $;
  if (!ee) {
    const ye = clsx(te == null ? void 0 : te.className, se, re == null ? void 0 : re.className, ne == null ? void 0 : ne.className), me = _extends$4({}, te == null ? void 0 : te.style, re == null ? void 0 : re.style, ne == null ? void 0 : ne.style), ve = _extends$4({}, te, re, ne);
    return ye.length > 0 && (ve.className = ye), Object.keys(me).length > 0 && (ve.style = me), {
      props: ve,
      internalRef: void 0
    };
  }
  const ie = extractEventHandlers(_extends$4({}, re, ne)), oe = omitEventHandlers(ne), le = omitEventHandlers(re), ue = ee(ie), de = clsx(ue == null ? void 0 : ue.className, te == null ? void 0 : te.className, se, re == null ? void 0 : re.className, ne == null ? void 0 : ne.className), fe = _extends$4({}, ue == null ? void 0 : ue.style, te == null ? void 0 : te.style, re == null ? void 0 : re.style, ne == null ? void 0 : ne.style), pe = _extends$4({}, ue, te, le, oe);
  return de.length > 0 && (pe.className = de), Object.keys(fe).length > 0 && (pe.style = fe), {
    props: pe,
    internalRef: ue.ref
  };
}
const _excluded$v = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps($) {
  var ee;
  const {
    elementType: te,
    externalSlotProps: ne,
    ownerState: re,
    skipResolvingSlotProps: se = !1
  } = $, ie = _objectWithoutPropertiesLoose$1($, _excluded$v), oe = se ? {} : resolveComponentProps(ne, re), {
    props: le,
    internalRef: ue
  } = mergeSlotProps(_extends$4({}, ie, {
    externalSlotProps: oe
  })), de = useForkRef(ue, oe == null ? void 0 : oe.ref, (ee = $.additionalProps) == null ? void 0 : ee.ref);
  return appendOwnerState(te, _extends$4({}, le, {
    ref: de
  }), re);
}
const RtlContext = /* @__PURE__ */ React.createContext();
process.env.NODE_ENV !== "production" && (PropTypes.node, PropTypes.bool);
const useRtl = () => {
  const $ = React.useContext(RtlContext);
  return $ ?? !1;
};
var createStyled$2 = {}, interopRequireDefault = { exports: {} };
(function($) {
  function ee(te) {
    return te && te.__esModule ? te : {
      default: te
    };
  }
  $.exports = ee, $.exports.__esModule = !0, $.exports.default = $.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, _extends$3 = { exports: {} }, hasRequired_extends;
function require_extends() {
  return hasRequired_extends || (hasRequired_extends = 1, function($) {
    function ee() {
      return $.exports = ee = Object.assign ? Object.assign.bind() : function(te) {
        for (var ne = 1; ne < arguments.length; ne++) {
          var re = arguments[ne];
          for (var se in re)
            Object.prototype.hasOwnProperty.call(re, se) && (te[se] = re[se]);
        }
        return te;
      }, $.exports.__esModule = !0, $.exports.default = $.exports, ee.apply(this, arguments);
    }
    $.exports = ee, $.exports.__esModule = !0, $.exports.default = $.exports;
  }(_extends$3)), _extends$3.exports;
}
var objectWithoutPropertiesLoose = { exports: {} }, hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  return hasRequiredObjectWithoutPropertiesLoose || (hasRequiredObjectWithoutPropertiesLoose = 1, function($) {
    function ee(te, ne) {
      if (te == null)
        return {};
      var re = {}, se = Object.keys(te), ie, oe;
      for (oe = 0; oe < se.length; oe++)
        ie = se[oe], !(ne.indexOf(ie) >= 0) && (re[ie] = te[ie]);
      return re;
    }
    $.exports = ee, $.exports.__esModule = !0, $.exports.default = $.exports;
  }(objectWithoutPropertiesLoose)), objectWithoutPropertiesLoose.exports;
}
function memoize$2($) {
  var ee = /* @__PURE__ */ Object.create(null);
  return function(te) {
    return ee[te] === void 0 && (ee[te] = $(te)), ee[te];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, isPropValid = /* @__PURE__ */ memoize$2(
  function($) {
    return reactPropsRegex.test($) || $.charCodeAt(0) === 111 && $.charCodeAt(1) === 110 && $.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag($) {
  if ($.sheet)
    return $.sheet;
  for (var ee = 0; ee < document.styleSheets.length; ee++)
    if (document.styleSheets[ee].ownerNode === $)
      return document.styleSheets[ee];
}
function createStyleElement($) {
  var ee = document.createElement("style");
  return ee.setAttribute("data-emotion", $.key), $.nonce !== void 0 && ee.setAttribute("nonce", $.nonce), ee.appendChild(document.createTextNode("")), ee.setAttribute("data-s", ""), ee;
}
var StyleSheet = /* @__PURE__ */ function() {
  function $(te) {
    var ne = this;
    this._insertTag = function(re) {
      var se;
      ne.tags.length === 0 ? ne.insertionPoint ? se = ne.insertionPoint.nextSibling : ne.prepend ? se = ne.container.firstChild : se = ne.before : se = ne.tags[ne.tags.length - 1].nextSibling, ne.container.insertBefore(re, se), ne.tags.push(re);
    }, this.isSpeedy = te.speedy === void 0 ? process.env.NODE_ENV === "production" : te.speedy, this.tags = [], this.ctr = 0, this.nonce = te.nonce, this.key = te.key, this.container = te.container, this.prepend = te.prepend, this.insertionPoint = te.insertionPoint, this.before = null;
  }
  var ee = $.prototype;
  return ee.hydrate = function(ne) {
    ne.forEach(this._insertTag);
  }, ee.insert = function(ne) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
    var re = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var se = ne.charCodeAt(0) === 64 && ne.charCodeAt(1) === 105;
      se && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + ne + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !se;
    }
    if (this.isSpeedy) {
      var ie = sheetForTag(re);
      try {
        ie.insertRule(ne, ie.cssRules.length);
      } catch (oe) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(ne) && console.error('There was a problem inserting the following rule: "' + ne + '"', oe);
      }
    } else
      re.appendChild(document.createTextNode(ne));
    this.ctr++;
  }, ee.flush = function() {
    this.tags.forEach(function(ne) {
      return ne.parentNode && ne.parentNode.removeChild(ne);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, $;
}(), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode, assign = Object.assign;
function hash($, ee) {
  return charat($, 0) ^ 45 ? (((ee << 2 ^ charat($, 0)) << 2 ^ charat($, 1)) << 2 ^ charat($, 2)) << 2 ^ charat($, 3) : 0;
}
function trim($) {
  return $.trim();
}
function match($, ee) {
  return ($ = ee.exec($)) ? $[0] : $;
}
function replace($, ee, te) {
  return $.replace(ee, te);
}
function indexof($, ee) {
  return $.indexOf(ee);
}
function charat($, ee) {
  return $.charCodeAt(ee) | 0;
}
function substr($, ee, te) {
  return $.slice(ee, te);
}
function strlen($) {
  return $.length;
}
function sizeof($) {
  return $.length;
}
function append($, ee) {
  return ee.push($), $;
}
function combine($, ee) {
  return $.map(ee).join("");
}
var line = 1, column = 1, length = 0, position = 0, character = 0, characters = "";
function node($, ee, te, ne, re, se, ie) {
  return { value: $, root: ee, parent: te, type: ne, props: re, children: se, line, column, length: ie, return: "" };
}
function copy($, ee) {
  return assign(node("", null, null, "", null, null, 0), $, { length: -$.length }, ee);
}
function char() {
  return character;
}
function prev() {
  return character = position > 0 ? charat(characters, --position) : 0, column--, character === 10 && (column = 1, line--), character;
}
function next() {
  return character = position < length ? charat(characters, position++) : 0, column++, character === 10 && (column = 1, line++), character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice($, ee) {
  return substr(characters, $, ee);
}
function token($) {
  switch ($) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc($) {
  return line = column = 1, length = strlen(characters = $), position = 0, [];
}
function dealloc($) {
  return characters = "", $;
}
function delimit($) {
  return trim(slice(position - 1, delimiter($ === 91 ? $ + 2 : $ === 40 ? $ + 1 : $)));
}
function whitespace($) {
  for (; (character = peek()) && character < 33; )
    next();
  return token($) > 2 || token(character) > 3 ? "" : " ";
}
function escaping($, ee) {
  for (; --ee && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice($, caret() + (ee < 6 && peek() == 32 && next() == 32));
}
function delimiter($) {
  for (; next(); )
    switch (character) {
      case $:
        return position;
      case 34:
      case 39:
        $ !== 34 && $ !== 39 && delimiter(character);
        break;
      case 40:
        $ === 41 && delimiter($);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter($, ee) {
  for (; next() && $ + character !== 57; )
    if ($ + character === 84 && peek() === 47)
      break;
  return "/*" + slice(ee, position - 1) + "*" + from($ === 47 ? $ : next());
}
function identifier($) {
  for (; !token(peek()); )
    next();
  return slice($, position);
}
function compile($) {
  return dealloc(parse("", null, null, null, [""], $ = alloc($), 0, [0], $));
}
function parse($, ee, te, ne, re, se, ie, oe, le) {
  for (var ue = 0, de = 0, fe = ie, pe = 0, ye = 0, me = 0, ve = 1, ge = 1, xe = 1, Ee = 0, Te = "", Se = re, he = se, Pe = ne, Ie = Te; ge; )
    switch (me = Ee, Ee = next()) {
      case 40:
        if (me != 108 && charat(Ie, fe - 1) == 58) {
          indexof(Ie += replace(delimit(Ee), "&", "&\f"), "&\f") != -1 && (xe = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        Ie += delimit(Ee);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        Ie += whitespace(me);
        break;
      case 92:
        Ie += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), ee, te), le);
            break;
          default:
            Ie += "/";
        }
        break;
      case 123 * ve:
        oe[ue++] = strlen(Ie) * xe;
      case 125 * ve:
      case 59:
      case 0:
        switch (Ee) {
          case 0:
          case 125:
            ge = 0;
          case 59 + de:
            xe == -1 && (Ie = replace(Ie, /\f/g, "")), ye > 0 && strlen(Ie) - fe && append(ye > 32 ? declaration(Ie + ";", ne, te, fe - 1) : declaration(replace(Ie, " ", "") + ";", ne, te, fe - 2), le);
            break;
          case 59:
            Ie += ";";
          default:
            if (append(Pe = ruleset(Ie, ee, te, ue, de, re, oe, Te, Se = [], he = [], fe), se), Ee === 123)
              if (de === 0)
                parse(Ie, ee, Pe, Pe, Se, se, fe, oe, he);
              else
                switch (pe === 99 && charat(Ie, 3) === 110 ? 100 : pe) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse($, Pe, Pe, ne && append(ruleset($, Pe, Pe, 0, 0, re, oe, Te, re, Se = [], fe), he), re, he, fe, oe, ne ? Se : he);
                    break;
                  default:
                    parse(Ie, Pe, Pe, Pe, [""], he, 0, oe, he);
                }
        }
        ue = de = ye = 0, ve = xe = 1, Te = Ie = "", fe = ie;
        break;
      case 58:
        fe = 1 + strlen(Ie), ye = me;
      default:
        if (ve < 1) {
          if (Ee == 123)
            --ve;
          else if (Ee == 125 && ve++ == 0 && prev() == 125)
            continue;
        }
        switch (Ie += from(Ee), Ee * ve) {
          case 38:
            xe = de > 0 ? 1 : (Ie += "\f", -1);
            break;
          case 44:
            oe[ue++] = (strlen(Ie) - 1) * xe, xe = 1;
            break;
          case 64:
            peek() === 45 && (Ie += delimit(next())), pe = peek(), de = fe = strlen(Te = Ie += identifier(caret())), Ee++;
            break;
          case 45:
            me === 45 && strlen(Ie) == 2 && (ve = 0);
        }
    }
  return se;
}
function ruleset($, ee, te, ne, re, se, ie, oe, le, ue, de) {
  for (var fe = re - 1, pe = re === 0 ? se : [""], ye = sizeof(pe), me = 0, ve = 0, ge = 0; me < ne; ++me)
    for (var xe = 0, Ee = substr($, fe + 1, fe = abs(ve = ie[me])), Te = $; xe < ye; ++xe)
      (Te = trim(ve > 0 ? pe[xe] + " " + Ee : replace(Ee, /&\f/g, pe[xe]))) && (le[ge++] = Te);
  return node($, ee, te, re === 0 ? RULESET : oe, le, ue, de);
}
function comment($, ee, te) {
  return node($, ee, te, COMMENT, from(char()), substr($, 2, -2), 0);
}
function declaration($, ee, te, ne) {
  return node($, ee, te, DECLARATION, substr($, 0, ne), substr($, ne + 1, -1), ne);
}
function serialize($, ee) {
  for (var te = "", ne = sizeof($), re = 0; re < ne; re++)
    te += ee($[re], re, $, ee) || "";
  return te;
}
function stringify($, ee, te, ne) {
  switch ($.type) {
    case LAYER:
      if ($.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return $.return = $.return || $.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return $.return = $.value + "{" + serialize($.children, ne) + "}";
    case RULESET:
      $.value = $.props.join(",");
  }
  return strlen(te = serialize($.children, ne)) ? $.return = $.value + "{" + te + "}" : "";
}
function middleware($) {
  var ee = sizeof($);
  return function(te, ne, re, se) {
    for (var ie = "", oe = 0; oe < ee; oe++)
      ie += $[oe](te, ne, re, se) || "";
    return ie;
  };
}
function rulesheet($) {
  return function(ee) {
    ee.root || (ee = ee.return) && $(ee);
  };
}
var identifierWithPointTracking = function $(ee, te, ne) {
  for (var re = 0, se = 0; re = se, se = peek(), re === 38 && se === 12 && (te[ne] = 1), !token(se); )
    next();
  return slice(ee, position);
}, toRules = function $(ee, te) {
  var ne = -1, re = 44;
  do
    switch (token(re)) {
      case 0:
        re === 38 && peek() === 12 && (te[ne] = 1), ee[ne] += identifierWithPointTracking(position - 1, te, ne);
        break;
      case 2:
        ee[ne] += delimit(re);
        break;
      case 4:
        if (re === 44) {
          ee[++ne] = peek() === 58 ? "&\f" : "", te[ne] = ee[ne].length;
          break;
        }
      default:
        ee[ne] += from(re);
    }
  while (re = next());
  return ee;
}, getRules = function $(ee, te) {
  return dealloc(toRules(alloc(ee), te));
}, fixedElements = /* @__PURE__ */ new WeakMap(), compat = function $(ee) {
  if (!(ee.type !== "rule" || !ee.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  ee.length < 1)) {
    for (var te = ee.value, ne = ee.parent, re = ee.column === ne.column && ee.line === ne.line; ne.type !== "rule"; )
      if (ne = ne.parent, !ne)
        return;
    if (!(ee.props.length === 1 && te.charCodeAt(0) !== 58 && !fixedElements.get(ne)) && !re) {
      fixedElements.set(ee, !0);
      for (var se = [], ie = getRules(te, se), oe = ne.props, le = 0, ue = 0; le < ie.length; le++)
        for (var de = 0; de < oe.length; de++, ue++)
          ee.props[ue] = se[le] ? ie[le].replace(/&\f/g, oe[de]) : oe[de] + " " + ie[le];
    }
  }
}, removeLabel = function $(ee) {
  if (ee.type === "decl") {
    var te = ee.value;
    // charcode for l
    te.charCodeAt(0) === 108 && // charcode for b
    te.charCodeAt(2) === 98 && (ee.return = "", ee.value = "");
  }
}, ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", isIgnoringComment = function $(ee) {
  return ee.type === "comm" && ee.children.indexOf(ignoreFlag) > -1;
}, createUnsafeSelectorsAlarm = function $(ee) {
  return function(te, ne, re) {
    if (!(te.type !== "rule" || ee.compat)) {
      var se = te.value.match(/(:first|:nth|:nth-last)-child/g);
      if (se) {
        for (var ie = !!te.parent, oe = ie ? te.parent.children : (
          // global rule at the root level
          re
        ), le = oe.length - 1; le >= 0; le--) {
          var ue = oe[le];
          if (ue.line < te.line)
            break;
          if (ue.column < te.column) {
            if (isIgnoringComment(ue))
              return;
            break;
          }
        }
        se.forEach(function(de) {
          console.error('The pseudo class "' + de + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + de.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, isImportRule = function $(ee) {
  return ee.type.charCodeAt(1) === 105 && ee.type.charCodeAt(0) === 64;
}, isPrependedWithRegularRules = function $(ee, te) {
  for (var ne = ee - 1; ne >= 0; ne--)
    if (!isImportRule(te[ne]))
      return !0;
  return !1;
}, nullifyElement = function $(ee) {
  ee.type = "", ee.value = "", ee.return = "", ee.children = "", ee.props = "";
}, incorrectImportAlarm = function $(ee, te, ne) {
  isImportRule(ee) && (ee.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), nullifyElement(ee)) : isPrependedWithRegularRules(te, ne) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), nullifyElement(ee)));
};
function prefix($, ee) {
  switch (hash($, ee)) {
    case 5103:
      return WEBKIT + "print-" + $ + $;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + $ + $;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + $ + MOZ + $ + MS + $ + $;
    case 6828:
    case 4268:
      return WEBKIT + $ + MS + $ + $;
    case 6165:
      return WEBKIT + $ + MS + "flex-" + $ + $;
    case 5187:
      return WEBKIT + $ + replace($, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + $;
    case 5443:
      return WEBKIT + $ + MS + "flex-item-" + replace($, /flex-|-self/, "") + $;
    case 4675:
      return WEBKIT + $ + MS + "flex-line-pack" + replace($, /align-content|flex-|-self/, "") + $;
    case 5548:
      return WEBKIT + $ + MS + replace($, "shrink", "negative") + $;
    case 5292:
      return WEBKIT + $ + MS + replace($, "basis", "preferred-size") + $;
    case 6060:
      return WEBKIT + "box-" + replace($, "-grow", "") + WEBKIT + $ + MS + replace($, "grow", "positive") + $;
    case 4554:
      return WEBKIT + replace($, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + $;
    case 6187:
      return replace(replace(replace($, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), $, "") + $;
    case 5495:
    case 3959:
      return replace($, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace($, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + $ + $;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace($, /(.+)-inline(.+)/, WEBKIT + "$1$2") + $;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen($) - 1 - ee > 6)
        switch (charat($, ee + 1)) {
          case 109:
            if (charat($, ee + 4) !== 45)
              break;
          case 102:
            return replace($, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat($, ee + 3) == 108 ? "$3" : "$2-$3")) + $;
          case 115:
            return ~indexof($, "stretch") ? prefix(replace($, "stretch", "fill-available"), ee) + $ : $;
        }
      break;
    case 4949:
      if (charat($, ee + 1) !== 115)
        break;
    case 6444:
      switch (charat($, strlen($) - 3 - (~indexof($, "!important") && 10))) {
        case 107:
          return replace($, ":", ":" + WEBKIT) + $;
        case 101:
          return replace($, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat($, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + $;
      }
      break;
    case 5936:
      switch (charat($, ee + 11)) {
        case 114:
          return WEBKIT + $ + MS + replace($, /[svh]\w+-[tblr]{2}/, "tb") + $;
        case 108:
          return WEBKIT + $ + MS + replace($, /[svh]\w+-[tblr]{2}/, "tb-rl") + $;
        case 45:
          return WEBKIT + $ + MS + replace($, /[svh]\w+-[tblr]{2}/, "lr") + $;
      }
      return WEBKIT + $ + MS + $ + $;
  }
  return $;
}
var prefixer = function $(ee, te, ne, re) {
  if (ee.length > -1 && !ee.return)
    switch (ee.type) {
      case DECLARATION:
        ee.return = prefix(ee.value, ee.length);
        break;
      case KEYFRAMES:
        return serialize([copy(ee, {
          value: replace(ee.value, "@", "@" + WEBKIT)
        })], re);
      case RULESET:
        if (ee.length)
          return combine(ee.props, function(se) {
            switch (match(se, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy(ee, {
                  props: [replace(se, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], re);
              case "::placeholder":
                return serialize([copy(ee, {
                  props: [replace(se, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(ee, {
                  props: [replace(se, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(ee, {
                  props: [replace(se, /:(plac\w+)/, MS + "input-$1")]
                })], re);
            }
            return "";
          });
    }
}, defaultStylisPlugins = [prefixer], createCache = function $(ee) {
  var te = ee.key;
  if (process.env.NODE_ENV !== "production" && !te)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (te === "css") {
    var ne = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ne, function(ve) {
      var ge = ve.getAttribute("data-emotion");
      ge.indexOf(" ") !== -1 && (document.head.appendChild(ve), ve.setAttribute("data-s", ""));
    });
  }
  var re = ee.stylisPlugins || defaultStylisPlugins;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(te))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + te + '" was passed');
  var se = {}, ie, oe = [];
  ie = ee.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + te + ' "]'),
    function(ve) {
      for (var ge = ve.getAttribute("data-emotion").split(" "), xe = 1; xe < ge.length; xe++)
        se[ge[xe]] = !0;
      oe.push(ve);
    }
  );
  var le, ue = [compat, removeLabel];
  process.env.NODE_ENV !== "production" && ue.push(createUnsafeSelectorsAlarm({
    get compat() {
      return me.compat;
    }
  }), incorrectImportAlarm);
  {
    var de, fe = [stringify, process.env.NODE_ENV !== "production" ? function(ve) {
      ve.root || (ve.return ? de.insert(ve.return) : ve.value && ve.type !== COMMENT && de.insert(ve.value + "{}"));
    } : rulesheet(function(ve) {
      de.insert(ve);
    })], pe = middleware(ue.concat(re, fe)), ye = function(ge) {
      return serialize(compile(ge), pe);
    };
    le = function(ge, xe, Ee, Te) {
      de = Ee, process.env.NODE_ENV !== "production" && xe.map !== void 0 && (de = {
        insert: function(he) {
          Ee.insert(he + xe.map);
        }
      }), ye(ge ? ge + "{" + xe.styles + "}" : xe.styles), Te && (me.inserted[xe.name] = !0);
    };
  }
  var me = {
    key: te,
    sheet: new StyleSheet({
      key: te,
      container: ie,
      nonce: ee.nonce,
      speedy: ee.speedy,
      prepend: ee.prepend,
      insertionPoint: ee.insertionPoint
    }),
    nonce: ee.nonce,
    inserted: se,
    registered: {},
    insert: le
  };
  return me.sheet.hydrate(oe), me;
}, reactIs$1 = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var $ = typeof Symbol == "function" && Symbol.for, ee = $ ? Symbol.for("react.element") : 60103, te = $ ? Symbol.for("react.portal") : 60106, ne = $ ? Symbol.for("react.fragment") : 60107, re = $ ? Symbol.for("react.strict_mode") : 60108, se = $ ? Symbol.for("react.profiler") : 60114, ie = $ ? Symbol.for("react.provider") : 60109, oe = $ ? Symbol.for("react.context") : 60110, le = $ ? Symbol.for("react.async_mode") : 60111, ue = $ ? Symbol.for("react.concurrent_mode") : 60111, de = $ ? Symbol.for("react.forward_ref") : 60112, fe = $ ? Symbol.for("react.suspense") : 60113, pe = $ ? Symbol.for("react.suspense_list") : 60120, ye = $ ? Symbol.for("react.memo") : 60115, me = $ ? Symbol.for("react.lazy") : 60116, ve = $ ? Symbol.for("react.block") : 60121, ge = $ ? Symbol.for("react.fundamental") : 60117, xe = $ ? Symbol.for("react.responder") : 60118, Ee = $ ? Symbol.for("react.scope") : 60119;
  function Te(he) {
    if (typeof he == "object" && he !== null) {
      var Pe = he.$$typeof;
      switch (Pe) {
        case ee:
          switch (he = he.type, he) {
            case le:
            case ue:
            case ne:
            case se:
            case re:
            case fe:
              return he;
            default:
              switch (he = he && he.$$typeof, he) {
                case oe:
                case de:
                case me:
                case ye:
                case ie:
                  return he;
                default:
                  return Pe;
              }
          }
        case te:
          return Pe;
      }
    }
  }
  function Se(he) {
    return Te(he) === ue;
  }
  return reactIs_production_min.AsyncMode = le, reactIs_production_min.ConcurrentMode = ue, reactIs_production_min.ContextConsumer = oe, reactIs_production_min.ContextProvider = ie, reactIs_production_min.Element = ee, reactIs_production_min.ForwardRef = de, reactIs_production_min.Fragment = ne, reactIs_production_min.Lazy = me, reactIs_production_min.Memo = ye, reactIs_production_min.Portal = te, reactIs_production_min.Profiler = se, reactIs_production_min.StrictMode = re, reactIs_production_min.Suspense = fe, reactIs_production_min.isAsyncMode = function(he) {
    return Se(he) || Te(he) === le;
  }, reactIs_production_min.isConcurrentMode = Se, reactIs_production_min.isContextConsumer = function(he) {
    return Te(he) === oe;
  }, reactIs_production_min.isContextProvider = function(he) {
    return Te(he) === ie;
  }, reactIs_production_min.isElement = function(he) {
    return typeof he == "object" && he !== null && he.$$typeof === ee;
  }, reactIs_production_min.isForwardRef = function(he) {
    return Te(he) === de;
  }, reactIs_production_min.isFragment = function(he) {
    return Te(he) === ne;
  }, reactIs_production_min.isLazy = function(he) {
    return Te(he) === me;
  }, reactIs_production_min.isMemo = function(he) {
    return Te(he) === ye;
  }, reactIs_production_min.isPortal = function(he) {
    return Te(he) === te;
  }, reactIs_production_min.isProfiler = function(he) {
    return Te(he) === se;
  }, reactIs_production_min.isStrictMode = function(he) {
    return Te(he) === re;
  }, reactIs_production_min.isSuspense = function(he) {
    return Te(he) === fe;
  }, reactIs_production_min.isValidElementType = function(he) {
    return typeof he == "string" || typeof he == "function" || he === ne || he === ue || he === se || he === re || he === fe || he === pe || typeof he == "object" && he !== null && (he.$$typeof === me || he.$$typeof === ye || he.$$typeof === ie || he.$$typeof === oe || he.$$typeof === de || he.$$typeof === ge || he.$$typeof === xe || he.$$typeof === Ee || he.$$typeof === ve);
  }, reactIs_production_min.typeOf = Te, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var $ = typeof Symbol == "function" && Symbol.for, ee = $ ? Symbol.for("react.element") : 60103, te = $ ? Symbol.for("react.portal") : 60106, ne = $ ? Symbol.for("react.fragment") : 60107, re = $ ? Symbol.for("react.strict_mode") : 60108, se = $ ? Symbol.for("react.profiler") : 60114, ie = $ ? Symbol.for("react.provider") : 60109, oe = $ ? Symbol.for("react.context") : 60110, le = $ ? Symbol.for("react.async_mode") : 60111, ue = $ ? Symbol.for("react.concurrent_mode") : 60111, de = $ ? Symbol.for("react.forward_ref") : 60112, fe = $ ? Symbol.for("react.suspense") : 60113, pe = $ ? Symbol.for("react.suspense_list") : 60120, ye = $ ? Symbol.for("react.memo") : 60115, me = $ ? Symbol.for("react.lazy") : 60116, ve = $ ? Symbol.for("react.block") : 60121, ge = $ ? Symbol.for("react.fundamental") : 60117, xe = $ ? Symbol.for("react.responder") : 60118, Ee = $ ? Symbol.for("react.scope") : 60119;
    function Te(Ke) {
      return typeof Ke == "string" || typeof Ke == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Ke === ne || Ke === ue || Ke === se || Ke === re || Ke === fe || Ke === pe || typeof Ke == "object" && Ke !== null && (Ke.$$typeof === me || Ke.$$typeof === ye || Ke.$$typeof === ie || Ke.$$typeof === oe || Ke.$$typeof === de || Ke.$$typeof === ge || Ke.$$typeof === xe || Ke.$$typeof === Ee || Ke.$$typeof === ve);
    }
    function Se(Ke) {
      if (typeof Ke == "object" && Ke !== null) {
        var Tt = Ke.$$typeof;
        switch (Tt) {
          case ee:
            var pt = Ke.type;
            switch (pt) {
              case le:
              case ue:
              case ne:
              case se:
              case re:
              case fe:
                return pt;
              default:
                var Bt = pt && pt.$$typeof;
                switch (Bt) {
                  case oe:
                  case de:
                  case me:
                  case ye:
                  case ie:
                    return Bt;
                  default:
                    return Tt;
                }
            }
          case te:
            return Tt;
        }
      }
    }
    var he = le, Pe = ue, Ie = oe, De = ie, Ce = ee, Ne = de, Me = ne, Be = me, We = ye, Le = te, He = se, Ge = re, Ze = fe, Ue = !1;
    function Qe(Ke) {
      return Ue || (Ue = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Je(Ke) || Se(Ke) === le;
    }
    function Je(Ke) {
      return Se(Ke) === ue;
    }
    function Ot(Ke) {
      return Se(Ke) === oe;
    }
    function At(Ke) {
      return Se(Ke) === ie;
    }
    function ze(Ke) {
      return typeof Ke == "object" && Ke !== null && Ke.$$typeof === ee;
    }
    function we(Ke) {
      return Se(Ke) === de;
    }
    function Ae(Ke) {
      return Se(Ke) === ne;
    }
    function Re(Ke) {
      return Se(Ke) === me;
    }
    function je(Ke) {
      return Se(Ke) === ye;
    }
    function Fe(Ke) {
      return Se(Ke) === te;
    }
    function $e(Ke) {
      return Se(Ke) === se;
    }
    function qe(Ke) {
      return Se(Ke) === re;
    }
    function Ye(Ke) {
      return Se(Ke) === fe;
    }
    reactIs_development.AsyncMode = he, reactIs_development.ConcurrentMode = Pe, reactIs_development.ContextConsumer = Ie, reactIs_development.ContextProvider = De, reactIs_development.Element = Ce, reactIs_development.ForwardRef = Ne, reactIs_development.Fragment = Me, reactIs_development.Lazy = Be, reactIs_development.Memo = We, reactIs_development.Portal = Le, reactIs_development.Profiler = He, reactIs_development.StrictMode = Ge, reactIs_development.Suspense = Ze, reactIs_development.isAsyncMode = Qe, reactIs_development.isConcurrentMode = Je, reactIs_development.isContextConsumer = Ot, reactIs_development.isContextProvider = At, reactIs_development.isElement = ze, reactIs_development.isForwardRef = we, reactIs_development.isFragment = Ae, reactIs_development.isLazy = Re, reactIs_development.isMemo = je, reactIs_development.isPortal = Fe, reactIs_development.isProfiler = $e, reactIs_development.isStrictMode = qe, reactIs_development.isSuspense = Ye, reactIs_development.isValidElementType = Te, reactIs_development.typeOf = Se;
  }()), reactIs_development;
}
process.env.NODE_ENV === "production" ? reactIs$1.exports = requireReactIs_production_min() : reactIs$1.exports = requireReactIs_development();
var reactIsExports = reactIs$1.exports, reactIs = reactIsExports, FORWARD_REF_STATICS = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, MEMO_STATICS = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$2 = !0;
function getRegisteredStyles($, ee, te) {
  var ne = "";
  return te.split(" ").forEach(function(re) {
    $[re] !== void 0 ? ee.push($[re] + ";") : ne += re + " ";
  }), ne;
}
var registerStyles = function $(ee, te, ne) {
  var re = ee.key + "-" + te.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (ne === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser$2 === !1) && ee.registered[re] === void 0 && (ee.registered[re] = te.styles);
}, insertStyles = function $(ee, te, ne) {
  registerStyles(ee, te, ne);
  var re = ee.key + "-" + te.name;
  if (ee.inserted[te.name] === void 0) {
    var se = te;
    do
      ee.insert(te === se ? "." + re : "", se, ee.sheet, !0), se = se.next;
    while (se !== void 0);
  }
};
function murmur2($) {
  for (var ee = 0, te, ne = 0, re = $.length; re >= 4; ++ne, re -= 4)
    te = $.charCodeAt(ne) & 255 | ($.charCodeAt(++ne) & 255) << 8 | ($.charCodeAt(++ne) & 255) << 16 | ($.charCodeAt(++ne) & 255) << 24, te = /* Math.imul(k, m): */
    (te & 65535) * 1540483477 + ((te >>> 16) * 59797 << 16), te ^= /* k >>> r: */
    te >>> 24, ee = /* Math.imul(k, m): */
    (te & 65535) * 1540483477 + ((te >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (ee & 65535) * 1540483477 + ((ee >>> 16) * 59797 << 16);
  switch (re) {
    case 3:
      ee ^= ($.charCodeAt(ne + 2) & 255) << 16;
    case 2:
      ee ^= ($.charCodeAt(ne + 1) & 255) << 8;
    case 1:
      ee ^= $.charCodeAt(ne) & 255, ee = /* Math.imul(h, m): */
      (ee & 65535) * 1540483477 + ((ee >>> 16) * 59797 << 16);
  }
  return ee ^= ee >>> 13, ee = /* Math.imul(h, m): */
  (ee & 65535) * 1540483477 + ((ee >>> 16) * 59797 << 16), ((ee ^ ee >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = function $(ee) {
  return ee.charCodeAt(1) === 45;
}, isProcessableValue = function $(ee) {
  return ee != null && typeof ee != "boolean";
}, processStyleName = /* @__PURE__ */ memoize$2(function($) {
  return isCustomProperty($) ? $ : $.replace(hyphenateRegex, "-$&").toLowerCase();
}), processStyleValue = function $(ee, te) {
  switch (ee) {
    case "animation":
    case "animationName":
      if (typeof te == "string")
        return te.replace(animationRegex, function(ne, re, se) {
          return cursor = {
            name: re,
            styles: se,
            next: cursor
          }, re;
        });
  }
  return unitlessKeys[ee] !== 1 && !isCustomProperty(ee) && typeof te == "number" && te !== 0 ? te + "px" : te;
};
if (process.env.NODE_ENV !== "production") {
  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, contentValues = ["normal", "none", "initial", "inherit", "unset"], oldProcessStyleValue = processStyleValue, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, hyphenatedCache = {};
  processStyleValue = function(ee, te) {
    if (ee === "content" && (typeof te != "string" || contentValues.indexOf(te) === -1 && !contentValuePattern.test(te) && (te.charAt(0) !== te.charAt(te.length - 1) || te.charAt(0) !== '"' && te.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + te + "\"'`");
    var ne = oldProcessStyleValue(ee, te);
    return ne !== "" && !isCustomProperty(ee) && ee.indexOf("-") !== -1 && hyphenatedCache[ee] === void 0 && (hyphenatedCache[ee] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + ee.replace(msPattern, "ms-").replace(hyphenPattern, function(re, se) {
      return se.toUpperCase();
    }) + "?")), ne;
  };
}
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation($, ee, te) {
  if (te == null)
    return "";
  if (te.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && te.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(noComponentSelectorMessage);
    return te;
  }
  switch (typeof te) {
    case "boolean":
      return "";
    case "object": {
      if (te.anim === 1)
        return cursor = {
          name: te.name,
          styles: te.styles,
          next: cursor
        }, te.name;
      if (te.styles !== void 0) {
        var ne = te.next;
        if (ne !== void 0)
          for (; ne !== void 0; )
            cursor = {
              name: ne.name,
              styles: ne.styles,
              next: cursor
            }, ne = ne.next;
        var re = te.styles + ";";
        return process.env.NODE_ENV !== "production" && te.map !== void 0 && (re += te.map), re;
      }
      return createStringFromObject($, ee, te);
    }
    case "function": {
      if ($ !== void 0) {
        var se = cursor, ie = te($);
        return cursor = se, handleInterpolation($, ee, ie);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var oe = [], le = te.replace(animationRegex, function(de, fe, pe) {
          var ye = "animation" + oe.length;
          return oe.push("const " + ye + " = keyframes`" + pe.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + ye + "}";
        });
        oe.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(oe, ["`" + le + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + le + "`"));
      }
      break;
  }
  if (ee == null)
    return te;
  var ue = ee[te];
  return ue !== void 0 ? ue : te;
}
function createStringFromObject($, ee, te) {
  var ne = "";
  if (Array.isArray(te))
    for (var re = 0; re < te.length; re++)
      ne += handleInterpolation($, ee, te[re]) + ";";
  else
    for (var se in te) {
      var ie = te[se];
      if (typeof ie != "object")
        ee != null && ee[ie] !== void 0 ? ne += se + "{" + ee[ie] + "}" : isProcessableValue(ie) && (ne += processStyleName(se) + ":" + processStyleValue(se, ie) + ";");
      else {
        if (se === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(noComponentSelectorMessage);
        if (Array.isArray(ie) && typeof ie[0] == "string" && (ee == null || ee[ie[0]] === void 0))
          for (var oe = 0; oe < ie.length; oe++)
            isProcessableValue(ie[oe]) && (ne += processStyleName(se) + ":" + processStyleValue(se, ie[oe]) + ";");
        else {
          var le = handleInterpolation($, ee, ie);
          switch (se) {
            case "animation":
            case "animationName": {
              ne += processStyleName(se) + ":" + le + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && se === "undefined" && console.error(UNDEFINED_AS_OBJECT_KEY_ERROR), ne += se + "{" + le + "}";
          }
        }
      }
    }
  return ne;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, sourceMapPattern;
process.env.NODE_ENV !== "production" && (sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var cursor, serializeStyles = function $(ee, te, ne) {
  if (ee.length === 1 && typeof ee[0] == "object" && ee[0] !== null && ee[0].styles !== void 0)
    return ee[0];
  var re = !0, se = "";
  cursor = void 0;
  var ie = ee[0];
  ie == null || ie.raw === void 0 ? (re = !1, se += handleInterpolation(ne, te, ie)) : (process.env.NODE_ENV !== "production" && ie[0] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1), se += ie[0]);
  for (var oe = 1; oe < ee.length; oe++)
    se += handleInterpolation(ne, te, ee[oe]), re && (process.env.NODE_ENV !== "production" && ie[oe] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1), se += ie[oe]);
  var le;
  process.env.NODE_ENV !== "production" && (se = se.replace(sourceMapPattern, function(pe) {
    return le = pe, "";
  })), labelPattern.lastIndex = 0;
  for (var ue = "", de; (de = labelPattern.exec(se)) !== null; )
    ue += "-" + // $FlowFixMe we know it's not null
    de[1];
  var fe = murmur2(se) + ue;
  return process.env.NODE_ENV !== "production" ? {
    name: fe,
    styles: se,
    map: le,
    next: cursor,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: fe,
    styles: se,
    next: cursor
  };
}, syncFallback = function $(ee) {
  return ee();
}, useInsertionEffect = React.useInsertionEffect ? React.useInsertionEffect : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback, useInsertionEffectWithLayoutFallback = useInsertionEffect || React.useLayoutEffect, hasOwn = {}.hasOwnProperty, EmotionCacheContext = /* @__PURE__ */ React.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (EmotionCacheContext.displayName = "EmotionCacheContext");
var CacheProvider = EmotionCacheContext.Provider, withEmotionCache = function $(ee) {
  return /* @__PURE__ */ forwardRef(function(te, ne) {
    var re = useContext(EmotionCacheContext);
    return ee(te, re, ne);
  });
}, ThemeContext = /* @__PURE__ */ React.createContext({});
process.env.NODE_ENV !== "production" && (ThemeContext.displayName = "EmotionThemeContext");
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", Insertion$2 = function $(ee) {
  var te = ee.cache, ne = ee.serialized, re = ee.isStringTag;
  return registerStyles(te, ne, re), useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(te, ne, re);
  }), null;
}, Emotion = /* @__PURE__ */ withEmotionCache(function($, ee, te) {
  var ne = $.css;
  typeof ne == "string" && ee.registered[ne] !== void 0 && (ne = ee.registered[ne]);
  var re = $[typePropName], se = [ne], ie = "";
  typeof $.className == "string" ? ie = getRegisteredStyles(ee.registered, se, $.className) : $.className != null && (ie = $.className + " ");
  var oe = serializeStyles(se, void 0, React.useContext(ThemeContext));
  if (process.env.NODE_ENV !== "production" && oe.name.indexOf("-") === -1) {
    var le = $[labelPropName];
    le && (oe = serializeStyles([oe, "label:" + le + ";"]));
  }
  ie += ee.key + "-" + oe.name;
  var ue = {};
  for (var de in $)
    hasOwn.call($, de) && de !== "css" && de !== typePropName && (process.env.NODE_ENV === "production" || de !== labelPropName) && (ue[de] = $[de]);
  return ue.ref = te, ue.className = ie, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion$2, {
    cache: ee,
    serialized: oe,
    isStringTag: typeof re == "string"
  }), /* @__PURE__ */ React.createElement(re, ue));
});
process.env.NODE_ENV !== "production" && (Emotion.displayName = "EmotionCssPropInternal");
require_extends();
var pkg = {
  name: "@emotion/react",
  version: "11.11.4",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.2",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, warnedAboutCssPropForGlobal = !1, Global = /* @__PURE__ */ withEmotionCache(function($, ee) {
  process.env.NODE_ENV !== "production" && !warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  ($.className || $.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), warnedAboutCssPropForGlobal = !0);
  var te = $.styles, ne = serializeStyles([te], void 0, React.useContext(ThemeContext)), re = React.useRef();
  return useInsertionEffectWithLayoutFallback(function() {
    var se = ee.key + "-global", ie = new ee.sheet.constructor({
      key: se,
      nonce: ee.sheet.nonce,
      container: ee.sheet.container,
      speedy: ee.sheet.isSpeedy
    }), oe = !1, le = document.querySelector('style[data-emotion="' + se + " " + ne.name + '"]');
    return ee.sheet.tags.length && (ie.before = ee.sheet.tags[0]), le !== null && (oe = !0, le.setAttribute("data-emotion", se), ie.hydrate([le])), re.current = [ie, oe], function() {
      ie.flush();
    };
  }, [ee]), useInsertionEffectWithLayoutFallback(function() {
    var se = re.current, ie = se[0], oe = se[1];
    if (oe) {
      se[1] = !1;
      return;
    }
    if (ne.next !== void 0 && insertStyles(ee, ne.next, !0), ie.tags.length) {
      var le = ie.tags[ie.tags.length - 1].nextElementSibling;
      ie.before = le, ie.flush();
    }
    ee.insert("", ne, ie, !1);
  }, [ee, ne.name]), null;
});
process.env.NODE_ENV !== "production" && (Global.displayName = "EmotionGlobal");
function css() {
  for (var $ = arguments.length, ee = new Array($), te = 0; te < $; te++)
    ee[te] = arguments[te];
  return serializeStyles(ee);
}
var keyframes = function $() {
  var ee = css.apply(void 0, arguments), te = "animation-" + ee.name;
  return {
    name: te,
    styles: "@keyframes " + te + "{" + ee.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, classnames$1 = function $(ee) {
  for (var te = ee.length, ne = 0, re = ""; ne < te; ne++) {
    var se = ee[ne];
    if (se != null) {
      var ie = void 0;
      switch (typeof se) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(se))
            ie = $(se);
          else {
            process.env.NODE_ENV !== "production" && se.styles !== void 0 && se.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), ie = "";
            for (var oe in se)
              se[oe] && oe && (ie && (ie += " "), ie += oe);
          }
          break;
        }
        default:
          ie = se;
      }
      ie && (re && (re += " "), re += ie);
    }
  }
  return re;
};
function merge$1($, ee, te) {
  var ne = [], re = getRegisteredStyles($, ne, te);
  return ne.length < 2 ? te : re + ee(ne);
}
var Insertion$1 = function $(ee) {
  var te = ee.cache, ne = ee.serializedArr;
  return useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var re = 0; re < ne.length; re++)
      insertStyles(te, ne[re], !1);
  }), null;
}, ClassNames = /* @__PURE__ */ withEmotionCache(function($, ee) {
  var te = !1, ne = [], re = function() {
    if (te && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var ue = arguments.length, de = new Array(ue), fe = 0; fe < ue; fe++)
      de[fe] = arguments[fe];
    var pe = serializeStyles(de, ee.registered);
    return ne.push(pe), registerStyles(ee, pe, !1), ee.key + "-" + pe.name;
  }, se = function() {
    if (te && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var ue = arguments.length, de = new Array(ue), fe = 0; fe < ue; fe++)
      de[fe] = arguments[fe];
    return merge$1(ee.registered, re, classnames$1(de));
  }, ie = {
    css: re,
    cx: se,
    theme: React.useContext(ThemeContext)
  }, oe = $.children(ie);
  return te = !0, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion$1, {
    cache: ee,
    serializedArr: ne
  }), oe);
});
process.env.NODE_ENV !== "production" && (ClassNames.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var isBrowser$1 = !0, isTestEnv = typeof jest < "u" || typeof vi < "u";
  if (isBrowser$1 && !isTestEnv) {
    var globalContext = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : isBrowser$1 ? window : global
    ), globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    globalContext[globalKey] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), globalContext[globalKey] = !0;
  }
}
var testOmitPropsOnStringTag = isPropValid, testOmitPropsOnComponent = function $(ee) {
  return ee !== "theme";
}, getDefaultShouldForwardProp = function $(ee) {
  return typeof ee == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  ee.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
}, composeShouldForwardProps = function $(ee, te, ne) {
  var re;
  if (te) {
    var se = te.shouldForwardProp;
    re = ee.__emotion_forwardProp && se ? function(ie) {
      return ee.__emotion_forwardProp(ie) && se(ie);
    } : se;
  }
  return typeof re != "function" && ne && (re = ee.__emotion_forwardProp), re;
}, ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, Insertion = function $(ee) {
  var te = ee.cache, ne = ee.serialized, re = ee.isStringTag;
  return registerStyles(te, ne, re), useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(te, ne, re);
  }), null;
}, createStyled$1 = function $(ee, te) {
  if (process.env.NODE_ENV !== "production" && ee === void 0)
    throw new Error(`You are trying to create a styled element with an undefined component.
You may have forgotten to import it.`);
  var ne = ee.__emotion_real === ee, re = ne && ee.__emotion_base || ee, se, ie;
  te !== void 0 && (se = te.label, ie = te.target);
  var oe = composeShouldForwardProps(ee, te, ne), le = oe || getDefaultShouldForwardProp(re), ue = !le("as");
  return function() {
    var de = arguments, fe = ne && ee.__emotion_styles !== void 0 ? ee.__emotion_styles.slice(0) : [];
    if (se !== void 0 && fe.push("label:" + se + ";"), de[0] == null || de[0].raw === void 0)
      fe.push.apply(fe, de);
    else {
      process.env.NODE_ENV !== "production" && de[0][0] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), fe.push(de[0][0]);
      for (var pe = de.length, ye = 1; ye < pe; ye++)
        process.env.NODE_ENV !== "production" && de[0][ye] === void 0 && console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR), fe.push(de[ye], de[0][ye]);
    }
    var me = withEmotionCache(function(ve, ge, xe) {
      var Ee = ue && ve.as || re, Te = "", Se = [], he = ve;
      if (ve.theme == null) {
        he = {};
        for (var Pe in ve)
          he[Pe] = ve[Pe];
        he.theme = React.useContext(ThemeContext);
      }
      typeof ve.className == "string" ? Te = getRegisteredStyles(ge.registered, Se, ve.className) : ve.className != null && (Te = ve.className + " ");
      var Ie = serializeStyles(fe.concat(Se), ge.registered, he);
      Te += ge.key + "-" + Ie.name, ie !== void 0 && (Te += " " + ie);
      var De = ue && oe === void 0 ? getDefaultShouldForwardProp(Ee) : le, Ce = {};
      for (var Ne in ve)
        ue && Ne === "as" || // $FlowFixMe
        De(Ne) && (Ce[Ne] = ve[Ne]);
      return Ce.className = Te, Ce.ref = xe, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion, {
        cache: ge,
        serialized: Ie,
        isStringTag: typeof Ee == "string"
      }), /* @__PURE__ */ React.createElement(Ee, Ce));
    });
    return me.displayName = se !== void 0 ? se : "Styled(" + (typeof re == "string" ? re : re.displayName || re.name || "Component") + ")", me.defaultProps = ee.defaultProps, me.__emotion_real = me, me.__emotion_base = re, me.__emotion_styles = fe, me.__emotion_forwardProp = oe, Object.defineProperty(me, "toString", {
      value: function() {
        return ie === void 0 && process.env.NODE_ENV !== "production" ? "NO_COMPONENT_SELECTOR" : "." + ie;
      }
    }), me.withComponent = function(ve, ge) {
      return $(ve, _extends$4({}, te, ge, {
        shouldForwardProp: composeShouldForwardProps(me, ge, !0)
      })).apply(void 0, fe);
    }, me;
  };
}, tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], newStyled = createStyled$1.bind();
tags.forEach(function($) {
  newStyled[$] = newStyled($);
});
let cache;
typeof document == "object" && (cache = createCache({
  key: "css",
  prepend: !0
}));
function StyledEngineProvider($) {
  const {
    injectFirst: ee,
    children: te
  } = $;
  return ee && cache ? /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, {
    value: cache,
    children: te
  }) : te;
}
process.env.NODE_ENV !== "production" && (StyledEngineProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: PropTypes.node,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: PropTypes.bool
});
function isEmpty$1($) {
  return $ == null || Object.keys($).length === 0;
}
function GlobalStyles($) {
  const {
    styles: ee,
    defaultTheme: te = {}
  } = $, ne = typeof ee == "function" ? (re) => ee(isEmpty$1(re) ? te : re) : ee;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: ne
  });
}
process.env.NODE_ENV !== "production" && (GlobalStyles.propTypes = {
  defaultTheme: PropTypes.object,
  styles: PropTypes.oneOfType([PropTypes.array, PropTypes.string, PropTypes.object, PropTypes.func])
});
/**
 * @mui/styled-engine v5.15.14
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$1($, ee) {
  const te = newStyled($, ee);
  return process.env.NODE_ENV !== "production" ? (...ne) => {
    const re = typeof $ == "string" ? `"${$}"` : "component";
    return ne.length === 0 ? console.error([`MUI: Seems like you called \`styled(${re})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : ne.some((se) => se === void 0) && console.error(`MUI: the styled(${re})(...args) API requires all its args to be defined.`), te(...ne);
  } : te;
}
const internal_processStyles = ($, ee) => {
  Array.isArray($.__emotion_styles) && ($.__emotion_styles = ee($.__emotion_styles));
}, styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GlobalStyles,
  StyledEngineProvider,
  ThemeContext,
  css,
  default: styled$1,
  internal_processStyles,
  keyframes
}, Symbol.toStringTag, { value: "Module" })), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(styledEngine), require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge), require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(capitalize), require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName), _excluded$u = ["values", "unit", "step"], sortBreakpointsValues = ($) => {
  const ee = Object.keys($).map((te) => ({
    key: te,
    val: $[te]
  })) || [];
  return ee.sort((te, ne) => te.val - ne.val), ee.reduce((te, ne) => _extends$4({}, te, {
    [ne.key]: ne.val
  }), {});
};
function createBreakpoints($) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: ee = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: te = "px",
    step: ne = 5
  } = $, re = _objectWithoutPropertiesLoose$1($, _excluded$u), se = sortBreakpointsValues(ee), ie = Object.keys(se);
  function oe(pe) {
    return `@media (min-width:${typeof ee[pe] == "number" ? ee[pe] : pe}${te})`;
  }
  function le(pe) {
    return `@media (max-width:${(typeof ee[pe] == "number" ? ee[pe] : pe) - ne / 100}${te})`;
  }
  function ue(pe, ye) {
    const me = ie.indexOf(ye);
    return `@media (min-width:${typeof ee[pe] == "number" ? ee[pe] : pe}${te}) and (max-width:${(me !== -1 && typeof ee[ie[me]] == "number" ? ee[ie[me]] : ye) - ne / 100}${te})`;
  }
  function de(pe) {
    return ie.indexOf(pe) + 1 < ie.length ? ue(pe, ie[ie.indexOf(pe) + 1]) : oe(pe);
  }
  function fe(pe) {
    const ye = ie.indexOf(pe);
    return ye === 0 ? oe(ie[1]) : ye === ie.length - 1 ? le(ie[ye]) : ue(pe, ie[ie.indexOf(pe) + 1]).replace("@media", "@media not all and");
  }
  return _extends$4({
    keys: ie,
    values: se,
    up: oe,
    down: le,
    between: ue,
    only: de,
    not: fe,
    unit: te
  }, re);
}
const shape = {
  borderRadius: 4
}, shape$1 = shape, responsivePropType = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) : {}, responsivePropType$1 = responsivePropType;
function merge($, ee) {
  return ee ? deepmerge$1($, ee, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : $;
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: ($) => `@media (min-width:${values$1[$]}px)`
};
function handleBreakpoints($, ee, te) {
  const ne = $.theme || {};
  if (Array.isArray(ee)) {
    const se = ne.breakpoints || defaultBreakpoints;
    return ee.reduce((ie, oe, le) => (ie[se.up(se.keys[le])] = te(ee[le]), ie), {});
  }
  if (typeof ee == "object") {
    const se = ne.breakpoints || defaultBreakpoints;
    return Object.keys(ee).reduce((ie, oe) => {
      if (Object.keys(se.values || values$1).indexOf(oe) !== -1) {
        const le = se.up(oe);
        ie[le] = te(ee[oe], oe);
      } else {
        const le = oe;
        ie[le] = ee[le];
      }
      return ie;
    }, {});
  }
  return te(ee);
}
function createEmptyBreakpointObject($ = {}) {
  var ee;
  return ((ee = $.keys) == null ? void 0 : ee.reduce((ne, re) => {
    const se = $.up(re);
    return ne[se] = {}, ne;
  }, {})) || {};
}
function removeUnusedBreakpoints($, ee) {
  return $.reduce((te, ne) => {
    const re = te[ne];
    return (!re || Object.keys(re).length === 0) && delete te[ne], te;
  }, ee);
}
function getPath($, ee, te = !0) {
  if (!ee || typeof ee != "string")
    return null;
  if ($ && $.vars && te) {
    const ne = `vars.${ee}`.split(".").reduce((re, se) => re && re[se] ? re[se] : null, $);
    if (ne != null)
      return ne;
  }
  return ee.split(".").reduce((ne, re) => ne && ne[re] != null ? ne[re] : null, $);
}
function getStyleValue($, ee, te, ne = te) {
  let re;
  return typeof $ == "function" ? re = $(te) : Array.isArray($) ? re = $[te] || ne : re = getPath($, te) || ne, ee && (re = ee(re, ne, $)), re;
}
function style$1($) {
  const {
    prop: ee,
    cssProperty: te = $.prop,
    themeKey: ne,
    transform: re
  } = $, se = (ie) => {
    if (ie[ee] == null)
      return null;
    const oe = ie[ee], le = ie.theme, ue = getPath(le, ne) || {};
    return handleBreakpoints(ie, oe, (fe) => {
      let pe = getStyleValue(ue, re, fe);
      return fe === pe && typeof fe == "string" && (pe = getStyleValue(ue, re, `${ee}${fe === "default" ? "" : capitalize$1(fe)}`, fe)), te === !1 ? pe : {
        [te]: pe
      };
    });
  };
  return se.propTypes = process.env.NODE_ENV !== "production" ? {
    [ee]: responsivePropType$1
  } : {}, se.filterProps = [ee], se;
}
function memoize$1($) {
  const ee = {};
  return (te) => (ee[te] === void 0 && (ee[te] = $(te)), ee[te]);
}
const properties = {
  m: "margin",
  p: "padding"
}, directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, getCssProperties = memoize$1(($) => {
  if ($.length > 2)
    if (aliases[$])
      $ = aliases[$];
    else
      return [$];
  const [ee, te] = $.split(""), ne = properties[ee], re = directions[te] || "";
  return Array.isArray(re) ? re.map((se) => ne + se) : [ne + re];
}), marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit($, ee, te, ne) {
  var re;
  const se = (re = getPath($, ee, !1)) != null ? re : te;
  return typeof se == "number" ? (ie) => typeof ie == "string" ? ie : (process.env.NODE_ENV !== "production" && typeof ie != "number" && console.error(`MUI: Expected ${ne} argument to be a number or a string, got ${ie}.`), se * ie) : Array.isArray(se) ? (ie) => typeof ie == "string" ? ie : (process.env.NODE_ENV !== "production" && (Number.isInteger(ie) ? ie > se.length - 1 && console.error([`MUI: The value provided (${ie}) overflows.`, `The supported values are: ${JSON.stringify(se)}.`, `${ie} > ${se.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${ee}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${ee}\` as a number.`].join(`
`))), se[ie]) : typeof se == "function" ? se : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${ee}\` value (${se}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function createUnarySpacing($) {
  return createUnaryUnit($, "spacing", 8, "spacing");
}
function getValue($, ee) {
  if (typeof ee == "string" || ee == null)
    return ee;
  const te = Math.abs(ee), ne = $(te);
  return ee >= 0 ? ne : typeof ne == "number" ? -ne : `-${ne}`;
}
function getStyleFromPropValue($, ee) {
  return (te) => $.reduce((ne, re) => (ne[re] = getValue(ee, te), ne), {});
}
function resolveCssProperty($, ee, te, ne) {
  if (ee.indexOf(te) === -1)
    return null;
  const re = getCssProperties(te), se = getStyleFromPropValue(re, ne), ie = $[te];
  return handleBreakpoints($, ie, se);
}
function style($, ee) {
  const te = createUnarySpacing($.theme);
  return Object.keys($).map((ne) => resolveCssProperty($, ee, ne, te)).reduce(merge, {});
}
function margin($) {
  return style($, marginKeys);
}
margin.propTypes = process.env.NODE_ENV !== "production" ? marginKeys.reduce(($, ee) => ($[ee] = responsivePropType$1, $), {}) : {};
margin.filterProps = marginKeys;
function padding($) {
  return style($, paddingKeys);
}
padding.propTypes = process.env.NODE_ENV !== "production" ? paddingKeys.reduce(($, ee) => ($[ee] = responsivePropType$1, $), {}) : {};
padding.filterProps = paddingKeys;
process.env.NODE_ENV !== "production" && spacingKeys.reduce(($, ee) => ($[ee] = responsivePropType$1, $), {});
function createSpacing($ = 8) {
  if ($.mui)
    return $;
  const ee = createUnarySpacing({
    spacing: $
  }), te = (...ne) => (process.env.NODE_ENV !== "production" && (ne.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${ne.length}`)), (ne.length === 0 ? [1] : ne).map((se) => {
    const ie = ee(se);
    return typeof ie == "number" ? `${ie}px` : ie;
  }).join(" "));
  return te.mui = !0, te;
}
function compose(...$) {
  const ee = $.reduce((ne, re) => (re.filterProps.forEach((se) => {
    ne[se] = re;
  }), ne), {}), te = (ne) => Object.keys(ne).reduce((re, se) => ee[se] ? merge(re, ee[se](ne)) : re, {});
  return te.propTypes = process.env.NODE_ENV !== "production" ? $.reduce((ne, re) => Object.assign(ne, re.propTypes), {}) : {}, te.filterProps = $.reduce((ne, re) => ne.concat(re.filterProps), []), te;
}
function borderTransform($) {
  return typeof $ != "number" ? $ : `${$}px solid`;
}
function createBorderStyle($, ee) {
  return style$1({
    prop: $,
    themeKey: "borders",
    transform: ee
  });
}
const border = createBorderStyle("border", borderTransform), borderTop = createBorderStyle("borderTop", borderTransform), borderRight = createBorderStyle("borderRight", borderTransform), borderBottom = createBorderStyle("borderBottom", borderTransform), borderLeft = createBorderStyle("borderLeft", borderTransform), borderColor = createBorderStyle("borderColor"), borderTopColor = createBorderStyle("borderTopColor"), borderRightColor = createBorderStyle("borderRightColor"), borderBottomColor = createBorderStyle("borderBottomColor"), borderLeftColor = createBorderStyle("borderLeftColor"), outline = createBorderStyle("outline", borderTransform), outlineColor = createBorderStyle("outlineColor"), borderRadius = ($) => {
  if ($.borderRadius !== void 0 && $.borderRadius !== null) {
    const ee = createUnaryUnit($.theme, "shape.borderRadius", 4, "borderRadius"), te = (ne) => ({
      borderRadius: getValue(ee, ne)
    });
    return handleBreakpoints($, $.borderRadius, te);
  }
  return null;
};
borderRadius.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: responsivePropType$1
} : {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = ($) => {
  if ($.gap !== void 0 && $.gap !== null) {
    const ee = createUnaryUnit($.theme, "spacing", 8, "gap"), te = (ne) => ({
      gap: getValue(ee, ne)
    });
    return handleBreakpoints($, $.gap, te);
  }
  return null;
};
gap.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: responsivePropType$1
} : {};
gap.filterProps = ["gap"];
const columnGap = ($) => {
  if ($.columnGap !== void 0 && $.columnGap !== null) {
    const ee = createUnaryUnit($.theme, "spacing", 8, "columnGap"), te = (ne) => ({
      columnGap: getValue(ee, ne)
    });
    return handleBreakpoints($, $.columnGap, te);
  }
  return null;
};
columnGap.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: responsivePropType$1
} : {};
columnGap.filterProps = ["columnGap"];
const rowGap = ($) => {
  if ($.rowGap !== void 0 && $.rowGap !== null) {
    const ee = createUnaryUnit($.theme, "spacing", 8, "rowGap"), te = (ne) => ({
      rowGap: getValue(ee, ne)
    });
    return handleBreakpoints($, $.rowGap, te);
  }
  return null;
};
rowGap.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: responsivePropType$1
} : {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
}), gridRow = style$1({
  prop: "gridRow"
}), gridAutoFlow = style$1({
  prop: "gridAutoFlow"
}), gridAutoColumns = style$1({
  prop: "gridAutoColumns"
}), gridAutoRows = style$1({
  prop: "gridAutoRows"
}), gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
}), gridTemplateRows = style$1({
  prop: "gridTemplateRows"
}), gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
}), gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform($, ee) {
  return ee === "grey" ? ee : $;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
}), bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
}), backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform($) {
  return $ <= 1 && $ !== 0 ? `${$ * 100}%` : $;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
}), maxWidth = ($) => {
  if ($.maxWidth !== void 0 && $.maxWidth !== null) {
    const ee = (te) => {
      var ne, re;
      const se = ((ne = $.theme) == null || (ne = ne.breakpoints) == null || (ne = ne.values) == null ? void 0 : ne[te]) || values$1[te];
      return se ? ((re = $.theme) == null || (re = re.breakpoints) == null ? void 0 : re.unit) !== "px" ? {
        maxWidth: `${se}${$.theme.breakpoints.unit}`
      } : {
        maxWidth: se
      } : {
        maxWidth: sizingTransform(te)
      };
    };
    return handleBreakpoints($, $.maxWidth, ee);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
}), height = style$1({
  prop: "height",
  transform: sizingTransform
}), maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
}), minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: ($) => ({
      "@media print": {
        display: $
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
}, defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...$) {
  const ee = $.reduce((ne, re) => ne.concat(Object.keys(re)), []), te = new Set(ee);
  return $.every((ne) => te.size === Object.keys(ne).length);
}
function callIfFn($, ee) {
  return typeof $ == "function" ? $(ee) : $;
}
function unstable_createStyleFunctionSx() {
  function $(te, ne, re, se) {
    const ie = {
      [te]: ne,
      theme: re
    }, oe = se[te];
    if (!oe)
      return {
        [te]: ne
      };
    const {
      cssProperty: le = te,
      themeKey: ue,
      transform: de,
      style: fe
    } = oe;
    if (ne == null)
      return null;
    if (ue === "typography" && ne === "inherit")
      return {
        [te]: ne
      };
    const pe = getPath(re, ue) || {};
    return fe ? fe(ie) : handleBreakpoints(ie, ne, (me) => {
      let ve = getStyleValue(pe, de, me);
      return me === ve && typeof me == "string" && (ve = getStyleValue(pe, de, `${te}${me === "default" ? "" : capitalize$1(me)}`, me)), le === !1 ? ve : {
        [le]: ve
      };
    });
  }
  function ee(te) {
    var ne;
    const {
      sx: re,
      theme: se = {}
    } = te || {};
    if (!re)
      return null;
    const ie = (ne = se.unstable_sxConfig) != null ? ne : defaultSxConfig$1;
    function oe(le) {
      let ue = le;
      if (typeof le == "function")
        ue = le(se);
      else if (typeof le != "object")
        return le;
      if (!ue)
        return null;
      const de = createEmptyBreakpointObject(se.breakpoints), fe = Object.keys(de);
      let pe = de;
      return Object.keys(ue).forEach((ye) => {
        const me = callIfFn(ue[ye], se);
        if (me != null)
          if (typeof me == "object")
            if (ie[ye])
              pe = merge(pe, $(ye, me, se, ie));
            else {
              const ve = handleBreakpoints({
                theme: se
              }, me, (ge) => ({
                [ye]: ge
              }));
              objectsHaveSameKeys(ve, me) ? pe[ye] = ee({
                sx: me,
                theme: se
              }) : pe = merge(pe, ve);
            }
          else
            pe = merge(pe, $(ye, me, se, ie));
      }), removeUnusedBreakpoints(fe, pe);
    }
    return Array.isArray(re) ? re.map(oe) : oe(re);
  }
  return ee;
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
function applyStyles($, ee) {
  const te = this;
  return te.vars && typeof te.getColorSchemeSelector == "function" ? {
    [te.getColorSchemeSelector($).replace(/(\[[^\]]+\])/, "*:where($1)")]: ee
  } : te.palette.mode === $ ? ee : {};
}
const _excluded$t = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$2($ = {}, ...ee) {
  const {
    breakpoints: te = {},
    palette: ne = {},
    spacing: re,
    shape: se = {}
  } = $, ie = _objectWithoutPropertiesLoose$1($, _excluded$t), oe = createBreakpoints(te), le = createSpacing(re);
  let ue = deepmerge$1({
    breakpoints: oe,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$4({
      mode: "light"
    }, ne),
    spacing: le,
    shape: _extends$4({}, shape$1, se)
  }, ie);
  return ue.applyStyles = applyStyles, ue = ee.reduce((de, fe) => deepmerge$1(de, fe), ue), ue.unstable_sxConfig = _extends$4({}, defaultSxConfig$1, ie == null ? void 0 : ie.unstable_sxConfig), ue.unstable_sx = function(fe) {
    return styleFunctionSx$1({
      sx: fe,
      theme: this
    });
  }, ue;
}
const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: createTheme$2,
  private_createBreakpoints: createBreakpoints,
  unstable_applyStyles: applyStyles
}, Symbol.toStringTag, { value: "Module" })), require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1), _excluded$s = ["sx"], splitProps = ($) => {
  var ee, te;
  const ne = {
    systemProps: {},
    otherProps: {}
  }, re = (ee = $ == null || (te = $.theme) == null ? void 0 : te.unstable_sxConfig) != null ? ee : defaultSxConfig$1;
  return Object.keys($).forEach((se) => {
    re[se] ? ne.systemProps[se] = $[se] : ne.otherProps[se] = $[se];
  }), ne;
};
function extendSxProp($) {
  const {
    sx: ee
  } = $, te = _objectWithoutPropertiesLoose$1($, _excluded$s), {
    systemProps: ne,
    otherProps: re
  } = splitProps(te);
  let se;
  return Array.isArray(ee) ? se = [ne, ...ee] : typeof ee == "function" ? se = (...ie) => {
    const oe = ee(...ie);
    return isPlainObject(oe) ? _extends$4({}, ne, oe) : ne;
  } : se = _extends$4({}, ne, ee), _extends$4({}, re, {
    sx: se
  });
}
const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: styleFunctionSx$1,
  extendSxProp,
  unstable_createStyleFunctionSx,
  unstable_defaultSxConfig: defaultSxConfig$1
}, Symbol.toStringTag, { value: "Module" })), require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(createStyled$2, "__esModule", {
  value: !0
});
var _default = createStyled$2.default = createStyled;
createStyled$2.shouldForwardProp = shouldForwardProp;
createStyled$2.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault$6(require_extends()), _objectWithoutPropertiesLoose2 = _interopRequireDefault$6(requireObjectWithoutPropertiesLoose()), _styledEngine = _interopRequireWildcard(require$$1$1), _deepmerge = require$$4, _capitalize = _interopRequireDefault$6(require$$5$1), _getDisplayName = _interopRequireDefault$6(require$$6), _createTheme = _interopRequireDefault$6(require$$7), _styleFunctionSx = _interopRequireDefault$6(require$$8$1);
const _excluded$r = ["ownerState"], _excluded2$4 = ["variants"], _excluded3$1 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function _getRequireWildcardCache($) {
  if (typeof WeakMap != "function")
    return null;
  var ee = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(ne) {
    return ne ? te : ee;
  })($);
}
function _interopRequireWildcard($, ee) {
  if (!ee && $ && $.__esModule)
    return $;
  if ($ === null || typeof $ != "object" && typeof $ != "function")
    return { default: $ };
  var te = _getRequireWildcardCache(ee);
  if (te && te.has($))
    return te.get($);
  var ne = { __proto__: null }, re = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var se in $)
    if (se !== "default" && Object.prototype.hasOwnProperty.call($, se)) {
      var ie = re ? Object.getOwnPropertyDescriptor($, se) : null;
      ie && (ie.get || ie.set) ? Object.defineProperty(ne, se, ie) : ne[se] = $[se];
    }
  return ne.default = $, te && te.set($, ne), ne;
}
function isEmpty($) {
  return Object.keys($).length === 0;
}
function isStringTag($) {
  return typeof $ == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  $.charCodeAt(0) > 96;
}
function shouldForwardProp($) {
  return $ !== "ownerState" && $ !== "theme" && $ !== "sx" && $ !== "as";
}
const systemDefaultTheme$1 = createStyled$2.systemDefaultTheme = (0, _createTheme.default)(), lowercaseFirstLetter = ($) => $ && $.charAt(0).toLowerCase() + $.slice(1);
function resolveTheme({
  defaultTheme: $,
  theme: ee,
  themeId: te
}) {
  return isEmpty(ee) ? $ : ee[te] || ee;
}
function defaultOverridesResolver($) {
  return $ ? (ee, te) => te[$] : null;
}
function processStyleArg($, ee) {
  let {
    ownerState: te
  } = ee, ne = (0, _objectWithoutPropertiesLoose2.default)(ee, _excluded$r);
  const re = typeof $ == "function" ? $((0, _extends2.default)({
    ownerState: te
  }, ne)) : $;
  if (Array.isArray(re))
    return re.flatMap((se) => processStyleArg(se, (0, _extends2.default)({
      ownerState: te
    }, ne)));
  if (re && typeof re == "object" && Array.isArray(re.variants)) {
    const {
      variants: se = []
    } = re;
    let oe = (0, _objectWithoutPropertiesLoose2.default)(re, _excluded2$4);
    return se.forEach((le) => {
      let ue = !0;
      typeof le.props == "function" ? ue = le.props((0, _extends2.default)({
        ownerState: te
      }, ne, te)) : Object.keys(le.props).forEach((de) => {
        (te == null ? void 0 : te[de]) !== le.props[de] && ne[de] !== le.props[de] && (ue = !1);
      }), ue && (Array.isArray(oe) || (oe = [oe]), oe.push(typeof le.style == "function" ? le.style((0, _extends2.default)({
        ownerState: te
      }, ne, te)) : le.style));
    }), oe;
  }
  return re;
}
function createStyled($ = {}) {
  const {
    themeId: ee,
    defaultTheme: te = systemDefaultTheme$1,
    rootShouldForwardProp: ne = shouldForwardProp,
    slotShouldForwardProp: re = shouldForwardProp
  } = $, se = (ie) => (0, _styleFunctionSx.default)((0, _extends2.default)({}, ie, {
    theme: resolveTheme((0, _extends2.default)({}, ie, {
      defaultTheme: te,
      themeId: ee
    }))
  }));
  return se.__mui_systemSx = !0, (ie, oe = {}) => {
    (0, _styledEngine.internal_processStyles)(ie, (he) => he.filter((Pe) => !(Pe != null && Pe.__mui_systemSx)));
    const {
      name: le,
      slot: ue,
      skipVariantsResolver: de,
      skipSx: fe,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: pe = defaultOverridesResolver(lowercaseFirstLetter(ue))
    } = oe, ye = (0, _objectWithoutPropertiesLoose2.default)(oe, _excluded3$1), me = de !== void 0 ? de : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      ue && ue !== "Root" && ue !== "root" || !1
    ), ve = fe || !1;
    let ge;
    process.env.NODE_ENV !== "production" && le && (ge = `${le}-${lowercaseFirstLetter(ue || "Root")}`);
    let xe = shouldForwardProp;
    ue === "Root" || ue === "root" ? xe = ne : ue ? xe = re : isStringTag(ie) && (xe = void 0);
    const Ee = (0, _styledEngine.default)(ie, (0, _extends2.default)({
      shouldForwardProp: xe,
      label: ge
    }, ye)), Te = (he) => typeof he == "function" && he.__emotion_real !== he || (0, _deepmerge.isPlainObject)(he) ? (Pe) => processStyleArg(he, (0, _extends2.default)({}, Pe, {
      theme: resolveTheme({
        theme: Pe.theme,
        defaultTheme: te,
        themeId: ee
      })
    })) : he, Se = (he, ...Pe) => {
      let Ie = Te(he);
      const De = Pe ? Pe.map(Te) : [];
      le && pe && De.push((Me) => {
        const Be = resolveTheme((0, _extends2.default)({}, Me, {
          defaultTheme: te,
          themeId: ee
        }));
        if (!Be.components || !Be.components[le] || !Be.components[le].styleOverrides)
          return null;
        const We = Be.components[le].styleOverrides, Le = {};
        return Object.entries(We).forEach(([He, Ge]) => {
          Le[He] = processStyleArg(Ge, (0, _extends2.default)({}, Me, {
            theme: Be
          }));
        }), pe(Me, Le);
      }), le && !me && De.push((Me) => {
        var Be;
        const We = resolveTheme((0, _extends2.default)({}, Me, {
          defaultTheme: te,
          themeId: ee
        })), Le = We == null || (Be = We.components) == null || (Be = Be[le]) == null ? void 0 : Be.variants;
        return processStyleArg({
          variants: Le
        }, (0, _extends2.default)({}, Me, {
          theme: We
        }));
      }), ve || De.push(se);
      const Ce = De.length - Pe.length;
      if (Array.isArray(he) && Ce > 0) {
        const Me = new Array(Ce).fill("");
        Ie = [...he, ...Me], Ie.raw = [...he.raw, ...Me];
      }
      const Ne = Ee(Ie, ...De);
      if (process.env.NODE_ENV !== "production") {
        let Me;
        le && (Me = `${le}${(0, _capitalize.default)(ue || "")}`), Me === void 0 && (Me = `Styled(${(0, _getDisplayName.default)(ie)})`), Ne.displayName = Me;
      }
      return ie.muiName && (Ne.muiName = ie.muiName), Ne;
    };
    return Ee.withConfig && (Se.withConfig = Ee.withConfig), Se;
  };
}
function createMixins($, ee) {
  return _extends$4({
    toolbar: {
      minHeight: 56,
      [$.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [$.up("sm")]: {
        minHeight: 64
      }
    }
  }, ee);
}
var colorManipulator = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(clamp$1);
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
  value: !0
});
var alpha_1 = colorManipulator.alpha = alpha;
colorManipulator.blend = blend;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
var emphasize_1 = colorManipulator.emphasize = emphasize, getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex;
var _formatMuiErrorMessage2 = _interopRequireDefault$5(require$$1), _clamp = _interopRequireDefault$5(require$$2$1);
function clampWrapper($, ee = 0, te = 1) {
  return process.env.NODE_ENV !== "production" && ($ < ee || $ > te) && console.error(`MUI: The value provided ${$} is out of range [${ee}, ${te}].`), (0, _clamp.default)($, ee, te);
}
function hexToRgb($) {
  $ = $.slice(1);
  const ee = new RegExp(`.{1,${$.length >= 6 ? 2 : 1}}`, "g");
  let te = $.match(ee);
  return te && te[0].length === 1 && (te = te.map((ne) => ne + ne)), te ? `rgb${te.length === 4 ? "a" : ""}(${te.map((ne, re) => re < 3 ? parseInt(ne, 16) : Math.round(parseInt(ne, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function intToHex($) {
  const ee = $.toString(16);
  return ee.length === 1 ? `0${ee}` : ee;
}
function decomposeColor($) {
  if ($.type)
    return $;
  if ($.charAt(0) === "#")
    return decomposeColor(hexToRgb($));
  const ee = $.indexOf("("), te = $.substring(0, ee);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(te) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${$}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : (0, _formatMuiErrorMessage2.default)(9, $));
  let ne = $.substring(ee + 1, $.length - 1), re;
  if (te === "color") {
    if (ne = ne.split(" "), re = ne.shift(), ne.length === 4 && ne[3].charAt(0) === "/" && (ne[3] = ne[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(re) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${re}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : (0, _formatMuiErrorMessage2.default)(10, re));
  } else
    ne = ne.split(",");
  return ne = ne.map((se) => parseFloat(se)), {
    type: te,
    values: ne,
    colorSpace: re
  };
}
const colorChannel = ($) => {
  const ee = decomposeColor($);
  return ee.values.slice(0, 3).map((te, ne) => ee.type.indexOf("hsl") !== -1 && ne !== 0 ? `${te}%` : te).join(" ");
};
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = ($, ee) => {
  try {
    return colorChannel($);
  } catch {
    return ee && process.env.NODE_ENV !== "production" && console.warn(ee), $;
  }
};
colorManipulator.private_safeColorChannel = private_safeColorChannel;
function recomposeColor($) {
  const {
    type: ee,
    colorSpace: te
  } = $;
  let {
    values: ne
  } = $;
  return ee.indexOf("rgb") !== -1 ? ne = ne.map((re, se) => se < 3 ? parseInt(re, 10) : re) : ee.indexOf("hsl") !== -1 && (ne[1] = `${ne[1]}%`, ne[2] = `${ne[2]}%`), ee.indexOf("color") !== -1 ? ne = `${te} ${ne.join(" ")}` : ne = `${ne.join(", ")}`, `${ee}(${ne})`;
}
function rgbToHex($) {
  if ($.indexOf("#") === 0)
    return $;
  const {
    values: ee
  } = decomposeColor($);
  return `#${ee.map((te, ne) => intToHex(ne === 3 ? Math.round(255 * te) : te)).join("")}`;
}
function hslToRgb($) {
  $ = decomposeColor($);
  const {
    values: ee
  } = $, te = ee[0], ne = ee[1] / 100, re = ee[2] / 100, se = ne * Math.min(re, 1 - re), ie = (ue, de = (ue + te / 30) % 12) => re - se * Math.max(Math.min(de - 3, 9 - de, 1), -1);
  let oe = "rgb";
  const le = [Math.round(ie(0) * 255), Math.round(ie(8) * 255), Math.round(ie(4) * 255)];
  return $.type === "hsla" && (oe += "a", le.push(ee[3])), recomposeColor({
    type: oe,
    values: le
  });
}
function getLuminance($) {
  $ = decomposeColor($);
  let ee = $.type === "hsl" || $.type === "hsla" ? decomposeColor(hslToRgb($)).values : $.values;
  return ee = ee.map((te) => ($.type !== "color" && (te /= 255), te <= 0.03928 ? te / 12.92 : ((te + 0.055) / 1.055) ** 2.4)), Number((0.2126 * ee[0] + 0.7152 * ee[1] + 0.0722 * ee[2]).toFixed(3));
}
function getContrastRatio($, ee) {
  const te = getLuminance($), ne = getLuminance(ee);
  return (Math.max(te, ne) + 0.05) / (Math.min(te, ne) + 0.05);
}
function alpha($, ee) {
  return $ = decomposeColor($), ee = clampWrapper(ee), ($.type === "rgb" || $.type === "hsl") && ($.type += "a"), $.type === "color" ? $.values[3] = `/${ee}` : $.values[3] = ee, recomposeColor($);
}
function private_safeAlpha($, ee, te) {
  try {
    return alpha($, ee);
  } catch {
    return te && process.env.NODE_ENV !== "production" && console.warn(te), $;
  }
}
function darken($, ee) {
  if ($ = decomposeColor($), ee = clampWrapper(ee), $.type.indexOf("hsl") !== -1)
    $.values[2] *= 1 - ee;
  else if ($.type.indexOf("rgb") !== -1 || $.type.indexOf("color") !== -1)
    for (let te = 0; te < 3; te += 1)
      $.values[te] *= 1 - ee;
  return recomposeColor($);
}
function private_safeDarken($, ee, te) {
  try {
    return darken($, ee);
  } catch {
    return te && process.env.NODE_ENV !== "production" && console.warn(te), $;
  }
}
function lighten($, ee) {
  if ($ = decomposeColor($), ee = clampWrapper(ee), $.type.indexOf("hsl") !== -1)
    $.values[2] += (100 - $.values[2]) * ee;
  else if ($.type.indexOf("rgb") !== -1)
    for (let te = 0; te < 3; te += 1)
      $.values[te] += (255 - $.values[te]) * ee;
  else if ($.type.indexOf("color") !== -1)
    for (let te = 0; te < 3; te += 1)
      $.values[te] += (1 - $.values[te]) * ee;
  return recomposeColor($);
}
function private_safeLighten($, ee, te) {
  try {
    return lighten($, ee);
  } catch {
    return te && process.env.NODE_ENV !== "production" && console.warn(te), $;
  }
}
function emphasize($, ee = 0.15) {
  return getLuminance($) > 0.5 ? darken($, ee) : lighten($, ee);
}
function private_safeEmphasize($, ee, te) {
  try {
    return private_safeEmphasize($, ee);
  } catch {
    return te && process.env.NODE_ENV !== "production" && console.warn(te), $;
  }
}
function blend($, ee, te, ne = 1) {
  const re = (le, ue) => Math.round((le ** (1 / ne) * (1 - te) + ue ** (1 / ne) * te) ** ne), se = decomposeColor($), ie = decomposeColor(ee), oe = [re(se.values[0], ie.values[0]), re(se.values[1], ie.values[1]), re(se.values[2], ie.values[2])];
  return recomposeColor({
    type: "rgb",
    values: oe
  });
}
const common = {
  black: "#000",
  white: "#fff"
}, common$1 = common, grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, grey$1 = grey, purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, purple$1 = purple, red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, red$1 = red, orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, orange$1 = orange, blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, blue$1 = blue, lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, lightBlue$1 = lightBlue, green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, green$1 = green, _excluded$q = ["mode", "contrastThreshold", "tonalOffset"], light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark($, ee, te, ne) {
  const re = ne.light || ne, se = ne.dark || ne * 1.5;
  $[ee] || ($.hasOwnProperty(te) ? $[ee] = $[te] : ee === "light" ? $.light = lighten_1($.main, re) : ee === "dark" && ($.dark = darken_1($.main, se)));
}
function getDefaultPrimary($ = "light") {
  return $ === "dark" ? {
    main: blue$1[200],
    light: blue$1[50],
    dark: blue$1[400]
  } : {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary($ = "light") {
  return $ === "dark" ? {
    main: purple$1[200],
    light: purple$1[50],
    dark: purple$1[400]
  } : {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError($ = "light") {
  return $ === "dark" ? {
    main: red$1[500],
    light: red$1[300],
    dark: red$1[700]
  } : {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo($ = "light") {
  return $ === "dark" ? {
    main: lightBlue$1[400],
    light: lightBlue$1[300],
    dark: lightBlue$1[700]
  } : {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess($ = "light") {
  return $ === "dark" ? {
    main: green$1[400],
    light: green$1[300],
    dark: green$1[700]
  } : {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning($ = "light") {
  return $ === "dark" ? {
    main: orange$1[400],
    light: orange$1[300],
    dark: orange$1[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette($) {
  const {
    mode: ee = "light",
    contrastThreshold: te = 3,
    tonalOffset: ne = 0.2
  } = $, re = _objectWithoutPropertiesLoose$1($, _excluded$q), se = $.primary || getDefaultPrimary(ee), ie = $.secondary || getDefaultSecondary(ee), oe = $.error || getDefaultError(ee), le = $.info || getDefaultInfo(ee), ue = $.success || getDefaultSuccess(ee), de = $.warning || getDefaultWarning(ee);
  function fe(ve) {
    const ge = getContrastRatio_1(ve, dark.text.primary) >= te ? dark.text.primary : light.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const xe = getContrastRatio_1(ve, ge);
      xe < 3 && console.error([`MUI: The contrast ratio of ${xe}:1 for ${ge} on ${ve}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return ge;
  }
  const pe = ({
    color: ve,
    name: ge,
    mainShade: xe = 500,
    lightShade: Ee = 300,
    darkShade: Te = 700
  }) => {
    if (ve = _extends$4({}, ve), !ve.main && ve[xe] && (ve.main = ve[xe]), !ve.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${ge ? ` (${ge})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${xe}\` property.` : formatMuiErrorMessage$1(11, ge ? ` (${ge})` : "", xe));
    if (typeof ve.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${ge ? ` (${ge})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(ve.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage$1(12, ge ? ` (${ge})` : "", JSON.stringify(ve.main)));
    return addLightOrDark(ve, "light", Ee, ne), addLightOrDark(ve, "dark", Te, ne), ve.contrastText || (ve.contrastText = fe(ve.main)), ve;
  }, ye = {
    dark,
    light
  };
  return process.env.NODE_ENV !== "production" && (ye[ee] || console.error(`MUI: The palette mode \`${ee}\` is not supported.`)), deepmerge$1(_extends$4({
    // A collection of common colors.
    common: _extends$4({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: ee,
    // The colors used to represent primary interface elements for a user.
    primary: pe({
      color: se,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: pe({
      color: ie,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: pe({
      color: oe,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: pe({
      color: de,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: pe({
      color: le,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: pe({
      color: ue,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: te,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: fe,
    // Generate a rich color object.
    augmentColor: pe,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: ne
  }, ye[ee]), re);
}
const _excluded$p = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round($) {
  return Math.round($ * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
}, defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography($, ee) {
  const te = typeof ee == "function" ? ee($) : ee, {
    fontFamily: ne = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: re = 14,
    // px
    fontWeightLight: se = 300,
    fontWeightRegular: ie = 400,
    fontWeightMedium: oe = 500,
    fontWeightBold: le = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: ue = 16,
    // Apply the CSS properties to all the variants.
    allVariants: de,
    pxToRem: fe
  } = te, pe = _objectWithoutPropertiesLoose$1(te, _excluded$p);
  process.env.NODE_ENV !== "production" && (typeof re != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof ue != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const ye = re / 14, me = fe || ((xe) => `${xe / ue * ye}rem`), ve = (xe, Ee, Te, Se, he) => _extends$4({
    fontFamily: ne,
    fontWeight: xe,
    fontSize: me(Ee),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: Te
  }, ne === defaultFontFamily ? {
    letterSpacing: `${round(Se / Ee)}em`
  } : {}, he, de), ge = {
    h1: ve(se, 96, 1.167, -1.5),
    h2: ve(se, 60, 1.2, -0.5),
    h3: ve(ie, 48, 1.167, 0),
    h4: ve(ie, 34, 1.235, 0.25),
    h5: ve(ie, 24, 1.334, 0),
    h6: ve(oe, 20, 1.6, 0.15),
    subtitle1: ve(ie, 16, 1.75, 0.15),
    subtitle2: ve(oe, 14, 1.57, 0.1),
    body1: ve(ie, 16, 1.5, 0.15),
    body2: ve(ie, 14, 1.43, 0.15),
    button: ve(oe, 14, 1.75, 0.4, caseAllCaps),
    caption: ve(ie, 12, 1.66, 0.4),
    overline: ve(ie, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$4({
    htmlFontSize: ue,
    pxToRem: me,
    fontFamily: ne,
    fontSize: re,
    fontWeightLight: se,
    fontWeightRegular: ie,
    fontWeightMedium: oe,
    fontWeightBold: le
  }, ge), pe, {
    clone: !1
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2, shadowKeyPenumbraOpacity = 0.14, shadowAmbientShadowOpacity = 0.12;
function createShadow(...$) {
  return [`${$[0]}px ${$[1]}px ${$[2]}px ${$[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${$[4]}px ${$[5]}px ${$[6]}px ${$[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${$[8]}px ${$[9]}px ${$[10]}px ${$[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], _excluded$o = ["duration", "easing", "delay"], easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs($) {
  return `${Math.round($)}ms`;
}
function getAutoHeightDuration($) {
  if (!$)
    return 0;
  const ee = $ / 36;
  return Math.round((4 + 15 * ee ** 0.25 + ee / 5) * 10);
}
function createTransitions($) {
  const ee = _extends$4({}, easing, $.easing), te = _extends$4({}, duration, $.duration);
  return _extends$4({
    getAutoHeightDuration,
    create: (re = ["all"], se = {}) => {
      const {
        duration: ie = te.standard,
        easing: oe = ee.easeInOut,
        delay: le = 0
      } = se, ue = _objectWithoutPropertiesLoose$1(se, _excluded$o);
      if (process.env.NODE_ENV !== "production") {
        const de = (pe) => typeof pe == "string", fe = (pe) => !isNaN(parseFloat(pe));
        !de(re) && !Array.isArray(re) && console.error('MUI: Argument "props" must be a string or Array.'), !fe(ie) && !de(ie) && console.error(`MUI: Argument "duration" must be a number or a string but found ${ie}.`), de(oe) || console.error('MUI: Argument "easing" must be a string.'), !fe(le) && !de(le) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof se != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(ue).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(ue).join(",")}].`);
      }
      return (Array.isArray(re) ? re : [re]).map((de) => `${de} ${typeof ie == "string" ? ie : formatMs(ie)} ${oe} ${typeof le == "string" ? le : formatMs(le)}`).join(",");
    }
  }, $, {
    easing: ee,
    duration: te
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, zIndex$1 = zIndex, _excluded$n = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme($ = {}, ...ee) {
  const {
    mixins: te = {},
    palette: ne = {},
    transitions: re = {},
    typography: se = {}
  } = $, ie = _objectWithoutPropertiesLoose$1($, _excluded$n);
  if ($.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : formatMuiErrorMessage$1(18));
  const oe = createPalette(ne), le = createTheme$2($);
  let ue = deepmerge$1(le, {
    mixins: createMixins(le.breakpoints, te),
    palette: oe,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(oe, se),
    transitions: createTransitions(re),
    zIndex: _extends$4({}, zIndex$1)
  });
  if (ue = deepmerge$1(ue, ie), ue = ee.reduce((de, fe) => deepmerge$1(de, fe), ue), process.env.NODE_ENV !== "production") {
    const de = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], fe = (pe, ye) => {
      let me;
      for (me in pe) {
        const ve = pe[me];
        if (de.indexOf(me) !== -1 && Object.keys(ve).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const ge = generateUtilityClass("", me);
            console.error([`MUI: The \`${ye}\` component increases the CSS specificity of the \`${me}\` internal state.`, "You can not override it like this: ", JSON.stringify(pe, null, 2), "", `Instead, you need to use the '&.${ge}' syntax:`, JSON.stringify({
              root: {
                [`&.${ge}`]: ve
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          pe[me] = {};
        }
      }
    };
    Object.keys(ue.components).forEach((pe) => {
      const ye = ue.components[pe].styleOverrides;
      ye && pe.indexOf("Mui") === 0 && fe(ye, pe);
    });
  }
  return ue.unstable_sxConfig = _extends$4({}, defaultSxConfig$1, ie == null ? void 0 : ie.unstable_sxConfig), ue.unstable_sx = function(fe) {
    return styleFunctionSx$1({
      sx: fe,
      theme: this
    });
  }, ue;
}
const defaultTheme = createTheme(), defaultTheme$1 = defaultTheme, THEME_ID = "$$material";
function slotShouldForwardProp($) {
  return $ !== "ownerState" && $ !== "theme" && $ !== "sx" && $ !== "as";
}
const rootShouldForwardProp = ($) => slotShouldForwardProp($) && $ !== "classes", styled = _default({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function getThemeProps($) {
  const {
    theme: ee,
    name: te,
    props: ne
  } = $;
  return !ee || !ee.components || !ee.components[te] || !ee.components[te].defaultProps ? ne : resolveProps(ee.components[te].defaultProps, ne);
}
function isObjectEmpty($) {
  return Object.keys($).length === 0;
}
function useTheme$2($ = null) {
  const ee = React.useContext(ThemeContext);
  return !ee || isObjectEmpty(ee) ? $ : ee;
}
const systemDefaultTheme = createTheme$2();
function useTheme$1($ = systemDefaultTheme) {
  return useTheme$2($);
}
function useThemeProps$2({
  props: $,
  name: ee,
  defaultTheme: te,
  themeId: ne
}) {
  let re = useTheme$1(te);
  return ne && (re = re[ne] || re), getThemeProps({
    theme: re,
    name: ee,
    props: $
  });
}
function useThemeProps$1({
  props: $,
  name: ee
}) {
  return useThemeProps$2({
    props: $,
    name: ee,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
const ListContext = /* @__PURE__ */ React.createContext({});
process.env.NODE_ENV !== "production" && (ListContext.displayName = "ListContext");
const ListContext$1 = ListContext;
function getListUtilityClass($) {
  return generateUtilityClass("MuiList", $);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$m = ["children", "className", "component", "dense", "disablePadding", "subheader"], useUtilityClasses$h = ($) => {
  const {
    classes: ee,
    disablePadding: te,
    dense: ne,
    subheader: re
  } = $;
  return composeClasses({
    root: ["root", !te && "padding", ne && "dense", re && "subheader"]
  }, getListUtilityClass, ee);
}, ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, !te.disablePadding && ee.padding, te.dense && ee.dense, te.subheader && ee.subheader];
  }
})(({
  ownerState: $
}) => _extends$4({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !$.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, $.subheader && {
  paddingTop: 0
})), List = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiList"
  }), {
    children: re,
    className: se,
    component: ie = "ul",
    dense: oe = !1,
    disablePadding: le = !1,
    subheader: ue
  } = ne, de = _objectWithoutPropertiesLoose$1(ne, _excluded$m), fe = React.useMemo(() => ({
    dense: oe
  }), [oe]), pe = _extends$4({}, ne, {
    component: ie,
    dense: oe,
    disablePadding: le
  }), ye = useUtilityClasses$h(pe);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: fe,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$4({
      as: ie,
      className: clsx(ye.root, se),
      ref: te,
      ownerState: pe
    }, de, {
      children: [ue, re]
    }))
  });
});
process.env.NODE_ENV !== "production" && (List.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used for
   * the list and list items.
   * The prop is available to descendant components as the `dense` context.
   * @default false
   */
  dense: PropTypes.bool,
  /**
   * If `true`, vertical padding is removed from the list.
   * @default false
   */
  disablePadding: PropTypes.bool,
  /**
   * The content of the subheader, normally `ListSubheader`.
   */
  subheader: PropTypes.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
});
const List$1 = List, _excluded$l = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem($, ee, te) {
  return $ === ee ? $.firstChild : ee && ee.nextElementSibling ? ee.nextElementSibling : te ? null : $.firstChild;
}
function previousItem($, ee, te) {
  return $ === ee ? te ? $.firstChild : $.lastChild : ee && ee.previousElementSibling ? ee.previousElementSibling : te ? null : $.lastChild;
}
function textCriteriaMatches($, ee) {
  if (ee === void 0)
    return !0;
  let te = $.innerText;
  return te === void 0 && (te = $.textContent), te = te.trim().toLowerCase(), te.length === 0 ? !1 : ee.repeating ? te[0] === ee.keys[0] : te.indexOf(ee.keys.join("")) === 0;
}
function moveFocus($, ee, te, ne, re, se) {
  let ie = !1, oe = re($, ee, ee ? te : !1);
  for (; oe; ) {
    if (oe === $.firstChild) {
      if (ie)
        return !1;
      ie = !0;
    }
    const le = ne ? !1 : oe.disabled || oe.getAttribute("aria-disabled") === "true";
    if (!oe.hasAttribute("tabindex") || !textCriteriaMatches(oe, se) || le)
      oe = re($, oe, te);
    else
      return oe.focus(), !0;
  }
  return !1;
}
const MenuList = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: ne,
    autoFocus: re = !1,
    autoFocusItem: se = !1,
    children: ie,
    className: oe,
    disabledItemsFocusable: le = !1,
    disableListWrap: ue = !1,
    onKeyDown: de,
    variant: fe = "selectedMenu"
  } = ee, pe = _objectWithoutPropertiesLoose$1(ee, _excluded$l), ye = React.useRef(null), me = React.useRef({
    keys: [],
    repeating: !0,
    previousKeyMatched: !0,
    lastTime: null
  });
  useEnhancedEffect(() => {
    re && ye.current.focus();
  }, [re]), React.useImperativeHandle(ne, () => ({
    adjustStyleForScrollbar: (Te, {
      direction: Se
    }) => {
      const he = !ye.current.style.width;
      if (Te.clientHeight < ye.current.clientHeight && he) {
        const Pe = `${getScrollbarSize(ownerDocument(Te))}px`;
        ye.current.style[Se === "rtl" ? "paddingLeft" : "paddingRight"] = Pe, ye.current.style.width = `calc(100% + ${Pe})`;
      }
      return ye.current;
    }
  }), []);
  const ve = (Te) => {
    const Se = ye.current, he = Te.key, Pe = ownerDocument(Se).activeElement;
    if (he === "ArrowDown")
      Te.preventDefault(), moveFocus(Se, Pe, ue, le, nextItem);
    else if (he === "ArrowUp")
      Te.preventDefault(), moveFocus(Se, Pe, ue, le, previousItem);
    else if (he === "Home")
      Te.preventDefault(), moveFocus(Se, null, ue, le, nextItem);
    else if (he === "End")
      Te.preventDefault(), moveFocus(Se, null, ue, le, previousItem);
    else if (he.length === 1) {
      const Ie = me.current, De = he.toLowerCase(), Ce = performance.now();
      Ie.keys.length > 0 && (Ce - Ie.lastTime > 500 ? (Ie.keys = [], Ie.repeating = !0, Ie.previousKeyMatched = !0) : Ie.repeating && De !== Ie.keys[0] && (Ie.repeating = !1)), Ie.lastTime = Ce, Ie.keys.push(De);
      const Ne = Pe && !Ie.repeating && textCriteriaMatches(Pe, Ie);
      Ie.previousKeyMatched && (Ne || moveFocus(Se, Pe, !1, le, nextItem, Ie)) ? Te.preventDefault() : Ie.previousKeyMatched = !1;
    }
    de && de(Te);
  }, ge = useForkRef(ye, te);
  let xe = -1;
  React.Children.forEach(ie, (Te, Se) => {
    if (!/* @__PURE__ */ React.isValidElement(Te)) {
      xe === Se && (xe += 1, xe >= ie.length && (xe = -1));
      return;
    }
    process.env.NODE_ENV !== "production" && reactIsExports$1.isFragment(Te) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), Te.props.disabled || (fe === "selectedMenu" && Te.props.selected || xe === -1) && (xe = Se), xe === Se && (Te.props.disabled || Te.props.muiSkipListHighlight || Te.type.muiSkipListHighlight) && (xe += 1, xe >= ie.length && (xe = -1));
  });
  const Ee = React.Children.map(ie, (Te, Se) => {
    if (Se === xe) {
      const he = {};
      return se && (he.autoFocus = !0), Te.props.tabIndex === void 0 && fe === "selectedMenu" && (he.tabIndex = 0), /* @__PURE__ */ React.cloneElement(Te, he);
    }
    return Te;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$4({
    role: "menu",
    ref: ge,
    className: oe,
    onKeyDown: ve,
    tabIndex: re ? 0 : -1
  }, pe, {
    children: Ee
  }));
});
process.env.NODE_ENV !== "production" && (MenuList.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, will focus the `[role="menu"]` container and move into tab order.
   * @default false
   */
  autoFocus: PropTypes.bool,
  /**
   * If `true`, will focus the first menuitem if `variant="menu"` or selected item
   * if `variant="selectedMenu"`.
   * @default false
   */
  autoFocusItem: PropTypes.bool,
  /**
   * MenuList contents, normally `MenuItem`s.
   */
  children: PropTypes.node,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: PropTypes.bool,
  /**
   * If `true`, the menu items will not wrap focus.
   * @default false
   */
  disableListWrap: PropTypes.bool,
  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus
   * and the vertical alignment relative to the anchor element.
   * @default 'selectedMenu'
   */
  variant: PropTypes.oneOf(["menu", "selectedMenu"])
});
const MenuList$1 = MenuList;
function _setPrototypeOf$4($, ee) {
  return _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, re) {
    return ne.__proto__ = re, ne;
  }, _setPrototypeOf$4($, ee);
}
function _inheritsLoose($, ee) {
  $.prototype = Object.create(ee.prototype), $.prototype.constructor = $, _setPrototypeOf$4($, ee);
}
const config = {
  disabled: !1
};
var timeoutsShape = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null;
process.env.NODE_ENV !== "production" && PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]);
const TransitionGroupContext = React__default.createContext(null);
var forceReflow = function $(ee) {
  return ee.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function($) {
  _inheritsLoose(ee, $);
  function ee(ne, re) {
    var se;
    se = $.call(this, ne, re) || this;
    var ie = re, oe = ie && !ie.isMounting ? ne.enter : ne.appear, le;
    return se.appearStatus = null, ne.in ? oe ? (le = EXITED, se.appearStatus = ENTERING) : le = ENTERED : ne.unmountOnExit || ne.mountOnEnter ? le = UNMOUNTED : le = EXITED, se.state = {
      status: le
    }, se.nextCallback = null, se;
  }
  ee.getDerivedStateFromProps = function(re, se) {
    var ie = re.in;
    return ie && se.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var te = ee.prototype;
  return te.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, te.componentDidUpdate = function(re) {
    var se = null;
    if (re !== this.props) {
      var ie = this.state.status;
      this.props.in ? ie !== ENTERING && ie !== ENTERED && (se = ENTERING) : (ie === ENTERING || ie === ENTERED) && (se = EXITING);
    }
    this.updateStatus(!1, se);
  }, te.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, te.getTimeouts = function() {
    var re = this.props.timeout, se, ie, oe;
    return se = ie = oe = re, re != null && typeof re != "number" && (se = re.exit, ie = re.enter, oe = re.appear !== void 0 ? re.appear : ie), {
      exit: se,
      enter: ie,
      appear: oe
    };
  }, te.updateStatus = function(re, se) {
    if (re === void 0 && (re = !1), se !== null)
      if (this.cancelNextCallback(), se === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var ie = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this);
          ie && forceReflow(ie);
        }
        this.performEnter(re);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, te.performEnter = function(re) {
    var se = this, ie = this.props.enter, oe = this.context ? this.context.isMounting : re, le = this.props.nodeRef ? [oe] : [ReactDOM__default.findDOMNode(this), oe], ue = le[0], de = le[1], fe = this.getTimeouts(), pe = oe ? fe.appear : fe.enter;
    if (!re && !ie || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        se.props.onEntered(ue);
      });
      return;
    }
    this.props.onEnter(ue, de), this.safeSetState({
      status: ENTERING
    }, function() {
      se.props.onEntering(ue, de), se.onTransitionEnd(pe, function() {
        se.safeSetState({
          status: ENTERED
        }, function() {
          se.props.onEntered(ue, de);
        });
      });
    });
  }, te.performExit = function() {
    var re = this, se = this.props.exit, ie = this.getTimeouts(), oe = this.props.nodeRef ? void 0 : ReactDOM__default.findDOMNode(this);
    if (!se || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        re.props.onExited(oe);
      });
      return;
    }
    this.props.onExit(oe), this.safeSetState({
      status: EXITING
    }, function() {
      re.props.onExiting(oe), re.onTransitionEnd(ie.exit, function() {
        re.safeSetState({
          status: EXITED
        }, function() {
          re.props.onExited(oe);
        });
      });
    });
  }, te.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, te.safeSetState = function(re, se) {
    se = this.setNextCallback(se), this.setState(re, se);
  }, te.setNextCallback = function(re) {
    var se = this, ie = !0;
    return this.nextCallback = function(oe) {
      ie && (ie = !1, se.nextCallback = null, re(oe));
    }, this.nextCallback.cancel = function() {
      ie = !1;
    }, this.nextCallback;
  }, te.onTransitionEnd = function(re, se) {
    this.setNextCallback(se);
    var ie = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default.findDOMNode(this), oe = re == null && !this.props.addEndListener;
    if (!ie || oe) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var le = this.props.nodeRef ? [this.nextCallback] : [ie, this.nextCallback], ue = le[0], de = le[1];
      this.props.addEndListener(ue, de);
    }
    re != null && setTimeout(this.nextCallback, re);
  }, te.render = function() {
    var re = this.state.status;
    if (re === UNMOUNTED)
      return null;
    var se = this.props, ie = se.children;
    se.in, se.mountOnEnter, se.unmountOnExit, se.appear, se.enter, se.exit, se.timeout, se.addEndListener, se.onEnter, se.onEntering, se.onEntered, se.onExit, se.onExiting, se.onExited, se.nodeRef;
    var oe = _objectWithoutPropertiesLoose$1(se, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof ie == "function" ? ie(re, oe) : React__default.cloneElement(React__default.Children.only(ie), oe))
    );
  }, ee;
}(React__default.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function($, ee, te, ne, re, se) {
      var ie = $[ee];
      return PropTypes.instanceOf(ie && "ownerDocument" in ie ? ie.ownerDocument.defaultView.Element : Element)($, ee, te, ne, re, se);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function $(ee) {
    var te = timeoutsShape;
    ee.addEndListener || (te = te.isRequired);
    for (var ne = arguments.length, re = new Array(ne > 1 ? ne - 1 : 0), se = 1; se < ne; se++)
      re[se - 1] = arguments[se];
    return te.apply(void 0, [ee].concat(re));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized$4($) {
  if ($ === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return $;
}
function getChildMapping($, ee) {
  var te = function(se) {
    return ee && isValidElement(se) ? ee(se) : se;
  }, ne = /* @__PURE__ */ Object.create(null);
  return $ && Children.map($, function(re) {
    return re;
  }).forEach(function(re) {
    ne[re.key] = te(re);
  }), ne;
}
function mergeChildMappings($, ee) {
  $ = $ || {}, ee = ee || {};
  function te(de) {
    return de in ee ? ee[de] : $[de];
  }
  var ne = /* @__PURE__ */ Object.create(null), re = [];
  for (var se in $)
    se in ee ? re.length && (ne[se] = re, re = []) : re.push(se);
  var ie, oe = {};
  for (var le in ee) {
    if (ne[le])
      for (ie = 0; ie < ne[le].length; ie++) {
        var ue = ne[le][ie];
        oe[ne[le][ie]] = te(ue);
      }
    oe[le] = te(le);
  }
  for (ie = 0; ie < re.length; ie++)
    oe[re[ie]] = te(re[ie]);
  return oe;
}
function getProp($, ee, te) {
  return te[ee] != null ? te[ee] : $.props[ee];
}
function getInitialChildMapping($, ee) {
  return getChildMapping($.children, function(te) {
    return cloneElement(te, {
      onExited: ee.bind(null, te),
      in: !0,
      appear: getProp(te, "appear", $),
      enter: getProp(te, "enter", $),
      exit: getProp(te, "exit", $)
    });
  });
}
function getNextChildMapping($, ee, te) {
  var ne = getChildMapping($.children), re = mergeChildMappings(ee, ne);
  return Object.keys(re).forEach(function(se) {
    var ie = re[se];
    if (isValidElement(ie)) {
      var oe = se in ee, le = se in ne, ue = ee[se], de = isValidElement(ue) && !ue.props.in;
      le && (!oe || de) ? re[se] = cloneElement(ie, {
        onExited: te.bind(null, ie),
        in: !0,
        exit: getProp(ie, "exit", $),
        enter: getProp(ie, "enter", $)
      }) : !le && oe && !de ? re[se] = cloneElement(ie, {
        in: !1
      }) : le && oe && isValidElement(ue) && (re[se] = cloneElement(ie, {
        onExited: te.bind(null, ie),
        in: ue.props.in,
        exit: getProp(ie, "exit", $),
        enter: getProp(ie, "enter", $)
      }));
    }
  }), re;
}
var values = Object.values || function($) {
  return Object.keys($).map(function(ee) {
    return $[ee];
  });
}, defaultProps$1 = {
  component: "div",
  childFactory: function $(ee) {
    return ee;
  }
}, TransitionGroup = /* @__PURE__ */ function($) {
  _inheritsLoose(ee, $);
  function ee(ne, re) {
    var se;
    se = $.call(this, ne, re) || this;
    var ie = se.handleExited.bind(_assertThisInitialized$4(se));
    return se.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: ie,
      firstRender: !0
    }, se;
  }
  var te = ee.prototype;
  return te.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, te.componentWillUnmount = function() {
    this.mounted = !1;
  }, ee.getDerivedStateFromProps = function(re, se) {
    var ie = se.children, oe = se.handleExited, le = se.firstRender;
    return {
      children: le ? getInitialChildMapping(re, oe) : getNextChildMapping(re, ie, oe),
      firstRender: !1
    };
  }, te.handleExited = function(re, se) {
    var ie = getChildMapping(this.props.children);
    re.key in ie || (re.props.onExited && re.props.onExited(se), this.mounted && this.setState(function(oe) {
      var le = _extends$4({}, oe.children);
      return delete le[re.key], {
        children: le
      };
    }));
  }, te.render = function() {
    var re = this.props, se = re.component, ie = re.childFactory, oe = _objectWithoutPropertiesLoose$1(re, ["component", "childFactory"]), le = this.state.contextValue, ue = values(this.state.children).map(ie);
    return delete oe.appear, delete oe.enter, delete oe.exit, se === null ? /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: le
    }, ue) : /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: le
    }, /* @__PURE__ */ React__default.createElement(se, oe, ue));
  }, ee;
}(React__default.Component);
TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: PropTypes.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: PropTypes.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: PropTypes.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: PropTypes.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: PropTypes.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: PropTypes.func
} : {};
TransitionGroup.defaultProps = defaultProps$1;
const TransitionGroup$1 = TransitionGroup;
function useTheme() {
  const $ = useTheme$1(defaultTheme$1);
  return process.env.NODE_ENV !== "production" && React.useDebugValue($), $[THEME_ID] || $;
}
const reflow = ($) => $.scrollTop;
function getTransitionProps($, ee) {
  var te, ne;
  const {
    timeout: re,
    easing: se,
    style: ie = {}
  } = $;
  return {
    duration: (te = ie.transitionDuration) != null ? te : typeof re == "number" ? re : re[ee.mode] || 0,
    easing: (ne = ie.transitionTimingFunction) != null ? ne : typeof se == "object" ? se[ee.mode] : se,
    delay: ie.transitionDelay
  };
}
const _excluded$k = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale($) {
  return `scale(${$}, ${$ ** 2})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
}, isWebKit154 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), Grow = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const {
    addEndListener: ne,
    appear: re = !0,
    children: se,
    easing: ie,
    in: oe,
    onEnter: le,
    onEntered: ue,
    onEntering: de,
    onExit: fe,
    onExited: pe,
    onExiting: ye,
    style: me,
    timeout: ve = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent: ge = Transition$1
  } = ee, xe = _objectWithoutPropertiesLoose$1(ee, _excluded$k), Ee = useTimeout(), Te = React.useRef(), Se = useTheme(), he = React.useRef(null), Pe = useForkRef(he, se.ref, te), Ie = (He) => (Ge) => {
    if (He) {
      const Ze = he.current;
      Ge === void 0 ? He(Ze) : He(Ze, Ge);
    }
  }, De = Ie(de), Ce = Ie((He, Ge) => {
    reflow(He);
    const {
      duration: Ze,
      delay: Ue,
      easing: Qe
    } = getTransitionProps({
      style: me,
      timeout: ve,
      easing: ie
    }, {
      mode: "enter"
    });
    let Je;
    ve === "auto" ? (Je = Se.transitions.getAutoHeightDuration(He.clientHeight), Te.current = Je) : Je = Ze, He.style.transition = [Se.transitions.create("opacity", {
      duration: Je,
      delay: Ue
    }), Se.transitions.create("transform", {
      duration: isWebKit154 ? Je : Je * 0.666,
      delay: Ue,
      easing: Qe
    })].join(","), le && le(He, Ge);
  }), Ne = Ie(ue), Me = Ie(ye), Be = Ie((He) => {
    const {
      duration: Ge,
      delay: Ze,
      easing: Ue
    } = getTransitionProps({
      style: me,
      timeout: ve,
      easing: ie
    }, {
      mode: "exit"
    });
    let Qe;
    ve === "auto" ? (Qe = Se.transitions.getAutoHeightDuration(He.clientHeight), Te.current = Qe) : Qe = Ge, He.style.transition = [Se.transitions.create("opacity", {
      duration: Qe,
      delay: Ze
    }), Se.transitions.create("transform", {
      duration: isWebKit154 ? Qe : Qe * 0.666,
      delay: isWebKit154 ? Ze : Ze || Qe * 0.333,
      easing: Ue
    })].join(","), He.style.opacity = 0, He.style.transform = getScale(0.75), fe && fe(He);
  }), We = Ie(pe), Le = (He) => {
    ve === "auto" && Ee.start(Te.current || 0, He), ne && ne(he.current, He);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ge, _extends$4({
    appear: re,
    in: oe,
    nodeRef: he,
    onEnter: Ce,
    onEntered: Ne,
    onEntering: De,
    onExit: Be,
    onExited: We,
    onExiting: Me,
    addEndListener: Le,
    timeout: ve === "auto" ? null : ve
  }, xe, {
    children: (He, Ge) => /* @__PURE__ */ React.cloneElement(se, _extends$4({
      style: _extends$4({
        opacity: 0,
        transform: getScale(0.75),
        visibility: He === "exited" && !oe ? "hidden" : void 0
      }, styles$1[He], me, se.props.style),
      ref: Pe
    }, Ge))
  }));
});
process.env.NODE_ENV !== "production" && (Grow.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: PropTypes.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: PropTypes.bool,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: PropTypes.oneOfType([PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string
  }), PropTypes.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: PropTypes.bool,
  /**
   * @ignore
   */
  onEnter: PropTypes.func,
  /**
   * @ignore
   */
  onEntered: PropTypes.func,
  /**
   * @ignore
   */
  onEntering: PropTypes.func,
  /**
   * @ignore
   */
  onExit: PropTypes.func,
  /**
   * @ignore
   */
  onExited: PropTypes.func,
  /**
   * @ignore
   */
  onExiting: PropTypes.func,
  /**
   * @ignore
   */
  style: PropTypes.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: PropTypes.oneOfType([PropTypes.oneOf(["auto"]), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })])
});
Grow.muiSupportAuto = !0;
const Grow$1 = Grow;
function isOverflowing($) {
  const ee = ownerDocument($);
  return ee.body === $ ? ownerWindow($).innerWidth > ee.documentElement.clientWidth : $.scrollHeight > $.clientHeight;
}
function ariaHidden($, ee) {
  ee ? $.setAttribute("aria-hidden", "true") : $.removeAttribute("aria-hidden");
}
function getPaddingRight($) {
  return parseInt(ownerWindow($).getComputedStyle($).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement($) {
  const te = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf($.tagName) !== -1, ne = $.tagName === "INPUT" && $.getAttribute("type") === "hidden";
  return te || ne;
}
function ariaHiddenSiblings($, ee, te, ne, re) {
  const se = [ee, te, ...ne];
  [].forEach.call($.children, (ie) => {
    const oe = se.indexOf(ie) === -1, le = !isAriaHiddenForbiddenOnElement(ie);
    oe && le && ariaHidden(ie, re);
  });
}
function findIndexOf($, ee) {
  let te = -1;
  return $.some((ne, re) => ee(ne) ? (te = re, !0) : !1), te;
}
function handleContainer($, ee) {
  const te = [], ne = $.container;
  if (!ee.disableScrollLock) {
    if (isOverflowing(ne)) {
      const ie = getScrollbarSize(ownerDocument(ne));
      te.push({
        value: ne.style.paddingRight,
        property: "padding-right",
        el: ne
      }), ne.style.paddingRight = `${getPaddingRight(ne) + ie}px`;
      const oe = ownerDocument(ne).querySelectorAll(".mui-fixed");
      [].forEach.call(oe, (le) => {
        te.push({
          value: le.style.paddingRight,
          property: "padding-right",
          el: le
        }), le.style.paddingRight = `${getPaddingRight(le) + ie}px`;
      });
    }
    let se;
    if (ne.parentNode instanceof DocumentFragment)
      se = ownerDocument(ne).body;
    else {
      const ie = ne.parentElement, oe = ownerWindow(ne);
      se = (ie == null ? void 0 : ie.nodeName) === "HTML" && oe.getComputedStyle(ie).overflowY === "scroll" ? ie : ne;
    }
    te.push({
      value: se.style.overflow,
      property: "overflow",
      el: se
    }, {
      value: se.style.overflowX,
      property: "overflow-x",
      el: se
    }, {
      value: se.style.overflowY,
      property: "overflow-y",
      el: se
    }), se.style.overflow = "hidden";
  }
  return () => {
    te.forEach(({
      value: se,
      el: ie,
      property: oe
    }) => {
      se ? ie.style.setProperty(oe, se) : ie.style.removeProperty(oe);
    });
  };
}
function getHiddenSiblings($) {
  const ee = [];
  return [].forEach.call($.children, (te) => {
    te.getAttribute("aria-hidden") === "true" && ee.push(te);
  }), ee;
}
class ModalManager {
  constructor() {
    this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = [];
  }
  add(ee, te) {
    let ne = this.modals.indexOf(ee);
    if (ne !== -1)
      return ne;
    ne = this.modals.length, this.modals.push(ee), ee.modalRef && ariaHidden(ee.modalRef, !1);
    const re = getHiddenSiblings(te);
    ariaHiddenSiblings(te, ee.mount, ee.modalRef, re, !0);
    const se = findIndexOf(this.containers, (ie) => ie.container === te);
    return se !== -1 ? (this.containers[se].modals.push(ee), ne) : (this.containers.push({
      modals: [ee],
      container: te,
      restore: null,
      hiddenSiblings: re
    }), ne);
  }
  mount(ee, te) {
    const ne = findIndexOf(this.containers, (se) => se.modals.indexOf(ee) !== -1), re = this.containers[ne];
    re.restore || (re.restore = handleContainer(re, te));
  }
  remove(ee, te = !0) {
    const ne = this.modals.indexOf(ee);
    if (ne === -1)
      return ne;
    const re = findIndexOf(this.containers, (ie) => ie.modals.indexOf(ee) !== -1), se = this.containers[re];
    if (se.modals.splice(se.modals.indexOf(ee), 1), this.modals.splice(ne, 1), se.modals.length === 0)
      se.restore && se.restore(), ee.modalRef && ariaHidden(ee.modalRef, te), ariaHiddenSiblings(se.container, ee.mount, ee.modalRef, se.hiddenSiblings, !1), this.containers.splice(re, 1);
    else {
      const ie = se.modals[se.modals.length - 1];
      ie.modalRef && ariaHidden(ie.modalRef, !1);
    }
    return ne;
  }
  isTopModal(ee) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === ee;
  }
}
function getContainer$1($) {
  return typeof $ == "function" ? $() : $;
}
function getHasTransition($) {
  return $ ? $.props.hasOwnProperty("in") : !1;
}
const defaultManager = new ModalManager();
function useModal($) {
  const {
    container: ee,
    disableEscapeKeyDown: te = !1,
    disableScrollLock: ne = !1,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager: re = defaultManager,
    closeAfterTransition: se = !1,
    onTransitionEnter: ie,
    onTransitionExited: oe,
    children: le,
    onClose: ue,
    open: de,
    rootRef: fe
  } = $, pe = React.useRef({}), ye = React.useRef(null), me = React.useRef(null), ve = useForkRef(me, fe), [ge, xe] = React.useState(!de), Ee = getHasTransition(le);
  let Te = !0;
  ($["aria-hidden"] === "false" || $["aria-hidden"] === !1) && (Te = !1);
  const Se = () => ownerDocument(ye.current), he = () => (pe.current.modalRef = me.current, pe.current.mount = ye.current, pe.current), Pe = () => {
    re.mount(he(), {
      disableScrollLock: ne
    }), me.current && (me.current.scrollTop = 0);
  }, Ie = useEventCallback(() => {
    const Ge = getContainer$1(ee) || Se().body;
    re.add(he(), Ge), me.current && Pe();
  }), De = React.useCallback(() => re.isTopModal(he()), [re]), Ce = useEventCallback((Ge) => {
    ye.current = Ge, Ge && (de && De() ? Pe() : me.current && ariaHidden(me.current, Te));
  }), Ne = React.useCallback(() => {
    re.remove(he(), Te);
  }, [Te, re]);
  React.useEffect(() => () => {
    Ne();
  }, [Ne]), React.useEffect(() => {
    de ? Ie() : (!Ee || !se) && Ne();
  }, [de, Ne, Ee, se, Ie]);
  const Me = (Ge) => (Ze) => {
    var Ue;
    (Ue = Ge.onKeyDown) == null || Ue.call(Ge, Ze), !(Ze.key !== "Escape" || Ze.which === 229 || // Wait until IME is settled.
    !De()) && (te || (Ze.stopPropagation(), ue && ue(Ze, "escapeKeyDown")));
  }, Be = (Ge) => (Ze) => {
    var Ue;
    (Ue = Ge.onClick) == null || Ue.call(Ge, Ze), Ze.target === Ze.currentTarget && ue && ue(Ze, "backdropClick");
  };
  return {
    getRootProps: (Ge = {}) => {
      const Ze = extractEventHandlers($);
      delete Ze.onTransitionEnter, delete Ze.onTransitionExited;
      const Ue = _extends$4({}, Ze, Ge);
      return _extends$4({
        role: "presentation"
      }, Ue, {
        onKeyDown: Me(Ue),
        ref: ve
      });
    },
    getBackdropProps: (Ge = {}) => {
      const Ze = Ge;
      return _extends$4({
        "aria-hidden": !0
      }, Ze, {
        onClick: Be(Ze),
        open: de
      });
    },
    getTransitionProps: () => {
      const Ge = () => {
        xe(!1), ie && ie();
      }, Ze = () => {
        xe(!0), oe && oe(), se && Ne();
      };
      return {
        onEnter: createChainedFunction(Ge, le == null ? void 0 : le.props.onEnter),
        onExited: createChainedFunction(Ze, le == null ? void 0 : le.props.onExited)
      };
    },
    rootRef: ve,
    portalRef: Ce,
    isTopModal: De,
    exited: ge,
    hasTransition: Ee
  };
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex($) {
  const ee = parseInt($.getAttribute("tabindex") || "", 10);
  return Number.isNaN(ee) ? $.contentEditable === "true" || ($.nodeName === "AUDIO" || $.nodeName === "VIDEO" || $.nodeName === "DETAILS") && $.getAttribute("tabindex") === null ? 0 : $.tabIndex : ee;
}
function isNonTabbableRadio($) {
  if ($.tagName !== "INPUT" || $.type !== "radio" || !$.name)
    return !1;
  const ee = (ne) => $.ownerDocument.querySelector(`input[type="radio"]${ne}`);
  let te = ee(`[name="${$.name}"]:checked`);
  return te || (te = ee(`[name="${$.name}"]`)), te !== $;
}
function isNodeMatchingSelectorFocusable($) {
  return !($.disabled || $.tagName === "INPUT" && $.type === "hidden" || isNonTabbableRadio($));
}
function defaultGetTabbable($) {
  const ee = [], te = [];
  return Array.from($.querySelectorAll(candidatesSelector)).forEach((ne, re) => {
    const se = getTabIndex(ne);
    se === -1 || !isNodeMatchingSelectorFocusable(ne) || (se === 0 ? ee.push(ne) : te.push({
      documentOrder: re,
      tabIndex: se,
      node: ne
    }));
  }), te.sort((ne, re) => ne.tabIndex === re.tabIndex ? ne.documentOrder - re.documentOrder : ne.tabIndex - re.tabIndex).map((ne) => ne.node).concat(ee);
}
function defaultIsEnabled() {
  return !0;
}
function FocusTrap($) {
  const {
    children: ee,
    disableAutoFocus: te = !1,
    disableEnforceFocus: ne = !1,
    disableRestoreFocus: re = !1,
    getTabbable: se = defaultGetTabbable,
    isEnabled: ie = defaultIsEnabled,
    open: oe
  } = $, le = React.useRef(!1), ue = React.useRef(null), de = React.useRef(null), fe = React.useRef(null), pe = React.useRef(null), ye = React.useRef(!1), me = React.useRef(null), ve = useForkRef(ee.ref, me), ge = React.useRef(null);
  React.useEffect(() => {
    !oe || !me.current || (ye.current = !te);
  }, [te, oe]), React.useEffect(() => {
    if (!oe || !me.current)
      return;
    const Te = ownerDocument(me.current);
    return me.current.contains(Te.activeElement) || (me.current.hasAttribute("tabIndex") || (process.env.NODE_ENV !== "production" && console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join(`
`)), me.current.setAttribute("tabIndex", "-1")), ye.current && me.current.focus()), () => {
      re || (fe.current && fe.current.focus && (le.current = !0, fe.current.focus()), fe.current = null);
    };
  }, [oe]), React.useEffect(() => {
    if (!oe || !me.current)
      return;
    const Te = ownerDocument(me.current), Se = (Ie) => {
      ge.current = Ie, !(ne || !ie() || Ie.key !== "Tab") && Te.activeElement === me.current && Ie.shiftKey && (le.current = !0, de.current && de.current.focus());
    }, he = () => {
      const Ie = me.current;
      if (Ie === null)
        return;
      if (!Te.hasFocus() || !ie() || le.current) {
        le.current = !1;
        return;
      }
      if (Ie.contains(Te.activeElement) || ne && Te.activeElement !== ue.current && Te.activeElement !== de.current)
        return;
      if (Te.activeElement !== pe.current)
        pe.current = null;
      else if (pe.current !== null)
        return;
      if (!ye.current)
        return;
      let De = [];
      if ((Te.activeElement === ue.current || Te.activeElement === de.current) && (De = se(me.current)), De.length > 0) {
        var Ce, Ne;
        const Me = !!((Ce = ge.current) != null && Ce.shiftKey && ((Ne = ge.current) == null ? void 0 : Ne.key) === "Tab"), Be = De[0], We = De[De.length - 1];
        typeof Be != "string" && typeof We != "string" && (Me ? We.focus() : Be.focus());
      } else
        Ie.focus();
    };
    Te.addEventListener("focusin", he), Te.addEventListener("keydown", Se, !0);
    const Pe = setInterval(() => {
      Te.activeElement && Te.activeElement.tagName === "BODY" && he();
    }, 50);
    return () => {
      clearInterval(Pe), Te.removeEventListener("focusin", he), Te.removeEventListener("keydown", Se, !0);
    };
  }, [te, ne, re, ie, oe, se]);
  const xe = (Te) => {
    fe.current === null && (fe.current = Te.relatedTarget), ye.current = !0, pe.current = Te.target;
    const Se = ee.props.onFocus;
    Se && Se(Te);
  }, Ee = (Te) => {
    fe.current === null && (fe.current = Te.relatedTarget), ye.current = !0;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: oe ? 0 : -1,
      onFocus: Ee,
      ref: ue,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ React.cloneElement(ee, {
      ref: ve,
      onFocus: xe
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: oe ? 0 : -1,
      onFocus: Ee,
      ref: de,
      "data-testid": "sentinelEnd"
    })]
  });
}
process.env.NODE_ENV !== "production" && (FocusTrap.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1,
  /**
   * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: PropTypes.bool,
  /**
   * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
   *
   * Generally this should never be set to `true` as it makes the focus trap less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: PropTypes.bool,
  /**
   * If `true`, the focus trap will not restore focus to previously focused element once
   * focus trap is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: PropTypes.bool,
  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: PropTypes.func,
  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple focus trap mounted at the same time.
   * @default function defaultIsEnabled(): boolean {
   *   return true;
   * }
   */
  isEnabled: PropTypes.func,
  /**
   * If `true`, focus is locked.
   */
  open: PropTypes.bool.isRequired
});
process.env.NODE_ENV !== "production" && (FocusTrap.propTypes = exactProp(FocusTrap.propTypes));
function getContainer($) {
  return typeof $ == "function" ? $() : $;
}
const Portal = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const {
    children: ne,
    container: re,
    disablePortal: se = !1
  } = ee, [ie, oe] = React.useState(null), le = useForkRef(/* @__PURE__ */ React.isValidElement(ne) ? ne.ref : null, te);
  if (useEnhancedEffect(() => {
    se || oe(getContainer(re) || document.body);
  }, [re, se]), useEnhancedEffect(() => {
    if (ie && !se)
      return setRef(te, ie), () => {
        setRef(te, null);
      };
  }, [te, ie, se]), se) {
    if (/* @__PURE__ */ React.isValidElement(ne)) {
      const ue = {
        ref: le
      };
      return /* @__PURE__ */ React.cloneElement(ne, ue);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
      children: ne
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
    children: ie && /* @__PURE__ */ ReactDOM.createPortal(ne, ie)
  });
});
process.env.NODE_ENV !== "production" && (Portal.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The children to render into the `container`.
   */
  children: PropTypes.node,
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes.oneOfType([HTMLElementType, PropTypes.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: PropTypes.bool
});
process.env.NODE_ENV !== "production" && (Portal.propTypes = exactProp(Portal.propTypes));
const _excluded$j = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"], styles = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
}, Fade = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useTheme(), re = {
    enter: ne.transitions.duration.enteringScreen,
    exit: ne.transitions.duration.leavingScreen
  }, {
    addEndListener: se,
    appear: ie = !0,
    children: oe,
    easing: le,
    in: ue,
    onEnter: de,
    onEntered: fe,
    onEntering: pe,
    onExit: ye,
    onExited: me,
    onExiting: ve,
    style: ge,
    timeout: xe = re,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: Ee = Transition$1
  } = ee, Te = _objectWithoutPropertiesLoose$1(ee, _excluded$j), Se = React.useRef(null), he = useForkRef(Se, oe.ref, te), Pe = (Le) => (He) => {
    if (Le) {
      const Ge = Se.current;
      He === void 0 ? Le(Ge) : Le(Ge, He);
    }
  }, Ie = Pe(pe), De = Pe((Le, He) => {
    reflow(Le);
    const Ge = getTransitionProps({
      style: ge,
      timeout: xe,
      easing: le
    }, {
      mode: "enter"
    });
    Le.style.webkitTransition = ne.transitions.create("opacity", Ge), Le.style.transition = ne.transitions.create("opacity", Ge), de && de(Le, He);
  }), Ce = Pe(fe), Ne = Pe(ve), Me = Pe((Le) => {
    const He = getTransitionProps({
      style: ge,
      timeout: xe,
      easing: le
    }, {
      mode: "exit"
    });
    Le.style.webkitTransition = ne.transitions.create("opacity", He), Le.style.transition = ne.transitions.create("opacity", He), ye && ye(Le);
  }), Be = Pe(me), We = (Le) => {
    se && se(Se.current, Le);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Ee, _extends$4({
    appear: ie,
    in: ue,
    nodeRef: Se,
    onEnter: De,
    onEntered: Ce,
    onEntering: Ie,
    onExit: Me,
    onExited: Be,
    onExiting: Ne,
    addEndListener: We,
    timeout: xe
  }, Te, {
    children: (Le, He) => /* @__PURE__ */ React.cloneElement(oe, _extends$4({
      style: _extends$4({
        opacity: 0,
        visibility: Le === "exited" && !ue ? "hidden" : void 0
      }, styles[Le], ge, oe.props.style),
      ref: he
    }, He))
  }));
});
process.env.NODE_ENV !== "production" && (Fade.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: PropTypes.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: PropTypes.bool,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: PropTypes.oneOfType([PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string
  }), PropTypes.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: PropTypes.bool,
  /**
   * @ignore
   */
  onEnter: PropTypes.func,
  /**
   * @ignore
   */
  onEntered: PropTypes.func,
  /**
   * @ignore
   */
  onEntering: PropTypes.func,
  /**
   * @ignore
   */
  onExit: PropTypes.func,
  /**
   * @ignore
   */
  onExited: PropTypes.func,
  /**
   * @ignore
   */
  onExiting: PropTypes.func,
  /**
   * @ignore
   */
  style: PropTypes.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })])
});
const Fade$1 = Fade;
function getBackdropUtilityClass($) {
  return generateUtilityClass("MuiBackdrop", $);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$i = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"], useUtilityClasses$g = ($) => {
  const {
    classes: ee,
    invisible: te
  } = $;
  return composeClasses({
    root: ["root", te && "invisible"]
  }, getBackdropUtilityClass, ee);
}, BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, te.invisible && ee.invisible];
  }
})(({
  ownerState: $
}) => _extends$4({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, $.invisible && {
  backgroundColor: "transparent"
})), Backdrop = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re, se;
  const ie = useThemeProps$1({
    props: ee,
    name: "MuiBackdrop"
  }), {
    children: oe,
    className: le,
    component: ue = "div",
    components: de = {},
    componentsProps: fe = {},
    invisible: pe = !1,
    open: ye,
    slotProps: me = {},
    slots: ve = {},
    TransitionComponent: ge = Fade$1,
    transitionDuration: xe
  } = ie, Ee = _objectWithoutPropertiesLoose$1(ie, _excluded$i), Te = _extends$4({}, ie, {
    component: ue,
    invisible: pe
  }), Se = useUtilityClasses$g(Te), he = (ne = me.root) != null ? ne : fe.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ge, _extends$4({
    in: ye,
    timeout: xe
  }, Ee, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$4({
      "aria-hidden": !0
    }, he, {
      as: (re = (se = ve.root) != null ? se : de.Root) != null ? re : ue,
      className: clsx(Se.root, le, he == null ? void 0 : he.className),
      ownerState: _extends$4({}, Te, he == null ? void 0 : he.ownerState),
      classes: Se,
      ref: te,
      children: oe
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Backdrop.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: PropTypes.shape({
    Root: PropTypes.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: PropTypes.shape({
    root: PropTypes.object
  }),
  /**
   * If `true`, the backdrop is invisible.
   * It can be used when rendering a popover or a custom select component.
   * @default false
   */
  invisible: PropTypes.bool,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool.isRequired,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: PropTypes.shape({
    root: PropTypes.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: PropTypes.shape({
    root: PropTypes.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: PropTypes.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })])
});
const Backdrop$1 = Backdrop;
function getModalUtilityClass($) {
  return generateUtilityClass("MuiModal", $);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$h = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"], useUtilityClasses$f = ($) => {
  const {
    open: ee,
    exited: te,
    classes: ne
  } = $;
  return composeClasses({
    root: ["root", !ee && te && "hidden"],
    backdrop: ["backdrop"]
  }, getModalUtilityClass, ne);
}, ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, !te.open && te.exited && ee.hidden];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  position: "fixed",
  zIndex: ($.vars || $).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ee.open && ee.exited && {
  visibility: "hidden"
})), ModalBackdrop = styled(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: ($, ee) => ee.backdrop
})({
  zIndex: -1
}), Modal = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re, se, ie, oe, le;
  const ue = useThemeProps$1({
    name: "MuiModal",
    props: ee
  }), {
    BackdropComponent: de = ModalBackdrop,
    BackdropProps: fe,
    className: pe,
    closeAfterTransition: ye = !1,
    children: me,
    container: ve,
    component: ge,
    components: xe = {},
    componentsProps: Ee = {},
    disableAutoFocus: Te = !1,
    disableEnforceFocus: Se = !1,
    disableEscapeKeyDown: he = !1,
    disablePortal: Pe = !1,
    disableRestoreFocus: Ie = !1,
    disableScrollLock: De = !1,
    hideBackdrop: Ce = !1,
    keepMounted: Ne = !1,
    onBackdropClick: Me,
    open: Be,
    slotProps: We,
    slots: Le
    // eslint-disable-next-line react/prop-types
  } = ue, He = _objectWithoutPropertiesLoose$1(ue, _excluded$h), Ge = _extends$4({}, ue, {
    closeAfterTransition: ye,
    disableAutoFocus: Te,
    disableEnforceFocus: Se,
    disableEscapeKeyDown: he,
    disablePortal: Pe,
    disableRestoreFocus: Ie,
    disableScrollLock: De,
    hideBackdrop: Ce,
    keepMounted: Ne
  }), {
    getRootProps: Ze,
    getBackdropProps: Ue,
    getTransitionProps: Qe,
    portalRef: Je,
    isTopModal: Ot,
    exited: At,
    hasTransition: ze
  } = useModal(_extends$4({}, Ge, {
    rootRef: te
  })), we = _extends$4({}, Ge, {
    exited: At
  }), Ae = useUtilityClasses$f(we), Re = {};
  if (me.props.tabIndex === void 0 && (Re.tabIndex = "-1"), ze) {
    const {
      onEnter: Tt,
      onExited: pt
    } = Qe();
    Re.onEnter = Tt, Re.onExited = pt;
  }
  const je = (ne = (re = Le == null ? void 0 : Le.root) != null ? re : xe.Root) != null ? ne : ModalRoot, Fe = (se = (ie = Le == null ? void 0 : Le.backdrop) != null ? ie : xe.Backdrop) != null ? se : de, $e = (oe = We == null ? void 0 : We.root) != null ? oe : Ee.root, qe = (le = We == null ? void 0 : We.backdrop) != null ? le : Ee.backdrop, Ye = useSlotProps({
    elementType: je,
    externalSlotProps: $e,
    externalForwardedProps: He,
    getSlotProps: Ze,
    additionalProps: {
      ref: te,
      as: ge
    },
    ownerState: we,
    className: clsx(pe, $e == null ? void 0 : $e.className, Ae == null ? void 0 : Ae.root, !we.open && we.exited && (Ae == null ? void 0 : Ae.hidden))
  }), Ke = useSlotProps({
    elementType: Fe,
    externalSlotProps: qe,
    additionalProps: fe,
    getSlotProps: (Tt) => Ue(_extends$4({}, Tt, {
      onClick: (pt) => {
        Me && Me(pt), Tt != null && Tt.onClick && Tt.onClick(pt);
      }
    })),
    className: clsx(qe == null ? void 0 : qe.className, fe == null ? void 0 : fe.className, Ae == null ? void 0 : Ae.backdrop),
    ownerState: we
  });
  return !Ne && !Be && (!ze || At) ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: Je,
    container: ve,
    disablePortal: Pe,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(je, _extends$4({}, Ye, {
      children: [!Ce && de ? /* @__PURE__ */ jsxRuntimeExports.jsx(Fe, _extends$4({}, Ke)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus: Se,
        disableAutoFocus: Te,
        disableRestoreFocus: Ie,
        isEnabled: Ot,
        open: Be,
        children: /* @__PURE__ */ React.cloneElement(me, Re)
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" && (Modal.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: PropTypes.elementType,
  /**
   * Props applied to the [`Backdrop`](/material-ui/api/backdrop/) element.
   * @deprecated Use `slotProps.backdrop` instead.
   */
  BackdropProps: PropTypes.object,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: PropTypes.bool,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: PropTypes.shape({
    Backdrop: PropTypes.elementType,
    Root: PropTypes.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: PropTypes.shape({
    backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes.oneOfType([HTMLElementType, PropTypes.func]),
  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: PropTypes.bool,
  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: PropTypes.bool,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: PropTypes.bool,
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: PropTypes.bool,
  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: PropTypes.bool,
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: PropTypes.bool,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: PropTypes.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: PropTypes.bool,
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: PropTypes.func,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: PropTypes.func,
  /**
   * A function called when a transition enters.
   */
  onTransitionEnter: PropTypes.func,
  /**
   * A function called when a transition has exited.
   */
  onTransitionExited: PropTypes.func,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool.isRequired,
  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  slotProps: PropTypes.shape({
    backdrop: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: PropTypes.shape({
    backdrop: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
});
const Modal$1 = Modal, getOverlayAlpha = ($) => {
  let ee;
  return $ < 1 ? ee = 5.11916 * $ ** 2 : ee = 4.5 * Math.log($ + 1) + 2, (ee / 100).toFixed(2);
};
function getPaperUtilityClass($) {
  return generateUtilityClass("MuiPaper", $);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$g = ["className", "component", "elevation", "square", "variant"], useUtilityClasses$e = ($) => {
  const {
    square: ee,
    elevation: te,
    variant: ne,
    classes: re
  } = $, se = {
    root: ["root", ne, !ee && "rounded", ne === "elevation" && `elevation${te}`]
  };
  return composeClasses(se, getPaperUtilityClass, re);
}, PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, ee[te.variant], !te.square && ee.rounded, te.variant === "elevation" && ee[`elevation${te.elevation}`]];
  }
})(({
  theme: $,
  ownerState: ee
}) => {
  var te;
  return _extends$4({
    backgroundColor: ($.vars || $).palette.background.paper,
    color: ($.vars || $).palette.text.primary,
    transition: $.transitions.create("box-shadow")
  }, !ee.square && {
    borderRadius: $.shape.borderRadius
  }, ee.variant === "outlined" && {
    border: `1px solid ${($.vars || $).palette.divider}`
  }, ee.variant === "elevation" && _extends$4({
    boxShadow: ($.vars || $).shadows[ee.elevation]
  }, !$.vars && $.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(ee.elevation))}, ${alpha_1("#fff", getOverlayAlpha(ee.elevation))})`
  }, $.vars && {
    backgroundImage: (te = $.vars.overlays) == null ? void 0 : te[ee.elevation]
  }));
}), Paper = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiPaper"
  }), {
    className: re,
    component: se = "div",
    elevation: ie = 1,
    square: oe = !1,
    variant: le = "elevation"
  } = ne, ue = _objectWithoutPropertiesLoose$1(ne, _excluded$g), de = _extends$4({}, ne, {
    component: se,
    elevation: ie,
    square: oe,
    variant: le
  }), fe = useUtilityClasses$e(de);
  return process.env.NODE_ENV !== "production" && useTheme().shadows[ie] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${ie}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${ie}]\` is defined.`].join(`
`)), /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$4({
    as: se,
    ownerState: de,
    className: clsx(fe.root, re),
    ref: te
  }, ue));
});
process.env.NODE_ENV !== "production" && (Paper.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: chainPropTypes(integerPropType, ($) => {
    const {
      elevation: ee,
      variant: te
    } = $;
    return ee > 0 && te === "outlined" ? new Error(`MUI: Combining \`elevation={${ee}}\` with \`variant="${te}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: PropTypes.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: PropTypes.oneOfType([PropTypes.oneOf(["elevation", "outlined"]), PropTypes.string])
});
const Paper$1 = Paper;
function getPopoverUtilityClass($) {
  return generateUtilityClass("MuiPopover", $);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$f = ["onEntering"], _excluded2$3 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3 = ["slotProps"];
function getOffsetTop($, ee) {
  let te = 0;
  return typeof ee == "number" ? te = ee : ee === "center" ? te = $.height / 2 : ee === "bottom" && (te = $.height), te;
}
function getOffsetLeft($, ee) {
  let te = 0;
  return typeof ee == "number" ? te = ee : ee === "center" ? te = $.width / 2 : ee === "right" && (te = $.width), te;
}
function getTransformOriginValue($) {
  return [$.horizontal, $.vertical].map((ee) => typeof ee == "number" ? `${ee}px` : ee).join(" ");
}
function resolveAnchorEl($) {
  return typeof $ == "function" ? $() : $;
}
const useUtilityClasses$d = ($) => {
  const {
    classes: ee
  } = $;
  return composeClasses({
    root: ["root"],
    paper: ["paper"]
  }, getPopoverUtilityClass, ee);
}, PopoverRoot = styled(Modal$1, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})({}), PopoverPaper = styled(Paper$1, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: ($, ee) => ee.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), Popover = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re, se;
  const ie = useThemeProps$1({
    props: ee,
    name: "MuiPopover"
  }), {
    action: oe,
    anchorEl: le,
    anchorOrigin: ue = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition: de,
    anchorReference: fe = "anchorEl",
    children: pe,
    className: ye,
    container: me,
    elevation: ve = 8,
    marginThreshold: ge = 16,
    open: xe,
    PaperProps: Ee = {},
    slots: Te,
    slotProps: Se,
    transformOrigin: he = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent: Pe = Grow$1,
    transitionDuration: Ie = "auto",
    TransitionProps: {
      onEntering: De
    } = {},
    disableScrollLock: Ce = !1
  } = ie, Ne = _objectWithoutPropertiesLoose$1(ie.TransitionProps, _excluded$f), Me = _objectWithoutPropertiesLoose$1(ie, _excluded2$3), Be = (ne = Se == null ? void 0 : Se.paper) != null ? ne : Ee, We = React.useRef(), Le = useForkRef(We, Be.ref), He = _extends$4({}, ie, {
    anchorOrigin: ue,
    anchorReference: fe,
    elevation: ve,
    marginThreshold: ge,
    externalPaperSlotProps: Be,
    transformOrigin: he,
    TransitionComponent: Pe,
    transitionDuration: Ie,
    TransitionProps: Ne
  }), Ge = useUtilityClasses$d(He), Ze = React.useCallback(() => {
    if (fe === "anchorPosition")
      return process.env.NODE_ENV !== "production" && (de || console.error('MUI: You need to provide a `anchorPosition` prop when using <Popover anchorReference="anchorPosition" />.')), de;
    const Tt = resolveAnchorEl(le), pt = Tt && Tt.nodeType === 1 ? Tt : ownerDocument(We.current).body, Bt = pt.getBoundingClientRect();
    if (process.env.NODE_ENV !== "production") {
      const Vt = pt.getBoundingClientRect();
      process.env.NODE_ENV !== "test" && Vt.top === 0 && Vt.left === 0 && Vt.right === 0 && Vt.bottom === 0 && console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
    }
    return {
      top: Bt.top + getOffsetTop(Bt, ue.vertical),
      left: Bt.left + getOffsetLeft(Bt, ue.horizontal)
    };
  }, [le, ue.horizontal, ue.vertical, de, fe]), Ue = React.useCallback((Tt) => ({
    vertical: getOffsetTop(Tt, he.vertical),
    horizontal: getOffsetLeft(Tt, he.horizontal)
  }), [he.horizontal, he.vertical]), Qe = React.useCallback((Tt) => {
    const pt = {
      width: Tt.offsetWidth,
      height: Tt.offsetHeight
    }, Bt = Ue(pt);
    if (fe === "none")
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(Bt)
      };
    const Vt = Ze();
    let qt = Vt.top - Bt.vertical, nn = Vt.left - Bt.horizontal;
    const mn = qt + pt.height, en = nn + pt.width, pn = ownerWindow(resolveAnchorEl(le)), Yt = pn.innerHeight - ge, Ut = pn.innerWidth - ge;
    if (ge !== null && qt < ge) {
      const jt = qt - ge;
      qt -= jt, Bt.vertical += jt;
    } else if (ge !== null && mn > Yt) {
      const jt = mn - Yt;
      qt -= jt, Bt.vertical += jt;
    }
    if (process.env.NODE_ENV !== "production" && pt.height > Yt && pt.height && Yt && console.error(["MUI: The popover component is too tall.", `Some part of it can not be seen on the screen (${pt.height - Yt}px).`, "Please consider adding a `max-height` to improve the user-experience."].join(`
`)), ge !== null && nn < ge) {
      const jt = nn - ge;
      nn -= jt, Bt.horizontal += jt;
    } else if (en > Ut) {
      const jt = en - Ut;
      nn -= jt, Bt.horizontal += jt;
    }
    return {
      top: `${Math.round(qt)}px`,
      left: `${Math.round(nn)}px`,
      transformOrigin: getTransformOriginValue(Bt)
    };
  }, [le, fe, Ze, Ue, ge]), [Je, Ot] = React.useState(xe), At = React.useCallback(() => {
    const Tt = We.current;
    if (!Tt)
      return;
    const pt = Qe(Tt);
    pt.top !== null && (Tt.style.top = pt.top), pt.left !== null && (Tt.style.left = pt.left), Tt.style.transformOrigin = pt.transformOrigin, Ot(!0);
  }, [Qe]);
  React.useEffect(() => (Ce && window.addEventListener("scroll", At), () => window.removeEventListener("scroll", At)), [le, Ce, At]);
  const ze = (Tt, pt) => {
    De && De(Tt, pt), At();
  }, we = () => {
    Ot(!1);
  };
  React.useEffect(() => {
    xe && At();
  }), React.useImperativeHandle(oe, () => xe ? {
    updatePosition: () => {
      At();
    }
  } : null, [xe, At]), React.useEffect(() => {
    if (!xe)
      return;
    const Tt = debounce$1(() => {
      At();
    }), pt = ownerWindow(le);
    return pt.addEventListener("resize", Tt), () => {
      Tt.clear(), pt.removeEventListener("resize", Tt);
    };
  }, [le, xe, At]);
  let Ae = Ie;
  Ie === "auto" && !Pe.muiSupportAuto && (Ae = void 0);
  const Re = me || (le ? ownerDocument(resolveAnchorEl(le)).body : void 0), je = (re = Te == null ? void 0 : Te.root) != null ? re : PopoverRoot, Fe = (se = Te == null ? void 0 : Te.paper) != null ? se : PopoverPaper, $e = useSlotProps({
    elementType: Fe,
    externalSlotProps: _extends$4({}, Be, {
      style: Je ? Be.style : _extends$4({}, Be.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation: ve,
      ref: Le
    },
    ownerState: He,
    className: clsx(Ge.paper, Be == null ? void 0 : Be.className)
  }), qe = useSlotProps({
    elementType: je,
    externalSlotProps: (Se == null ? void 0 : Se.root) || {},
    externalForwardedProps: Me,
    additionalProps: {
      ref: te,
      slotProps: {
        backdrop: {
          invisible: !0
        }
      },
      container: Re,
      open: xe
    },
    ownerState: He,
    className: clsx(Ge.root, ye)
  }), {
    slotProps: Ye
  } = qe, Ke = _objectWithoutPropertiesLoose$1(qe, _excluded3);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(je, _extends$4({}, Ke, !isHostComponent(je) && {
    slotProps: Ye,
    disableScrollLock: Ce
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pe, _extends$4({
      appear: !0,
      in: xe,
      onEntering: ze,
      onExited: we,
      timeout: Ae
    }, Ne, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fe, _extends$4({}, $e, {
        children: pe
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Popover.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports updatePosition() action.
   */
  action: refType$1,
  /**
   * An HTML element, [PopoverVirtualElement](/material-ui/react-popover/#virtual-element),
   * or a function that returns either.
   * It's used to set the position of the popover.
   */
  anchorEl: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.func]), ($) => {
    if ($.open && (!$.anchorReference || $.anchorReference === "anchorEl")) {
      const ee = resolveAnchorEl($.anchorEl);
      if (ee && ee.nodeType === 1) {
        const te = ee.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0)
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else
        return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", `It should be an Element or PopoverVirtualElement instance but it's \`${ee}\` instead.`].join(`
`));
    }
    return null;
  }),
  /**
   * This is the point on the anchor where the popover's
   * `anchorEl` will attach to. This is not used when the
   * anchorReference is 'anchorPosition'.
   *
   * Options:
   * vertical: [top, center, bottom];
   * horizontal: [left, center, right].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  anchorOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOfType([PropTypes.oneOf(["center", "left", "right"]), PropTypes.number]).isRequired,
    vertical: PropTypes.oneOfType([PropTypes.oneOf(["bottom", "center", "top"]), PropTypes.number]).isRequired
  }),
  /**
   * This is the position that may be used to set the position of the popover.
   * The coordinates are relative to the application's client area.
   */
  anchorPosition: PropTypes.shape({
    left: PropTypes.number.isRequired,
    top: PropTypes.number.isRequired
  }),
  /**
   * This determines which anchor prop to refer to when setting
   * the position of the popover.
   * @default 'anchorEl'
   */
  anchorReference: PropTypes.oneOf(["anchorEl", "anchorPosition", "none"]),
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * An HTML element, component instance, or function that returns either.
   * The `container` will passed to the Modal component.
   *
   * By default, it uses the body of the anchorEl's top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: PropTypes.oneOfType([HTMLElementType, PropTypes.func]),
  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: PropTypes.bool,
  /**
   * The elevation of the popover.
   * @default 8
   */
  elevation: integerPropType,
  /**
   * Specifies how close to the edge of the window the popover can appear.
   * If null, the popover will not be constrained by the window.
   * @default 16
   */
  marginThreshold: PropTypes.number,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   */
  onClose: PropTypes.func,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool.isRequired,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   *
   * This prop is an alias for `slotProps.paper` and will be overriden by it if both are used.
   * @deprecated Use `slotProps.paper` instead.
   *
   * @default {}
   */
  PaperProps: PropTypes.shape({
    component: elementTypeAcceptingRef$1
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: PropTypes.shape({
    paper: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: PropTypes.shape({
    paper: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * This is the point on the popover which
   * will attach to the anchor's origin.
   *
   * Options:
   * vertical: [top, center, bottom, x(px)];
   * horizontal: [left, center, right, x(px)].
   * @default {
   *   vertical: 'top',
   *   horizontal: 'left',
   * }
   */
  transformOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOfType([PropTypes.oneOf(["center", "left", "right"]), PropTypes.number]).isRequired,
    vertical: PropTypes.oneOfType([PropTypes.oneOf(["bottom", "center", "top"]), PropTypes.number]).isRequired
  }),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: PropTypes.elementType,
  /**
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(["auto"]), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: PropTypes.object
});
const Popover$1 = Popover;
function getMenuUtilityClass($) {
  return generateUtilityClass("MuiMenu", $);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$e = ["onEntering"], _excluded2$2 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"], RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
}, LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
}, useUtilityClasses$c = ($) => {
  const {
    classes: ee
  } = $;
  return composeClasses({
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  }, getMenuUtilityClass, ee);
}, MenuRoot = styled(Popover$1, {
  shouldForwardProp: ($) => rootShouldForwardProp($) || $ === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})({}), MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: ($, ee) => ee.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
}), MenuMenuList = styled(MenuList$1, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: ($, ee) => ee.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}), Menu = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re;
  const se = useThemeProps$1({
    props: ee,
    name: "MuiMenu"
  }), {
    autoFocus: ie = !0,
    children: oe,
    className: le,
    disableAutoFocusItem: ue = !1,
    MenuListProps: de = {},
    onClose: fe,
    open: pe,
    PaperProps: ye = {},
    PopoverClasses: me,
    transitionDuration: ve = "auto",
    TransitionProps: {
      onEntering: ge
    } = {},
    variant: xe = "selectedMenu",
    slots: Ee = {},
    slotProps: Te = {}
  } = se, Se = _objectWithoutPropertiesLoose$1(se.TransitionProps, _excluded$e), he = _objectWithoutPropertiesLoose$1(se, _excluded2$2), Pe = useRtl(), Ie = _extends$4({}, se, {
    autoFocus: ie,
    disableAutoFocusItem: ue,
    MenuListProps: de,
    onEntering: ge,
    PaperProps: ye,
    transitionDuration: ve,
    TransitionProps: Se,
    variant: xe
  }), De = useUtilityClasses$c(Ie), Ce = ie && !ue && pe, Ne = React.useRef(null), Me = (Ue, Qe) => {
    Ne.current && Ne.current.adjustStyleForScrollbar(Ue, {
      direction: Pe ? "rtl" : "ltr"
    }), ge && ge(Ue, Qe);
  }, Be = (Ue) => {
    Ue.key === "Tab" && (Ue.preventDefault(), fe && fe(Ue, "tabKeyDown"));
  };
  let We = -1;
  React.Children.map(oe, (Ue, Qe) => {
    /* @__PURE__ */ React.isValidElement(Ue) && (process.env.NODE_ENV !== "production" && reactIsExports$1.isFragment(Ue) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), Ue.props.disabled || (xe === "selectedMenu" && Ue.props.selected || We === -1) && (We = Qe));
  });
  const Le = (ne = Ee.paper) != null ? ne : MenuPaper, He = (re = Te.paper) != null ? re : ye, Ge = useSlotProps({
    elementType: Ee.root,
    externalSlotProps: Te.root,
    ownerState: Ie,
    className: [De.root, le]
  }), Ze = useSlotProps({
    elementType: Le,
    externalSlotProps: He,
    ownerState: Ie,
    className: De.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$4({
    onClose: fe,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: Pe ? "right" : "left"
    },
    transformOrigin: Pe ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: Le,
      root: Ee.root
    },
    slotProps: {
      root: Ge,
      paper: Ze
    },
    open: pe,
    ref: te,
    transitionDuration: ve,
    TransitionProps: _extends$4({
      onEntering: Me
    }, Se),
    ownerState: Ie
  }, he, {
    classes: me,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$4({
      onKeyDown: Be,
      actions: Ne,
      autoFocus: ie && (We === -1 || ue),
      autoFocusItem: Ce,
      variant: xe
    }, de, {
      className: clsx(De.list, de.className),
      children: oe
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Menu.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the position of the menu.
   */
  anchorEl: PropTypes.oneOfType([HTMLElementType, PropTypes.func]),
  /**
   * If `true` (Default) will focus the `[role="menu"]` if no focusable child is found. Disabled
   * children are not focusable. If you set this prop to `false` focus will be placed
   * on the parent modal container. This has severe accessibility implications
   * and should only be considered if you manage focus otherwise.
   * @default true
   */
  autoFocus: PropTypes.bool,
  /**
   * Menu contents, normally `MenuItem`s.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * When opening the menu will not focus the active item but the `[role="menu"]`
   * unless `autoFocus` is also set to `false`. Not using the default means not
   * following WAI-ARIA authoring practices. Please be considerate about possible
   * accessibility implications.
   * @default false
   */
  disableAutoFocusItem: PropTypes.bool,
  /**
   * Props applied to the [`MenuList`](/material-ui/api/menu-list/) element.
   * @default {}
   */
  MenuListProps: PropTypes.object,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`, `"tabKeyDown"`.
   */
  onClose: PropTypes.func,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: PropTypes.object,
  /**
   * `classes` prop applied to the [`Popover`](/material-ui/api/popover/) element.
   */
  PopoverClasses: PropTypes.object,
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * @default {}
   */
  slotProps: PropTypes.shape({
    paper: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * The components used for each slot inside.
   *
   * @default {}
   */
  slots: PropTypes.shape({
    paper: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The length of the transition in `ms`, or 'auto'
   * @default 'auto'
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.oneOf(["auto"]), PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: PropTypes.object,
  /**
   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus.
   * @default 'selectedMenu'
   */
  variant: PropTypes.oneOf(["menu", "selectedMenu"])
});
const Menu$1 = Menu;
function Ripple($) {
  const {
    className: ee,
    classes: te,
    pulsate: ne = !1,
    rippleX: re,
    rippleY: se,
    rippleSize: ie,
    in: oe,
    onExited: le,
    timeout: ue
  } = $, [de, fe] = React.useState(!1), pe = clsx(ee, te.ripple, te.rippleVisible, ne && te.ripplePulsate), ye = {
    width: ie,
    height: ie,
    top: -(ie / 2) + se,
    left: -(ie / 2) + re
  }, me = clsx(te.child, de && te.childLeaving, ne && te.childPulsate);
  return !oe && !de && fe(!0), React.useEffect(() => {
    if (!oe && le != null) {
      const ve = setTimeout(le, ue);
      return () => {
        clearTimeout(ve);
      };
    }
  }, [le, oe, ue]), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: pe,
    style: ye,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: me
    })
  });
}
process.env.NODE_ENV !== "production" && (Ripple.propTypes = {
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object.isRequired,
  className: PropTypes.string,
  /**
   * @ignore - injected from TransitionGroup
   */
  in: PropTypes.bool,
  /**
   * @ignore - injected from TransitionGroup
   */
  onExited: PropTypes.func,
  /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */
  pulsate: PropTypes.bool,
  /**
   * Diameter of the ripple.
   */
  rippleSize: PropTypes.number,
  /**
   * Horizontal position of the ripple center.
   */
  rippleX: PropTypes.number,
  /**
   * Vertical position of the ripple center.
   */
  rippleY: PropTypes.number,
  /**
   * exit delay
   */
  timeout: PropTypes.number.isRequired
});
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), _excluded$d = ["center", "classes", "className"];
let _$1 = ($) => $, _t$1, _t2$1, _t3$1, _t4$1;
const DURATION = 550, DELAY_RIPPLE = 80, enterKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), exitKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), pulsateKeyframe = keyframes(_t3$1 || (_t3$1 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4$1 || (_t4$1 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
  theme: $
}) => $.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
  theme: $
}) => $.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
  theme: $
}) => $.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
  theme: $
}) => $.transitions.easing.easeInOut), TouchRipple = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiTouchRipple"
  }), {
    center: re = !1,
    classes: se = {},
    className: ie
  } = ne, oe = _objectWithoutPropertiesLoose$1(ne, _excluded$d), [le, ue] = React.useState([]), de = React.useRef(0), fe = React.useRef(null);
  React.useEffect(() => {
    fe.current && (fe.current(), fe.current = null);
  }, [le]);
  const pe = React.useRef(!1), ye = useTimeout(), me = React.useRef(null), ve = React.useRef(null), ge = React.useCallback((Se) => {
    const {
      pulsate: he,
      rippleX: Pe,
      rippleY: Ie,
      rippleSize: De,
      cb: Ce
    } = Se;
    ue((Ne) => [...Ne, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(se.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(se.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(se.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(se.child, touchRippleClasses.child),
        childLeaving: clsx(se.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(se.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: he,
      rippleX: Pe,
      rippleY: Ie,
      rippleSize: De
    }, de.current)]), de.current += 1, fe.current = Ce;
  }, [se]), xe = React.useCallback((Se = {}, he = {}, Pe = () => {
  }) => {
    const {
      pulsate: Ie = !1,
      center: De = re || he.pulsate,
      fakeElement: Ce = !1
      // For test purposes
    } = he;
    if ((Se == null ? void 0 : Se.type) === "mousedown" && pe.current) {
      pe.current = !1;
      return;
    }
    (Se == null ? void 0 : Se.type) === "touchstart" && (pe.current = !0);
    const Ne = Ce ? null : ve.current, Me = Ne ? Ne.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let Be, We, Le;
    if (De || Se === void 0 || Se.clientX === 0 && Se.clientY === 0 || !Se.clientX && !Se.touches)
      Be = Math.round(Me.width / 2), We = Math.round(Me.height / 2);
    else {
      const {
        clientX: He,
        clientY: Ge
      } = Se.touches && Se.touches.length > 0 ? Se.touches[0] : Se;
      Be = Math.round(He - Me.left), We = Math.round(Ge - Me.top);
    }
    if (De)
      Le = Math.sqrt((2 * Me.width ** 2 + Me.height ** 2) / 3), Le % 2 === 0 && (Le += 1);
    else {
      const He = Math.max(Math.abs((Ne ? Ne.clientWidth : 0) - Be), Be) * 2 + 2, Ge = Math.max(Math.abs((Ne ? Ne.clientHeight : 0) - We), We) * 2 + 2;
      Le = Math.sqrt(He ** 2 + Ge ** 2);
    }
    Se != null && Se.touches ? me.current === null && (me.current = () => {
      ge({
        pulsate: Ie,
        rippleX: Be,
        rippleY: We,
        rippleSize: Le,
        cb: Pe
      });
    }, ye.start(DELAY_RIPPLE, () => {
      me.current && (me.current(), me.current = null);
    })) : ge({
      pulsate: Ie,
      rippleX: Be,
      rippleY: We,
      rippleSize: Le,
      cb: Pe
    });
  }, [re, ge, ye]), Ee = React.useCallback(() => {
    xe({}, {
      pulsate: !0
    });
  }, [xe]), Te = React.useCallback((Se, he) => {
    if (ye.clear(), (Se == null ? void 0 : Se.type) === "touchend" && me.current) {
      me.current(), me.current = null, ye.start(0, () => {
        Te(Se, he);
      });
      return;
    }
    me.current = null, ue((Pe) => Pe.length > 0 ? Pe.slice(1) : Pe), fe.current = he;
  }, [ye]);
  return React.useImperativeHandle(te, () => ({
    pulsate: Ee,
    start: xe,
    stop: Te
  }), [Ee, xe, Te]), /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$4({
    className: clsx(touchRippleClasses.root, se.root, ie),
    ref: ve
  }, oe, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: !0,
      children: le
    })
  }));
});
process.env.NODE_ENV !== "production" && (TouchRipple.propTypes = {
  /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */
  center: PropTypes.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass($) {
  return generateUtilityClass("MuiButtonBase", $);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]), _excluded$c = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], useUtilityClasses$b = ($) => {
  const {
    disabled: ee,
    focusVisible: te,
    focusVisibleClassName: ne,
    classes: re
  } = $, ie = composeClasses({
    root: ["root", ee && "disabled", te && "focusVisible"]
  }, getButtonBaseUtilityClass, re);
  return te && ne && (ie.root += ` ${ne}`), ie;
}, ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), ButtonBase = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiButtonBase"
  }), {
    action: re,
    centerRipple: se = !1,
    children: ie,
    className: oe,
    component: le = "button",
    disabled: ue = !1,
    disableRipple: de = !1,
    disableTouchRipple: fe = !1,
    focusRipple: pe = !1,
    LinkComponent: ye = "a",
    onBlur: me,
    onClick: ve,
    onContextMenu: ge,
    onDragLeave: xe,
    onFocus: Ee,
    onFocusVisible: Te,
    onKeyDown: Se,
    onKeyUp: he,
    onMouseDown: Pe,
    onMouseLeave: Ie,
    onMouseUp: De,
    onTouchEnd: Ce,
    onTouchMove: Ne,
    onTouchStart: Me,
    tabIndex: Be = 0,
    TouchRippleProps: We,
    touchRippleRef: Le,
    type: He
  } = ne, Ge = _objectWithoutPropertiesLoose$1(ne, _excluded$c), Ze = React.useRef(null), Ue = React.useRef(null), Qe = useForkRef(Ue, Le), {
    isFocusVisibleRef: Je,
    onFocus: Ot,
    onBlur: At,
    ref: ze
  } = useIsFocusVisible(), [we, Ae] = React.useState(!1);
  ue && we && Ae(!1), React.useImperativeHandle(re, () => ({
    focusVisible: () => {
      Ae(!0), Ze.current.focus();
    }
  }), []);
  const [Re, je] = React.useState(!1);
  React.useEffect(() => {
    je(!0);
  }, []);
  const Fe = Re && !de && !ue;
  React.useEffect(() => {
    we && pe && !de && Re && Ue.current.pulsate();
  }, [de, pe, we, Re]);
  function $e(un, En, wn = fe) {
    return useEventCallback((Tn) => (En && En(Tn), !wn && Ue.current && Ue.current[un](Tn), !0));
  }
  const qe = $e("start", Pe), Ye = $e("stop", ge), Ke = $e("stop", xe), Tt = $e("stop", De), pt = $e("stop", (un) => {
    we && un.preventDefault(), Ie && Ie(un);
  }), Bt = $e("start", Me), Vt = $e("stop", Ce), qt = $e("stop", Ne), nn = $e("stop", (un) => {
    At(un), Je.current === !1 && Ae(!1), me && me(un);
  }, !1), mn = useEventCallback((un) => {
    Ze.current || (Ze.current = un.currentTarget), Ot(un), Je.current === !0 && (Ae(!0), Te && Te(un)), Ee && Ee(un);
  }), en = () => {
    const un = Ze.current;
    return le && le !== "button" && !(un.tagName === "A" && un.href);
  }, pn = React.useRef(!1), Yt = useEventCallback((un) => {
    pe && !pn.current && we && Ue.current && un.key === " " && (pn.current = !0, Ue.current.stop(un, () => {
      Ue.current.start(un);
    })), un.target === un.currentTarget && en() && un.key === " " && un.preventDefault(), Se && Se(un), un.target === un.currentTarget && en() && un.key === "Enter" && !ue && (un.preventDefault(), ve && ve(un));
  }), Ut = useEventCallback((un) => {
    pe && un.key === " " && Ue.current && we && !un.defaultPrevented && (pn.current = !1, Ue.current.stop(un, () => {
      Ue.current.pulsate(un);
    })), he && he(un), ve && un.target === un.currentTarget && en() && un.key === " " && !un.defaultPrevented && ve(un);
  });
  let jt = le;
  jt === "button" && (Ge.href || Ge.to) && (jt = ye);
  const Gt = {};
  jt === "button" ? (Gt.type = He === void 0 ? "button" : He, Gt.disabled = ue) : (!Ge.href && !Ge.to && (Gt.role = "button"), ue && (Gt["aria-disabled"] = ue));
  const ln = useForkRef(te, ze, Ze);
  process.env.NODE_ENV !== "production" && React.useEffect(() => {
    Fe && !Ue.current && console.error(["MUI: The `component` prop provided to ButtonBase is invalid.", "Please make sure the children prop is rendered in this custom component."].join(`
`));
  }, [Fe]);
  const sn = _extends$4({}, ne, {
    centerRipple: se,
    component: le,
    disabled: ue,
    disableRipple: de,
    disableTouchRipple: fe,
    focusRipple: pe,
    tabIndex: Be,
    focusVisible: we
  }), _n = useUtilityClasses$b(sn);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$4({
    as: jt,
    className: clsx(_n.root, oe),
    ownerState: sn,
    onBlur: nn,
    onClick: ve,
    onContextMenu: Ye,
    onFocus: mn,
    onKeyDown: Yt,
    onKeyUp: Ut,
    onMouseDown: qe,
    onMouseLeave: pt,
    onMouseUp: Tt,
    onDragLeave: Ke,
    onTouchEnd: Vt,
    onTouchMove: qt,
    onTouchStart: Bt,
    ref: ln,
    tabIndex: ue ? -1 : Be,
    type: He
  }, Gt, Ge, {
    children: [ie, Fe ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$4({
        ref: Qe,
        center: se
      }, We))
    ) : null]
  }));
});
process.env.NODE_ENV !== "production" && (ButtonBase.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: refType$1,
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: PropTypes.bool,
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: elementTypeAcceptingRef$1,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   *  Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: PropTypes.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: PropTypes.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: PropTypes.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: PropTypes.string,
  /**
   * @ignore
   */
  href: PropTypes.any,
  /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */
  LinkComponent: PropTypes.elementType,
  /**
   * @ignore
   */
  onBlur: PropTypes.func,
  /**
   * @ignore
   */
  onClick: PropTypes.func,
  /**
   * @ignore
   */
  onContextMenu: PropTypes.func,
  /**
   * @ignore
   */
  onDragLeave: PropTypes.func,
  /**
   * @ignore
   */
  onFocus: PropTypes.func,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: PropTypes.func,
  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,
  /**
   * @ignore
   */
  onKeyUp: PropTypes.func,
  /**
   * @ignore
   */
  onMouseDown: PropTypes.func,
  /**
   * @ignore
   */
  onMouseLeave: PropTypes.func,
  /**
   * @ignore
   */
  onMouseUp: PropTypes.func,
  /**
   * @ignore
   */
  onTouchEnd: PropTypes.func,
  /**
   * @ignore
   */
  onTouchMove: PropTypes.func,
  /**
   * @ignore
   */
  onTouchStart: PropTypes.func,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * @default 0
   */
  tabIndex: PropTypes.number,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: PropTypes.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: PropTypes.oneOfType([PropTypes.func, PropTypes.shape({
    current: PropTypes.shape({
      pulsate: PropTypes.func.isRequired,
      start: PropTypes.func.isRequired,
      stop: PropTypes.func.isRequired
    })
  })]),
  /**
   * @ignore
   */
  type: PropTypes.oneOfType([PropTypes.oneOf(["button", "reset", "submit"]), PropTypes.string])
});
const ButtonBase$1 = ButtonBase;
function getDividerUtilityClass($) {
  return generateUtilityClass("MuiDivider", $);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), dividerClasses$1 = dividerClasses, _excluded$b = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"], useUtilityClasses$a = ($) => {
  const {
    absolute: ee,
    children: te,
    classes: ne,
    flexItem: re,
    light: se,
    orientation: ie,
    textAlign: oe,
    variant: le
  } = $;
  return composeClasses({
    root: ["root", ee && "absolute", le, se && "light", ie === "vertical" && "vertical", re && "flexItem", te && "withChildren", te && ie === "vertical" && "withChildrenVertical", oe === "right" && ie !== "vertical" && "textAlignRight", oe === "left" && ie !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", ie === "vertical" && "wrapperVertical"]
  }, getDividerUtilityClass, ne);
}, DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, te.absolute && ee.absolute, ee[te.variant], te.light && ee.light, te.orientation === "vertical" && ee.vertical, te.flexItem && ee.flexItem, te.children && ee.withChildren, te.children && te.orientation === "vertical" && ee.withChildrenVertical, te.textAlign === "right" && te.orientation !== "vertical" && ee.textAlignRight, te.textAlign === "left" && te.orientation !== "vertical" && ee.textAlignLeft];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: ($.vars || $).palette.divider,
  borderBottomWidth: "thin"
}, ee.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, ee.light && {
  borderColor: $.vars ? `rgba(${$.vars.palette.dividerChannel} / 0.08)` : alpha_1($.palette.divider, 0.08)
}, ee.variant === "inset" && {
  marginLeft: 72
}, ee.variant === "middle" && ee.orientation === "horizontal" && {
  marginLeft: $.spacing(2),
  marginRight: $.spacing(2)
}, ee.variant === "middle" && ee.orientation === "vertical" && {
  marginTop: $.spacing(1),
  marginBottom: $.spacing(1)
}, ee.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, ee.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  ownerState: $
}) => _extends$4({}, $.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  "&::before, &::after": {
    content: '""',
    alignSelf: "center"
  }
}), ({
  theme: $,
  ownerState: ee
}) => _extends$4({}, ee.children && ee.orientation !== "vertical" && {
  "&::before, &::after": {
    width: "100%",
    borderTop: `thin solid ${($.vars || $).palette.divider}`
  }
}), ({
  theme: $,
  ownerState: ee
}) => _extends$4({}, ee.children && ee.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    borderLeft: `thin solid ${($.vars || $).palette.divider}`
  }
}), ({
  ownerState: $
}) => _extends$4({}, $.textAlign === "right" && $.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, $.textAlign === "left" && $.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
})), DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.wrapper, te.orientation === "vertical" && ee.wrapperVertical];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  display: "inline-block",
  paddingLeft: `calc(${$.spacing(1)} * 1.2)`,
  paddingRight: `calc(${$.spacing(1)} * 1.2)`
}, ee.orientation === "vertical" && {
  paddingTop: `calc(${$.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${$.spacing(1)} * 1.2)`
})), Divider = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiDivider"
  }), {
    absolute: re = !1,
    children: se,
    className: ie,
    component: oe = se ? "div" : "hr",
    flexItem: le = !1,
    light: ue = !1,
    orientation: de = "horizontal",
    role: fe = oe !== "hr" ? "separator" : void 0,
    textAlign: pe = "center",
    variant: ye = "fullWidth"
  } = ne, me = _objectWithoutPropertiesLoose$1(ne, _excluded$b), ve = _extends$4({}, ne, {
    absolute: re,
    component: oe,
    flexItem: le,
    light: ue,
    orientation: de,
    role: fe,
    textAlign: pe,
    variant: ye
  }), ge = useUtilityClasses$a(ve);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, _extends$4({
    as: oe,
    className: clsx(ge.root, ie),
    role: fe,
    ref: te,
    ownerState: ve
  }, me, {
    children: se ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: ge.wrapper,
      ownerState: ve,
      children: se
    }) : null
  }));
});
Divider.muiSkipListHighlight = !0;
process.env.NODE_ENV !== "production" && (Divider.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Absolutely position the element.
   * @default false
   */
  absolute: PropTypes.bool,
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * If `true`, a vertical divider will have the correct height when used in flex container.
   * (By default, a vertical divider will have a calculated height of `0px` if it is the child of a flex container.)
   * @default false
   */
  flexItem: PropTypes.bool,
  /**
   * If `true`, the divider will have a lighter color.
   * @default false
   * @deprecated Use <Divider sx={{ opacity: 0.6 }} /> (or any opacity or color) instead. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/)
   */
  light: PropTypes.bool,
  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: PropTypes.oneOf(["horizontal", "vertical"]),
  /**
   * @ignore
   */
  role: PropTypes.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The text alignment.
   * @default 'center'
   */
  textAlign: PropTypes.oneOf(["center", "left", "right"]),
  /**
   * The variant to use.
   * @default 'fullWidth'
   */
  variant: PropTypes.oneOfType([PropTypes.oneOf(["fullWidth", "inset", "middle"]), PropTypes.string])
});
const Divider$1 = Divider, listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]), listItemIconClasses$1 = listItemIconClasses, listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), listItemTextClasses$1 = listItemTextClasses;
function getMenuItemUtilityClass($) {
  return generateUtilityClass("MuiMenuItem", $);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), menuItemClasses$1 = menuItemClasses, _excluded$a = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"], overridesResolver$1 = ($, ee) => {
  const {
    ownerState: te
  } = $;
  return [ee.root, te.dense && ee.dense, te.divider && ee.divider, !te.disableGutters && ee.gutters];
}, useUtilityClasses$9 = ($) => {
  const {
    disabled: ee,
    dense: te,
    divider: ne,
    disableGutters: re,
    selected: se,
    classes: ie
  } = $, le = composeClasses({
    root: ["root", te && "dense", ee && "disabled", !re && "gutters", ne && "divider", se && "selected"]
  }, getMenuItemUtilityClass, ie);
  return _extends$4({}, ie, le);
}, MenuItemRoot = styled(ButtonBase$1, {
  shouldForwardProp: ($) => rootShouldForwardProp($) || $ === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({}, $.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ee.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ee.divider && {
  borderBottom: `1px solid ${($.vars || $).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: ($.vars || $).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: $.vars ? `rgba(${$.vars.palette.primary.mainChannel} / ${$.vars.palette.action.selectedOpacity})` : alpha_1($.palette.primary.main, $.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: $.vars ? `rgba(${$.vars.palette.primary.mainChannel} / calc(${$.vars.palette.action.selectedOpacity} + ${$.vars.palette.action.focusOpacity}))` : alpha_1($.palette.primary.main, $.palette.action.selectedOpacity + $.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: $.vars ? `rgba(${$.vars.palette.primary.mainChannel} / calc(${$.vars.palette.action.selectedOpacity} + ${$.vars.palette.action.hoverOpacity}))` : alpha_1($.palette.primary.main, $.palette.action.selectedOpacity + $.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: $.vars ? `rgba(${$.vars.palette.primary.mainChannel} / ${$.vars.palette.action.selectedOpacity})` : alpha_1($.palette.primary.main, $.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: ($.vars || $).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: ($.vars || $).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses$1.root}`]: {
    marginTop: $.spacing(1),
    marginBottom: $.spacing(1)
  },
  [`& + .${dividerClasses$1.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses$1.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses$1.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses$1.root}`]: {
    minWidth: 36
  }
}, !ee.dense && {
  [$.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ee.dense && _extends$4({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, $.typography.body2, {
  [`& .${listItemIconClasses$1.root} svg`]: {
    fontSize: "1.25rem"
  }
}))), MenuItem = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiMenuItem"
  }), {
    autoFocus: re = !1,
    component: se = "li",
    dense: ie = !1,
    divider: oe = !1,
    disableGutters: le = !1,
    focusVisibleClassName: ue,
    role: de = "menuitem",
    tabIndex: fe,
    className: pe
  } = ne, ye = _objectWithoutPropertiesLoose$1(ne, _excluded$a), me = React.useContext(ListContext$1), ve = React.useMemo(() => ({
    dense: ie || me.dense || !1,
    disableGutters: le
  }), [me.dense, ie, le]), ge = React.useRef(null);
  useEnhancedEffect(() => {
    re && (ge.current ? ge.current.focus() : process.env.NODE_ENV !== "production" && console.error("MUI: Unable to set focus to a MenuItem whose component has not been rendered."));
  }, [re]);
  const xe = _extends$4({}, ne, {
    dense: ve.dense,
    divider: oe,
    disableGutters: le
  }), Ee = useUtilityClasses$9(ne), Te = useForkRef(ge, te);
  let Se;
  return ne.disabled || (Se = fe !== void 0 ? fe : -1), /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: ve,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$4({
      ref: Te,
      role: de,
      tabIndex: Se,
      component: se,
      focusVisibleClassName: clsx(Ee.focusVisible, ue),
      className: clsx(Ee.root, pe)
    }, ye, {
      ownerState: xe,
      classes: Ee
    }))
  });
});
process.env.NODE_ENV !== "production" && (MenuItem.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the list item is focused during the first mount.
   * Focus will also be triggered if the value changes from false to true.
   * @default false
   */
  autoFocus: PropTypes.bool,
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * If `true`, compact vertical padding designed for keyboard and mouse input is used.
   * The prop defaults to the value inherited from the parent Menu component.
   * @default false
   */
  dense: PropTypes.bool,
  /**
   * @ignore
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: PropTypes.bool,
  /**
   * If `true`, a 1px light border is added to the bottom of the menu item.
   * @default false
   */
  divider: PropTypes.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: PropTypes.string,
  /**
   * @ignore
   */
  role: PropTypes.string,
  /**
   * If `true`, the component is selected.
   * @default false
   */
  selected: PropTypes.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * @default 0
   */
  tabIndex: PropTypes.number
});
const MenuItem$1 = MenuItem;
function useTopicDropdown($, ee, te, ne, re) {
  const { lmFeedclient: se } = useContext(GlobalClientProviderContext), { TopicsCustomCallbacks: ie = {}, topicComponentClickCustomCallback: oe } = useContext(CustomAgentProviderContext), {
    setSearchKeyCustomAction: le,
    updateCheckedTopicsCustomAction: ue,
    clearAllCheckedTopicsCustomAction: de
  } = ie, { displaySnackbarMessage: fe, closeSnackbar: pe, showSnackbar: ye, message: me } = useContext(GeneralContext), { logoutUser: ve, currentUser: ge, currentCommunity: xe } = useContext(
    UserProviderContext
  ), Ee = useNavigate(), [Te, Se] = useState([]), [he, Pe] = useState(!0), [Ie, De] = useState([]), [Ce, Ne] = useState(1), [Me, Be] = useState(""), We = useCallback(async () => {
    try {
      const Ue = await (se == null ? void 0 : se.getTopics(
        It.builder().setPage(Ce).setSearchType("name").setSearch(Me).setPageSize(10).setIsEnabled(LMTopicsDropdownMode.edit === re ? !0 : null).build()
      ));
      Ue.success && (Ne((Qe) => Qe + 1), De([...Ie, ...Ue.data.topics]), Ue.data.topics.length || Pe(!1));
    } catch (Ue) {
      console.log(Ue);
    }
  }, [Ce, se, re, Me, Ie]), Le = useCallback(async () => {
    try {
      const Ue = await (se == null ? void 0 : se.getTopics(
        It.builder().setPage(1).setSearchType("name").setSearch(Me).setPageSize(10).setIsEnabled(LMTopicsDropdownMode.edit === re ? !0 : null).build()
      ));
      Ue.success && (Ne(2), De([...Ue.data.topics]), Ue.data.topics.length || Pe(!1));
    } catch (Ue) {
      console.log(Ue);
    }
  }, [se, re, Me]), He = useCallback(
    (Ue) => {
      if (Te.some((Je) => Je.Id === Ue.Id)) {
        const Je = Te.findIndex((At) => At.Id === Ue.Id), Ot = [...Te];
        Ot.splice(Je, 1), Se(Ot);
      } else {
        const Je = [...Te];
        Je.push(Ue), Se(Je);
      }
    },
    [Te]
  ), Ge = () => {
    Se([]);
  };
  useEffect(() => {
    Le();
  }, [Le, Me]);
  const Ze = useMemo(() => ({
    topicsDataStore: {
      checkedTopics: Te,
      setCheckedTopics: Se,
      loadNewTopics: he,
      setLoadNewTopics: Pe,
      topics: Ie,
      setTopics: De,
      currentPageCount: Ce,
      setCurrentPageCount: Ne,
      searchKey: Me,
      setSearchKey: Be
    },
    applicationGeneralStore: {
      userDataStore: {
        lmFeedUser: ge,
        lmFeedUserCurrentCommunity: xe,
        logOutUser: ve
      },
      generalDataStore: {
        displaySnackbarMessage: fe,
        closeSnackbar: pe,
        showSnackbar: ye,
        message: me
      }
    },
    defaultActions: {
      setSearchKey: Be,
      updateCheckedTopics: He,
      clearAllCheckedTopics: Ge,
      getNextPage: We
    },
    navigate: Ee
  }), [
    Te,
    pe,
    xe,
    Ce,
    ge,
    fe,
    We,
    he,
    ve,
    me,
    Ee,
    Me,
    ye,
    Ie,
    He
  ]);
  return useEffect(() => {
    ee && (Te.map((Ue) => Ue.Id), ee((Ue) => {
      const Qe = Te.map((At) => At.Id);
      if (Te.length !== Ue.length)
        return Qe;
      const Je = [...Ue].sort(), Ot = [...Qe].sort();
      for (let At = 0; At < Je.length; At++)
        if (Je[At] !== Ot[At])
          return Qe;
      return Ue;
    }));
  }, [Te, ee]), useEffect(() => {
    te && Se(te);
  }, [te]), {
    checkedTopics: Te,
    topics: Ie,
    loadNewTopics: he,
    getNextPage: We,
    searchKey: Me,
    setSearchKey: le ? le.bind(null, Ze) : Be,
    updateCheckedTopics: ue ? ue.bind(null, Ze) : He,
    clearAllCheckedTopics: de ? de.bind(null, Ze) : Ge,
    topicComponentClickCustomCallback: oe ? oe.bind(null, Ze) : void 0
  };
}
function getSvgIconUtilityClass($) {
  return generateUtilityClass("MuiSvgIcon", $);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$9 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], useUtilityClasses$8 = ($) => {
  const {
    color: ee,
    fontSize: te,
    classes: ne
  } = $, re = {
    root: ["root", ee !== "inherit" && `color${capitalize$1(ee)}`, `fontSize${capitalize$1(te)}`]
  };
  return composeClasses(re, getSvgIconUtilityClass, ne);
}, SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, te.color !== "inherit" && ee[`color${capitalize$1(te.color)}`], ee[`fontSize${capitalize$1(te.fontSize)}`]];
  }
})(({
  theme: $,
  ownerState: ee
}) => {
  var te, ne, re, se, ie, oe, le, ue, de, fe, pe, ye, me;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // for example heroicons uses fill="none" and stroke="currentColor"
    fill: ee.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (te = $.transitions) == null || (ne = te.create) == null ? void 0 : ne.call(te, "fill", {
      duration: (re = $.transitions) == null || (re = re.duration) == null ? void 0 : re.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((se = $.typography) == null || (ie = se.pxToRem) == null ? void 0 : ie.call(se, 20)) || "1.25rem",
      medium: ((oe = $.typography) == null || (le = oe.pxToRem) == null ? void 0 : le.call(oe, 24)) || "1.5rem",
      large: ((ue = $.typography) == null || (de = ue.pxToRem) == null ? void 0 : de.call(ue, 35)) || "2.1875rem"
    }[ee.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (fe = (pe = ($.vars || $).palette) == null || (pe = pe[ee.color]) == null ? void 0 : pe.main) != null ? fe : {
      action: (ye = ($.vars || $).palette) == null || (ye = ye.action) == null ? void 0 : ye.active,
      disabled: (me = ($.vars || $).palette) == null || (me = me.action) == null ? void 0 : me.disabled,
      inherit: void 0
    }[ee.color]
  };
}), SvgIcon = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiSvgIcon"
  }), {
    children: re,
    className: se,
    color: ie = "inherit",
    component: oe = "svg",
    fontSize: le = "medium",
    htmlColor: ue,
    inheritViewBox: de = !1,
    titleAccess: fe,
    viewBox: pe = "0 0 24 24"
  } = ne, ye = _objectWithoutPropertiesLoose$1(ne, _excluded$9), me = /* @__PURE__ */ React.isValidElement(re) && re.type === "svg", ve = _extends$4({}, ne, {
    color: ie,
    component: oe,
    fontSize: le,
    instanceFontSize: ee.fontSize,
    inheritViewBox: de,
    viewBox: pe,
    hasSvgAsChild: me
  }), ge = {};
  de || (ge.viewBox = pe);
  const xe = useUtilityClasses$8(ve);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$4({
    as: oe,
    className: clsx(xe.root, se),
    focusable: "false",
    color: ue,
    "aria-hidden": fe ? void 0 : !0,
    role: fe ? "img" : void 0,
    ref: te
  }, ge, ye, me && re.props, {
    ownerState: ve,
    children: [me ? re.props.children : re, fe ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: fe
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (SvgIcon.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Node passed into the SVG element.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "large", "medium", "small"]), PropTypes.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: PropTypes.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: PropTypes.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: PropTypes.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: PropTypes.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: PropTypes.string
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon($, ee) {
  function te(ne, re) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$4({
      "data-testid": `${ee}Icon`,
      ref: re
    }, ne, {
      children: $
    }));
  }
  return process.env.NODE_ENV !== "production" && (te.displayName = `${ee}Icon`), te.muiName = SvgIcon.muiName, /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(te));
}
function createUseThemeProps($) {
  return useThemeProps$1;
}
function useBadge($) {
  const {
    badgeContent: ee,
    invisible: te = !1,
    max: ne = 99,
    showZero: re = !1
  } = $, se = usePreviousProps({
    badgeContent: ee,
    max: ne
  });
  let ie = te;
  te === !1 && ee === 0 && !re && (ie = !0);
  const {
    badgeContent: oe,
    max: le = ne
  } = ie ? se : $, ue = oe && Number(oe) > le ? `${le}+` : oe;
  return {
    badgeContent: oe,
    invisible: ie,
    max: le,
    displayValue: ue
  };
}
function mapEventPropToEvent($) {
  return $.substring(2).toLowerCase();
}
function clickedRootScrollbar($, ee) {
  return ee.documentElement.clientWidth < $.clientX || ee.documentElement.clientHeight < $.clientY;
}
function ClickAwayListener($) {
  const {
    children: ee,
    disableReactTree: te = !1,
    mouseEvent: ne = "onClick",
    onClickAway: re,
    touchEvent: se = "onTouchEnd"
  } = $, ie = React.useRef(!1), oe = React.useRef(null), le = React.useRef(!1), ue = React.useRef(!1);
  React.useEffect(() => (setTimeout(() => {
    le.current = !0;
  }, 0), () => {
    le.current = !1;
  }), []);
  const de = useForkRef(
    // @ts-expect-error TODO upstream fix
    ee.ref,
    oe
  ), fe = useEventCallback((me) => {
    const ve = ue.current;
    ue.current = !1;
    const ge = ownerDocument(oe.current);
    if (!le.current || !oe.current || "clientX" in me && clickedRootScrollbar(me, ge))
      return;
    if (ie.current) {
      ie.current = !1;
      return;
    }
    let xe;
    me.composedPath ? xe = me.composedPath().indexOf(oe.current) > -1 : xe = !ge.documentElement.contains(
      // @ts-expect-error returns `false` as intended when not dispatched from a Node
      me.target
    ) || oe.current.contains(
      // @ts-expect-error returns `false` as intended when not dispatched from a Node
      me.target
    ), !xe && (te || !ve) && re(me);
  }), pe = (me) => (ve) => {
    ue.current = !0;
    const ge = ee.props[me];
    ge && ge(ve);
  }, ye = {
    ref: de
  };
  return se !== !1 && (ye[se] = pe(se)), React.useEffect(() => {
    if (se !== !1) {
      const me = mapEventPropToEvent(se), ve = ownerDocument(oe.current), ge = () => {
        ie.current = !0;
      };
      return ve.addEventListener(me, fe), ve.addEventListener("touchmove", ge), () => {
        ve.removeEventListener(me, fe), ve.removeEventListener("touchmove", ge);
      };
    }
  }, [fe, se]), ne !== !1 && (ye[ne] = pe(ne)), React.useEffect(() => {
    if (ne !== !1) {
      const me = mapEventPropToEvent(ne), ve = ownerDocument(oe.current);
      return ve.addEventListener(me, fe), () => {
        ve.removeEventListener(me, fe);
      };
    }
  }, [fe, ne]), /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
    children: /* @__PURE__ */ React.cloneElement(ee, ye)
  });
}
process.env.NODE_ENV !== "production" && (ClickAwayListener.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //  To update them, edit the TypeScript types and run `pnpm proptypes`. 
  // 
  /**
   * The wrapped element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * If `true`, the React tree is ignored and only the DOM tree is considered.
   * This prop changes how portaled elements are handled.
   * @default false
   */
  disableReactTree: PropTypes.bool,
  /**
   * The mouse event to listen to. You can disable the listener by providing `false`.
   * @default 'onClick'
   */
  mouseEvent: PropTypes.oneOf(["onClick", "onMouseDown", "onMouseUp", "onPointerDown", "onPointerUp", !1]),
  /**
   * Callback fired when a "click away" event is detected.
   */
  onClickAway: PropTypes.func.isRequired,
  /**
   * The touch event to listen to. You can disable the listener by providing `false`.
   * @default 'onTouchEnd'
   */
  touchEvent: PropTypes.oneOf(["onTouchEnd", "onTouchStart", !1])
});
process.env.NODE_ENV !== "production" && (ClickAwayListener.propTypes = exactProp(ClickAwayListener.propTypes));
function useSnackbar($ = {}) {
  const {
    autoHideDuration: ee = null,
    disableWindowBlurListener: te = !1,
    onClose: ne,
    open: re,
    resumeHideDuration: se
  } = $, ie = useTimeout();
  React.useEffect(() => {
    if (!re)
      return;
    function xe(Ee) {
      Ee.defaultPrevented || (Ee.key === "Escape" || Ee.key === "Esc") && (ne == null || ne(Ee, "escapeKeyDown"));
    }
    return document.addEventListener("keydown", xe), () => {
      document.removeEventListener("keydown", xe);
    };
  }, [re, ne]);
  const oe = useEventCallback((xe, Ee) => {
    ne == null || ne(xe, Ee);
  }), le = useEventCallback((xe) => {
    !ne || xe == null || ie.start(xe, () => {
      oe(null, "timeout");
    });
  });
  React.useEffect(() => (re && le(ee), ie.clear), [re, ee, le, ie]);
  const ue = (xe) => {
    ne == null || ne(xe, "clickaway");
  }, de = ie.clear, fe = React.useCallback(() => {
    ee != null && le(se ?? ee * 0.5);
  }, [ee, se, le]), pe = (xe) => (Ee) => {
    const Te = xe.onBlur;
    Te == null || Te(Ee), fe();
  }, ye = (xe) => (Ee) => {
    const Te = xe.onFocus;
    Te == null || Te(Ee), de();
  }, me = (xe) => (Ee) => {
    const Te = xe.onMouseEnter;
    Te == null || Te(Ee), de();
  }, ve = (xe) => (Ee) => {
    const Te = xe.onMouseLeave;
    Te == null || Te(Ee), fe();
  };
  return React.useEffect(() => {
    if (!te && re)
      return window.addEventListener("focus", fe), window.addEventListener("blur", de), () => {
        window.removeEventListener("focus", fe), window.removeEventListener("blur", de);
      };
  }, [te, re, fe, de]), {
    getRootProps: (xe = {}) => {
      const Ee = _extends$4({}, extractEventHandlers($), extractEventHandlers(xe));
      return _extends$4({
        // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
        // See https://github.com/mui/material-ui/issues/29080
        role: "presentation"
      }, xe, Ee, {
        onBlur: pe(Ee),
        onFocus: ye(Ee),
        onMouseEnter: me(Ee),
        onMouseLeave: ve(Ee)
      });
    },
    onClickAway: ue
  };
}
const FormControlContext = /* @__PURE__ */ React.createContext(void 0);
process.env.NODE_ENV !== "production" && (FormControlContext.displayName = "FormControlContext");
const FormControlContext$1 = FormControlContext;
function useFormControl() {
  return React.useContext(FormControlContext$1);
}
function getBadgeUtilityClass($) {
  return generateUtilityClass("MuiBadge", $);
}
const badgeClasses = generateUtilityClasses("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]), badgeClasses$1 = badgeClasses, _excluded$8 = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"], RADIUS_STANDARD = 10, RADIUS_DOT = 4, useThemeProps = createUseThemeProps(), useUtilityClasses$7 = ($) => {
  const {
    color: ee,
    anchorOrigin: te,
    invisible: ne,
    overlap: re,
    variant: se,
    classes: ie = {}
  } = $, oe = {
    root: ["root"],
    badge: ["badge", se, ne && "invisible", `anchorOrigin${capitalize$1(te.vertical)}${capitalize$1(te.horizontal)}`, `anchorOrigin${capitalize$1(te.vertical)}${capitalize$1(te.horizontal)}${capitalize$1(re)}`, `overlap${capitalize$1(re)}`, ee !== "default" && `color${capitalize$1(ee)}`]
  };
  return composeClasses(oe, getBadgeUtilityClass, ie);
}, BadgeRoot = styled("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
}), BadgeBadge = styled("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.badge, ee[te.variant], ee[`anchorOrigin${capitalize$1(te.anchorOrigin.vertical)}${capitalize$1(te.anchorOrigin.horizontal)}${capitalize$1(te.overlap)}`], te.color !== "default" && ee[`color${capitalize$1(te.color)}`], te.invisible && ee.invisible];
  }
})(({
  theme: $
}) => {
  var ee;
  return {
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    fontFamily: $.typography.fontFamily,
    fontWeight: $.typography.fontWeightMedium,
    fontSize: $.typography.pxToRem(12),
    minWidth: RADIUS_STANDARD * 2,
    lineHeight: 1,
    padding: "0 6px",
    height: RADIUS_STANDARD * 2,
    borderRadius: RADIUS_STANDARD,
    zIndex: 1,
    // Render the badge on top of potential ripples.
    transition: $.transitions.create("transform", {
      easing: $.transitions.easing.easeInOut,
      duration: $.transitions.duration.enteringScreen
    }),
    variants: [...Object.keys(((ee = $.vars) != null ? ee : $).palette).filter((te) => {
      var ne, re;
      return ((ne = $.vars) != null ? ne : $).palette[te].main && ((re = $.vars) != null ? re : $).palette[te].contrastText;
    }).map((te) => ({
      props: {
        color: te
      },
      style: {
        backgroundColor: ($.vars || $).palette[te].main,
        color: ($.vars || $).palette[te].contrastText
      }
    })), {
      props: {
        variant: "dot"
      },
      style: {
        borderRadius: RADIUS_DOT,
        height: RADIUS_DOT * 2,
        minWidth: RADIUS_DOT * 2,
        padding: 0
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "top" && te.anchorOrigin.horizontal === "right" && te.overlap === "rectangular",
      style: {
        top: 0,
        right: 0,
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "bottom" && te.anchorOrigin.horizontal === "right" && te.overlap === "rectangular",
      style: {
        bottom: 0,
        right: 0,
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "top" && te.anchorOrigin.horizontal === "left" && te.overlap === "rectangular",
      style: {
        top: 0,
        left: 0,
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "bottom" && te.anchorOrigin.horizontal === "left" && te.overlap === "rectangular",
      style: {
        bottom: 0,
        left: 0,
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "top" && te.anchorOrigin.horizontal === "right" && te.overlap === "circular",
      style: {
        top: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "bottom" && te.anchorOrigin.horizontal === "right" && te.overlap === "circular",
      style: {
        bottom: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "top" && te.anchorOrigin.horizontal === "left" && te.overlap === "circular",
      style: {
        top: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState: te
      }) => te.anchorOrigin.vertical === "bottom" && te.anchorOrigin.horizontal === "left" && te.overlap === "circular",
      style: {
        bottom: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses$1.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: {
        invisible: !0
      },
      style: {
        transition: $.transitions.create("transform", {
          easing: $.transitions.easing.easeInOut,
          duration: $.transitions.duration.leavingScreen
        })
      }
    }]
  };
}), Badge = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re, se, ie, oe, le;
  const ue = useThemeProps({
    props: ee,
    name: "MuiBadge"
  }), {
    anchorOrigin: de = {
      vertical: "top",
      horizontal: "right"
    },
    className: fe,
    component: pe,
    components: ye = {},
    componentsProps: me = {},
    children: ve,
    overlap: ge = "rectangular",
    color: xe = "default",
    invisible: Ee = !1,
    max: Te = 99,
    badgeContent: Se,
    slots: he,
    slotProps: Pe,
    showZero: Ie = !1,
    variant: De = "standard"
  } = ue, Ce = _objectWithoutPropertiesLoose$1(ue, _excluded$8), {
    badgeContent: Ne,
    invisible: Me,
    max: Be,
    displayValue: We
  } = useBadge({
    max: Te,
    invisible: Ee,
    badgeContent: Se,
    showZero: Ie
  }), Le = usePreviousProps({
    anchorOrigin: de,
    color: xe,
    overlap: ge,
    variant: De,
    badgeContent: Se
  }), He = Me || Ne == null && De !== "dot", {
    color: Ge = xe,
    overlap: Ze = ge,
    anchorOrigin: Ue = de,
    variant: Qe = De
  } = He ? Le : ue, Je = Qe !== "dot" ? We : void 0, Ot = _extends$4({}, ue, {
    badgeContent: Ne,
    invisible: He,
    max: Be,
    displayValue: Je,
    showZero: Ie,
    anchorOrigin: Ue,
    color: Ge,
    overlap: Ze,
    variant: Qe
  }), At = useUtilityClasses$7(Ot), ze = (ne = (re = he == null ? void 0 : he.root) != null ? re : ye.Root) != null ? ne : BadgeRoot, we = (se = (ie = he == null ? void 0 : he.badge) != null ? ie : ye.Badge) != null ? se : BadgeBadge, Ae = (oe = Pe == null ? void 0 : Pe.root) != null ? oe : me.root, Re = (le = Pe == null ? void 0 : Pe.badge) != null ? le : me.badge, je = useSlotProps({
    elementType: ze,
    externalSlotProps: Ae,
    externalForwardedProps: Ce,
    additionalProps: {
      ref: te,
      as: pe
    },
    ownerState: Ot,
    className: clsx(Ae == null ? void 0 : Ae.className, At.root, fe)
  }), Fe = useSlotProps({
    elementType: we,
    externalSlotProps: Re,
    ownerState: Ot,
    className: clsx(At.badge, Re == null ? void 0 : Re.className)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ze, _extends$4({}, je, {
    children: [ve, /* @__PURE__ */ jsxRuntimeExports.jsx(we, _extends$4({}, Fe, {
      children: Je
    }))]
  }));
});
process.env.NODE_ENV !== "production" && (Badge.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The anchor of the badge.
   * @default {
   *   vertical: 'top',
   *   horizontal: 'right',
   * }
   */
  anchorOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOf(["left", "right"]).isRequired,
    vertical: PropTypes.oneOf(["bottom", "top"]).isRequired
  }),
  /**
   * The content rendered within the badge.
   */
  badgeContent: PropTypes.node,
  /**
   * The badge will be added relative to this node.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'default'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: PropTypes.shape({
    Badge: PropTypes.elementType,
    Root: PropTypes.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: PropTypes.shape({
    badge: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * If `true`, the badge is invisible.
   * @default false
   */
  invisible: PropTypes.bool,
  /**
   * Max count to show.
   * @default 99
   */
  max: PropTypes.number,
  /**
   * Wrapped shape the badge should overlap.
   * @default 'rectangular'
   */
  overlap: PropTypes.oneOf(["circular", "rectangular"]),
  /**
   * Controls whether the badge is hidden when `badgeContent` is zero.
   * @default false
   */
  showZero: PropTypes.bool,
  /**
   * The props used for each slot inside the Badge.
   * @default {}
   */
  slotProps: PropTypes.shape({
    badge: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    root: PropTypes.oneOfType([PropTypes.func, PropTypes.object])
  }),
  /**
   * The components used for each slot inside the Badge.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: PropTypes.shape({
    badge: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The variant to use.
   * @default 'standard'
   */
  variant: PropTypes.oneOfType([PropTypes.oneOf(["dot", "standard"]), PropTypes.string])
});
const Badge$1 = Badge;
function getSwitchBaseUtilityClass($) {
  return generateUtilityClass("PrivateSwitchBase", $);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$7 = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"], useUtilityClasses$6 = ($) => {
  const {
    classes: ee,
    checked: te,
    disabled: ne,
    edge: re
  } = $, se = {
    root: ["root", te && "checked", ne && "disabled", re && `edge${capitalize$1(re)}`],
    input: ["input"]
  };
  return composeClasses(se, getSwitchBaseUtilityClass, ee);
}, SwitchBaseRoot = styled(ButtonBase$1)(({
  ownerState: $
}) => _extends$4({
  padding: 9,
  borderRadius: "50%"
}, $.edge === "start" && {
  marginLeft: $.size === "small" ? -3 : -12
}, $.edge === "end" && {
  marginRight: $.size === "small" ? -3 : -12
})), SwitchBaseInput = styled("input", {
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
}), SwitchBase = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const {
    autoFocus: ne,
    checked: re,
    checkedIcon: se,
    className: ie,
    defaultChecked: oe,
    disabled: le,
    disableFocusRipple: ue = !1,
    edge: de = !1,
    icon: fe,
    id: pe,
    inputProps: ye,
    inputRef: me,
    name: ve,
    onBlur: ge,
    onChange: xe,
    onFocus: Ee,
    readOnly: Te,
    required: Se = !1,
    tabIndex: he,
    type: Pe,
    value: Ie
  } = ee, De = _objectWithoutPropertiesLoose$1(ee, _excluded$7), [Ce, Ne] = useControlled({
    controlled: re,
    default: !!oe,
    name: "SwitchBase",
    state: "checked"
  }), Me = useFormControl(), Be = (Qe) => {
    Ee && Ee(Qe), Me && Me.onFocus && Me.onFocus(Qe);
  }, We = (Qe) => {
    ge && ge(Qe), Me && Me.onBlur && Me.onBlur(Qe);
  }, Le = (Qe) => {
    if (Qe.nativeEvent.defaultPrevented)
      return;
    const Je = Qe.target.checked;
    Ne(Je), xe && xe(Qe, Je);
  };
  let He = le;
  Me && typeof He > "u" && (He = Me.disabled);
  const Ge = Pe === "checkbox" || Pe === "radio", Ze = _extends$4({}, ee, {
    checked: Ce,
    disabled: He,
    disableFocusRipple: ue,
    edge: de
  }), Ue = useUtilityClasses$6(Ze);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$4({
    component: "span",
    className: clsx(Ue.root, ie),
    centerRipple: !0,
    focusRipple: !ue,
    disabled: He,
    tabIndex: null,
    role: void 0,
    onFocus: Be,
    onBlur: We,
    ownerState: Ze,
    ref: te
  }, De, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends$4({
      autoFocus: ne,
      checked: re,
      defaultChecked: oe,
      className: Ue.input,
      disabled: He,
      id: Ge ? pe : void 0,
      name: ve,
      onChange: Le,
      readOnly: Te,
      ref: me,
      required: Se,
      ownerState: Ze,
      tabIndex: he,
      type: Pe
    }, Pe === "checkbox" && Ie === void 0 ? {} : {
      value: Ie
    }, ye)), Ce ? se : fe]
  }));
});
process.env.NODE_ENV !== "production" && (SwitchBase.propTypes = {
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: PropTypes.bool,
  /**
   * If `true`, the component is checked.
   */
  checked: PropTypes.bool,
  /**
   * The icon to display when the component is checked.
   */
  checkedIcon: PropTypes.node.isRequired,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * @ignore
   */
  defaultChecked: PropTypes.bool,
  /**
   * If `true`, the component is disabled.
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, the  keyboard focus ripple is disabled.
   * @default false
   */
  disableFocusRipple: PropTypes.bool,
  /**
   * If given, uses a negative margin to counteract the padding on one
   * side (this is often helpful for aligning the left or right
   * side of the icon with content above or below, without ruining the border
   * size and shape).
   * @default false
   */
  edge: PropTypes.oneOf(["end", "start", !1]),
  /**
   * The icon to display when the component is unchecked.
   */
  icon: PropTypes.node.isRequired,
  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /*
   * @ignore
   */
  name: PropTypes.string,
  /**
   * @ignore
   */
  onBlur: PropTypes.func,
  /**
   * Callback fired when the state is changed.
   *
   * @param {object} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: PropTypes.func,
  /**
   * @ignore
   */
  onFocus: PropTypes.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,
  /**
   * If `true`, the `input` element is required.
   */
  required: PropTypes.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.object,
  /**
   * @ignore
   */
  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * The input component prop `type`.
   */
  type: PropTypes.string.isRequired,
  /**
   * The value of the component.
   */
  value: PropTypes.any
});
const SwitchBase$1 = SwitchBase, CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank"), CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox"), IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass($) {
  return generateUtilityClass("MuiCheckbox", $);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), checkboxClasses$1 = checkboxClasses, _excluded$6 = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"], useUtilityClasses$5 = ($) => {
  const {
    classes: ee,
    indeterminate: te,
    color: ne,
    size: re
  } = $, se = {
    root: ["root", te && "indeterminate", `color${capitalize$1(ne)}`, `size${capitalize$1(re)}`]
  }, ie = composeClasses(se, getCheckboxUtilityClass, ee);
  return _extends$4({}, ee, ie);
}, CheckboxRoot = styled(SwitchBase$1, {
  shouldForwardProp: ($) => rootShouldForwardProp($) || $ === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, te.indeterminate && ee.indeterminate, ee[`size${capitalize$1(te.size)}`], te.color !== "default" && ee[`color${capitalize$1(te.color)}`]];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  color: ($.vars || $).palette.text.secondary
}, !ee.disableRipple && {
  "&:hover": {
    backgroundColor: $.vars ? `rgba(${ee.color === "default" ? $.vars.palette.action.activeChannel : $.vars.palette[ee.color].mainChannel} / ${$.vars.palette.action.hoverOpacity})` : alpha_1(ee.color === "default" ? $.palette.action.active : $.palette[ee.color].main, $.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ee.color !== "default" && {
  [`&.${checkboxClasses$1.checked}, &.${checkboxClasses$1.indeterminate}`]: {
    color: ($.vars || $).palette[ee.color].main
  },
  [`&.${checkboxClasses$1.disabled}`]: {
    color: ($.vars || $).palette.action.disabled
  }
})), defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {}), defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {}), defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {}), Checkbox = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  var ne, re;
  const se = useThemeProps$1({
    props: ee,
    name: "MuiCheckbox"
  }), {
    checkedIcon: ie = defaultCheckedIcon,
    color: oe = "primary",
    icon: le = defaultIcon,
    indeterminate: ue = !1,
    indeterminateIcon: de = defaultIndeterminateIcon,
    inputProps: fe,
    size: pe = "medium",
    className: ye
  } = se, me = _objectWithoutPropertiesLoose$1(se, _excluded$6), ve = ue ? de : le, ge = ue ? de : ie, xe = _extends$4({}, se, {
    color: oe,
    indeterminate: ue,
    size: pe
  }), Ee = useUtilityClasses$5(xe);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxRoot, _extends$4({
    type: "checkbox",
    inputProps: _extends$4({
      "data-indeterminate": ue
    }, fe),
    icon: /* @__PURE__ */ React.cloneElement(ve, {
      fontSize: (ne = ve.props.fontSize) != null ? ne : pe
    }),
    checkedIcon: /* @__PURE__ */ React.cloneElement(ge, {
      fontSize: (re = ge.props.fontSize) != null ? re : pe
    }),
    ownerState: xe,
    ref: te,
    className: clsx(Ee.root, ye)
  }, me, {
    classes: Ee
  }));
});
process.env.NODE_ENV !== "production" && (Checkbox.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * If `true`, the component is checked.
   */
  checked: PropTypes.bool,
  /**
   * The icon to display when the component is checked.
   * @default <CheckBoxIcon />
   */
  checkedIcon: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The default checked state. Use when the component is not controlled.
   */
  defaultChecked: PropTypes.bool,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, the ripple effect is disabled.
   * @default false
   */
  disableRipple: PropTypes.bool,
  /**
   * The icon to display when the component is unchecked.
   * @default <CheckBoxOutlineBlankIcon />
   */
  icon: PropTypes.node,
  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,
  /**
   * If `true`, the component appears indeterminate.
   * This does not set the native input element to indeterminate due
   * to inconsistent behavior across browsers.
   * However, we set a `data-indeterminate` attribute on the `input`.
   * @default false
   */
  indeterminate: PropTypes.bool,
  /**
   * The icon to display when the component is indeterminate.
   * @default <IndeterminateCheckBoxIcon />
   */
  indeterminateIcon: PropTypes.node,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: PropTypes.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * Callback fired when the state is changed.
   *
   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: PropTypes.func,
  /**
   * If `true`, the `input` element is required.
   * @default false
   */
  required: PropTypes.bool,
  /**
   * The size of the component.
   * `small` is equivalent to the dense checkbox styling.
   * @default 'medium'
   */
  size: PropTypes.oneOfType([PropTypes.oneOf(["medium", "small"]), PropTypes.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The value of the component. The DOM API casts this to a string.
   * The browser uses "on" as the default value.
   */
  value: PropTypes.any
});
const Checkbox$1 = Checkbox;
function getCircularProgressUtilityClass($) {
  return generateUtilityClass("MuiCircularProgress", $);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const _excluded$5 = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let _ = ($) => $, _t, _t2, _t3, _t4;
const SIZE = 44, circularRotateKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`)), circularDashKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`)), useUtilityClasses$4 = ($) => {
  const {
    classes: ee,
    variant: te,
    color: ne,
    disableShrink: re
  } = $, se = {
    root: ["root", te, `color${capitalize$1(ne)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize$1(te)}`, re && "circleDisableShrink"]
  };
  return composeClasses(se, getCircularProgressUtilityClass, ee);
}, CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, ee[te.variant], ee[`color${capitalize$1(te.color)}`]];
  }
})(({
  ownerState: $,
  theme: ee
}) => _extends$4({
  display: "inline-block"
}, $.variant === "determinate" && {
  transition: ee.transitions.create("transform")
}, $.color !== "inherit" && {
  color: (ee.vars || ee).palette[$.color].main
}), ({
  ownerState: $
}) => $.variant === "indeterminate" && css(_t3 || (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe)), CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: ($, ee) => ee.svg
})({
  display: "block"
  // Keeps the progress centered
}), CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.circle, ee[`circle${capitalize$1(te.variant)}`], te.disableShrink && ee.circleDisableShrink];
  }
})(({
  ownerState: $,
  theme: ee
}) => _extends$4({
  stroke: "currentColor"
}, $.variant === "determinate" && {
  transition: ee.transitions.create("stroke-dashoffset")
}, $.variant === "indeterminate" && {
  // Some default value that looks fine waiting for the animation to kicks in.
  strokeDasharray: "80px, 200px",
  strokeDashoffset: 0
  // Add the unit to fix a Edge 16 and below bug.
}), ({
  ownerState: $
}) => $.variant === "indeterminate" && !$.disableShrink && css(_t4 || (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe)), CircularProgress = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiCircularProgress"
  }), {
    className: re,
    color: se = "primary",
    disableShrink: ie = !1,
    size: oe = 40,
    style: le,
    thickness: ue = 3.6,
    value: de = 0,
    variant: fe = "indeterminate"
  } = ne, pe = _objectWithoutPropertiesLoose$1(ne, _excluded$5), ye = _extends$4({}, ne, {
    color: se,
    disableShrink: ie,
    size: oe,
    thickness: ue,
    value: de,
    variant: fe
  }), me = useUtilityClasses$4(ye), ve = {}, ge = {}, xe = {};
  if (fe === "determinate") {
    const Ee = 2 * Math.PI * ((SIZE - ue) / 2);
    ve.strokeDasharray = Ee.toFixed(3), xe["aria-valuenow"] = Math.round(de), ve.strokeDashoffset = `${((100 - de) / 100 * Ee).toFixed(3)}px`, ge.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, _extends$4({
    className: clsx(me.root, re),
    style: _extends$4({
      width: oe,
      height: oe
    }, ge, le),
    ownerState: ye,
    ref: te,
    role: "progressbar"
  }, xe, pe, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: me.svg,
      ownerState: ye,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: me.circle,
        style: ve,
        ownerState: ye,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - ue) / 2,
        fill: "none",
        strokeWidth: ue
      })
    })
  }));
});
process.env.NODE_ENV !== "production" && (CircularProgress.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * If `true`, the shrink animation is disabled.
   * This only works if variant is `indeterminate`.
   * @default false
   */
  disableShrink: chainPropTypes(PropTypes.bool, ($) => $.disableShrink && $.variant && $.variant !== "indeterminate" ? new Error("MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.") : null),
  /**
   * The size of the component.
   * If using a number, the pixel unit is assumed.
   * If using a string, you need to provide the CSS unit, for example '3rem'.
   * @default 40
   */
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * @ignore
   */
  style: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The thickness of the circle.
   * @default 3.6
   */
  thickness: PropTypes.number,
  /**
   * The value of the progress indicator for the determinate variant.
   * Value between 0 and 100.
   * @default 0
   */
  value: PropTypes.number,
  /**
   * The variant to use.
   * Use indeterminate when there is no progress value.
   * @default 'indeterminate'
   */
  variant: PropTypes.oneOf(["determinate", "indeterminate"])
});
const CircularProgress$1 = CircularProgress;
function getDialogUtilityClass($) {
  return generateUtilityClass("MuiDialog", $);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]), dialogClasses$1 = dialogClasses, DialogContext = /* @__PURE__ */ React.createContext({});
process.env.NODE_ENV !== "production" && (DialogContext.displayName = "DialogContext");
const DialogContext$1 = DialogContext, _excluded$4 = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"], DialogBackdrop = styled(Backdrop$1, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: ($, ee) => ee.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
}), useUtilityClasses$3 = ($) => {
  const {
    classes: ee,
    scroll: te,
    maxWidth: ne,
    fullWidth: re,
    fullScreen: se
  } = $, ie = {
    root: ["root"],
    container: ["container", `scroll${capitalize$1(te)}`],
    paper: ["paper", `paperScroll${capitalize$1(te)}`, `paperWidth${capitalize$1(String(ne))}`, re && "paperFullWidth", se && "paperFullScreen"]
  };
  return composeClasses(ie, getDialogUtilityClass, ee);
}, DialogRoot = styled(Modal$1, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
}), DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.container, ee[`scroll${capitalize$1(te.scroll)}`]];
  }
})(({
  ownerState: $
}) => _extends$4({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, $.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, $.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&::after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
})), DialogPaper = styled(Paper$1, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.paper, ee[`scrollPaper${capitalize$1(te.scroll)}`], ee[`paperWidth${capitalize$1(String(te.maxWidth))}`], te.fullWidth && ee.paperFullWidth, te.fullScreen && ee.paperFullScreen];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ee.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ee.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ee.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ee.maxWidth === "xs" && {
  maxWidth: $.breakpoints.unit === "px" ? Math.max($.breakpoints.values.xs, 444) : `max(${$.breakpoints.values.xs}${$.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [$.breakpoints.down(Math.max($.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ee.maxWidth && ee.maxWidth !== "xs" && {
  maxWidth: `${$.breakpoints.values[ee.maxWidth]}${$.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [$.breakpoints.down($.breakpoints.values[ee.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ee.fullWidth && {
  width: "calc(100% - 64px)"
}, ee.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
})), Dialog = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiDialog"
  }), re = useTheme(), se = {
    enter: re.transitions.duration.enteringScreen,
    exit: re.transitions.duration.leavingScreen
  }, {
    "aria-describedby": ie,
    "aria-labelledby": oe,
    BackdropComponent: le,
    BackdropProps: ue,
    children: de,
    className: fe,
    disableEscapeKeyDown: pe = !1,
    fullScreen: ye = !1,
    fullWidth: me = !1,
    maxWidth: ve = "sm",
    onBackdropClick: ge,
    onClose: xe,
    open: Ee,
    PaperComponent: Te = Paper$1,
    PaperProps: Se = {},
    scroll: he = "paper",
    TransitionComponent: Pe = Fade$1,
    transitionDuration: Ie = se,
    TransitionProps: De
  } = ne, Ce = _objectWithoutPropertiesLoose$1(ne, _excluded$4), Ne = _extends$4({}, ne, {
    disableEscapeKeyDown: pe,
    fullScreen: ye,
    fullWidth: me,
    maxWidth: ve,
    scroll: he
  }), Me = useUtilityClasses$3(Ne), Be = React.useRef(), We = (Ze) => {
    Be.current = Ze.target === Ze.currentTarget;
  }, Le = (Ze) => {
    Be.current && (Be.current = null, ge && ge(Ze), xe && xe(Ze, "backdropClick"));
  }, He = useId(oe), Ge = React.useMemo(() => ({
    titleId: He
  }), [He]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$4({
    className: clsx(Me.root, fe),
    closeAfterTransition: !0,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$4({
        transitionDuration: Ie,
        as: le
      }, ue)
    },
    disableEscapeKeyDown: pe,
    onClose: xe,
    open: Ee,
    ref: te,
    onClick: Le,
    ownerState: Ne
  }, Ce, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pe, _extends$4({
      appear: !0,
      in: Ee,
      timeout: Ie,
      role: "presentation"
    }, De, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(Me.container),
        onMouseDown: We,
        ownerState: Ne,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$4({
          as: Te,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ie,
          "aria-labelledby": He
        }, Se, {
          className: clsx(Me.paper, Se.className),
          ownerState: Ne,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext$1.Provider, {
            value: Ge,
            children: de
          })
        }))
      })
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Dialog.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The id(s) of the element(s) that describe the dialog.
   */
  "aria-describedby": PropTypes.string,
  /**
   * The id(s) of the element(s) that label the dialog.
   */
  "aria-labelledby": PropTypes.string,
  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
   * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
   * @default styled(Backdrop, {
   *   name: 'MuiModal',
   *   slot: 'Backdrop',
   *   overridesResolver: (props, styles) => {
   *     return styles.backdrop;
   *   },
   * })({
   *   zIndex: -1,
   * })
   */
  BackdropComponent: PropTypes.elementType,
  /**
   * @ignore
   */
  BackdropProps: PropTypes.object,
  /**
   * Dialog children, usually the included sub-components.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: PropTypes.bool,
  /**
   * If `true`, the dialog is full-screen.
   * @default false
   */
  fullScreen: PropTypes.bool,
  /**
   * If `true`, the dialog stretches to `maxWidth`.
   *
   * Notice that the dialog width grow is limited by the default margin.
   * @default false
   */
  fullWidth: PropTypes.bool,
  /**
   * Determine the max-width of the dialog.
   * The dialog width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'sm'
   */
  maxWidth: PropTypes.oneOfType([PropTypes.oneOf(["xs", "sm", "md", "lg", "xl", !1]), PropTypes.string]),
  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: PropTypes.func,
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: PropTypes.func,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool.isRequired,
  /**
   * The component used to render the body of the dialog.
   * @default Paper
   */
  PaperComponent: PropTypes.elementType,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: PropTypes.object,
  /**
   * Determine the container for scrolling the dialog.
   * @default 'paper'
   */
  scroll: PropTypes.oneOf(["body", "paper"]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Fade
   */
  TransitionComponent: PropTypes.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: PropTypes.object
});
const Dialog$1 = Dialog, _excluded$3 = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getTranslateValue($, ee, te) {
  const ne = ee.getBoundingClientRect(), re = te && te.getBoundingClientRect(), se = ownerWindow(ee);
  let ie;
  if (ee.fakeTransform)
    ie = ee.fakeTransform;
  else {
    const ue = se.getComputedStyle(ee);
    ie = ue.getPropertyValue("-webkit-transform") || ue.getPropertyValue("transform");
  }
  let oe = 0, le = 0;
  if (ie && ie !== "none" && typeof ie == "string") {
    const ue = ie.split("(")[1].split(")")[0].split(",");
    oe = parseInt(ue[4], 10), le = parseInt(ue[5], 10);
  }
  return $ === "left" ? re ? `translateX(${re.right + oe - ne.left}px)` : `translateX(${se.innerWidth + oe - ne.left}px)` : $ === "right" ? re ? `translateX(-${ne.right - re.left - oe}px)` : `translateX(-${ne.left + ne.width - oe}px)` : $ === "up" ? re ? `translateY(${re.bottom + le - ne.top}px)` : `translateY(${se.innerHeight + le - ne.top}px)` : re ? `translateY(-${ne.top - re.top + ne.height - le}px)` : `translateY(-${ne.top + ne.height - le}px)`;
}
function resolveContainer($) {
  return typeof $ == "function" ? $() : $;
}
function setTranslateValue($, ee, te) {
  const ne = resolveContainer(te), re = getTranslateValue($, ee, ne);
  re && (ee.style.webkitTransform = re, ee.style.transform = re);
}
const Slide = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useTheme(), re = {
    enter: ne.transitions.easing.easeOut,
    exit: ne.transitions.easing.sharp
  }, se = {
    enter: ne.transitions.duration.enteringScreen,
    exit: ne.transitions.duration.leavingScreen
  }, {
    addEndListener: ie,
    appear: oe = !0,
    children: le,
    container: ue,
    direction: de = "down",
    easing: fe = re,
    in: pe,
    onEnter: ye,
    onEntered: me,
    onEntering: ve,
    onExit: ge,
    onExited: xe,
    onExiting: Ee,
    style: Te,
    timeout: Se = se,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: he = Transition$1
  } = ee, Pe = _objectWithoutPropertiesLoose$1(ee, _excluded$3), Ie = React.useRef(null), De = useForkRef(le.ref, Ie, te), Ce = (Ue) => (Qe) => {
    Ue && (Qe === void 0 ? Ue(Ie.current) : Ue(Ie.current, Qe));
  }, Ne = Ce((Ue, Qe) => {
    setTranslateValue(de, Ue, ue), reflow(Ue), ye && ye(Ue, Qe);
  }), Me = Ce((Ue, Qe) => {
    const Je = getTransitionProps({
      timeout: Se,
      style: Te,
      easing: fe
    }, {
      mode: "enter"
    });
    Ue.style.webkitTransition = ne.transitions.create("-webkit-transform", _extends$4({}, Je)), Ue.style.transition = ne.transitions.create("transform", _extends$4({}, Je)), Ue.style.webkitTransform = "none", Ue.style.transform = "none", ve && ve(Ue, Qe);
  }), Be = Ce(me), We = Ce(Ee), Le = Ce((Ue) => {
    const Qe = getTransitionProps({
      timeout: Se,
      style: Te,
      easing: fe
    }, {
      mode: "exit"
    });
    Ue.style.webkitTransition = ne.transitions.create("-webkit-transform", Qe), Ue.style.transition = ne.transitions.create("transform", Qe), setTranslateValue(de, Ue, ue), ge && ge(Ue);
  }), He = Ce((Ue) => {
    Ue.style.webkitTransition = "", Ue.style.transition = "", xe && xe(Ue);
  }), Ge = (Ue) => {
    ie && ie(Ie.current, Ue);
  }, Ze = React.useCallback(() => {
    Ie.current && setTranslateValue(de, Ie.current, ue);
  }, [de, ue]);
  return React.useEffect(() => {
    if (pe || de === "down" || de === "right")
      return;
    const Ue = debounce$1(() => {
      Ie.current && setTranslateValue(de, Ie.current, ue);
    }), Qe = ownerWindow(Ie.current);
    return Qe.addEventListener("resize", Ue), () => {
      Ue.clear(), Qe.removeEventListener("resize", Ue);
    };
  }, [de, pe, ue]), React.useEffect(() => {
    pe || Ze();
  }, [pe, Ze]), /* @__PURE__ */ jsxRuntimeExports.jsx(he, _extends$4({
    nodeRef: Ie,
    onEnter: Ne,
    onEntered: Be,
    onEntering: Me,
    onExit: Le,
    onExited: He,
    onExiting: We,
    addEndListener: Ge,
    appear: oe,
    in: pe,
    timeout: Se
  }, Pe, {
    children: (Ue, Qe) => /* @__PURE__ */ React.cloneElement(le, _extends$4({
      ref: De,
      style: _extends$4({
        visibility: Ue === "exited" && !pe ? "hidden" : void 0
      }, Te, le.props.style)
    }, Qe))
  }));
});
process.env.NODE_ENV !== "production" && (Slide.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: PropTypes.func,
  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: PropTypes.bool,
  /**
   * A single child content element.
   */
  children: elementAcceptingRef$1.isRequired,
  /**
   * An HTML element, or a function that returns one.
   * It's used to set the container the Slide is transitioning from.
   */
  container: chainPropTypes(PropTypes.oneOfType([HTMLElementType, PropTypes.func]), ($) => {
    if ($.open) {
      const ee = resolveContainer($.container);
      if (ee && ee.nodeType === 1) {
        const te = ee.getBoundingClientRect();
        if (process.env.NODE_ENV !== "test" && te.top === 0 && te.left === 0 && te.right === 0 && te.bottom === 0)
          return new Error(["MUI: The `container` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join(`
`));
      } else if (!ee || typeof ee.getBoundingClientRect != "function" || ee.contextElement != null && ee.contextElement.nodeType !== 1)
        return new Error(["MUI: The `container` prop provided to the component is invalid.", "It should be an HTML element instance."].join(`
`));
    }
    return null;
  }),
  /**
   * Direction the child node will enter from.
   * @default 'down'
   */
  direction: PropTypes.oneOf(["down", "left", "right", "up"]),
  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   * @default {
   *   enter: theme.transitions.easing.easeOut,
   *   exit: theme.transitions.easing.sharp,
   * }
   */
  easing: PropTypes.oneOfType([PropTypes.shape({
    enter: PropTypes.string,
    exit: PropTypes.string
  }), PropTypes.string]),
  /**
   * If `true`, the component will transition in.
   */
  in: PropTypes.bool,
  /**
   * @ignore
   */
  onEnter: PropTypes.func,
  /**
   * @ignore
   */
  onEntered: PropTypes.func,
  /**
   * @ignore
   */
  onEntering: PropTypes.func,
  /**
   * @ignore
   */
  onExit: PropTypes.func,
  /**
   * @ignore
   */
  onExited: PropTypes.func,
  /**
   * @ignore
   */
  onExiting: PropTypes.func,
  /**
   * @ignore
   */
  style: PropTypes.object,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  timeout: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })])
});
const Slide$1 = Slide;
function getDrawerUtilityClass($) {
  return generateUtilityClass("MuiDrawer", $);
}
generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const _excluded$2 = ["BackdropProps"], _excluded2$1 = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"], overridesResolver = ($, ee) => {
  const {
    ownerState: te
  } = $;
  return [ee.root, (te.variant === "permanent" || te.variant === "persistent") && ee.docked, ee.modal];
}, useUtilityClasses$2 = ($) => {
  const {
    classes: ee,
    anchor: te,
    variant: ne
  } = $, re = {
    root: ["root"],
    docked: [(ne === "permanent" || ne === "persistent") && "docked"],
    modal: ["modal"],
    paper: ["paper", `paperAnchor${capitalize$1(te)}`, ne !== "temporary" && `paperAnchorDocked${capitalize$1(te)}`]
  };
  return composeClasses(re, getDrawerUtilityClass, ee);
}, DrawerRoot = styled(Modal$1, {
  name: "MuiDrawer",
  slot: "Root",
  overridesResolver
})(({
  theme: $
}) => ({
  zIndex: ($.vars || $).zIndex.drawer
})), DrawerDockedRoot = styled("div", {
  shouldForwardProp: rootShouldForwardProp,
  name: "MuiDrawer",
  slot: "Docked",
  skipVariantsResolver: !1,
  overridesResolver
})({
  flex: "0 0 auto"
}), DrawerPaper = styled(Paper$1, {
  name: "MuiDrawer",
  slot: "Paper",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.paper, ee[`paperAnchor${capitalize$1(te.anchor)}`], te.variant !== "temporary" && ee[`paperAnchorDocked${capitalize$1(te.anchor)}`]];
  }
})(({
  theme: $,
  ownerState: ee
}) => _extends$4({
  overflowY: "auto",
  display: "flex",
  flexDirection: "column",
  height: "100%",
  flex: "1 0 auto",
  zIndex: ($.vars || $).zIndex.drawer,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  // temporary style
  position: "fixed",
  top: 0,
  // We disable the focus ring for mouse, touch and keyboard users.
  // At some point, it would be better to keep it for keyboard users.
  // :focus-ring CSS pseudo-class will help.
  outline: 0
}, ee.anchor === "left" && {
  left: 0
}, ee.anchor === "top" && {
  top: 0,
  left: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ee.anchor === "right" && {
  right: 0
}, ee.anchor === "bottom" && {
  top: "auto",
  left: 0,
  bottom: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ee.anchor === "left" && ee.variant !== "temporary" && {
  borderRight: `1px solid ${($.vars || $).palette.divider}`
}, ee.anchor === "top" && ee.variant !== "temporary" && {
  borderBottom: `1px solid ${($.vars || $).palette.divider}`
}, ee.anchor === "right" && ee.variant !== "temporary" && {
  borderLeft: `1px solid ${($.vars || $).palette.divider}`
}, ee.anchor === "bottom" && ee.variant !== "temporary" && {
  borderTop: `1px solid ${($.vars || $).palette.divider}`
})), oppositeDirection = {
  left: "right",
  right: "left",
  top: "down",
  bottom: "up"
};
function isHorizontal($) {
  return ["left", "right"].indexOf($) !== -1;
}
function getAnchor({
  direction: $
}, ee) {
  return $ === "rtl" && isHorizontal(ee) ? oppositeDirection[ee] : ee;
}
const Drawer = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiDrawer"
  }), re = useTheme(), se = useRtl(), ie = {
    enter: re.transitions.duration.enteringScreen,
    exit: re.transitions.duration.leavingScreen
  }, {
    anchor: oe = "left",
    BackdropProps: le,
    children: ue,
    className: de,
    elevation: fe = 16,
    hideBackdrop: pe = !1,
    ModalProps: {
      BackdropProps: ye
    } = {},
    onClose: me,
    open: ve = !1,
    PaperProps: ge = {},
    SlideProps: xe,
    // eslint-disable-next-line react/prop-types
    TransitionComponent: Ee = Slide$1,
    transitionDuration: Te = ie,
    variant: Se = "temporary"
  } = ne, he = _objectWithoutPropertiesLoose$1(ne.ModalProps, _excluded$2), Pe = _objectWithoutPropertiesLoose$1(ne, _excluded2$1), Ie = React.useRef(!1);
  React.useEffect(() => {
    Ie.current = !0;
  }, []);
  const De = getAnchor({
    direction: se ? "rtl" : "ltr"
  }, oe), Ne = _extends$4({}, ne, {
    anchor: oe,
    elevation: fe,
    open: ve,
    variant: Se
  }, Pe), Me = useUtilityClasses$2(Ne), Be = /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerPaper, _extends$4({
    elevation: Se === "temporary" ? fe : 0,
    square: !0
  }, ge, {
    className: clsx(Me.paper, ge.className),
    ownerState: Ne,
    children: ue
  }));
  if (Se === "permanent")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$4({
      className: clsx(Me.root, Me.docked, de),
      ownerState: Ne,
      ref: te
    }, Pe, {
      children: Be
    }));
  const We = /* @__PURE__ */ jsxRuntimeExports.jsx(Ee, _extends$4({
    in: ve,
    direction: oppositeDirection[De],
    timeout: Te,
    appear: Ie.current
  }, xe, {
    children: Be
  }));
  return Se === "persistent" ? /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$4({
    className: clsx(Me.root, Me.docked, de),
    ownerState: Ne,
    ref: te
  }, Pe, {
    children: We
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerRoot, _extends$4({
    BackdropProps: _extends$4({}, le, ye, {
      transitionDuration: Te
    }),
    className: clsx(Me.root, Me.modal, de),
    open: ve,
    ownerState: Ne,
    onClose: me,
    hideBackdrop: pe,
    ref: te
  }, Pe, he, {
    children: We
  }));
});
process.env.NODE_ENV !== "production" && (Drawer.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * Side from which the drawer will appear.
   * @default 'left'
   */
  anchor: PropTypes.oneOf(["bottom", "left", "right", "top"]),
  /**
   * @ignore
   */
  BackdropProps: PropTypes.object,
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The elevation of the drawer.
   * @default 16
   */
  elevation: integerPropType,
  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: PropTypes.bool,
  /**
   * Props applied to the [`Modal`](/material-ui/api/modal/) element.
   * @default {}
   */
  ModalProps: PropTypes.object,
  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: PropTypes.func,
  /**
   * If `true`, the component is shown.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * Props applied to the [`Paper`](/material-ui/api/paper/) element.
   * @default {}
   */
  PaperProps: PropTypes.object,
  /**
   * Props applied to the [`Slide`](/material-ui/api/slide/) element.
   */
  SlideProps: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),
  /**
   * The variant to use.
   * @default 'temporary'
   */
  variant: PropTypes.oneOf(["permanent", "persistent", "temporary"])
});
const Drawer$1 = Drawer;
function getSnackbarContentUtilityClass($) {
  return generateUtilityClass("MuiSnackbarContent", $);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const _excluded$1 = ["action", "className", "message", "role"], useUtilityClasses$1 = ($) => {
  const {
    classes: ee
  } = $;
  return composeClasses({
    root: ["root"],
    action: ["action"],
    message: ["message"]
  }, getSnackbarContentUtilityClass, ee);
}, SnackbarContentRoot = styled(Paper$1, {
  name: "MuiSnackbarContent",
  slot: "Root",
  overridesResolver: ($, ee) => ee.root
})(({
  theme: $
}) => {
  const ee = $.palette.mode === "light" ? 0.8 : 0.98, te = emphasize_1($.palette.background.default, ee);
  return _extends$4({}, $.typography.body2, {
    color: $.vars ? $.vars.palette.SnackbarContent.color : $.palette.getContrastText(te),
    backgroundColor: $.vars ? $.vars.palette.SnackbarContent.bg : te,
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    borderRadius: ($.vars || $).shape.borderRadius,
    flexGrow: 1,
    [$.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  });
}), SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message",
  overridesResolver: ($, ee) => ee.message
})({
  padding: "8px 0"
}), SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action",
  overridesResolver: ($, ee) => ee.action
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
}), SnackbarContent = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiSnackbarContent"
  }), {
    action: re,
    className: se,
    message: ie,
    role: oe = "alert"
  } = ne, le = _objectWithoutPropertiesLoose$1(ne, _excluded$1), ue = ne, de = useUtilityClasses$1(ue);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, _extends$4({
    role: oe,
    square: !0,
    elevation: 6,
    className: clsx(de.root, se),
    ownerState: ue,
    ref: te
  }, le, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: de.message,
      ownerState: ue,
      children: ie
    }), re ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: de.action,
      ownerState: ue,
      children: re
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (SnackbarContent.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The action to display. It renders after the message, at the end of the snackbar.
   */
  action: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The message to display.
   */
  message: PropTypes.node,
  /**
   * The ARIA role attribute of the element.
   * @default 'alert'
   */
  role: PropTypes.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
});
const SnackbarContent$1 = SnackbarContent;
function getSnackbarUtilityClass($) {
  return generateUtilityClass("MuiSnackbar", $);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const _excluded = ["onEnter", "onExited"], _excluded2 = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"], useUtilityClasses = ($) => {
  const {
    classes: ee,
    anchorOrigin: te
  } = $, ne = {
    root: ["root", `anchorOrigin${capitalize$1(te.vertical)}${capitalize$1(te.horizontal)}`]
  };
  return composeClasses(ne, getSnackbarUtilityClass, ee);
}, SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: ($, ee) => {
    const {
      ownerState: te
    } = $;
    return [ee.root, ee[`anchorOrigin${capitalize$1(te.anchorOrigin.vertical)}${capitalize$1(te.anchorOrigin.horizontal)}`]];
  }
})(({
  theme: $,
  ownerState: ee
}) => {
  const te = {
    left: "50%",
    right: "auto",
    transform: "translateX(-50%)"
  };
  return _extends$4({
    zIndex: ($.vars || $).zIndex.snackbar,
    position: "fixed",
    display: "flex",
    left: 8,
    right: 8,
    justifyContent: "center",
    alignItems: "center"
  }, ee.anchorOrigin.vertical === "top" ? {
    top: 8
  } : {
    bottom: 8
  }, ee.anchorOrigin.horizontal === "left" && {
    justifyContent: "flex-start"
  }, ee.anchorOrigin.horizontal === "right" && {
    justifyContent: "flex-end"
  }, {
    [$.breakpoints.up("sm")]: _extends$4({}, ee.anchorOrigin.vertical === "top" ? {
      top: 24
    } : {
      bottom: 24
    }, ee.anchorOrigin.horizontal === "center" && te, ee.anchorOrigin.horizontal === "left" && {
      left: 24,
      right: "auto"
    }, ee.anchorOrigin.horizontal === "right" && {
      right: 24,
      left: "auto"
    })
  });
}), Snackbar = /* @__PURE__ */ React.forwardRef(function $(ee, te) {
  const ne = useThemeProps$1({
    props: ee,
    name: "MuiSnackbar"
  }), re = useTheme(), se = {
    enter: re.transitions.duration.enteringScreen,
    exit: re.transitions.duration.leavingScreen
  }, {
    action: ie,
    anchorOrigin: {
      vertical: oe,
      horizontal: le
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration: ue = null,
    children: de,
    className: fe,
    ClickAwayListenerProps: pe,
    ContentProps: ye,
    disableWindowBlurListener: me = !1,
    message: ve,
    open: ge,
    TransitionComponent: xe = Grow$1,
    transitionDuration: Ee = se,
    TransitionProps: {
      onEnter: Te,
      onExited: Se
    } = {}
  } = ne, he = _objectWithoutPropertiesLoose$1(ne.TransitionProps, _excluded), Pe = _objectWithoutPropertiesLoose$1(ne, _excluded2), Ie = _extends$4({}, ne, {
    anchorOrigin: {
      vertical: oe,
      horizontal: le
    },
    autoHideDuration: ue,
    disableWindowBlurListener: me,
    TransitionComponent: xe,
    transitionDuration: Ee
  }), De = useUtilityClasses(Ie), {
    getRootProps: Ce,
    onClickAway: Ne
  } = useSnackbar(_extends$4({}, Ie)), [Me, Be] = React.useState(!0), We = useSlotProps({
    elementType: SnackbarRoot,
    getSlotProps: Ce,
    externalForwardedProps: Pe,
    ownerState: Ie,
    additionalProps: {
      ref: te
    },
    className: [De.root, fe]
  }), Le = (Ge) => {
    Be(!0), Se && Se(Ge);
  }, He = (Ge, Ze) => {
    Be(!1), Te && Te(Ge, Ze);
  };
  return !ge && Me ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, _extends$4({
    onClickAway: Ne
  }, pe, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarRoot, _extends$4({}, We, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(xe, _extends$4({
        appear: !0,
        in: ge,
        timeout: Ee,
        direction: oe === "top" ? "down" : "up",
        onEnter: He,
        onExited: Le
      }, he, {
        children: de || /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContent$1, _extends$4({
          message: ve,
          action: ie
        }, ye))
      }))
    }))
  }));
});
process.env.NODE_ENV !== "production" && (Snackbar.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The action to display. It renders after the message, at the end of the snackbar.
   */
  action: PropTypes.node,
  /**
   * The anchor of the `Snackbar`.
   * On smaller screens, the component grows to occupy all the available width,
   * the horizontal alignment is ignored.
   * @default { vertical: 'bottom', horizontal: 'left' }
   */
  anchorOrigin: PropTypes.shape({
    horizontal: PropTypes.oneOf(["center", "left", "right"]).isRequired,
    vertical: PropTypes.oneOf(["bottom", "top"]).isRequired
  }),
  /**
   * The number of milliseconds to wait before automatically calling the
   * `onClose` function. `onClose` should then set the state of the `open`
   * prop to hide the Snackbar. This behavior is disabled by default with
   * the `null` value.
   * @default null
   */
  autoHideDuration: PropTypes.number,
  /**
   * Replace the `SnackbarContent` component.
   */
  children: PropTypes.element,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * Props applied to the `ClickAwayListener` element.
   */
  ClickAwayListenerProps: PropTypes.object,
  /**
   * Props applied to the [`SnackbarContent`](/material-ui/api/snackbar-content/) element.
   */
  ContentProps: PropTypes.object,
  /**
   * If `true`, the `autoHideDuration` timer will expire even if the window is not focused.
   * @default false
   */
  disableWindowBlurListener: PropTypes.bool,
  /**
   * When displaying multiple consecutive snackbars using a single parent-rendered
   * `<Snackbar/>`, add the `key` prop to ensure independent treatment of each message.
   * For instance, use `<Snackbar key={message} />`. Otherwise, messages might update
   * in place, and features like `autoHideDuration` could be affected.
   */
  key: () => null,
  /**
   * The message to display.
   */
  message: PropTypes.node,
  /**
   * @ignore
   */
  onBlur: PropTypes.func,
  /**
   * Callback fired when the component requests to be closed.
   * Typically `onClose` is used to set state in the parent component,
   * which is used to control the `Snackbar` `open` prop.
   * The `reason` parameter can optionally be used to control the response to `onClose`,
   * for example ignoring `clickaway`.
   *
   * @param {React.SyntheticEvent<any> | Event} event The event source of the callback.
   * @param {string} reason Can be: `"timeout"` (`autoHideDuration` expired), `"clickaway"`, or `"escapeKeyDown"`.
   */
  onClose: PropTypes.func,
  /**
   * @ignore
   */
  onFocus: PropTypes.func,
  /**
   * @ignore
   */
  onMouseEnter: PropTypes.func,
  /**
   * @ignore
   */
  onMouseLeave: PropTypes.func,
  /**
   * If `true`, the component is shown.
   */
  open: PropTypes.bool,
  /**
   * The number of milliseconds to wait before dismissing after user interaction.
   * If `autoHideDuration` prop isn't specified, it does nothing.
   * If `autoHideDuration` prop is specified but `resumeHideDuration` isn't,
   * we default to `autoHideDuration / 2` ms.
   */
  resumeHideDuration: PropTypes.number,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: PropTypes.elementType,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    appear: PropTypes.number,
    enter: PropTypes.number,
    exit: PropTypes.number
  })]),
  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
   * @default {}
   */
  TransitionProps: PropTypes.object
});
const Snackbar$1 = Snackbar, LMFeedTopicSelectionTile = memo(
  ({ topic: $, checkedList: ee, clickHandler: te }) => {
    const ne = () => {
      te($);
    }, re = ee.some((se) => se.Id === $.Id);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-topic-dropdown__topic", onClick: ne, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox$1,
        {
          disableRipple: !0,
          checked: re,
          className: "lm-topic-checkbox"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "lm-topic-name-container", children: $.name })
    ] });
  }
), lmCancelIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20opacity='0.01'%20width='20'%20height='20'%20fill='white'/%3e%3cpath%20d='M5.92578%205.9259L14.6555%2014.11L5.92578%205.9259Z'%20fill='%235046E5'/%3e%3cpath%20d='M5.92578%205.9259L14.6555%2014.11'%20stroke='%235046E5'/%3e%3cpath%20d='M14.6555%205.9259L5.92578%2014.11L14.6555%205.9259Z'%20fill='%235046E5'/%3e%3cpath%20d='M14.6555%205.9259L5.92578%2014.11'%20stroke='%235046E5'/%3e%3c/svg%3e", LMFeedTopicSelectedBlock = ({
  topic: $,
  onDeleteClick: ee,
  isCreateMode: te
}) => {
  const { name: ne } = $;
  switch (te) {
    case !0:
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-float-left lm-mr-3 lm-feed-topic-tile-create lm-d-flex lm-align-items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ne }) });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-feed-topic-tile", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ne }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => ee($), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: lmCancelIcon,
            alt: "cross-icon",
            className: "lm-cursor-pointer"
          }
        ) })
      ] });
  }
}, POST = "post", EDITED = "edited", LIKE = "like", LIKES = "likes", COMMNENT = "comment", COMMNENTS = "comments", ALL_TOPICS = "all topics", DEFAULT_PAGE_SIZE = 10, CREATE_POST = "Create Post", EDIT_POST = "Edit Post", MEMBER_LIST = "Member List", PHOTO = "photo", VIDEO = "video", PDF = "pdf", downArrowIcon = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_2716_147211)'%3e%3cpath%20d='M8.52616%2015.7821L13.2875%2011.0208C13.578%2010.7303%2013.578%2010.2591%2013.2875%209.96863C12.9969%209.67807%2012.5259%209.67807%2012.2354%209.96863L8.74405%2013.4599V0.743959C8.74405%200.333115%208.41093%200%208.00009%200C7.5893%200%207.25613%200.333115%207.25613%200.743959L7.25613%2013.4599L3.76482%209.96875C3.47426%209.67819%203.00324%209.67819%202.71268%209.96875C2.56752%2010.114%202.49479%2010.3044%202.49479%2010.4948C2.49479%2010.6852%202.56752%2010.8756%202.71268%2011.0209L7.47402%2015.7821C7.76458%2016.0727%208.2356%2016.0727%208.52616%2015.7821Z'%20fill='%23666666'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_2716_147211'%3e%3crect%20width='16'%20height='16'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", topicSearchIcon = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.3833%2012.8767C7.76953%2012.8767%209.04785%2012.4285%2010.0938%2011.6814L14.0283%2015.616C14.2109%2015.7986%2014.4517%2015.8899%2014.709%2015.8899C15.2485%2015.8899%2015.6304%2015.4749%2015.6304%2014.9436C15.6304%2014.6946%2015.5474%2014.4539%2015.3647%2014.2795L11.4551%2010.3616C12.2769%209.28247%2012.7666%207.94604%2012.7666%206.49341C12.7666%202.98218%209.89453%200.110107%206.3833%200.110107C2.88037%200.110107%200%202.97388%200%206.49341C0%2010.0046%202.87207%2012.8767%206.3833%2012.8767ZM6.3833%2011.4988C3.64404%2011.4988%201.37793%209.23267%201.37793%206.49341C1.37793%203.75415%203.64404%201.48804%206.3833%201.48804C9.12256%201.48804%2011.3887%203.75415%2011.3887%206.49341C11.3887%209.23267%209.12256%2011.4988%206.3833%2011.4988Z'%20fill='%233C3C43'%20fill-opacity='0.6'/%3e%3c/svg%3e", LMFeedViewTopicDropdown = ({
  mode: $,
  setSelectedTopicsIds: ee,
  selectedTopicIds: te,
  preSelectedTopics: ne,
  setPreSelectedTopics: re
}) => {
  const {
    checkedTopics: se,
    topics: ie,
    loadNewTopics: oe,
    getNextPage: le,
    searchKey: ue,
    setSearchKey: de,
    updateCheckedTopics: fe,
    clearAllCheckedTopics: pe,
    topicComponentClickCustomCallback: ye
  } = useTopicDropdown(
    te,
    ee,
    ne,
    re,
    $
  ), [me, ve] = useState(
    !(ne != null && ne.length)
  ), [ge, xe] = useState(
    null
  ), Ee = (Ce) => {
    xe(Ce.currentTarget);
  }, Te = () => {
    se.length && ve(!1), ee && ee(se.map((Ce) => Ce.Id)), xe(null);
  }, Se = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-topic-dropdown__search", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: topicSearchIcon, alt: "Topic search" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        className: "lm-topic-search-box",
        placeholder: "Search",
        value: ue,
        onChange: (Ce) => {
          de(Ce.target.value);
        }
      }
    )
  ] }), he = useMemo(() => ie.map((Ce) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuItem$1,
    {
      disableRipple: !0,
      value: Ce.Id,
      role: "option",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        LMFeedTopicSelectionTile,
        {
          clickHandler: fe,
          topic: Ce,
          checkedList: se
        }
      )
    },
    Ce.Id
  )), [se, ie, fe]), Pe = () => {
    switch ($) {
      case LMTopicsDropdownMode.modify:
      case LMTopicsDropdownMode.edit:
        return De();
      case LMTopicsDropdownMode.view:
        return Ie();
    }
  }, Ie = () => {
    switch (me) {
      case !0:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-topic-btn-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: Ee, className: "lm-all-topic-button", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ALL_TOPICS }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: downArrowIcon, alt: "down arrow icon", loading: "lazy" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Menu$1,
            {
              anchorEl: ge,
              open: !!ge,
              onClose: Te,
              anchorOrigin: {
                horizontal: "left",
                vertical: "bottom"
              },
              slotProps: {
                paper: {
                  id: "scrollerTopics",
                  sx: {
                    height: "300px",
                    borderRadius: "8px",
                    overflow: "auto"
                  }
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                InfiniteScroll,
                {
                  next: le,
                  hasMore: oe,
                  loader: null,
                  dataLength: ie.length,
                  scrollableTarget: "scrollerTopics",
                  children: [
                    Se,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MenuItem$1,
                      {
                        disableRipple: !0,
                        role: "option",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            className: "lm-topic-dropdown__topic lm-all-topic",
                            onClick: pe,
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Checkbox$1,
                                {
                                  disableRipple: !0,
                                  checked: !se.length,
                                  className: "lm-topic-checkbox"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "All Topics" })
                            ]
                          }
                        )
                      },
                      Math.random()
                    ),
                    he
                  ]
                }
              )
            }
          )
        ] });
      case !1:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmSelectedTopics", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmSelectedTopics__tags", children: se.map((Ce) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            LMFeedTopicSelectedBlock,
            {
              onDeleteClick: () => {
                fe(Ce), se.length === 1 && ve(!0);
              },
              topic: Ce
            },
            Ce.Id
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lmSelectedTopics--clear",
              onClick: () => {
                pe(), ve(!0);
              },
              children: "Clear"
            }
          )
        ] });
    }
  }, De = function() {
    switch (me) {
      case !0:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: Ee,
              className: "lm-post-creation-all-topic-button",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    width: "16",
                    height: "16",
                    viewBox: "0 0 16 16",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        d: "M2 8C2 8.16537 2.05939 8.30749 2.17818 8.42636C2.29697 8.54005 2.43641 8.5969 2.59651 8.5969H7.40736V13.4109C7.40736 13.5711 7.46417 13.708 7.57779 13.8217C7.69658 13.9406 7.83861 14 8.00387 14C8.16398 14 8.30084 13.9406 8.41446 13.8217C8.52808 13.708 8.58489 13.5711 8.58489 13.4109V8.5969H13.4112C13.5713 8.5969 13.7082 8.54005 13.8218 8.42636C13.9406 8.30749 14 8.16537 14 8C14 7.83979 13.9406 7.70284 13.8218 7.58915C13.7082 7.47028 13.5713 7.41085 13.4112 7.41085H8.58489V2.58915C8.58489 2.43411 8.52808 2.29716 8.41446 2.17829C8.30084 2.05943 8.16398 2 8.00387 2C7.83861 2 7.69658 2.05943 7.57779 2.17829C7.46417 2.29716 7.40736 2.43411 7.40736 2.58915V7.41085H2.59651C2.43641 7.41085 2.29697 7.47028 2.17818 7.58915C2.05939 7.70284 2 7.83979 2 8Z",
                        fill: "#5046E5"
                      }
                    )
                  }
                ),
                "Select Topics",
                " "
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Menu$1,
            {
              anchorEl: ge,
              open: !!ge,
              onClose: Te,
              anchorOrigin: {
                horizontal: "left",
                vertical: "bottom"
              },
              slotProps: {
                paper: {
                  sx: {
                    height: "284px",
                    marginTop: "6px",
                    borderRadius: "8px",
                    paddingTop: "0px"
                  },
                  id: "scrollerTopics"
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                InfiniteScroll,
                {
                  next: le,
                  hasMore: oe,
                  loader: null,
                  dataLength: ie.length,
                  scrollableTarget: "scrollerTopics",
                  children: [
                    Se,
                    he
                  ]
                }
              )
            }
          )
        ] });
      case !1:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-display-selected-topics-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Menu$1,
            {
              anchorEl: ge,
              open: !!ge,
              onClose: Te,
              anchorOrigin: {
                horizontal: "left",
                vertical: "bottom"
              },
              slotProps: {
                paper: {
                  sx: {
                    height: "284px",
                    marginTop: "6px",
                    borderRadius: "8px",
                    paddingTop: "0px"
                  },
                  id: "scrollerTopics"
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                InfiniteScroll,
                {
                  next: le,
                  hasMore: oe,
                  loader: null,
                  dataLength: ie.length,
                  scrollableTarget: "scrollerTopics",
                  children: [
                    Se,
                    he
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-topic-tags-container", children: [
            se.map((Ce) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              LMFeedTopicSelectedBlock,
              {
                isCreateMode: !0,
                onDeleteClick: fe,
                topic: Ce
              },
              Ce.Id
            )),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-edit-topics-icon", onClick: Ee, children: [
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  width: "20",
                  height: "20",
                  viewBox: "0 0 20 20",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      fillRule: "evenodd",
                      clipRule: "evenodd",
                      d: "M15.754 5.41104L14.6656 4.31708C14.245 3.89431 13.5619 3.89431 13.1399 4.31708L12.0973 5.36498L14.5379 7.81801L15.754 6.59569C16.0803 6.26776 16.0803 5.73894 15.754 5.41104ZM11.4615 6.00267L13.9021 8.45567L7.72422 14.665L5.285 12.212L11.4615 6.00267ZM4.34375 15.9919C4.14383 16.0408 3.96335 15.8608 4.00777 15.6599L4.62417 12.8762L7.06339 15.3292L4.34375 15.9919Z",
                      fill: "#5046E5"
                    }
                  )
                }
              )
            ] })
          ] })
        ] });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      onClick: (Ce) => {
        ye && ye(Ce);
      },
      "lm-feed-component-id": "lm-feed-topic-dropdown-rstuw",
      children: Pe()
    }
  );
}, FeedPostContext = React__default.createContext({
  post: null,
  topics: null,
  users: null
});
var relativeTime$1 = { exports: {} };
(function($, ee) {
  (function(te, ne) {
    $.exports = ne();
  })(commonjsGlobal, function() {
    return function(te, ne, re) {
      te = te || {};
      var se = ne.prototype, ie = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function oe(ue, de, fe, pe) {
        return se.fromToBase(ue, de, fe, pe);
      }
      re.en.relativeTime = ie, se.fromToBase = function(ue, de, fe, pe, ye) {
        for (var me, ve, ge, xe = fe.$locale().relativeTime || ie, Ee = te.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], Te = Ee.length, Se = 0; Se < Te; Se += 1) {
          var he = Ee[Se];
          he.d && (me = pe ? re(ue).diff(fe, he.d, !0) : fe.diff(ue, he.d, !0));
          var Pe = (te.rounding || Math.round)(Math.abs(me));
          if (ge = me > 0, Pe <= he.r || !he.r) {
            Pe <= 1 && Se > 0 && (he = Ee[Se - 1]);
            var Ie = xe[he.l];
            ye && (Pe = ye("" + Pe)), ve = typeof Ie == "string" ? Ie.replace("%d", Pe) : Ie(Pe, de, he.l, ge);
            break;
          }
        }
        if (de)
          return ve;
        var De = ge ? xe.future : xe.past;
        return typeof De == "function" ? De(ve) : De.replace("%s", ve);
      }, se.to = function(ue, de) {
        return oe(ue, de, this, !0);
      }, se.from = function(ue, de) {
        return oe(ue, de, this);
      };
      var le = function(ue) {
        return ue.$u ? re.utc() : re();
      };
      se.toNow = function(ue) {
        return this.to(le(this), ue);
      }, se.fromNow = function(ue) {
        return this.from(le(this), ue);
      };
    };
  });
})(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
var dayjs_min = { exports: {} };
(function($, ee) {
  (function(te, ne) {
    $.exports = ne();
  })(commonjsGlobal, function() {
    var te = 1e3, ne = 6e4, re = 36e5, se = "millisecond", ie = "second", oe = "minute", le = "hour", ue = "day", de = "week", fe = "month", pe = "quarter", ye = "year", me = "date", ve = "Invalid Date", ge = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, xe = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, Ee = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(Le) {
      var He = ["th", "st", "nd", "rd"], Ge = Le % 100;
      return "[" + Le + (He[(Ge - 20) % 10] || He[Ge] || He[0]) + "]";
    } }, Te = function(Le, He, Ge) {
      var Ze = String(Le);
      return !Ze || Ze.length >= He ? Le : "" + Array(He + 1 - Ze.length).join(Ge) + Le;
    }, Se = { s: Te, z: function(Le) {
      var He = -Le.utcOffset(), Ge = Math.abs(He), Ze = Math.floor(Ge / 60), Ue = Ge % 60;
      return (He <= 0 ? "+" : "-") + Te(Ze, 2, "0") + ":" + Te(Ue, 2, "0");
    }, m: function Le(He, Ge) {
      if (He.date() < Ge.date())
        return -Le(Ge, He);
      var Ze = 12 * (Ge.year() - He.year()) + (Ge.month() - He.month()), Ue = He.clone().add(Ze, fe), Qe = Ge - Ue < 0, Je = He.clone().add(Ze + (Qe ? -1 : 1), fe);
      return +(-(Ze + (Ge - Ue) / (Qe ? Ue - Je : Je - Ue)) || 0);
    }, a: function(Le) {
      return Le < 0 ? Math.ceil(Le) || 0 : Math.floor(Le);
    }, p: function(Le) {
      return { M: fe, y: ye, w: de, d: ue, D: me, h: le, m: oe, s: ie, ms: se, Q: pe }[Le] || String(Le || "").toLowerCase().replace(/s$/, "");
    }, u: function(Le) {
      return Le === void 0;
    } }, he = "en", Pe = {};
    Pe[he] = Ee;
    var Ie = "$isDayjsObject", De = function(Le) {
      return Le instanceof Be || !(!Le || !Le[Ie]);
    }, Ce = function Le(He, Ge, Ze) {
      var Ue;
      if (!He)
        return he;
      if (typeof He == "string") {
        var Qe = He.toLowerCase();
        Pe[Qe] && (Ue = Qe), Ge && (Pe[Qe] = Ge, Ue = Qe);
        var Je = He.split("-");
        if (!Ue && Je.length > 1)
          return Le(Je[0]);
      } else {
        var Ot = He.name;
        Pe[Ot] = He, Ue = Ot;
      }
      return !Ze && Ue && (he = Ue), Ue || !Ze && he;
    }, Ne = function(Le, He) {
      if (De(Le))
        return Le.clone();
      var Ge = typeof He == "object" ? He : {};
      return Ge.date = Le, Ge.args = arguments, new Be(Ge);
    }, Me = Se;
    Me.l = Ce, Me.i = De, Me.w = function(Le, He) {
      return Ne(Le, { locale: He.$L, utc: He.$u, x: He.$x, $offset: He.$offset });
    };
    var Be = function() {
      function Le(Ge) {
        this.$L = Ce(Ge.locale, null, !0), this.parse(Ge), this.$x = this.$x || Ge.x || {}, this[Ie] = !0;
      }
      var He = Le.prototype;
      return He.parse = function(Ge) {
        this.$d = function(Ze) {
          var Ue = Ze.date, Qe = Ze.utc;
          if (Ue === null)
            return /* @__PURE__ */ new Date(NaN);
          if (Me.u(Ue))
            return /* @__PURE__ */ new Date();
          if (Ue instanceof Date)
            return new Date(Ue);
          if (typeof Ue == "string" && !/Z$/i.test(Ue)) {
            var Je = Ue.match(ge);
            if (Je) {
              var Ot = Je[2] - 1 || 0, At = (Je[7] || "0").substring(0, 3);
              return Qe ? new Date(Date.UTC(Je[1], Ot, Je[3] || 1, Je[4] || 0, Je[5] || 0, Je[6] || 0, At)) : new Date(Je[1], Ot, Je[3] || 1, Je[4] || 0, Je[5] || 0, Je[6] || 0, At);
            }
          }
          return new Date(Ue);
        }(Ge), this.init();
      }, He.init = function() {
        var Ge = this.$d;
        this.$y = Ge.getFullYear(), this.$M = Ge.getMonth(), this.$D = Ge.getDate(), this.$W = Ge.getDay(), this.$H = Ge.getHours(), this.$m = Ge.getMinutes(), this.$s = Ge.getSeconds(), this.$ms = Ge.getMilliseconds();
      }, He.$utils = function() {
        return Me;
      }, He.isValid = function() {
        return this.$d.toString() !== ve;
      }, He.isSame = function(Ge, Ze) {
        var Ue = Ne(Ge);
        return this.startOf(Ze) <= Ue && Ue <= this.endOf(Ze);
      }, He.isAfter = function(Ge, Ze) {
        return Ne(Ge) < this.startOf(Ze);
      }, He.isBefore = function(Ge, Ze) {
        return this.endOf(Ze) < Ne(Ge);
      }, He.$g = function(Ge, Ze, Ue) {
        return Me.u(Ge) ? this[Ze] : this.set(Ue, Ge);
      }, He.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, He.valueOf = function() {
        return this.$d.getTime();
      }, He.startOf = function(Ge, Ze) {
        var Ue = this, Qe = !!Me.u(Ze) || Ze, Je = Me.p(Ge), Ot = function($e, qe) {
          var Ye = Me.w(Ue.$u ? Date.UTC(Ue.$y, qe, $e) : new Date(Ue.$y, qe, $e), Ue);
          return Qe ? Ye : Ye.endOf(ue);
        }, At = function($e, qe) {
          return Me.w(Ue.toDate()[$e].apply(Ue.toDate("s"), (Qe ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(qe)), Ue);
        }, ze = this.$W, we = this.$M, Ae = this.$D, Re = "set" + (this.$u ? "UTC" : "");
        switch (Je) {
          case ye:
            return Qe ? Ot(1, 0) : Ot(31, 11);
          case fe:
            return Qe ? Ot(1, we) : Ot(0, we + 1);
          case de:
            var je = this.$locale().weekStart || 0, Fe = (ze < je ? ze + 7 : ze) - je;
            return Ot(Qe ? Ae - Fe : Ae + (6 - Fe), we);
          case ue:
          case me:
            return At(Re + "Hours", 0);
          case le:
            return At(Re + "Minutes", 1);
          case oe:
            return At(Re + "Seconds", 2);
          case ie:
            return At(Re + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, He.endOf = function(Ge) {
        return this.startOf(Ge, !1);
      }, He.$set = function(Ge, Ze) {
        var Ue, Qe = Me.p(Ge), Je = "set" + (this.$u ? "UTC" : ""), Ot = (Ue = {}, Ue[ue] = Je + "Date", Ue[me] = Je + "Date", Ue[fe] = Je + "Month", Ue[ye] = Je + "FullYear", Ue[le] = Je + "Hours", Ue[oe] = Je + "Minutes", Ue[ie] = Je + "Seconds", Ue[se] = Je + "Milliseconds", Ue)[Qe], At = Qe === ue ? this.$D + (Ze - this.$W) : Ze;
        if (Qe === fe || Qe === ye) {
          var ze = this.clone().set(me, 1);
          ze.$d[Ot](At), ze.init(), this.$d = ze.set(me, Math.min(this.$D, ze.daysInMonth())).$d;
        } else
          Ot && this.$d[Ot](At);
        return this.init(), this;
      }, He.set = function(Ge, Ze) {
        return this.clone().$set(Ge, Ze);
      }, He.get = function(Ge) {
        return this[Me.p(Ge)]();
      }, He.add = function(Ge, Ze) {
        var Ue, Qe = this;
        Ge = Number(Ge);
        var Je = Me.p(Ze), Ot = function(we) {
          var Ae = Ne(Qe);
          return Me.w(Ae.date(Ae.date() + Math.round(we * Ge)), Qe);
        };
        if (Je === fe)
          return this.set(fe, this.$M + Ge);
        if (Je === ye)
          return this.set(ye, this.$y + Ge);
        if (Je === ue)
          return Ot(1);
        if (Je === de)
          return Ot(7);
        var At = (Ue = {}, Ue[oe] = ne, Ue[le] = re, Ue[ie] = te, Ue)[Je] || 1, ze = this.$d.getTime() + Ge * At;
        return Me.w(ze, this);
      }, He.subtract = function(Ge, Ze) {
        return this.add(-1 * Ge, Ze);
      }, He.format = function(Ge) {
        var Ze = this, Ue = this.$locale();
        if (!this.isValid())
          return Ue.invalidDate || ve;
        var Qe = Ge || "YYYY-MM-DDTHH:mm:ssZ", Je = Me.z(this), Ot = this.$H, At = this.$m, ze = this.$M, we = Ue.weekdays, Ae = Ue.months, Re = Ue.meridiem, je = function(qe, Ye, Ke, Tt) {
          return qe && (qe[Ye] || qe(Ze, Qe)) || Ke[Ye].slice(0, Tt);
        }, Fe = function(qe) {
          return Me.s(Ot % 12 || 12, qe, "0");
        }, $e = Re || function(qe, Ye, Ke) {
          var Tt = qe < 12 ? "AM" : "PM";
          return Ke ? Tt.toLowerCase() : Tt;
        };
        return Qe.replace(xe, function(qe, Ye) {
          return Ye || function(Ke) {
            switch (Ke) {
              case "YY":
                return String(Ze.$y).slice(-2);
              case "YYYY":
                return Me.s(Ze.$y, 4, "0");
              case "M":
                return ze + 1;
              case "MM":
                return Me.s(ze + 1, 2, "0");
              case "MMM":
                return je(Ue.monthsShort, ze, Ae, 3);
              case "MMMM":
                return je(Ae, ze);
              case "D":
                return Ze.$D;
              case "DD":
                return Me.s(Ze.$D, 2, "0");
              case "d":
                return String(Ze.$W);
              case "dd":
                return je(Ue.weekdaysMin, Ze.$W, we, 2);
              case "ddd":
                return je(Ue.weekdaysShort, Ze.$W, we, 3);
              case "dddd":
                return we[Ze.$W];
              case "H":
                return String(Ot);
              case "HH":
                return Me.s(Ot, 2, "0");
              case "h":
                return Fe(1);
              case "hh":
                return Fe(2);
              case "a":
                return $e(Ot, At, !0);
              case "A":
                return $e(Ot, At, !1);
              case "m":
                return String(At);
              case "mm":
                return Me.s(At, 2, "0");
              case "s":
                return String(Ze.$s);
              case "ss":
                return Me.s(Ze.$s, 2, "0");
              case "SSS":
                return Me.s(Ze.$ms, 3, "0");
              case "Z":
                return Je;
            }
            return null;
          }(qe) || Je.replace(":", "");
        });
      }, He.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, He.diff = function(Ge, Ze, Ue) {
        var Qe, Je = this, Ot = Me.p(Ze), At = Ne(Ge), ze = (At.utcOffset() - this.utcOffset()) * ne, we = this - At, Ae = function() {
          return Me.m(Je, At);
        };
        switch (Ot) {
          case ye:
            Qe = Ae() / 12;
            break;
          case fe:
            Qe = Ae();
            break;
          case pe:
            Qe = Ae() / 3;
            break;
          case de:
            Qe = (we - ze) / 6048e5;
            break;
          case ue:
            Qe = (we - ze) / 864e5;
            break;
          case le:
            Qe = we / re;
            break;
          case oe:
            Qe = we / ne;
            break;
          case ie:
            Qe = we / te;
            break;
          default:
            Qe = we;
        }
        return Ue ? Qe : Me.a(Qe);
      }, He.daysInMonth = function() {
        return this.endOf(fe).$D;
      }, He.$locale = function() {
        return Pe[this.$L];
      }, He.locale = function(Ge, Ze) {
        if (!Ge)
          return this.$L;
        var Ue = this.clone(), Qe = Ce(Ge, Ze, !0);
        return Qe && (Ue.$L = Qe), Ue;
      }, He.clone = function() {
        return Me.w(this.$d, this);
      }, He.toDate = function() {
        return new Date(this.valueOf());
      }, He.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, He.toISOString = function() {
        return this.$d.toISOString();
      }, He.toString = function() {
        return this.$d.toUTCString();
      }, Le;
    }(), We = Be.prototype;
    return Ne.prototype = We, [["$ms", se], ["$s", ie], ["$m", oe], ["$H", le], ["$W", ue], ["$M", fe], ["$y", ye], ["$D", me]].forEach(function(Le) {
      We[Le[1]] = function(He) {
        return this.$g(He, Le[0], Le[1]);
      };
    }), Ne.extend = function(Le, He) {
      return Le.$i || (Le(He, Be, Ne), Le.$i = !0), Ne;
    }, Ne.locale = Ce, Ne.isDayjs = De, Ne.unix = function(Le) {
      return Ne(1e3 * Le);
    }, Ne.en = Pe[he], Ne.Ls = Pe, Ne.p = {}, Ne;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
dayjs.extend(relativeTime);
const formatTimeAgo = ($) => {
  const te = Date.now() - $, ne = Math.floor(te / 1e3), re = Math.floor(ne / 60), se = Math.floor(re / 60), ie = Math.floor(se / 24), oe = Math.floor(ie / 30), le = Math.floor(oe / 12);
  return le > 0 ? `${le} ${le === 1 ? "year" : "years"} ago` : oe > 0 ? `${oe} ${oe === 1 ? "month" : "months"} ago` : ie > 0 ? `${ie} ${ie === 1 ? "day" : "days"} ago` : se > 0 ? `${se} ${se === 1 ? "hour" : "hours"} ago` : `${re} ${re === 1 ? "minute" : "minutes"} ago`;
}, truncateString = ($, ee) => ($ || ($ = ""), ($ == null ? void 0 : $.length) <= ee ? $ : $.substring(0, ee) + "..."), formatFileSize = ($) => $ < 1024 ? $ + " Bytes" : $ < 1024 * 1024 ? ($ / 1024).toFixed(2) + " KB" : $ < 1024 * 1024 * 1024 ? ($ / (1024 * 1024)).toFixed(2) + " MB" : ($ / (1024 * 1024 * 1024)).toFixed(2) + " GB";
function getCharacterWidth($) {
  const ee = "Roboto", re = document.createElement("canvas").getContext("2d");
  return re ? (re.font = `16px ${ee}`, re.measureText($).width) : 0;
}
const getCaretPosition = () => {
  const $ = window.getSelection(), ee = $ == null ? void 0 : $.focusNode;
  let te = 0;
  if (window.getSelection() && $ != null && $.rangeCount && $.rangeCount > 0) {
    const ne = $.getRangeAt(0), re = ne.cloneRange();
    re.selectNodeContents(ee), re.setEnd(ne.endContainer, ne.endOffset), te = re.toString().length;
  }
  return te;
};
function checkAtSymbol($, ee) {
  if (ee < 0 || ee >= $.length)
    return -1;
  let te = -1;
  for (let ne = ee; ne >= 0; ne--)
    if ($[ne] === "@") {
      te = ne;
      break;
    }
  return te === -1 ? -1 : te === 0 ? 1 : te > 0 && /\s/.test($[te - 1]) ? te + 1 : -1;
}
function findSpaceAfterIndex($, ee) {
  if (ee < 0 || ee >= $.length)
    throw new Error("Invalid index");
  let te = -1;
  for (let ne = ee + 1; ne < $.length; ne++)
    if ($[ne] === " ") {
      te = ne - 1;
      break;
    } else if ($[ne] === "@") {
      te = ne - 1;
      break;
    }
  return te === -1 ? $.length - 1 : te;
}
function findTag($) {
  if ($.length === 0)
    return;
  const ee = getCaretPosition(), te = checkAtSymbol($, ee - 1);
  if (te === -1)
    return;
  const ne = findSpaceAfterIndex($, ee - 1);
  return {
    tagString: $.substring(te, ne + 1),
    limitLeft: te,
    limitRight: ne
  };
}
function returnCSSForTagging($) {
  var ie, oe, le, ue, de;
  if (!($ && $.current))
    return;
  const ee = window.getSelection();
  if (!ee)
    return;
  const te = {
    left: "0px",
    position: "absolute",
    top: "0px"
  };
  if (ee === null)
    return {};
  const ne = (oe = (ie = ee.focusNode) == null ? void 0 : ie.parentElement) == null ? void 0 : oe.getBoundingClientRect();
  te.top = (ne.top - $.current.getBoundingClientRect().top + 30).toString().concat("px");
  const re = (de = (ue = (le = ee.focusNode) == null ? void 0 : le.parentElement) == null ? void 0 : ue.textContent) == null ? void 0 : de.substring(
    0,
    ee.focusOffset - 1
  ), se = getCharacterWidth(re);
  return se > 264 ? te.left = "264px" : te.left = se, te.position = "absolute", te;
}
function setCursorAtEnd($) {
  if (!$.current)
    return;
  const ee = document.createRange(), te = window.getSelection();
  ee.selectNodeContents($.current), ee.collapse(!1), te && (te.removeAllRanges(), te.addRange(ee)), $.current.focus();
}
function extractTextFromNode($) {
  if ($.nodeType === Node.TEXT_NODE)
    return $.textContent;
  if ($.nodeType === Node.ELEMENT_NODE)
    if ($.nodeName === "A") {
      let ee = $.textContent;
      ee = ee.substring(1);
      const te = $.getAttribute("id");
      return `<<${ee}|route://user_profile/${te}>>`;
    } else {
      if ($.nodeName === "BR")
        return `
`;
      if ($.nodeName === "SPAN")
        return "";
      {
        let ee = "";
        const te = $.childNodes;
        for (const ne of te) {
          const re = extractTextFromNode(ne);
          ee += re;
        }
        return `
` + ee;
      }
    }
  else
    return "";
}
const getInitials = ($) => {
  const ee = $.split(" ");
  if (ee.length === 1)
    return $[0].toUpperCase();
  if (ee.length === 2) {
    const te = ee[0][0], ne = ee[1][0];
    return (te + ne).toUpperCase();
  } else {
    const te = ee[0][0], ne = ee[ee.length - 1][0];
    return (te + ne).toUpperCase();
  }
}, getAvatar = ({ imageUrl: $, name: ee, onError: te }) => {
  const ne = (re) => {
    te ? te() : re.currentTarget.style.display = "none";
  };
  return $ ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: $,
      onError: ne,
      alt: "avatar",
      loading: "lazy",
      "lm-feed-component-id": `lm-feed-user-avatar-opqrs-${$}`
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "lm-feed-component-id": `lm-feed-post-wrapper-tuvwx-${$}`,
      className: "avatar-initials lm-flex-container lm-justify-content-center lm-align-items-center",
      children: ee ? getInitials(ee) : ""
    }
  );
}, cancelModelMcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M3.47755%2020.5254C3.89943%2020.9356%204.59084%2020.9356%204.98927%2020.5254L11.9971%2013.5176L19.0049%2020.5254C19.4151%2020.9356%2020.1065%2020.9473%2020.5166%2020.5254C20.9268%2020.1035%2020.9385%2019.4121%2020.5283%2019.002L13.5205%2011.9942L20.5283%204.99806C20.9385%204.58791%2020.9385%203.88478%2020.5166%203.47462C20.0947%203.06447%2019.4151%203.06447%2019.0049%203.47462L11.9971%2010.4824L4.98927%203.47462C4.59084%203.06447%203.88771%203.05275%203.47755%203.47462C3.0674%203.8965%203.0674%204.58791%203.47755%204.99806L10.4736%2011.9942L3.47755%2019.002C3.0674%2019.4121%203.05568%2020.1152%203.47755%2020.5254Z'%20fill='%23484F67'/%3e%3c/svg%3e", LMFeedReportPostDialog = ({
  closeReportDialog: $,
  entityId: ee,
  entityType: te
}) => {
  const { lmFeedclient: ne } = useContext(GlobalClientProviderContext), { currentUser: re } = useContext(UserProviderContext), [se, ie] = useState([]), [oe, le] = useState(null), [ue, de] = useState("");
  async function fe() {
    try {
      await (ne == null ? void 0 : ne.postReport(
        W$1.builder().setUuid((re == null ? void 0 : re.sdkClientInfo.uuid) || "").setTagId((oe == null ? void 0 : oe.id) || 0).setReason(
          (oe == null ? void 0 : oe.id) === 11 ? ue : (oe == null ? void 0 : oe.name) || ""
        ).setEntityId(ee).setEntityType(te).build()
      )), $();
    } catch (pe) {
      console.log(pe);
    }
  }
  return useEffect(() => {
    async function pe() {
      try {
        const ye = await (ne == null ? void 0 : ne.getReportTags(
          J$1.builder().settype(0).build()
        ));
        ye.success && ie(ye.data.reportTags);
      } catch (ye) {
        console.log(ye);
      }
    }
    pe();
  }, [ne]), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__header", children: "Report Post" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: cancelModelMcon,
        className: "lmReportPostWrapper__header__closeIcon",
        alt: "close-icon",
        onClick: $
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper__body__content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper__body__content--texted", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Please specify the problem to continue " }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        "You would be able to report this Post after selecting a problem."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__body__content__types", children: se.map((pe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          "lm-feed-component-id": "lm-feed-report-tag-vwxyz",
          className: `${(oe == null ? void 0 : oe.id) === pe.id ? "active" : ""}`,
          onClick: () => {
            le(pe);
          },
          children: pe.name
        },
        pe.id
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper__body__content__actions", children: [
        (oe == null ? void 0 : oe.id) === 11 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            value: ue,
            onChange: (pe) => {
              de(pe.target.value);
            },
            placeholder: "Enter the reason here...",
            type: "text",
            "lm-feed-component-id": "lm-feed-report-input-fghij",
            className: "lmReportPostWrapper__body__content__actions--input"
          }
        ) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: fe,
            disabled: !oe,
            className: "lmReportPostWrapper__body__content__actions--btnReport",
            "lm-feed-component-id": "lm-feed-report-submit-klmno",
            children: "Report"
          }
        )
      ] })
    ] }) })
  ] });
};
var LMFeedEntityType = /* @__PURE__ */ (($) => ($[$.POST = 5] = "POST", $[$.COMMENT = 6] = "COMMENT", $[$.REPLY = 7] = "REPLY", $))(LMFeedEntityType || {});
const threeDotMenuIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8%2012C8%2010.9%207.1%2010%206%2010C4.9%2010%204%2010.9%204%2012C4%2013.1%204.9%2014%206%2014C7.1%2014%208%2013.1%208%2012ZM10%2012C10%2013.1%2010.9%2014%2012%2014C13.1%2014%2014%2013.1%2014%2012C14%2010.9%2013.1%2010%2012%2010C10.9%2010%2010%2010.9%2010%2012ZM16%2012C16%2013.1%2016.9%2014%2018%2014C19.1%2014%2020%2013.1%2020%2012C20%2010.9%2019.1%2010%2018%2010C16.9%2010%2016%2010.9%2016%2012Z'%20fill='%23666666'/%3e%3c/svg%3e", pinIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12.0053%2022.001C17.4832%2022.001%2022%2017.4842%2022%2012.0063C22%206.51779%2017.4832%202.00098%2011.9947%202.00098C6.50614%202.00098%202%206.51779%202%2012.0063C2%2017.4842%206.51682%2022.001%2012.0053%2022.001ZM12.0053%2020.9438C7.05072%2020.9438%203.05713%2016.9503%203.05713%2012.0063C3.05713%207.06238%207.05072%203.0581%2011.9947%203.0581C16.9386%203.0581%2020.9429%207.06238%2020.9429%2012.0063C20.9536%2016.9503%2016.9493%2020.9438%2012.0053%2020.9438ZM8.05446%2014.1206C8.05446%2014.4836%208.31073%2014.7079%208.68446%2014.7079H11.5569V16.9289C11.5569%2017.7404%2011.8558%2018.4345%2011.9947%2018.4345C12.1335%2018.4345%2012.4431%2017.7404%2012.4431%2016.9289V14.7079H15.2942C15.6893%2014.7079%2015.9349%2014.4836%2015.9349%2014.1206C15.9349%2012.9567%2015.0272%2011.8034%2013.575%2011.3122L13.4042%208.74951C14.0021%208.39713%2014.6215%207.91662%2014.9204%207.53221C15.0593%207.36136%2015.1233%207.17983%2015.1233%207.04102C15.1233%206.77407%2014.9311%206.58186%2014.6108%206.58186H9.38922C9.07955%206.58186%208.86599%206.77407%208.86599%207.04102C8.86599%207.19051%208.95142%207.37204%209.10091%207.56424C9.39989%207.94865%2010.0085%208.40781%2010.5958%208.74951L10.4143%2011.3122C8.97277%2011.8034%208.05446%2012.9567%208.05446%2014.1206Z'%20fill='%23484F67'/%3e%3c/svg%3e";
var LMFeedDeletePostModes = /* @__PURE__ */ (($) => ($.POST = "POST", $.COMMENT = "COMMENT", $.REPLY = "REPLY", $))(LMFeedDeletePostModes || {});
const ReplyContext = React__default.createContext({
  reply: null,
  user: null
}), LMFeedDeleteDialogBox = ({ mode: $, onClose: ee }) => {
  const { deletePost: te, post: ne, removeAComment: re } = useContext(FeedPostContext), { reply: se, deleteReply: ie } = useContext(ReplyContext);
  function oe() {
    switch ($) {
      case LMFeedDeletePostModes.POST: {
        te && te((ne == null ? void 0 : ne.Id) || "");
        return;
      }
      case LMFeedDeletePostModes.COMMENT: {
        re && re((se == null ? void 0 : se.Id) || "");
        return;
      }
      case LMFeedDeletePostModes.REPLY:
        ie && ie((se == null ? void 0 : se.Id) || "");
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__header", children: "Delete Post" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: cancelModelMcon,
        className: "lmReportPostWrapper__header__closeIcon",
        alt: "close-icon",
        onClick: ee
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__body", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmReportPostWrapper__body__content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__body__content--texted", children: "Are you sure you want to delete this post permanently. Once confirmed, this action can't be reversed." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmReportPostWrapper__body__content__actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: oe,
          className: "lmReportPostWrapper__body__content__actions--btnReport",
          children: "Delete"
        }
      ) })
    ] }) })
  ] });
}, LMFeedPostHeader = () => {
  const { customEventClient: $ } = useContext(GlobalClientProviderContext), { post: ee, users: te, topics: ne, pinPost: re } = useContext(FeedPostContext), { LMPostHeaderStyles: se, LMFeedCustomIcons: ie } = useContext(
    CustomAgentProviderContext
  ), [oe, le] = useState(!1), [ue, de] = useState(!1);
  function fe() {
    de(!1);
  }
  const { createdAt: pe, isEdited: ye, menuItems: me, isPinned: ve } = ee, { name: ge, imageUrl: xe, customTitle: Ee } = useMemo(
    () => te[ee.uuid],
    [ee, te]
  ), Te = getAvatar({ imageUrl: xe, name: ge });
  function Se() {
    le(!1);
  }
  function he(De) {
    if (!ee)
      return;
    switch (Ie(null), De.currentTarget.id) {
      case LMFeedPostMenuItems.EDIT_POST: {
        ee && ne && ($ == null || $.dispatchEvent(
          LMFeedCustomActionEvents.OPEN_CREATE_POST_DIALOUGE,
          {
            post: ee,
            topics: ne
          }
        ));
        break;
      }
      case LMFeedPostMenuItems.REPORT_POST: {
        le(!0);
        break;
      }
      case LMFeedPostMenuItems.DELETE_POST: {
        de(!0);
        break;
      }
      case LMFeedPostMenuItems.PIN_POST: {
        re && re(ee.Id);
        break;
      }
      case LMFeedPostMenuItems.UNPIN_POST: {
        re && re(ee == null ? void 0 : ee.Id);
        break;
      }
    }
  }
  const [Pe, Ie] = useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$1, { open: ue, onClose: fe, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LMFeedDeleteDialogBox,
      {
        mode: LMFeedDeletePostModes.POST,
        onClose: fe
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$1, { open: oe, onClose: Se, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LMFeedReportPostDialog,
      {
        entityType: LMFeedEntityType.POST,
        closeReportDialog: Se,
        entityId: (ee == null ? void 0 : ee.Id) || ""
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "lm-feed-wrapper__card__header",
        "lm-feed-component-id": `lm-feed-post-header-abcde-${ee == null ? void 0 : ee.Id}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-flex-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "lm-avatar lm-mr-5",
                style: se == null ? void 0 : se.avatar,
                "lm-feed-component-id": `lm-feed-post-header-fghij-${ee == null ? void 0 : ee.Id}`,
                children: Te
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { "lm-feed-component-id": `lm-feed-post-header-klmno-${ee == null ? void 0 : ee.Id}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "lm-feed-wrapper__card__header--title",
                  style: se == null ? void 0 : se.title,
                  "lm-feed-component-id": `lm-feed-post-header-pqrst-${ee == null ? void 0 : ee.Id}`,
                  children: [
                    ge,
                    " ",
                    Ee ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        style: se == null ? void 0 : se.customTitle,
                        "lm-feed-component-id": `lm-feed-post-header-uvwxy-${ee == null ? void 0 : ee.Id}`,
                        children: Ee
                      }
                    ) : null
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "lm-feed-wrapper__card__header--text",
                  "lm-feed-component-id": `lm-feed-post-header-zabcd-${ee == null ? void 0 : ee.Id}`,
                  children: ye ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "edited",
                        "lm-feed-component-id": `lm-feed-post-header-efghi-${ee == null ? void 0 : ee.Id}`,
                        children: formatTimeAgo(pe)
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "lm-primary-text lm-post-badge",
                        style: se == null ? void 0 : se.editBadge,
                        "lm-feed-component-id": `lm-feed-post-header-jklmn-${ee == null ? void 0 : ee.Id}`,
                        children: se != null && se.editBadgeCustomText ? se.editBadgeCustomText : EDITED
                      }
                    )
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    (se == null ? void 0 : se.postBadgeText) || POST,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        "lm-feed-component-id": `lm-feed-post-header-opqrs-${ee == null ? void 0 : ee.Id}`,
                        children: formatTimeAgo(pe)
                      }
                    )
                  ] })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "lm-feed-wrapper__card__header__menu-items-container",
              "lm-feed-component-id": `lm-feed-post-header-tuvwx-${ee == null ? void 0 : ee.Id}`,
              children: [
                ve ? ie != null && ie.postPinCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ie.postPinCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: "three-dot-menu-image lm-cursor-pointer lm-mr-4",
                    src: pinIcon,
                    alt: "pinned post",
                    "lm-feed-component-id": `lm-feed-post-header-yzabc-${ee == null ? void 0 : ee.Id}`
                  }
                ) : null,
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: "three-dot-menu-image lm-cursor-pointer",
                    src: threeDotMenuIcon,
                    alt: "3-dot-menu",
                    onClick: (De) => {
                      Ie(De.currentTarget);
                    },
                    "lm-feed-component-id": `lm-feed-post-header-defgh-${ee == null ? void 0 : ee.Id}`
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Menu$1,
                  {
                    anchorEl: Pe,
                    open: !!Pe,
                    anchorOrigin: { horizontal: "right", vertical: "top" },
                    transformOrigin: { vertical: "top", horizontal: "right" },
                    onClose: () => Ie(null),
                    "lm-feed-component-id": `lm-feed-post-header-ijklm-${ee == null ? void 0 : ee.Id}`,
                    children: me == null ? void 0 : me.map((De) => {
                      var Ce;
                      return /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "three-dot-menu-options lm-cursor-pointer lm-hover-effect",
                          onClick: he,
                          id: (Ce = De == null ? void 0 : De.id) == null ? void 0 : Ce.toString(),
                          "lm-feed-component-id": `lm-feed-post-header-nopqr-${ee == null ? void 0 : ee.Id}`,
                          children: De == null ? void 0 : De.title
                        },
                        De == null ? void 0 : De.id
                      );
                    })
                  }
                )
              ]
            }
          )
        ]
      }
    )
  ] });
}, parseAndReplaceTags = ($) => {
  if (!$)
    return null;
  const ee = /<<([^|]+)\|([^>]+)>>/g, te = $.split(/\r?\n/), ne = [];
  return te.forEach((se, ie) => {
    ie > 0 && ne.push(/* @__PURE__ */ jsxRuntimeExports.jsx("br", {}, `br-${ie}`));
    let oe = 0;
    se.replace(ee, (le, ue, de, fe) => (fe > oe && ne.push(se.substring(oe, fe)), ne.push(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          onClick: () => handleRouteClick(de),
          className: "userTag",
          children: ue
        },
        `${ie}-${fe}`
      )
    ), oe = fe + le.length, le)), oe < se.length && ne.push(se.substring(oe));
  }), ne.map((se, ie) => typeof se == "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(React__default.Fragment, { children: se.split(/\b(https?:\/\/\S+|www\.\S+)\b/g).map((oe, le) => {
    if (le % 2 === 0)
      return oe;
    {
      const ue = oe.startsWith("http") ? oe : `http://${oe}`;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: ue, target: "_blank", rel: "noopener noreferrer", children: oe }, le);
    }
  }) }, ie) : se);
}, textPreprocessor = ($) => {
  const ee = $.split(" ");
  return ee.length <= 300 ? {
    text: $,
    showReadMore: !1
  } : { showReadMore: !0, text: ee.slice(0, 299).join(" ") };
}, handleRouteClick = ($) => {
  alert($);
};
function setTagUserImage($) {
  var te;
  const ee = $ == null ? void 0 : $.imageUrl;
  return ee !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: ee,
      alt: "",
      style: {
        width: "100%",
        height: "100%",
        borderRadius: "50%"
      }
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        minWidth: "36px",
        width: "36px",
        height: "36px",
        borderRadius: "50%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        backgroundColor: "#5046e5",
        fontSize: "14px",
        fontWeight: "bold",
        color: "#fff",
        letterSpacing: "1px"
      },
      className: "reply-editor",
      children: (te = $ == null ? void 0 : $.name) == null ? void 0 : te.split(" ").map((ne) => {
        var re;
        return (re = ne.charAt(0)) == null ? void 0 : re.toUpperCase();
      })
    }
  );
}
function convertTextToHTML($) {
  const ee = /<<.*?>>|(?:https?|ftp):\/\/[^\s/$.?#].[^\s]*|www\.[^\s/$.?#].[^\s]*/g, te = ($ == null ? void 0 : $.match(ee)) || [], ne = $ == null ? void 0 : $.split(ee), re = document.createElement("div");
  for (let se = 0; se < (ne == null ? void 0 : ne.length); se++) {
    const ie = document.createTextNode(ne[se]);
    if (re.appendChild(ie), te[se]) {
      const oe = te[se], le = /<<([^|]+)\|([^>>]+)>>/, ue = oe.match(le), de = {
        type: 1
      };
      if (ue) {
        const fe = ue[1], pe = ue[2];
        de.displayName = fe, de.routeId = pe;
      } else
        de.type = 2, de.link = oe;
      if (de.type === 1) {
        const fe = document.createElement("a");
        fe.href = "#", fe.textContent = de.displayName, fe.id = de.routeId, re.appendChild(fe);
      } else {
        const fe = document.createElement("a");
        fe.href = de.link, fe.textContent = de.link, re.appendChild(fe);
      }
    }
  }
  return re;
}
var lib = {}, slider = {}, innerSlider = {}, initialState = {};
(function($) {
  Object.defineProperty($, "__esModule", {
    value: !0
  }), $.default = void 0;
  var ee = {
    animating: !1,
    autoplaying: null,
    currentDirection: 0,
    currentLeft: null,
    currentSlide: 0,
    direction: 1,
    dragging: !1,
    edgeDragged: !1,
    initialized: !1,
    lazyLoadedList: [],
    listHeight: null,
    listWidth: null,
    scrolling: !1,
    slideCount: null,
    slideHeight: null,
    slideWidth: null,
    swipeLeft: null,
    swiped: !1,
    // used by swipeEvent. differentites between touch and swipe.
    swiping: !1,
    touchObject: {
      startX: 0,
      startY: 0,
      curX: 0,
      curY: 0
    },
    trackStyle: {},
    trackWidth: 0,
    targetSlide: 0
  };
  $.default = ee;
})(initialState);
var FUNC_ERROR_TEXT = "Expected a function", NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectProto = Object.prototype, objectToString = objectProto.toString, nativeMax = Math.max, nativeMin = Math.min, now = function() {
  return root.Date.now();
};
function debounce($, ee, te) {
  var ne, re, se, ie, oe, le, ue = 0, de = !1, fe = !1, pe = !0;
  if (typeof $ != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  ee = toNumber$2(ee) || 0, isObject(te) && (de = !!te.leading, fe = "maxWait" in te, se = fe ? nativeMax(toNumber$2(te.maxWait) || 0, ee) : se, pe = "trailing" in te ? !!te.trailing : pe);
  function ye(Pe) {
    var Ie = ne, De = re;
    return ne = re = void 0, ue = Pe, ie = $.apply(De, Ie), ie;
  }
  function me(Pe) {
    return ue = Pe, oe = setTimeout(xe, ee), de ? ye(Pe) : ie;
  }
  function ve(Pe) {
    var Ie = Pe - le, De = Pe - ue, Ce = ee - Ie;
    return fe ? nativeMin(Ce, se - De) : Ce;
  }
  function ge(Pe) {
    var Ie = Pe - le, De = Pe - ue;
    return le === void 0 || Ie >= ee || Ie < 0 || fe && De >= se;
  }
  function xe() {
    var Pe = now();
    if (ge(Pe))
      return Ee(Pe);
    oe = setTimeout(xe, ve(Pe));
  }
  function Ee(Pe) {
    return oe = void 0, pe && ne ? ye(Pe) : (ne = re = void 0, ie);
  }
  function Te() {
    oe !== void 0 && clearTimeout(oe), ue = 0, ne = le = re = oe = void 0;
  }
  function Se() {
    return oe === void 0 ? ie : Ee(now());
  }
  function he() {
    var Pe = now(), Ie = ge(Pe);
    if (ne = arguments, re = this, le = Pe, Ie) {
      if (oe === void 0)
        return me(le);
      if (fe)
        return oe = setTimeout(xe, ee), ye(le);
    }
    return oe === void 0 && (oe = setTimeout(xe, ee)), ie;
  }
  return he.cancel = Te, he.flush = Se, he;
}
function isObject($) {
  var ee = typeof $;
  return !!$ && (ee == "object" || ee == "function");
}
function isObjectLike($) {
  return !!$ && typeof $ == "object";
}
function isSymbol($) {
  return typeof $ == "symbol" || isObjectLike($) && objectToString.call($) == symbolTag;
}
function toNumber$2($) {
  if (typeof $ == "number")
    return $;
  if (isSymbol($))
    return NAN;
  if (isObject($)) {
    var ee = typeof $.valueOf == "function" ? $.valueOf() : $;
    $ = isObject(ee) ? ee + "" : ee;
  }
  if (typeof $ != "string")
    return $ === 0 ? $ : +$;
  $ = $.replace(reTrim, "");
  var te = reIsBinary.test($);
  return te || reIsOctal.test($) ? freeParseInt($.slice(2), te ? 2 : 8) : reIsBadHex.test($) ? NAN : +$;
}
var lodash_debounce = debounce, classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function($) {
  (function() {
    var ee = {}.hasOwnProperty;
    function te() {
      for (var se = "", ie = 0; ie < arguments.length; ie++) {
        var oe = arguments[ie];
        oe && (se = re(se, ne(oe)));
      }
      return se;
    }
    function ne(se) {
      if (typeof se == "string" || typeof se == "number")
        return se;
      if (typeof se != "object")
        return "";
      if (Array.isArray(se))
        return te.apply(null, se);
      if (se.toString !== Object.prototype.toString && !se.toString.toString().includes("[native code]"))
        return se.toString();
      var ie = "";
      for (var oe in se)
        ee.call(se, oe) && se[oe] && (ie = re(ie, oe));
      return ie;
    }
    function re(se, ie) {
      return ie ? se ? se + " " + ie : se + ie : se;
    }
    $.exports ? (te.default = te, $.exports = te) : window.classNames = te;
  })();
})(classnames);
var classnamesExports = classnames.exports, innerSliderUtils = {}, defaultProps = {};
(function($) {
  Object.defineProperty($, "__esModule", {
    value: !0
  }), $.default = void 0;
  var ee = te(React__default);
  function te(re) {
    return re && re.__esModule ? re : { default: re };
  }
  var ne = {
    accessibility: !0,
    adaptiveHeight: !1,
    afterChange: null,
    appendDots: function(se) {
      return /* @__PURE__ */ ee.default.createElement("ul", {
        style: {
          display: "block"
        }
      }, se);
    },
    arrows: !0,
    autoplay: !1,
    autoplaySpeed: 3e3,
    beforeChange: null,
    centerMode: !1,
    centerPadding: "50px",
    className: "",
    cssEase: "ease",
    customPaging: function(se) {
      return /* @__PURE__ */ ee.default.createElement("button", null, se + 1);
    },
    dots: !1,
    dotsClass: "slick-dots",
    draggable: !0,
    easing: "linear",
    edgeFriction: 0.35,
    fade: !1,
    focusOnSelect: !1,
    infinite: !0,
    initialSlide: 0,
    lazyLoad: null,
    nextArrow: null,
    onEdge: null,
    onInit: null,
    onLazyLoadError: null,
    onReInit: null,
    pauseOnDotsHover: !1,
    pauseOnFocus: !1,
    pauseOnHover: !0,
    prevArrow: null,
    responsive: null,
    rows: 1,
    rtl: !1,
    slide: "div",
    slidesPerRow: 1,
    slidesToScroll: 1,
    slidesToShow: 1,
    speed: 500,
    swipe: !0,
    swipeEvent: null,
    swipeToSlide: !1,
    touchMove: !0,
    touchThreshold: 5,
    useCSS: !0,
    useTransform: !0,
    variableWidth: !1,
    vertical: !1,
    waitForAnimate: !0,
    asNavFor: null
  };
  $.default = ne;
})(defaultProps);
Object.defineProperty(innerSliderUtils, "__esModule", {
  value: !0
});
innerSliderUtils.checkSpecKeys = innerSliderUtils.checkNavigable = innerSliderUtils.changeSlide = innerSliderUtils.canUseDOM = innerSliderUtils.canGoNext = void 0;
innerSliderUtils.clamp = clamp;
innerSliderUtils.extractObject = void 0;
innerSliderUtils.filterSettings = filterSettings;
innerSliderUtils.validSettings = innerSliderUtils.swipeStart = innerSliderUtils.swipeMove = innerSliderUtils.swipeEnd = innerSliderUtils.slidesOnRight = innerSliderUtils.slidesOnLeft = innerSliderUtils.slideHandler = innerSliderUtils.siblingDirection = innerSliderUtils.safePreventDefault = innerSliderUtils.lazyStartIndex = innerSliderUtils.lazySlidesOnRight = innerSliderUtils.lazySlidesOnLeft = innerSliderUtils.lazyEndIndex = innerSliderUtils.keyHandler = innerSliderUtils.initializedState = innerSliderUtils.getWidth = innerSliderUtils.getTrackLeft = innerSliderUtils.getTrackCSS = innerSliderUtils.getTrackAnimateCSS = innerSliderUtils.getTotalSlides = innerSliderUtils.getSwipeDirection = innerSliderUtils.getSlideCount = innerSliderUtils.getRequiredLazySlides = innerSliderUtils.getPreClones = innerSliderUtils.getPostClones = innerSliderUtils.getOnDemandLazySlides = innerSliderUtils.getNavigableIndexes = innerSliderUtils.getHeight = void 0;
var _react$4 = _interopRequireDefault$4(React__default), _defaultProps = _interopRequireDefault$4(defaultProps);
function _interopRequireDefault$4($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function _typeof$4($) {
  "@babel/helpers - typeof";
  return _typeof$4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
    return typeof ee;
  } : function(ee) {
    return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee;
  }, _typeof$4($);
}
function ownKeys$4($, ee) {
  var te = Object.keys($);
  if (Object.getOwnPropertySymbols) {
    var ne = Object.getOwnPropertySymbols($);
    ee && (ne = ne.filter(function(re) {
      return Object.getOwnPropertyDescriptor($, re).enumerable;
    })), te.push.apply(te, ne);
  }
  return te;
}
function _objectSpread$4($) {
  for (var ee = 1; ee < arguments.length; ee++) {
    var te = arguments[ee] != null ? arguments[ee] : {};
    ee % 2 ? ownKeys$4(Object(te), !0).forEach(function(ne) {
      _defineProperty$4($, ne, te[ne]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(te)) : ownKeys$4(Object(te)).forEach(function(ne) {
      Object.defineProperty($, ne, Object.getOwnPropertyDescriptor(te, ne));
    });
  }
  return $;
}
function _defineProperty$4($, ee, te) {
  return ee = _toPropertyKey$4(ee), ee in $ ? Object.defineProperty($, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : $[ee] = te, $;
}
function _toPropertyKey$4($) {
  var ee = _toPrimitive$4($, "string");
  return _typeof$4(ee) == "symbol" ? ee : String(ee);
}
function _toPrimitive$4($, ee) {
  if (_typeof$4($) != "object" || !$)
    return $;
  var te = $[Symbol.toPrimitive];
  if (te !== void 0) {
    var ne = te.call($, ee || "default");
    if (_typeof$4(ne) != "object")
      return ne;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ee === "string" ? String : Number)($);
}
function clamp($, ee, te) {
  return Math.max(ee, Math.min($, te));
}
var safePreventDefault = innerSliderUtils.safePreventDefault = function $(ee) {
  var te = ["onTouchStart", "onTouchMove", "onWheel"];
  te.includes(ee._reactName) || ee.preventDefault();
}, getOnDemandLazySlides = innerSliderUtils.getOnDemandLazySlides = function $(ee) {
  for (var te = [], ne = lazyStartIndex(ee), re = lazyEndIndex(ee), se = ne; se < re; se++)
    ee.lazyLoadedList.indexOf(se) < 0 && te.push(se);
  return te;
};
innerSliderUtils.getRequiredLazySlides = function $(ee) {
  for (var te = [], ne = lazyStartIndex(ee), re = lazyEndIndex(ee), se = ne; se < re; se++)
    te.push(se);
  return te;
};
var lazyStartIndex = innerSliderUtils.lazyStartIndex = function $(ee) {
  return ee.currentSlide - lazySlidesOnLeft(ee);
}, lazyEndIndex = innerSliderUtils.lazyEndIndex = function $(ee) {
  return ee.currentSlide + lazySlidesOnRight(ee);
}, lazySlidesOnLeft = innerSliderUtils.lazySlidesOnLeft = function $(ee) {
  return ee.centerMode ? Math.floor(ee.slidesToShow / 2) + (parseInt(ee.centerPadding) > 0 ? 1 : 0) : 0;
}, lazySlidesOnRight = innerSliderUtils.lazySlidesOnRight = function $(ee) {
  return ee.centerMode ? Math.floor((ee.slidesToShow - 1) / 2) + 1 + (parseInt(ee.centerPadding) > 0 ? 1 : 0) : ee.slidesToShow;
}, getWidth = innerSliderUtils.getWidth = function $(ee) {
  return ee && ee.offsetWidth || 0;
}, getHeight = innerSliderUtils.getHeight = function $(ee) {
  return ee && ee.offsetHeight || 0;
}, getSwipeDirection = innerSliderUtils.getSwipeDirection = function $(ee) {
  var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, ne, re, se, ie;
  return ne = ee.startX - ee.curX, re = ee.startY - ee.curY, se = Math.atan2(re, ne), ie = Math.round(se * 180 / Math.PI), ie < 0 && (ie = 360 - Math.abs(ie)), ie <= 45 && ie >= 0 || ie <= 360 && ie >= 315 ? "left" : ie >= 135 && ie <= 225 ? "right" : te === !0 ? ie >= 35 && ie <= 135 ? "up" : "down" : "vertical";
}, canGoNext = innerSliderUtils.canGoNext = function $(ee) {
  var te = !0;
  return ee.infinite || (ee.centerMode && ee.currentSlide >= ee.slideCount - 1 || ee.slideCount <= ee.slidesToShow || ee.currentSlide >= ee.slideCount - ee.slidesToShow) && (te = !1), te;
};
innerSliderUtils.extractObject = function $(ee, te) {
  var ne = {};
  return te.forEach(function(re) {
    return ne[re] = ee[re];
  }), ne;
};
innerSliderUtils.initializedState = function $(ee) {
  var te = _react$4.default.Children.count(ee.children), ne = ee.listRef, re = Math.ceil(getWidth(ne)), se = ee.trackRef && ee.trackRef.node, ie = Math.ceil(getWidth(se)), oe;
  if (ee.vertical)
    oe = re;
  else {
    var le = ee.centerMode && parseInt(ee.centerPadding) * 2;
    typeof ee.centerPadding == "string" && ee.centerPadding.slice(-1) === "%" && (le *= re / 100), oe = Math.ceil((re - le) / ee.slidesToShow);
  }
  var ue = ne && getHeight(ne.querySelector('[data-index="0"]')), de = ue * ee.slidesToShow, fe = ee.currentSlide === void 0 ? ee.initialSlide : ee.currentSlide;
  ee.rtl && ee.currentSlide === void 0 && (fe = te - 1 - ee.initialSlide);
  var pe = ee.lazyLoadedList || [], ye = getOnDemandLazySlides(_objectSpread$4(_objectSpread$4({}, ee), {}, {
    currentSlide: fe,
    lazyLoadedList: pe
  }));
  pe = pe.concat(ye);
  var me = {
    slideCount: te,
    slideWidth: oe,
    listWidth: re,
    trackWidth: ie,
    currentSlide: fe,
    slideHeight: ue,
    listHeight: de,
    lazyLoadedList: pe
  };
  return ee.autoplaying === null && ee.autoplay && (me.autoplaying = "playing"), me;
};
innerSliderUtils.slideHandler = function $(ee) {
  var te = ee.waitForAnimate, ne = ee.animating, re = ee.fade, se = ee.infinite, ie = ee.index, oe = ee.slideCount, le = ee.lazyLoad, ue = ee.currentSlide, de = ee.centerMode, fe = ee.slidesToScroll, pe = ee.slidesToShow, ye = ee.useCSS, me = ee.lazyLoadedList;
  if (te && ne)
    return {};
  var ve = ie, ge, xe, Ee, Te = {}, Se = {}, he = se ? ie : clamp(ie, 0, oe - 1);
  if (re) {
    if (!se && (ie < 0 || ie >= oe))
      return {};
    ie < 0 ? ve = ie + oe : ie >= oe && (ve = ie - oe), le && me.indexOf(ve) < 0 && (me = me.concat(ve)), Te = {
      animating: !0,
      currentSlide: ve,
      lazyLoadedList: me,
      targetSlide: ve
    }, Se = {
      animating: !1,
      targetSlide: ve
    };
  } else
    ge = ve, ve < 0 ? (ge = ve + oe, se ? oe % fe !== 0 && (ge = oe - oe % fe) : ge = 0) : !canGoNext(ee) && ve > ue ? ve = ge = ue : de && ve >= oe ? (ve = se ? oe : oe - 1, ge = se ? 0 : oe - 1) : ve >= oe && (ge = ve - oe, se ? oe % fe !== 0 && (ge = 0) : ge = oe - pe), !se && ve + pe >= oe && (ge = oe - pe), xe = getTrackLeft(_objectSpread$4(_objectSpread$4({}, ee), {}, {
      slideIndex: ve
    })), Ee = getTrackLeft(_objectSpread$4(_objectSpread$4({}, ee), {}, {
      slideIndex: ge
    })), se || (xe === Ee && (ve = ge), xe = Ee), le && (me = me.concat(getOnDemandLazySlides(_objectSpread$4(_objectSpread$4({}, ee), {}, {
      currentSlide: ve
    })))), ye ? (Te = {
      animating: !0,
      currentSlide: ge,
      trackStyle: getTrackAnimateCSS(_objectSpread$4(_objectSpread$4({}, ee), {}, {
        left: xe
      })),
      lazyLoadedList: me,
      targetSlide: he
    }, Se = {
      animating: !1,
      currentSlide: ge,
      trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, ee), {}, {
        left: Ee
      })),
      swipeLeft: null,
      targetSlide: he
    }) : Te = {
      currentSlide: ge,
      trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, ee), {}, {
        left: Ee
      })),
      lazyLoadedList: me,
      targetSlide: he
    };
  return {
    state: Te,
    nextState: Se
  };
};
innerSliderUtils.changeSlide = function $(ee, te) {
  var ne, re, se, ie, oe, le = ee.slidesToScroll, ue = ee.slidesToShow, de = ee.slideCount, fe = ee.currentSlide, pe = ee.targetSlide, ye = ee.lazyLoad, me = ee.infinite;
  if (ie = de % le !== 0, ne = ie ? 0 : (de - fe) % le, te.message === "previous")
    se = ne === 0 ? le : ue - ne, oe = fe - se, ye && !me && (re = fe - se, oe = re === -1 ? de - 1 : re), me || (oe = pe - le);
  else if (te.message === "next")
    se = ne === 0 ? le : ne, oe = fe + se, ye && !me && (oe = (fe + le) % de + ne), me || (oe = pe + le);
  else if (te.message === "dots")
    oe = te.index * te.slidesToScroll;
  else if (te.message === "children") {
    if (oe = te.index, me) {
      var ve = siblingDirection(_objectSpread$4(_objectSpread$4({}, ee), {}, {
        targetSlide: oe
      }));
      oe > te.currentSlide && ve === "left" ? oe = oe - de : oe < te.currentSlide && ve === "right" && (oe = oe + de);
    }
  } else
    te.message === "index" && (oe = Number(te.index));
  return oe;
};
innerSliderUtils.keyHandler = function $(ee, te, ne) {
  return ee.target.tagName.match("TEXTAREA|INPUT|SELECT") || !te ? "" : ee.keyCode === 37 ? ne ? "next" : "previous" : ee.keyCode === 39 ? ne ? "previous" : "next" : "";
};
innerSliderUtils.swipeStart = function $(ee, te, ne) {
  return ee.target.tagName === "IMG" && safePreventDefault(ee), !te || !ne && ee.type.indexOf("mouse") !== -1 ? "" : {
    dragging: !0,
    touchObject: {
      startX: ee.touches ? ee.touches[0].pageX : ee.clientX,
      startY: ee.touches ? ee.touches[0].pageY : ee.clientY,
      curX: ee.touches ? ee.touches[0].pageX : ee.clientX,
      curY: ee.touches ? ee.touches[0].pageY : ee.clientY
    }
  };
};
innerSliderUtils.swipeMove = function $(ee, te) {
  var ne = te.scrolling, re = te.animating, se = te.vertical, ie = te.swipeToSlide, oe = te.verticalSwiping, le = te.rtl, ue = te.currentSlide, de = te.edgeFriction, fe = te.edgeDragged, pe = te.onEdge, ye = te.swiped, me = te.swiping, ve = te.slideCount, ge = te.slidesToScroll, xe = te.infinite, Ee = te.touchObject, Te = te.swipeEvent, Se = te.listHeight, he = te.listWidth;
  if (!ne) {
    if (re)
      return safePreventDefault(ee);
    se && ie && oe && safePreventDefault(ee);
    var Pe, Ie = {}, De = getTrackLeft(te);
    Ee.curX = ee.touches ? ee.touches[0].pageX : ee.clientX, Ee.curY = ee.touches ? ee.touches[0].pageY : ee.clientY, Ee.swipeLength = Math.round(Math.sqrt(Math.pow(Ee.curX - Ee.startX, 2)));
    var Ce = Math.round(Math.sqrt(Math.pow(Ee.curY - Ee.startY, 2)));
    if (!oe && !me && Ce > 10)
      return {
        scrolling: !0
      };
    oe && (Ee.swipeLength = Ce);
    var Ne = (le ? -1 : 1) * (Ee.curX > Ee.startX ? 1 : -1);
    oe && (Ne = Ee.curY > Ee.startY ? 1 : -1);
    var Me = Math.ceil(ve / ge), Be = getSwipeDirection(te.touchObject, oe), We = Ee.swipeLength;
    return xe || (ue === 0 && (Be === "right" || Be === "down") || ue + 1 >= Me && (Be === "left" || Be === "up") || !canGoNext(te) && (Be === "left" || Be === "up")) && (We = Ee.swipeLength * de, fe === !1 && pe && (pe(Be), Ie.edgeDragged = !0)), !ye && Te && (Te(Be), Ie.swiped = !0), se ? Pe = De + We * (Se / he) * Ne : le ? Pe = De - We * Ne : Pe = De + We * Ne, oe && (Pe = De + We * Ne), Ie = _objectSpread$4(_objectSpread$4({}, Ie), {}, {
      touchObject: Ee,
      swipeLeft: Pe,
      trackStyle: getTrackCSS(_objectSpread$4(_objectSpread$4({}, te), {}, {
        left: Pe
      }))
    }), Math.abs(Ee.curX - Ee.startX) < Math.abs(Ee.curY - Ee.startY) * 0.8 || Ee.swipeLength > 10 && (Ie.swiping = !0, safePreventDefault(ee)), Ie;
  }
};
innerSliderUtils.swipeEnd = function $(ee, te) {
  var ne = te.dragging, re = te.swipe, se = te.touchObject, ie = te.listWidth, oe = te.touchThreshold, le = te.verticalSwiping, ue = te.listHeight, de = te.swipeToSlide, fe = te.scrolling, pe = te.onSwipe, ye = te.targetSlide, me = te.currentSlide, ve = te.infinite;
  if (!ne)
    return re && safePreventDefault(ee), {};
  var ge = le ? ue / oe : ie / oe, xe = getSwipeDirection(se, le), Ee = {
    dragging: !1,
    edgeDragged: !1,
    scrolling: !1,
    swiping: !1,
    swiped: !1,
    swipeLeft: null,
    touchObject: {}
  };
  if (fe || !se.swipeLength)
    return Ee;
  if (se.swipeLength > ge) {
    safePreventDefault(ee), pe && pe(xe);
    var Te, Se, he = ve ? me : ye;
    switch (xe) {
      case "left":
      case "up":
        Se = he + getSlideCount(te), Te = de ? checkNavigable(te, Se) : Se, Ee.currentDirection = 0;
        break;
      case "right":
      case "down":
        Se = he - getSlideCount(te), Te = de ? checkNavigable(te, Se) : Se, Ee.currentDirection = 1;
        break;
      default:
        Te = he;
    }
    Ee.triggerSlideHandler = Te;
  } else {
    var Pe = getTrackLeft(te);
    Ee.trackStyle = getTrackAnimateCSS(_objectSpread$4(_objectSpread$4({}, te), {}, {
      left: Pe
    }));
  }
  return Ee;
};
var getNavigableIndexes = innerSliderUtils.getNavigableIndexes = function $(ee) {
  for (var te = ee.infinite ? ee.slideCount * 2 : ee.slideCount, ne = ee.infinite ? ee.slidesToShow * -1 : 0, re = ee.infinite ? ee.slidesToShow * -1 : 0, se = []; ne < te; )
    se.push(ne), ne = re + ee.slidesToScroll, re += Math.min(ee.slidesToScroll, ee.slidesToShow);
  return se;
}, checkNavigable = innerSliderUtils.checkNavigable = function $(ee, te) {
  var ne = getNavigableIndexes(ee), re = 0;
  if (te > ne[ne.length - 1])
    te = ne[ne.length - 1];
  else
    for (var se in ne) {
      if (te < ne[se]) {
        te = re;
        break;
      }
      re = ne[se];
    }
  return te;
}, getSlideCount = innerSliderUtils.getSlideCount = function $(ee) {
  var te = ee.centerMode ? ee.slideWidth * Math.floor(ee.slidesToShow / 2) : 0;
  if (ee.swipeToSlide) {
    var ne, re = ee.listRef, se = re.querySelectorAll && re.querySelectorAll(".slick-slide") || [];
    if (Array.from(se).every(function(le) {
      if (ee.vertical) {
        if (le.offsetTop + getHeight(le) / 2 > ee.swipeLeft * -1)
          return ne = le, !1;
      } else if (le.offsetLeft - te + getWidth(le) / 2 > ee.swipeLeft * -1)
        return ne = le, !1;
      return !0;
    }), !ne)
      return 0;
    var ie = ee.rtl === !0 ? ee.slideCount - ee.currentSlide : ee.currentSlide, oe = Math.abs(ne.dataset.index - ie) || 1;
    return oe;
  } else
    return ee.slidesToScroll;
}, checkSpecKeys = innerSliderUtils.checkSpecKeys = function $(ee, te) {
  return te.reduce(function(ne, re) {
    return ne && ee.hasOwnProperty(re);
  }, !0) ? null : console.error("Keys Missing:", ee);
}, getTrackCSS = innerSliderUtils.getTrackCSS = function $(ee) {
  checkSpecKeys(ee, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var te, ne, re = ee.slideCount + 2 * ee.slidesToShow;
  ee.vertical ? ne = re * ee.slideHeight : te = getTotalSlides(ee) * ee.slideWidth;
  var se = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (ee.useTransform) {
    var ie = ee.vertical ? "translate3d(0px, " + ee.left + "px, 0px)" : "translate3d(" + ee.left + "px, 0px, 0px)", oe = ee.vertical ? "translate3d(0px, " + ee.left + "px, 0px)" : "translate3d(" + ee.left + "px, 0px, 0px)", le = ee.vertical ? "translateY(" + ee.left + "px)" : "translateX(" + ee.left + "px)";
    se = _objectSpread$4(_objectSpread$4({}, se), {}, {
      WebkitTransform: ie,
      transform: oe,
      msTransform: le
    });
  } else
    ee.vertical ? se.top = ee.left : se.left = ee.left;
  return ee.fade && (se = {
    opacity: 1
  }), te && (se.width = te), ne && (se.height = ne), window && !window.addEventListener && window.attachEvent && (ee.vertical ? se.marginTop = ee.left + "px" : se.marginLeft = ee.left + "px"), se;
}, getTrackAnimateCSS = innerSliderUtils.getTrackAnimateCSS = function $(ee) {
  checkSpecKeys(ee, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var te = getTrackCSS(ee);
  return ee.useTransform ? (te.WebkitTransition = "-webkit-transform " + ee.speed + "ms " + ee.cssEase, te.transition = "transform " + ee.speed + "ms " + ee.cssEase) : ee.vertical ? te.transition = "top " + ee.speed + "ms " + ee.cssEase : te.transition = "left " + ee.speed + "ms " + ee.cssEase, te;
}, getTrackLeft = innerSliderUtils.getTrackLeft = function $(ee) {
  if (ee.unslick)
    return 0;
  checkSpecKeys(ee, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var te = ee.slideIndex, ne = ee.trackRef, re = ee.infinite, se = ee.centerMode, ie = ee.slideCount, oe = ee.slidesToShow, le = ee.slidesToScroll, ue = ee.slideWidth, de = ee.listWidth, fe = ee.variableWidth, pe = ee.slideHeight, ye = ee.fade, me = ee.vertical, ve = 0, ge, xe, Ee = 0;
  if (ye || ee.slideCount === 1)
    return 0;
  var Te = 0;
  if (re ? (Te = -getPreClones(ee), ie % le !== 0 && te + le > ie && (Te = -(te > ie ? oe - (te - ie) : ie % le)), se && (Te += parseInt(oe / 2))) : (ie % le !== 0 && te + le > ie && (Te = oe - ie % le), se && (Te = parseInt(oe / 2))), ve = Te * ue, Ee = Te * pe, me ? ge = te * pe * -1 + Ee : ge = te * ue * -1 + ve, fe === !0) {
    var Se, he = ne && ne.node;
    if (Se = te + getPreClones(ee), xe = he && he.childNodes[Se], ge = xe ? xe.offsetLeft * -1 : 0, se === !0) {
      Se = re ? te + getPreClones(ee) : te, xe = he && he.children[Se], ge = 0;
      for (var Pe = 0; Pe < Se; Pe++)
        ge -= he && he.children[Pe] && he.children[Pe].offsetWidth;
      ge -= parseInt(ee.centerPadding), ge += xe && (de - xe.offsetWidth) / 2;
    }
  }
  return ge;
}, getPreClones = innerSliderUtils.getPreClones = function $(ee) {
  return ee.unslick || !ee.infinite ? 0 : ee.variableWidth ? ee.slideCount : ee.slidesToShow + (ee.centerMode ? 1 : 0);
}, getPostClones = innerSliderUtils.getPostClones = function $(ee) {
  return ee.unslick || !ee.infinite ? 0 : ee.slideCount;
}, getTotalSlides = innerSliderUtils.getTotalSlides = function $(ee) {
  return ee.slideCount === 1 ? 1 : getPreClones(ee) + ee.slideCount + getPostClones(ee);
}, siblingDirection = innerSliderUtils.siblingDirection = function $(ee) {
  return ee.targetSlide > ee.currentSlide ? ee.targetSlide > ee.currentSlide + slidesOnRight(ee) ? "left" : "right" : ee.targetSlide < ee.currentSlide - slidesOnLeft(ee) ? "right" : "left";
}, slidesOnRight = innerSliderUtils.slidesOnRight = function $(ee) {
  var te = ee.slidesToShow, ne = ee.centerMode, re = ee.rtl, se = ee.centerPadding;
  if (ne) {
    var ie = (te - 1) / 2 + 1;
    return parseInt(se) > 0 && (ie += 1), re && te % 2 === 0 && (ie += 1), ie;
  }
  return re ? 0 : te - 1;
}, slidesOnLeft = innerSliderUtils.slidesOnLeft = function $(ee) {
  var te = ee.slidesToShow, ne = ee.centerMode, re = ee.rtl, se = ee.centerPadding;
  if (ne) {
    var ie = (te - 1) / 2 + 1;
    return parseInt(se) > 0 && (ie += 1), !re && te % 2 === 0 && (ie += 1), ie;
  }
  return re ? te - 1 : 0;
};
innerSliderUtils.canUseDOM = function $() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
};
var validSettings = innerSliderUtils.validSettings = Object.keys(_defaultProps.default);
function filterSettings($) {
  return validSettings.reduce(function(ee, te) {
    return $.hasOwnProperty(te) && (ee[te] = $[te]), ee;
  }, {});
}
var track = {};
Object.defineProperty(track, "__esModule", {
  value: !0
});
track.Track = void 0;
var _react$3 = _interopRequireDefault$3(React__default), _classnames$3 = _interopRequireDefault$3(classnamesExports), _innerSliderUtils$3 = innerSliderUtils;
function _interopRequireDefault$3($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function _typeof$3($) {
  "@babel/helpers - typeof";
  return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
    return typeof ee;
  } : function(ee) {
    return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee;
  }, _typeof$3($);
}
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$2.apply(this, arguments);
}
function _classCallCheck$3($, ee) {
  if (!($ instanceof ee))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$3($, ee) {
  for (var te = 0; te < ee.length; te++) {
    var ne = ee[te];
    ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty($, _toPropertyKey$3(ne.key), ne);
  }
}
function _createClass$3($, ee, te) {
  return ee && _defineProperties$3($.prototype, ee), te && _defineProperties$3($, te), Object.defineProperty($, "prototype", { writable: !1 }), $;
}
function _inherits$3($, ee) {
  if (typeof ee != "function" && ee !== null)
    throw new TypeError("Super expression must either be null or a function");
  $.prototype = Object.create(ee && ee.prototype, { constructor: { value: $, writable: !0, configurable: !0 } }), Object.defineProperty($, "prototype", { writable: !1 }), ee && _setPrototypeOf$3($, ee);
}
function _setPrototypeOf$3($, ee) {
  return _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, re) {
    return ne.__proto__ = re, ne;
  }, _setPrototypeOf$3($, ee);
}
function _createSuper$3($) {
  var ee = _isNativeReflectConstruct$3();
  return function() {
    var ne = _getPrototypeOf$3($), re;
    if (ee) {
      var se = _getPrototypeOf$3(this).constructor;
      re = Reflect.construct(ne, arguments, se);
    } else
      re = ne.apply(this, arguments);
    return _possibleConstructorReturn$3(this, re);
  };
}
function _possibleConstructorReturn$3($, ee) {
  if (ee && (_typeof$3(ee) === "object" || typeof ee == "function"))
    return ee;
  if (ee !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$3($);
}
function _assertThisInitialized$3($) {
  if ($ === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return $;
}
function _isNativeReflectConstruct$3() {
  try {
    var $ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$3 = function() {
    return !!$;
  })();
}
function _getPrototypeOf$3($) {
  return _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
    return te.__proto__ || Object.getPrototypeOf(te);
  }, _getPrototypeOf$3($);
}
function ownKeys$3($, ee) {
  var te = Object.keys($);
  if (Object.getOwnPropertySymbols) {
    var ne = Object.getOwnPropertySymbols($);
    ee && (ne = ne.filter(function(re) {
      return Object.getOwnPropertyDescriptor($, re).enumerable;
    })), te.push.apply(te, ne);
  }
  return te;
}
function _objectSpread$3($) {
  for (var ee = 1; ee < arguments.length; ee++) {
    var te = arguments[ee] != null ? arguments[ee] : {};
    ee % 2 ? ownKeys$3(Object(te), !0).forEach(function(ne) {
      _defineProperty$3($, ne, te[ne]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(te)) : ownKeys$3(Object(te)).forEach(function(ne) {
      Object.defineProperty($, ne, Object.getOwnPropertyDescriptor(te, ne));
    });
  }
  return $;
}
function _defineProperty$3($, ee, te) {
  return ee = _toPropertyKey$3(ee), ee in $ ? Object.defineProperty($, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : $[ee] = te, $;
}
function _toPropertyKey$3($) {
  var ee = _toPrimitive$3($, "string");
  return _typeof$3(ee) == "symbol" ? ee : String(ee);
}
function _toPrimitive$3($, ee) {
  if (_typeof$3($) != "object" || !$)
    return $;
  var te = $[Symbol.toPrimitive];
  if (te !== void 0) {
    var ne = te.call($, ee || "default");
    if (_typeof$3(ne) != "object")
      return ne;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ee === "string" ? String : Number)($);
}
var getSlideClasses = function $(ee) {
  var te, ne, re, se, ie;
  ee.rtl ? ie = ee.slideCount - 1 - ee.index : ie = ee.index, re = ie < 0 || ie >= ee.slideCount, ee.centerMode ? (se = Math.floor(ee.slidesToShow / 2), ne = (ie - ee.currentSlide) % ee.slideCount === 0, ie > ee.currentSlide - se - 1 && ie <= ee.currentSlide + se && (te = !0)) : te = ee.currentSlide <= ie && ie < ee.currentSlide + ee.slidesToShow;
  var oe;
  ee.targetSlide < 0 ? oe = ee.targetSlide + ee.slideCount : ee.targetSlide >= ee.slideCount ? oe = ee.targetSlide - ee.slideCount : oe = ee.targetSlide;
  var le = ie === oe;
  return {
    "slick-slide": !0,
    "slick-active": te,
    "slick-center": ne,
    "slick-cloned": re,
    "slick-current": le
    // dubious in case of RTL
  };
}, getSlideStyle = function $(ee) {
  var te = {};
  return (ee.variableWidth === void 0 || ee.variableWidth === !1) && (te.width = ee.slideWidth), ee.fade && (te.position = "relative", ee.vertical ? te.top = -ee.index * parseInt(ee.slideHeight) : te.left = -ee.index * parseInt(ee.slideWidth), te.opacity = ee.currentSlide === ee.index ? 1 : 0, te.zIndex = ee.currentSlide === ee.index ? 999 : 998, ee.useCSS && (te.transition = "opacity " + ee.speed + "ms " + ee.cssEase + ", visibility " + ee.speed + "ms " + ee.cssEase)), te;
}, getKey = function $(ee, te) {
  return ee.key || te;
}, renderSlides = function $(ee) {
  var te, ne = [], re = [], se = [], ie = _react$3.default.Children.count(ee.children), oe = (0, _innerSliderUtils$3.lazyStartIndex)(ee), le = (0, _innerSliderUtils$3.lazyEndIndex)(ee);
  return _react$3.default.Children.forEach(ee.children, function(ue, de) {
    var fe, pe = {
      message: "children",
      index: de,
      slidesToScroll: ee.slidesToScroll,
      currentSlide: ee.currentSlide
    };
    !ee.lazyLoad || ee.lazyLoad && ee.lazyLoadedList.indexOf(de) >= 0 ? fe = ue : fe = /* @__PURE__ */ _react$3.default.createElement("div", null);
    var ye = getSlideStyle(_objectSpread$3(_objectSpread$3({}, ee), {}, {
      index: de
    })), me = fe.props.className || "", ve = getSlideClasses(_objectSpread$3(_objectSpread$3({}, ee), {}, {
      index: de
    }));
    if (ne.push(/* @__PURE__ */ _react$3.default.cloneElement(fe, {
      key: "original" + getKey(fe, de),
      "data-index": de,
      className: (0, _classnames$3.default)(ve, me),
      tabIndex: "-1",
      "aria-hidden": !ve["slick-active"],
      style: _objectSpread$3(_objectSpread$3({
        outline: "none"
      }, fe.props.style || {}), ye),
      onClick: function(Ee) {
        fe.props && fe.props.onClick && fe.props.onClick(Ee), ee.focusOnSelect && ee.focusOnSelect(pe);
      }
    })), ee.infinite && ee.fade === !1) {
      var ge = ie - de;
      ge <= (0, _innerSliderUtils$3.getPreClones)(ee) && (te = -ge, te >= oe && (fe = ue), ve = getSlideClasses(_objectSpread$3(_objectSpread$3({}, ee), {}, {
        index: te
      })), re.push(/* @__PURE__ */ _react$3.default.cloneElement(fe, {
        key: "precloned" + getKey(fe, te),
        "data-index": te,
        tabIndex: "-1",
        className: (0, _classnames$3.default)(ve, me),
        "aria-hidden": !ve["slick-active"],
        style: _objectSpread$3(_objectSpread$3({}, fe.props.style || {}), ye),
        onClick: function(Ee) {
          fe.props && fe.props.onClick && fe.props.onClick(Ee), ee.focusOnSelect && ee.focusOnSelect(pe);
        }
      }))), te = ie + de, te < le && (fe = ue), ve = getSlideClasses(_objectSpread$3(_objectSpread$3({}, ee), {}, {
        index: te
      })), se.push(/* @__PURE__ */ _react$3.default.cloneElement(fe, {
        key: "postcloned" + getKey(fe, te),
        "data-index": te,
        tabIndex: "-1",
        className: (0, _classnames$3.default)(ve, me),
        "aria-hidden": !ve["slick-active"],
        style: _objectSpread$3(_objectSpread$3({}, fe.props.style || {}), ye),
        onClick: function(Ee) {
          fe.props && fe.props.onClick && fe.props.onClick(Ee), ee.focusOnSelect && ee.focusOnSelect(pe);
        }
      }));
    }
  }), ee.rtl ? re.concat(ne, se).reverse() : re.concat(ne, se);
};
track.Track = /* @__PURE__ */ function($) {
  _inherits$3(te, $);
  var ee = _createSuper$3(te);
  function te() {
    var ne;
    _classCallCheck$3(this, te);
    for (var re = arguments.length, se = new Array(re), ie = 0; ie < re; ie++)
      se[ie] = arguments[ie];
    return ne = ee.call.apply(ee, [this].concat(se)), _defineProperty$3(_assertThisInitialized$3(ne), "node", null), _defineProperty$3(_assertThisInitialized$3(ne), "handleRef", function(oe) {
      ne.node = oe;
    }), ne;
  }
  return _createClass$3(te, [{
    key: "render",
    value: function() {
      var re = renderSlides(this.props), se = this.props, ie = se.onMouseEnter, oe = se.onMouseOver, le = se.onMouseLeave, ue = {
        onMouseEnter: ie,
        onMouseOver: oe,
        onMouseLeave: le
      };
      return /* @__PURE__ */ _react$3.default.createElement("div", _extends$2({
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle
      }, ue), re);
    }
  }]), te;
}(_react$3.default.PureComponent);
var dots = {};
function _typeof$2($) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
    return typeof ee;
  } : function(ee) {
    return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee;
  }, _typeof$2($);
}
Object.defineProperty(dots, "__esModule", {
  value: !0
});
dots.Dots = void 0;
var _react$2 = _interopRequireDefault$2(React__default), _classnames$2 = _interopRequireDefault$2(classnamesExports), _innerSliderUtils$2 = innerSliderUtils;
function _interopRequireDefault$2($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function ownKeys$2($, ee) {
  var te = Object.keys($);
  if (Object.getOwnPropertySymbols) {
    var ne = Object.getOwnPropertySymbols($);
    ee && (ne = ne.filter(function(re) {
      return Object.getOwnPropertyDescriptor($, re).enumerable;
    })), te.push.apply(te, ne);
  }
  return te;
}
function _objectSpread$2($) {
  for (var ee = 1; ee < arguments.length; ee++) {
    var te = arguments[ee] != null ? arguments[ee] : {};
    ee % 2 ? ownKeys$2(Object(te), !0).forEach(function(ne) {
      _defineProperty$2($, ne, te[ne]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(te)) : ownKeys$2(Object(te)).forEach(function(ne) {
      Object.defineProperty($, ne, Object.getOwnPropertyDescriptor(te, ne));
    });
  }
  return $;
}
function _defineProperty$2($, ee, te) {
  return ee = _toPropertyKey$2(ee), ee in $ ? Object.defineProperty($, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : $[ee] = te, $;
}
function _classCallCheck$2($, ee) {
  if (!($ instanceof ee))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2($, ee) {
  for (var te = 0; te < ee.length; te++) {
    var ne = ee[te];
    ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty($, _toPropertyKey$2(ne.key), ne);
  }
}
function _createClass$2($, ee, te) {
  return ee && _defineProperties$2($.prototype, ee), te && _defineProperties$2($, te), Object.defineProperty($, "prototype", { writable: !1 }), $;
}
function _toPropertyKey$2($) {
  var ee = _toPrimitive$2($, "string");
  return _typeof$2(ee) == "symbol" ? ee : String(ee);
}
function _toPrimitive$2($, ee) {
  if (_typeof$2($) != "object" || !$)
    return $;
  var te = $[Symbol.toPrimitive];
  if (te !== void 0) {
    var ne = te.call($, ee || "default");
    if (_typeof$2(ne) != "object")
      return ne;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ee === "string" ? String : Number)($);
}
function _inherits$2($, ee) {
  if (typeof ee != "function" && ee !== null)
    throw new TypeError("Super expression must either be null or a function");
  $.prototype = Object.create(ee && ee.prototype, { constructor: { value: $, writable: !0, configurable: !0 } }), Object.defineProperty($, "prototype", { writable: !1 }), ee && _setPrototypeOf$2($, ee);
}
function _setPrototypeOf$2($, ee) {
  return _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, re) {
    return ne.__proto__ = re, ne;
  }, _setPrototypeOf$2($, ee);
}
function _createSuper$2($) {
  var ee = _isNativeReflectConstruct$2();
  return function() {
    var ne = _getPrototypeOf$2($), re;
    if (ee) {
      var se = _getPrototypeOf$2(this).constructor;
      re = Reflect.construct(ne, arguments, se);
    } else
      re = ne.apply(this, arguments);
    return _possibleConstructorReturn$2(this, re);
  };
}
function _possibleConstructorReturn$2($, ee) {
  if (ee && (_typeof$2(ee) === "object" || typeof ee == "function"))
    return ee;
  if (ee !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$2($);
}
function _assertThisInitialized$2($) {
  if ($ === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return $;
}
function _isNativeReflectConstruct$2() {
  try {
    var $ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$2 = function() {
    return !!$;
  })();
}
function _getPrototypeOf$2($) {
  return _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
    return te.__proto__ || Object.getPrototypeOf(te);
  }, _getPrototypeOf$2($);
}
var getDotCount = function $(ee) {
  var te;
  return ee.infinite ? te = Math.ceil(ee.slideCount / ee.slidesToScroll) : te = Math.ceil((ee.slideCount - ee.slidesToShow) / ee.slidesToScroll) + 1, te;
};
dots.Dots = /* @__PURE__ */ function($) {
  _inherits$2(te, $);
  var ee = _createSuper$2(te);
  function te() {
    return _classCallCheck$2(this, te), ee.apply(this, arguments);
  }
  return _createClass$2(te, [{
    key: "clickHandler",
    value: function(re, se) {
      se.preventDefault(), this.props.clickHandler(re);
    }
  }, {
    key: "render",
    value: function() {
      for (var re = this.props, se = re.onMouseEnter, ie = re.onMouseOver, oe = re.onMouseLeave, le = re.infinite, ue = re.slidesToScroll, de = re.slidesToShow, fe = re.slideCount, pe = re.currentSlide, ye = getDotCount({
        slideCount: fe,
        slidesToScroll: ue,
        slidesToShow: de,
        infinite: le
      }), me = {
        onMouseEnter: se,
        onMouseOver: ie,
        onMouseLeave: oe
      }, ve = [], ge = 0; ge < ye; ge++) {
        var xe = (ge + 1) * ue - 1, Ee = le ? xe : (0, _innerSliderUtils$2.clamp)(xe, 0, fe - 1), Te = Ee - (ue - 1), Se = le ? Te : (0, _innerSliderUtils$2.clamp)(Te, 0, fe - 1), he = (0, _classnames$2.default)({
          "slick-active": le ? pe >= Se && pe <= Ee : pe === Se
        }), Pe = {
          message: "dots",
          index: ge,
          slidesToScroll: ue,
          currentSlide: pe
        }, Ie = this.clickHandler.bind(this, Pe);
        ve = ve.concat(/* @__PURE__ */ _react$2.default.createElement("li", {
          key: ge,
          className: he
        }, /* @__PURE__ */ _react$2.default.cloneElement(this.props.customPaging(ge), {
          onClick: Ie
        })));
      }
      return /* @__PURE__ */ _react$2.default.cloneElement(this.props.appendDots(ve), _objectSpread$2({
        className: this.props.dotsClass
      }, me));
    }
  }]), te;
}(_react$2.default.PureComponent);
var arrows = {};
function _typeof$1($) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
    return typeof ee;
  } : function(ee) {
    return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee;
  }, _typeof$1($);
}
Object.defineProperty(arrows, "__esModule", {
  value: !0
});
arrows.PrevArrow = arrows.NextArrow = void 0;
var _react$1 = _interopRequireDefault$1(React__default), _classnames$1 = _interopRequireDefault$1(classnamesExports), _innerSliderUtils$1 = innerSliderUtils;
function _interopRequireDefault$1($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends$1.apply(this, arguments);
}
function ownKeys$1($, ee) {
  var te = Object.keys($);
  if (Object.getOwnPropertySymbols) {
    var ne = Object.getOwnPropertySymbols($);
    ee && (ne = ne.filter(function(re) {
      return Object.getOwnPropertyDescriptor($, re).enumerable;
    })), te.push.apply(te, ne);
  }
  return te;
}
function _objectSpread$1($) {
  for (var ee = 1; ee < arguments.length; ee++) {
    var te = arguments[ee] != null ? arguments[ee] : {};
    ee % 2 ? ownKeys$1(Object(te), !0).forEach(function(ne) {
      _defineProperty$1($, ne, te[ne]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(te)) : ownKeys$1(Object(te)).forEach(function(ne) {
      Object.defineProperty($, ne, Object.getOwnPropertyDescriptor(te, ne));
    });
  }
  return $;
}
function _defineProperty$1($, ee, te) {
  return ee = _toPropertyKey$1(ee), ee in $ ? Object.defineProperty($, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : $[ee] = te, $;
}
function _classCallCheck$1($, ee) {
  if (!($ instanceof ee))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1($, ee) {
  for (var te = 0; te < ee.length; te++) {
    var ne = ee[te];
    ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty($, _toPropertyKey$1(ne.key), ne);
  }
}
function _createClass$1($, ee, te) {
  return ee && _defineProperties$1($.prototype, ee), te && _defineProperties$1($, te), Object.defineProperty($, "prototype", { writable: !1 }), $;
}
function _toPropertyKey$1($) {
  var ee = _toPrimitive$1($, "string");
  return _typeof$1(ee) == "symbol" ? ee : String(ee);
}
function _toPrimitive$1($, ee) {
  if (_typeof$1($) != "object" || !$)
    return $;
  var te = $[Symbol.toPrimitive];
  if (te !== void 0) {
    var ne = te.call($, ee || "default");
    if (_typeof$1(ne) != "object")
      return ne;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ee === "string" ? String : Number)($);
}
function _inherits$1($, ee) {
  if (typeof ee != "function" && ee !== null)
    throw new TypeError("Super expression must either be null or a function");
  $.prototype = Object.create(ee && ee.prototype, { constructor: { value: $, writable: !0, configurable: !0 } }), Object.defineProperty($, "prototype", { writable: !1 }), ee && _setPrototypeOf$1($, ee);
}
function _setPrototypeOf$1($, ee) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, re) {
    return ne.__proto__ = re, ne;
  }, _setPrototypeOf$1($, ee);
}
function _createSuper$1($) {
  var ee = _isNativeReflectConstruct$1();
  return function() {
    var ne = _getPrototypeOf$1($), re;
    if (ee) {
      var se = _getPrototypeOf$1(this).constructor;
      re = Reflect.construct(ne, arguments, se);
    } else
      re = ne.apply(this, arguments);
    return _possibleConstructorReturn$1(this, re);
  };
}
function _possibleConstructorReturn$1($, ee) {
  if (ee && (_typeof$1(ee) === "object" || typeof ee == "function"))
    return ee;
  if (ee !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$1($);
}
function _assertThisInitialized$1($) {
  if ($ === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return $;
}
function _isNativeReflectConstruct$1() {
  try {
    var $ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$1 = function() {
    return !!$;
  })();
}
function _getPrototypeOf$1($) {
  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
    return te.__proto__ || Object.getPrototypeOf(te);
  }, _getPrototypeOf$1($);
}
arrows.PrevArrow = /* @__PURE__ */ function($) {
  _inherits$1(te, $);
  var ee = _createSuper$1(te);
  function te() {
    return _classCallCheck$1(this, te), ee.apply(this, arguments);
  }
  return _createClass$1(te, [{
    key: "clickHandler",
    value: function(re, se) {
      se && se.preventDefault(), this.props.clickHandler(re, se);
    }
  }, {
    key: "render",
    value: function() {
      var re = {
        "slick-arrow": !0,
        "slick-prev": !0
      }, se = this.clickHandler.bind(this, {
        message: "previous"
      });
      !this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow) && (re["slick-disabled"] = !0, se = null);
      var ie = {
        key: "0",
        "data-role": "none",
        className: (0, _classnames$1.default)(re),
        style: {
          display: "block"
        },
        onClick: se
      }, oe = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      }, le;
      return this.props.prevArrow ? le = /* @__PURE__ */ _react$1.default.cloneElement(this.props.prevArrow, _objectSpread$1(_objectSpread$1({}, ie), oe)) : le = /* @__PURE__ */ _react$1.default.createElement("button", _extends$1({
        key: "0",
        type: "button"
      }, ie), " ", "Previous"), le;
    }
  }]), te;
}(_react$1.default.PureComponent);
arrows.NextArrow = /* @__PURE__ */ function($) {
  _inherits$1(te, $);
  var ee = _createSuper$1(te);
  function te() {
    return _classCallCheck$1(this, te), ee.apply(this, arguments);
  }
  return _createClass$1(te, [{
    key: "clickHandler",
    value: function(re, se) {
      se && se.preventDefault(), this.props.clickHandler(re, se);
    }
  }, {
    key: "render",
    value: function() {
      var re = {
        "slick-arrow": !0,
        "slick-next": !0
      }, se = this.clickHandler.bind(this, {
        message: "next"
      });
      (0, _innerSliderUtils$1.canGoNext)(this.props) || (re["slick-disabled"] = !0, se = null);
      var ie = {
        key: "1",
        "data-role": "none",
        className: (0, _classnames$1.default)(re),
        style: {
          display: "block"
        },
        onClick: se
      }, oe = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      }, le;
      return this.props.nextArrow ? le = /* @__PURE__ */ _react$1.default.cloneElement(this.props.nextArrow, _objectSpread$1(_objectSpread$1({}, ie), oe)) : le = /* @__PURE__ */ _react$1.default.createElement("button", _extends$1({
        key: "1",
        type: "button"
      }, ie), " ", "Next"), le;
    }
  }]), te;
}(_react$1.default.PureComponent);
var MapShim = function() {
  if (typeof Map < "u")
    return Map;
  function $(ee, te) {
    var ne = -1;
    return ee.some(function(re, se) {
      return re[0] === te ? (ne = se, !0) : !1;
    }), ne;
  }
  return (
    /** @class */
    function() {
      function ee() {
        this.__entries__ = [];
      }
      return Object.defineProperty(ee.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), ee.prototype.get = function(te) {
        var ne = $(this.__entries__, te), re = this.__entries__[ne];
        return re && re[1];
      }, ee.prototype.set = function(te, ne) {
        var re = $(this.__entries__, te);
        ~re ? this.__entries__[re][1] = ne : this.__entries__.push([te, ne]);
      }, ee.prototype.delete = function(te) {
        var ne = this.__entries__, re = $(ne, te);
        ~re && ne.splice(re, 1);
      }, ee.prototype.has = function(te) {
        return !!~$(this.__entries__, te);
      }, ee.prototype.clear = function() {
        this.__entries__.splice(0);
      }, ee.prototype.forEach = function(te, ne) {
        ne === void 0 && (ne = null);
        for (var re = 0, se = this.__entries__; re < se.length; re++) {
          var ie = se[re];
          te.call(ne, ie[1], ie[0]);
        }
      }, ee;
    }()
  );
}(), isBrowser = typeof window < "u" && typeof document < "u" && window.document === document, global$1 = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), requestAnimationFrame$1 = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function($) {
    return setTimeout(function() {
      return $(Date.now());
    }, 1e3 / 60);
  };
}(), trailingTimeout = 2;
function throttle($, ee) {
  var te = !1, ne = !1, re = 0;
  function se() {
    te && (te = !1, $()), ne && oe();
  }
  function ie() {
    requestAnimationFrame$1(se);
  }
  function oe() {
    var le = Date.now();
    if (te) {
      if (le - re < trailingTimeout)
        return;
      ne = !0;
    } else
      te = !0, ne = !1, setTimeout(ie, ee);
    re = le;
  }
  return oe;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver < "u", ResizeObserverController = (
  /** @class */
  function() {
    function $() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    return $.prototype.addObserver = function(ee) {
      ~this.observers_.indexOf(ee) || this.observers_.push(ee), this.connected_ || this.connect_();
    }, $.prototype.removeObserver = function(ee) {
      var te = this.observers_, ne = te.indexOf(ee);
      ~ne && te.splice(ne, 1), !te.length && this.connected_ && this.disconnect_();
    }, $.prototype.refresh = function() {
      var ee = this.updateObservers_();
      ee && this.refresh();
    }, $.prototype.updateObservers_ = function() {
      var ee = this.observers_.filter(function(te) {
        return te.gatherActive(), te.hasActive();
      });
      return ee.forEach(function(te) {
        return te.broadcastActive();
      }), ee.length > 0;
    }, $.prototype.connect_ = function() {
      !isBrowser || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, $.prototype.disconnect_ = function() {
      !isBrowser || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, $.prototype.onTransitionEnd_ = function(ee) {
      var te = ee.propertyName, ne = te === void 0 ? "" : te, re = transitionKeys.some(function(se) {
        return !!~ne.indexOf(se);
      });
      re && this.refresh();
    }, $.getInstance = function() {
      return this.instance_ || (this.instance_ = new $()), this.instance_;
    }, $.instance_ = null, $;
  }()
), defineConfigurable = function($, ee) {
  for (var te = 0, ne = Object.keys(ee); te < ne.length; te++) {
    var re = ne[te];
    Object.defineProperty($, re, {
      value: ee[re],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return $;
}, getWindowOf = function($) {
  var ee = $ && $.ownerDocument && $.ownerDocument.defaultView;
  return ee || global$1;
}, emptyRect = createRectInit(0, 0, 0, 0);
function toFloat($) {
  return parseFloat($) || 0;
}
function getBordersSize($) {
  for (var ee = [], te = 1; te < arguments.length; te++)
    ee[te - 1] = arguments[te];
  return ee.reduce(function(ne, re) {
    var se = $["border-" + re + "-width"];
    return ne + toFloat(se);
  }, 0);
}
function getPaddings($) {
  for (var ee = ["top", "right", "bottom", "left"], te = {}, ne = 0, re = ee; ne < re.length; ne++) {
    var se = re[ne], ie = $["padding-" + se];
    te[se] = toFloat(ie);
  }
  return te;
}
function getSVGContentRect($) {
  var ee = $.getBBox();
  return createRectInit(0, 0, ee.width, ee.height);
}
function getHTMLElementContentRect($) {
  var ee = $.clientWidth, te = $.clientHeight;
  if (!ee && !te)
    return emptyRect;
  var ne = getWindowOf($).getComputedStyle($), re = getPaddings(ne), se = re.left + re.right, ie = re.top + re.bottom, oe = toFloat(ne.width), le = toFloat(ne.height);
  if (ne.boxSizing === "border-box" && (Math.round(oe + se) !== ee && (oe -= getBordersSize(ne, "left", "right") + se), Math.round(le + ie) !== te && (le -= getBordersSize(ne, "top", "bottom") + ie)), !isDocumentElement($)) {
    var ue = Math.round(oe + se) - ee, de = Math.round(le + ie) - te;
    Math.abs(ue) !== 1 && (oe -= ue), Math.abs(de) !== 1 && (le -= de);
  }
  return createRectInit(re.left, re.top, oe, le);
}
var isSVGGraphicsElement = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function($) {
    return $ instanceof getWindowOf($).SVGGraphicsElement;
  } : function($) {
    return $ instanceof getWindowOf($).SVGElement && typeof $.getBBox == "function";
  };
}();
function isDocumentElement($) {
  return $ === getWindowOf($).document.documentElement;
}
function getContentRect($) {
  return isBrowser ? isSVGGraphicsElement($) ? getSVGContentRect($) : getHTMLElementContentRect($) : emptyRect;
}
function createReadOnlyRect($) {
  var ee = $.x, te = $.y, ne = $.width, re = $.height, se = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, ie = Object.create(se.prototype);
  return defineConfigurable(ie, {
    x: ee,
    y: te,
    width: ne,
    height: re,
    top: te,
    right: ee + ne,
    bottom: re + te,
    left: ee
  }), ie;
}
function createRectInit($, ee, te, ne) {
  return { x: $, y: ee, width: te, height: ne };
}
var ResizeObservation = (
  /** @class */
  function() {
    function $(ee) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = ee;
    }
    return $.prototype.isActive = function() {
      var ee = getContentRect(this.target);
      return this.contentRect_ = ee, ee.width !== this.broadcastWidth || ee.height !== this.broadcastHeight;
    }, $.prototype.broadcastRect = function() {
      var ee = this.contentRect_;
      return this.broadcastWidth = ee.width, this.broadcastHeight = ee.height, ee;
    }, $;
  }()
), ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function $(ee, te) {
      var ne = createReadOnlyRect(te);
      defineConfigurable(this, { target: ee, contentRect: ne });
    }
    return $;
  }()
), ResizeObserverSPI = (
  /** @class */
  function() {
    function $(ee, te, ne) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof ee != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = ee, this.controller_ = te, this.callbackCtx_ = ne;
    }
    return $.prototype.observe = function(ee) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(ee instanceof getWindowOf(ee).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var te = this.observations_;
        te.has(ee) || (te.set(ee, new ResizeObservation(ee)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, $.prototype.unobserve = function(ee) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(ee instanceof getWindowOf(ee).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var te = this.observations_;
        te.has(ee) && (te.delete(ee), te.size || this.controller_.removeObserver(this));
      }
    }, $.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, $.prototype.gatherActive = function() {
      var ee = this;
      this.clearActive(), this.observations_.forEach(function(te) {
        te.isActive() && ee.activeObservations_.push(te);
      });
    }, $.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var ee = this.callbackCtx_, te = this.activeObservations_.map(function(ne) {
          return new ResizeObserverEntry(ne.target, ne.broadcastRect());
        });
        this.callback_.call(ee, te, ee), this.clearActive();
      }
    }, $.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, $.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, $;
  }()
), observers = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function $(ee) {
      if (!(this instanceof $))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var te = ResizeObserverController.getInstance(), ne = new ResizeObserverSPI(ee, te, this);
      observers.set(this, ne);
    }
    return $;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function($) {
  ResizeObserver$1.prototype[$] = function() {
    var ee;
    return (ee = observers.get(this))[$].apply(ee, arguments);
  };
});
var index = function() {
  return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$1;
}();
const ResizeObserver_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: index
}, Symbol.toStringTag, { value: "Module" })), require$$8 = /* @__PURE__ */ getAugmentedNamespace(ResizeObserver_es);
Object.defineProperty(innerSlider, "__esModule", {
  value: !0
});
innerSlider.InnerSlider = void 0;
var _react = _interopRequireDefault(React__default), _initialState = _interopRequireDefault(initialState), _lodash = _interopRequireDefault(lodash_debounce), _classnames = _interopRequireDefault(classnamesExports), _innerSliderUtils = innerSliderUtils, _track = track, _dots = dots, _arrows = arrows, _resizeObserverPolyfill = _interopRequireDefault(require$$8);
function _interopRequireDefault($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function _typeof($) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ee) {
    return typeof ee;
  } : function(ee) {
    return ee && typeof Symbol == "function" && ee.constructor === Symbol && ee !== Symbol.prototype ? "symbol" : typeof ee;
  }, _typeof($);
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function($) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var te = arguments[ee];
      for (var ne in te)
        Object.prototype.hasOwnProperty.call(te, ne) && ($[ne] = te[ne]);
    }
    return $;
  }, _extends.apply(this, arguments);
}
function _objectWithoutProperties($, ee) {
  if ($ == null)
    return {};
  var te = _objectWithoutPropertiesLoose($, ee), ne, re;
  if (Object.getOwnPropertySymbols) {
    var se = Object.getOwnPropertySymbols($);
    for (re = 0; re < se.length; re++)
      ne = se[re], !(ee.indexOf(ne) >= 0) && Object.prototype.propertyIsEnumerable.call($, ne) && (te[ne] = $[ne]);
  }
  return te;
}
function _objectWithoutPropertiesLoose($, ee) {
  if ($ == null)
    return {};
  var te = {}, ne = Object.keys($), re, se;
  for (se = 0; se < ne.length; se++)
    re = ne[se], !(ee.indexOf(re) >= 0) && (te[re] = $[re]);
  return te;
}
function ownKeys($, ee) {
  var te = Object.keys($);
  if (Object.getOwnPropertySymbols) {
    var ne = Object.getOwnPropertySymbols($);
    ee && (ne = ne.filter(function(re) {
      return Object.getOwnPropertyDescriptor($, re).enumerable;
    })), te.push.apply(te, ne);
  }
  return te;
}
function _objectSpread($) {
  for (var ee = 1; ee < arguments.length; ee++) {
    var te = arguments[ee] != null ? arguments[ee] : {};
    ee % 2 ? ownKeys(Object(te), !0).forEach(function(ne) {
      _defineProperty($, ne, te[ne]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(te)) : ownKeys(Object(te)).forEach(function(ne) {
      Object.defineProperty($, ne, Object.getOwnPropertyDescriptor(te, ne));
    });
  }
  return $;
}
function _classCallCheck($, ee) {
  if (!($ instanceof ee))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties($, ee) {
  for (var te = 0; te < ee.length; te++) {
    var ne = ee[te];
    ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty($, _toPropertyKey(ne.key), ne);
  }
}
function _createClass($, ee, te) {
  return ee && _defineProperties($.prototype, ee), te && _defineProperties($, te), Object.defineProperty($, "prototype", { writable: !1 }), $;
}
function _inherits($, ee) {
  if (typeof ee != "function" && ee !== null)
    throw new TypeError("Super expression must either be null or a function");
  $.prototype = Object.create(ee && ee.prototype, { constructor: { value: $, writable: !0, configurable: !0 } }), Object.defineProperty($, "prototype", { writable: !1 }), ee && _setPrototypeOf($, ee);
}
function _setPrototypeOf($, ee) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, re) {
    return ne.__proto__ = re, ne;
  }, _setPrototypeOf($, ee);
}
function _createSuper($) {
  var ee = _isNativeReflectConstruct();
  return function() {
    var ne = _getPrototypeOf($), re;
    if (ee) {
      var se = _getPrototypeOf(this).constructor;
      re = Reflect.construct(ne, arguments, se);
    } else
      re = ne.apply(this, arguments);
    return _possibleConstructorReturn(this, re);
  };
}
function _possibleConstructorReturn($, ee) {
  if (ee && (_typeof(ee) === "object" || typeof ee == "function"))
    return ee;
  if (ee !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized($);
}
function _assertThisInitialized($) {
  if ($ === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return $;
}
function _isNativeReflectConstruct() {
  try {
    var $ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct = function() {
    return !!$;
  })();
}
function _getPrototypeOf($) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
    return te.__proto__ || Object.getPrototypeOf(te);
  }, _getPrototypeOf($);
}
function _defineProperty($, ee, te) {
  return ee = _toPropertyKey(ee), ee in $ ? Object.defineProperty($, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : $[ee] = te, $;
}
function _toPropertyKey($) {
  var ee = _toPrimitive($, "string");
  return _typeof(ee) == "symbol" ? ee : String(ee);
}
function _toPrimitive($, ee) {
  if (_typeof($) != "object" || !$)
    return $;
  var te = $[Symbol.toPrimitive];
  if (te !== void 0) {
    var ne = te.call($, ee || "default");
    if (_typeof(ne) != "object")
      return ne;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (ee === "string" ? String : Number)($);
}
innerSlider.InnerSlider = /* @__PURE__ */ function($) {
  _inherits(te, $);
  var ee = _createSuper(te);
  function te(ne) {
    var re;
    _classCallCheck(this, te), re = ee.call(this, ne), _defineProperty(_assertThisInitialized(re), "listRefHandler", function(ie) {
      return re.list = ie;
    }), _defineProperty(_assertThisInitialized(re), "trackRefHandler", function(ie) {
      return re.track = ie;
    }), _defineProperty(_assertThisInitialized(re), "adaptHeight", function() {
      if (re.props.adaptiveHeight && re.list) {
        var ie = re.list.querySelector('[data-index="'.concat(re.state.currentSlide, '"]'));
        re.list.style.height = (0, _innerSliderUtils.getHeight)(ie) + "px";
      }
    }), _defineProperty(_assertThisInitialized(re), "componentDidMount", function() {
      if (re.props.onInit && re.props.onInit(), re.props.lazyLoad) {
        var ie = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, re.props), re.state));
        ie.length > 0 && (re.setState(function(le) {
          return {
            lazyLoadedList: le.lazyLoadedList.concat(ie)
          };
        }), re.props.onLazyLoad && re.props.onLazyLoad(ie));
      }
      var oe = _objectSpread({
        listRef: re.list,
        trackRef: re.track
      }, re.props);
      re.updateState(oe, !0, function() {
        re.adaptHeight(), re.props.autoplay && re.autoPlay("update");
      }), re.props.lazyLoad === "progressive" && (re.lazyLoadTimer = setInterval(re.progressiveLazyLoad, 1e3)), re.ro = new _resizeObserverPolyfill.default(function() {
        re.state.animating ? (re.onWindowResized(!1), re.callbackTimers.push(setTimeout(function() {
          return re.onWindowResized();
        }, re.props.speed))) : re.onWindowResized();
      }), re.ro.observe(re.list), document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(le) {
        le.onfocus = re.props.pauseOnFocus ? re.onSlideFocus : null, le.onblur = re.props.pauseOnFocus ? re.onSlideBlur : null;
      }), window.addEventListener ? window.addEventListener("resize", re.onWindowResized) : window.attachEvent("onresize", re.onWindowResized);
    }), _defineProperty(_assertThisInitialized(re), "componentWillUnmount", function() {
      re.animationEndCallback && clearTimeout(re.animationEndCallback), re.lazyLoadTimer && clearInterval(re.lazyLoadTimer), re.callbackTimers.length && (re.callbackTimers.forEach(function(ie) {
        return clearTimeout(ie);
      }), re.callbackTimers = []), window.addEventListener ? window.removeEventListener("resize", re.onWindowResized) : window.detachEvent("onresize", re.onWindowResized), re.autoplayTimer && clearInterval(re.autoplayTimer), re.ro.disconnect();
    }), _defineProperty(_assertThisInitialized(re), "componentDidUpdate", function(ie) {
      if (re.checkImagesLoad(), re.props.onReInit && re.props.onReInit(), re.props.lazyLoad) {
        var oe = (0, _innerSliderUtils.getOnDemandLazySlides)(_objectSpread(_objectSpread({}, re.props), re.state));
        oe.length > 0 && (re.setState(function(de) {
          return {
            lazyLoadedList: de.lazyLoadedList.concat(oe)
          };
        }), re.props.onLazyLoad && re.props.onLazyLoad(oe));
      }
      re.adaptHeight();
      var le = _objectSpread(_objectSpread({
        listRef: re.list,
        trackRef: re.track
      }, re.props), re.state), ue = re.didPropsChange(ie);
      ue && re.updateState(le, ue, function() {
        re.state.currentSlide >= _react.default.Children.count(re.props.children) && re.changeSlide({
          message: "index",
          index: _react.default.Children.count(re.props.children) - re.props.slidesToShow,
          currentSlide: re.state.currentSlide
        }), re.props.autoplay ? re.autoPlay("update") : re.pause("paused");
      });
    }), _defineProperty(_assertThisInitialized(re), "onWindowResized", function(ie) {
      re.debouncedResize && re.debouncedResize.cancel(), re.debouncedResize = (0, _lodash.default)(function() {
        return re.resizeWindow(ie);
      }, 50), re.debouncedResize();
    }), _defineProperty(_assertThisInitialized(re), "resizeWindow", function() {
      var ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, oe = !!(re.track && re.track.node);
      if (oe) {
        var le = _objectSpread(_objectSpread({
          listRef: re.list,
          trackRef: re.track
        }, re.props), re.state);
        re.updateState(le, ie, function() {
          re.props.autoplay ? re.autoPlay("update") : re.pause("paused");
        }), re.setState({
          animating: !1
        }), clearTimeout(re.animationEndCallback), delete re.animationEndCallback;
      }
    }), _defineProperty(_assertThisInitialized(re), "updateState", function(ie, oe, le) {
      var ue = (0, _innerSliderUtils.initializedState)(ie);
      ie = _objectSpread(_objectSpread(_objectSpread({}, ie), ue), {}, {
        slideIndex: ue.currentSlide
      });
      var de = (0, _innerSliderUtils.getTrackLeft)(ie);
      ie = _objectSpread(_objectSpread({}, ie), {}, {
        left: de
      });
      var fe = (0, _innerSliderUtils.getTrackCSS)(ie);
      (oe || _react.default.Children.count(re.props.children) !== _react.default.Children.count(ie.children)) && (ue.trackStyle = fe), re.setState(ue, le);
    }), _defineProperty(_assertThisInitialized(re), "ssrInit", function() {
      if (re.props.variableWidth) {
        var ie = 0, oe = 0, le = [], ue = (0, _innerSliderUtils.getPreClones)(_objectSpread(_objectSpread(_objectSpread({}, re.props), re.state), {}, {
          slideCount: re.props.children.length
        })), de = (0, _innerSliderUtils.getPostClones)(_objectSpread(_objectSpread(_objectSpread({}, re.props), re.state), {}, {
          slideCount: re.props.children.length
        }));
        re.props.children.forEach(function(Ie) {
          le.push(Ie.props.style.width), ie += Ie.props.style.width;
        });
        for (var fe = 0; fe < ue; fe++)
          oe += le[le.length - 1 - fe], ie += le[le.length - 1 - fe];
        for (var pe = 0; pe < de; pe++)
          ie += le[pe];
        for (var ye = 0; ye < re.state.currentSlide; ye++)
          oe += le[ye];
        var me = {
          width: ie + "px",
          left: -oe + "px"
        };
        if (re.props.centerMode) {
          var ve = "".concat(le[re.state.currentSlide], "px");
          me.left = "calc(".concat(me.left, " + (100% - ").concat(ve, ") / 2 ) ");
        }
        return {
          trackStyle: me
        };
      }
      var ge = _react.default.Children.count(re.props.children), xe = _objectSpread(_objectSpread(_objectSpread({}, re.props), re.state), {}, {
        slideCount: ge
      }), Ee = (0, _innerSliderUtils.getPreClones)(xe) + (0, _innerSliderUtils.getPostClones)(xe) + ge, Te = 100 / re.props.slidesToShow * Ee, Se = 100 / Ee, he = -Se * ((0, _innerSliderUtils.getPreClones)(xe) + re.state.currentSlide) * Te / 100;
      re.props.centerMode && (he += (100 - Se * Te / 100) / 2);
      var Pe = {
        width: Te + "%",
        left: he + "%"
      };
      return {
        slideWidth: Se + "%",
        trackStyle: Pe
      };
    }), _defineProperty(_assertThisInitialized(re), "checkImagesLoad", function() {
      var ie = re.list && re.list.querySelectorAll && re.list.querySelectorAll(".slick-slide img") || [], oe = ie.length, le = 0;
      Array.prototype.forEach.call(ie, function(ue) {
        var de = function() {
          return ++le && le >= oe && re.onWindowResized();
        };
        if (!ue.onclick)
          ue.onclick = function() {
            return ue.parentNode.focus();
          };
        else {
          var fe = ue.onclick;
          ue.onclick = function(pe) {
            fe(pe), ue.parentNode.focus();
          };
        }
        ue.onload || (re.props.lazyLoad ? ue.onload = function() {
          re.adaptHeight(), re.callbackTimers.push(setTimeout(re.onWindowResized, re.props.speed));
        } : (ue.onload = de, ue.onerror = function() {
          de(), re.props.onLazyLoadError && re.props.onLazyLoadError();
        }));
      });
    }), _defineProperty(_assertThisInitialized(re), "progressiveLazyLoad", function() {
      for (var ie = [], oe = _objectSpread(_objectSpread({}, re.props), re.state), le = re.state.currentSlide; le < re.state.slideCount + (0, _innerSliderUtils.getPostClones)(oe); le++)
        if (re.state.lazyLoadedList.indexOf(le) < 0) {
          ie.push(le);
          break;
        }
      for (var ue = re.state.currentSlide - 1; ue >= -(0, _innerSliderUtils.getPreClones)(oe); ue--)
        if (re.state.lazyLoadedList.indexOf(ue) < 0) {
          ie.push(ue);
          break;
        }
      ie.length > 0 ? (re.setState(function(de) {
        return {
          lazyLoadedList: de.lazyLoadedList.concat(ie)
        };
      }), re.props.onLazyLoad && re.props.onLazyLoad(ie)) : re.lazyLoadTimer && (clearInterval(re.lazyLoadTimer), delete re.lazyLoadTimer);
    }), _defineProperty(_assertThisInitialized(re), "slideHandler", function(ie) {
      var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, le = re.props, ue = le.asNavFor, de = le.beforeChange, fe = le.onLazyLoad, pe = le.speed, ye = le.afterChange, me = re.state.currentSlide, ve = (0, _innerSliderUtils.slideHandler)(_objectSpread(_objectSpread(_objectSpread({
        index: ie
      }, re.props), re.state), {}, {
        trackRef: re.track,
        useCSS: re.props.useCSS && !oe
      })), ge = ve.state, xe = ve.nextState;
      if (ge) {
        de && de(me, ge.currentSlide);
        var Ee = ge.lazyLoadedList.filter(function(Te) {
          return re.state.lazyLoadedList.indexOf(Te) < 0;
        });
        fe && Ee.length > 0 && fe(Ee), !re.props.waitForAnimate && re.animationEndCallback && (clearTimeout(re.animationEndCallback), ye && ye(me), delete re.animationEndCallback), re.setState(ge, function() {
          ue && re.asNavForIndex !== ie && (re.asNavForIndex = ie, ue.innerSlider.slideHandler(ie)), xe && (re.animationEndCallback = setTimeout(function() {
            var Te = xe.animating, Se = _objectWithoutProperties(xe, ["animating"]);
            re.setState(Se, function() {
              re.callbackTimers.push(setTimeout(function() {
                return re.setState({
                  animating: Te
                });
              }, 10)), ye && ye(ge.currentSlide), delete re.animationEndCallback;
            });
          }, pe));
        });
      }
    }), _defineProperty(_assertThisInitialized(re), "changeSlide", function(ie) {
      var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, le = _objectSpread(_objectSpread({}, re.props), re.state), ue = (0, _innerSliderUtils.changeSlide)(le, ie);
      if (!(ue !== 0 && !ue) && (oe === !0 ? re.slideHandler(ue, oe) : re.slideHandler(ue), re.props.autoplay && re.autoPlay("update"), re.props.focusOnSelect)) {
        var de = re.list.querySelectorAll(".slick-current");
        de[0] && de[0].focus();
      }
    }), _defineProperty(_assertThisInitialized(re), "clickHandler", function(ie) {
      re.clickable === !1 && (ie.stopPropagation(), ie.preventDefault()), re.clickable = !0;
    }), _defineProperty(_assertThisInitialized(re), "keyHandler", function(ie) {
      var oe = (0, _innerSliderUtils.keyHandler)(ie, re.props.accessibility, re.props.rtl);
      oe !== "" && re.changeSlide({
        message: oe
      });
    }), _defineProperty(_assertThisInitialized(re), "selectHandler", function(ie) {
      re.changeSlide(ie);
    }), _defineProperty(_assertThisInitialized(re), "disableBodyScroll", function() {
      var ie = function(le) {
        le = le || window.event, le.preventDefault && le.preventDefault(), le.returnValue = !1;
      };
      window.ontouchmove = ie;
    }), _defineProperty(_assertThisInitialized(re), "enableBodyScroll", function() {
      window.ontouchmove = null;
    }), _defineProperty(_assertThisInitialized(re), "swipeStart", function(ie) {
      re.props.verticalSwiping && re.disableBodyScroll();
      var oe = (0, _innerSliderUtils.swipeStart)(ie, re.props.swipe, re.props.draggable);
      oe !== "" && re.setState(oe);
    }), _defineProperty(_assertThisInitialized(re), "swipeMove", function(ie) {
      var oe = (0, _innerSliderUtils.swipeMove)(ie, _objectSpread(_objectSpread(_objectSpread({}, re.props), re.state), {}, {
        trackRef: re.track,
        listRef: re.list,
        slideIndex: re.state.currentSlide
      }));
      oe && (oe.swiping && (re.clickable = !1), re.setState(oe));
    }), _defineProperty(_assertThisInitialized(re), "swipeEnd", function(ie) {
      var oe = (0, _innerSliderUtils.swipeEnd)(ie, _objectSpread(_objectSpread(_objectSpread({}, re.props), re.state), {}, {
        trackRef: re.track,
        listRef: re.list,
        slideIndex: re.state.currentSlide
      }));
      if (oe) {
        var le = oe.triggerSlideHandler;
        delete oe.triggerSlideHandler, re.setState(oe), le !== void 0 && (re.slideHandler(le), re.props.verticalSwiping && re.enableBodyScroll());
      }
    }), _defineProperty(_assertThisInitialized(re), "touchEnd", function(ie) {
      re.swipeEnd(ie), re.clickable = !0;
    }), _defineProperty(_assertThisInitialized(re), "slickPrev", function() {
      re.callbackTimers.push(setTimeout(function() {
        return re.changeSlide({
          message: "previous"
        });
      }, 0));
    }), _defineProperty(_assertThisInitialized(re), "slickNext", function() {
      re.callbackTimers.push(setTimeout(function() {
        return re.changeSlide({
          message: "next"
        });
      }, 0));
    }), _defineProperty(_assertThisInitialized(re), "slickGoTo", function(ie) {
      var oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (ie = Number(ie), isNaN(ie))
        return "";
      re.callbackTimers.push(setTimeout(function() {
        return re.changeSlide({
          message: "index",
          index: ie,
          currentSlide: re.state.currentSlide
        }, oe);
      }, 0));
    }), _defineProperty(_assertThisInitialized(re), "play", function() {
      var ie;
      if (re.props.rtl)
        ie = re.state.currentSlide - re.props.slidesToScroll;
      else if ((0, _innerSliderUtils.canGoNext)(_objectSpread(_objectSpread({}, re.props), re.state)))
        ie = re.state.currentSlide + re.props.slidesToScroll;
      else
        return !1;
      re.slideHandler(ie);
    }), _defineProperty(_assertThisInitialized(re), "autoPlay", function(ie) {
      re.autoplayTimer && clearInterval(re.autoplayTimer);
      var oe = re.state.autoplaying;
      if (ie === "update") {
        if (oe === "hovered" || oe === "focused" || oe === "paused")
          return;
      } else if (ie === "leave") {
        if (oe === "paused" || oe === "focused")
          return;
      } else if (ie === "blur" && (oe === "paused" || oe === "hovered"))
        return;
      re.autoplayTimer = setInterval(re.play, re.props.autoplaySpeed + 50), re.setState({
        autoplaying: "playing"
      });
    }), _defineProperty(_assertThisInitialized(re), "pause", function(ie) {
      re.autoplayTimer && (clearInterval(re.autoplayTimer), re.autoplayTimer = null);
      var oe = re.state.autoplaying;
      ie === "paused" ? re.setState({
        autoplaying: "paused"
      }) : ie === "focused" ? (oe === "hovered" || oe === "playing") && re.setState({
        autoplaying: "focused"
      }) : oe === "playing" && re.setState({
        autoplaying: "hovered"
      });
    }), _defineProperty(_assertThisInitialized(re), "onDotsOver", function() {
      return re.props.autoplay && re.pause("hovered");
    }), _defineProperty(_assertThisInitialized(re), "onDotsLeave", function() {
      return re.props.autoplay && re.state.autoplaying === "hovered" && re.autoPlay("leave");
    }), _defineProperty(_assertThisInitialized(re), "onTrackOver", function() {
      return re.props.autoplay && re.pause("hovered");
    }), _defineProperty(_assertThisInitialized(re), "onTrackLeave", function() {
      return re.props.autoplay && re.state.autoplaying === "hovered" && re.autoPlay("leave");
    }), _defineProperty(_assertThisInitialized(re), "onSlideFocus", function() {
      return re.props.autoplay && re.pause("focused");
    }), _defineProperty(_assertThisInitialized(re), "onSlideBlur", function() {
      return re.props.autoplay && re.state.autoplaying === "focused" && re.autoPlay("blur");
    }), _defineProperty(_assertThisInitialized(re), "render", function() {
      var ie = (0, _classnames.default)("slick-slider", re.props.className, {
        "slick-vertical": re.props.vertical,
        "slick-initialized": !0
      }), oe = _objectSpread(_objectSpread({}, re.props), re.state), le = (0, _innerSliderUtils.extractObject)(oe, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]), ue = re.props.pauseOnHover;
      le = _objectSpread(_objectSpread({}, le), {}, {
        onMouseEnter: ue ? re.onTrackOver : null,
        onMouseLeave: ue ? re.onTrackLeave : null,
        onMouseOver: ue ? re.onTrackOver : null,
        focusOnSelect: re.props.focusOnSelect && re.clickable ? re.selectHandler : null
      });
      var de;
      if (re.props.dots === !0 && re.state.slideCount >= re.props.slidesToShow) {
        var fe = (0, _innerSliderUtils.extractObject)(oe, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]), pe = re.props.pauseOnDotsHover;
        fe = _objectSpread(_objectSpread({}, fe), {}, {
          clickHandler: re.changeSlide,
          onMouseEnter: pe ? re.onDotsLeave : null,
          onMouseOver: pe ? re.onDotsOver : null,
          onMouseLeave: pe ? re.onDotsLeave : null
        }), de = /* @__PURE__ */ _react.default.createElement(_dots.Dots, fe);
      }
      var ye, me, ve = (0, _innerSliderUtils.extractObject)(oe, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      ve.clickHandler = re.changeSlide, re.props.arrows && (ye = /* @__PURE__ */ _react.default.createElement(_arrows.PrevArrow, ve), me = /* @__PURE__ */ _react.default.createElement(_arrows.NextArrow, ve));
      var ge = null;
      re.props.vertical && (ge = {
        height: re.state.listHeight
      });
      var xe = null;
      re.props.vertical === !1 ? re.props.centerMode === !0 && (xe = {
        padding: "0px " + re.props.centerPadding
      }) : re.props.centerMode === !0 && (xe = {
        padding: re.props.centerPadding + " 0px"
      });
      var Ee = _objectSpread(_objectSpread({}, ge), xe), Te = re.props.touchMove, Se = {
        className: "slick-list",
        style: Ee,
        onClick: re.clickHandler,
        onMouseDown: Te ? re.swipeStart : null,
        onMouseMove: re.state.dragging && Te ? re.swipeMove : null,
        onMouseUp: Te ? re.swipeEnd : null,
        onMouseLeave: re.state.dragging && Te ? re.swipeEnd : null,
        onTouchStart: Te ? re.swipeStart : null,
        onTouchMove: re.state.dragging && Te ? re.swipeMove : null,
        onTouchEnd: Te ? re.touchEnd : null,
        onTouchCancel: re.state.dragging && Te ? re.swipeEnd : null,
        onKeyDown: re.props.accessibility ? re.keyHandler : null
      }, he = {
        className: ie,
        dir: "ltr",
        style: re.props.style
      };
      return re.props.unslick && (Se = {
        className: "slick-list"
      }, he = {
        className: ie
      }), /* @__PURE__ */ _react.default.createElement("div", he, re.props.unslick ? "" : ye, /* @__PURE__ */ _react.default.createElement("div", _extends({
        ref: re.listRefHandler
      }, Se), /* @__PURE__ */ _react.default.createElement(_track.Track, _extends({
        ref: re.trackRefHandler
      }, le), re.props.children)), re.props.unslick ? "" : me, re.props.unslick ? "" : de);
    }), re.list = null, re.track = null, re.state = _objectSpread(_objectSpread({}, _initialState.default), {}, {
      currentSlide: re.props.initialSlide,
      targetSlide: re.props.initialSlide ? re.props.initialSlide : 0,
      slideCount: _react.default.Children.count(re.props.children)
    }), re.callbackTimers = [], re.clickable = !0, re.debouncedResize = null;
    var se = re.ssrInit();
    return re.state = _objectSpread(_objectSpread({}, re.state), se), re;
  }
  return _createClass(te, [{
    key: "didPropsChange",
    value: function(re) {
      for (var se = !1, ie = 0, oe = Object.keys(this.props); ie < oe.length; ie++) {
        var le = oe[ie];
        if (!re.hasOwnProperty(le)) {
          se = !0;
          break;
        }
        if (!(_typeof(re[le]) === "object" || typeof re[le] == "function" || isNaN(re[le])) && re[le] !== this.props[le]) {
          se = !0;
          break;
        }
      }
      return se || _react.default.Children.count(this.props.children) !== _react.default.Children.count(re.children);
    }
  }]), te;
}(_react.default.Component);
var camel2hyphen$1 = function($) {
  return $.replace(/[A-Z]/g, function(ee) {
    return "-" + ee.toLowerCase();
  }).toLowerCase();
}, camel2hyphen_1 = camel2hyphen$1, camel2hyphen = camel2hyphen_1, isDimension = function($) {
  var ee = /[height|width]$/;
  return ee.test($);
}, obj2mq = function($) {
  var ee = "", te = Object.keys($);
  return te.forEach(function(ne, re) {
    var se = $[ne];
    ne = camel2hyphen(ne), isDimension(ne) && typeof se == "number" && (se = se + "px"), se === !0 ? ee += ne : se === !1 ? ee += "not " + ne : ee += "(" + ne + ": " + se + ")", re < te.length - 1 && (ee += " and ");
  }), ee;
}, json2mq = function($) {
  var ee = "";
  return typeof $ == "string" ? $ : $ instanceof Array ? ($.forEach(function(te, ne) {
    ee += obj2mq(te), ne < $.length - 1 && (ee += ", ");
  }), ee) : obj2mq($);
}, json2mq_1 = json2mq, QueryHandler_1, hasRequiredQueryHandler;
function requireQueryHandler() {
  if (hasRequiredQueryHandler)
    return QueryHandler_1;
  hasRequiredQueryHandler = 1;
  function $(ee) {
    this.options = ee, !ee.deferSetup && this.setup();
  }
  return $.prototype = {
    constructor: $,
    /**
     * coordinates setup of the handler
     *
     * @function
     */
    setup: function() {
      this.options.setup && this.options.setup(), this.initialised = !0;
    },
    /**
     * coordinates setup and triggering of the handler
     *
     * @function
     */
    on: function() {
      !this.initialised && this.setup(), this.options.match && this.options.match();
    },
    /**
     * coordinates the unmatch event for the handler
     *
     * @function
     */
    off: function() {
      this.options.unmatch && this.options.unmatch();
    },
    /**
     * called when a handler is to be destroyed.
     * delegates to the destroy or unmatch callbacks, depending on availability.
     *
     * @function
     */
    destroy: function() {
      this.options.destroy ? this.options.destroy() : this.off();
    },
    /**
     * determines equality by reference.
     * if object is supplied compare options, if function, compare match callback
     *
     * @function
     * @param {object || function} [target] the target for comparison
     */
    equals: function(ee) {
      return this.options === ee || this.options.match === ee;
    }
  }, QueryHandler_1 = $, QueryHandler_1;
}
var Util, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return Util;
  hasRequiredUtil = 1;
  function $(ne, re) {
    var se = 0, ie = ne.length, oe;
    for (se; se < ie && (oe = re(ne[se], se), oe !== !1); se++)
      ;
  }
  function ee(ne) {
    return Object.prototype.toString.apply(ne) === "[object Array]";
  }
  function te(ne) {
    return typeof ne == "function";
  }
  return Util = {
    isFunction: te,
    isArray: ee,
    each: $
  }, Util;
}
var MediaQuery_1, hasRequiredMediaQuery;
function requireMediaQuery() {
  if (hasRequiredMediaQuery)
    return MediaQuery_1;
  hasRequiredMediaQuery = 1;
  var $ = requireQueryHandler(), ee = requireUtil().each;
  function te(ne, re) {
    this.query = ne, this.isUnconditional = re, this.handlers = [], this.mql = window.matchMedia(ne);
    var se = this;
    this.listener = function(ie) {
      se.mql = ie.currentTarget || ie, se.assess();
    }, this.mql.addListener(this.listener);
  }
  return te.prototype = {
    constuctor: te,
    /**
     * add a handler for this query, triggering if already active
     *
     * @param {object} handler
     * @param {function} handler.match callback for when query is activated
     * @param {function} [handler.unmatch] callback for when query is deactivated
     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
     */
    addHandler: function(ne) {
      var re = new $(ne);
      this.handlers.push(re), this.matches() && re.on();
    },
    /**
     * removes the given handler from the collection, and calls it's destroy methods
     *
     * @param {object || function} handler the handler to remove
     */
    removeHandler: function(ne) {
      var re = this.handlers;
      ee(re, function(se, ie) {
        if (se.equals(ne))
          return se.destroy(), !re.splice(ie, 1);
      });
    },
    /**
     * Determine whether the media query should be considered a match
     *
     * @return {Boolean} true if media query can be considered a match, false otherwise
     */
    matches: function() {
      return this.mql.matches || this.isUnconditional;
    },
    /**
     * Clears all handlers and unbinds events
     */
    clear: function() {
      ee(this.handlers, function(ne) {
        ne.destroy();
      }), this.mql.removeListener(this.listener), this.handlers.length = 0;
    },
    /*
        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
        */
    assess: function() {
      var ne = this.matches() ? "on" : "off";
      ee(this.handlers, function(re) {
        re[ne]();
      });
    }
  }, MediaQuery_1 = te, MediaQuery_1;
}
var MediaQueryDispatch_1, hasRequiredMediaQueryDispatch;
function requireMediaQueryDispatch() {
  if (hasRequiredMediaQueryDispatch)
    return MediaQueryDispatch_1;
  hasRequiredMediaQueryDispatch = 1;
  var $ = requireMediaQuery(), ee = requireUtil(), te = ee.each, ne = ee.isFunction, re = ee.isArray;
  function se() {
    if (!window.matchMedia)
      throw new Error("matchMedia not present, legacy browsers require a polyfill");
    this.queries = {}, this.browserIsIncapable = !window.matchMedia("only all").matches;
  }
  return se.prototype = {
    constructor: se,
    /**
     * Registers a handler for the given media query
     *
     * @param {string} q the media query
     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
     * @param {function} options.match fired when query matched
     * @param {function} [options.unmatch] fired when a query is no longer matched
     * @param {function} [options.setup] fired when handler first triggered
     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
     */
    register: function(ie, oe, le) {
      var ue = this.queries, de = le && this.browserIsIncapable;
      return ue[ie] || (ue[ie] = new $(ie, de)), ne(oe) && (oe = { match: oe }), re(oe) || (oe = [oe]), te(oe, function(fe) {
        ne(fe) && (fe = { match: fe }), ue[ie].addHandler(fe);
      }), this;
    },
    /**
     * unregisters a query and all it's handlers, or a specific handler for a query
     *
     * @param {string} q the media query to target
     * @param {object || function} [handler] specific handler to unregister
     */
    unregister: function(ie, oe) {
      var le = this.queries[ie];
      return le && (oe ? le.removeHandler(oe) : (le.clear(), delete this.queries[ie])), this;
    }
  }, MediaQueryDispatch_1 = se, MediaQueryDispatch_1;
}
var src, hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var $ = requireMediaQueryDispatch();
  return src = new $(), src;
}
(function($) {
  Object.defineProperty($, "__esModule", {
    value: !0
  }), $.default = void 0;
  var ee = ie(React__default), te = innerSlider, ne = ie(json2mq_1), re = ie(defaultProps), se = innerSliderUtils;
  function ie(Ce) {
    return Ce && Ce.__esModule ? Ce : { default: Ce };
  }
  function oe(Ce) {
    "@babel/helpers - typeof";
    return oe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ne) {
      return typeof Ne;
    } : function(Ne) {
      return Ne && typeof Symbol == "function" && Ne.constructor === Symbol && Ne !== Symbol.prototype ? "symbol" : typeof Ne;
    }, oe(Ce);
  }
  function le() {
    return le = Object.assign ? Object.assign.bind() : function(Ce) {
      for (var Ne = 1; Ne < arguments.length; Ne++) {
        var Me = arguments[Ne];
        for (var Be in Me)
          Object.prototype.hasOwnProperty.call(Me, Be) && (Ce[Be] = Me[Be]);
      }
      return Ce;
    }, le.apply(this, arguments);
  }
  function ue(Ce, Ne) {
    var Me = Object.keys(Ce);
    if (Object.getOwnPropertySymbols) {
      var Be = Object.getOwnPropertySymbols(Ce);
      Ne && (Be = Be.filter(function(We) {
        return Object.getOwnPropertyDescriptor(Ce, We).enumerable;
      })), Me.push.apply(Me, Be);
    }
    return Me;
  }
  function de(Ce) {
    for (var Ne = 1; Ne < arguments.length; Ne++) {
      var Me = arguments[Ne] != null ? arguments[Ne] : {};
      Ne % 2 ? ue(Object(Me), !0).forEach(function(Be) {
        he(Ce, Be, Me[Be]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ce, Object.getOwnPropertyDescriptors(Me)) : ue(Object(Me)).forEach(function(Be) {
        Object.defineProperty(Ce, Be, Object.getOwnPropertyDescriptor(Me, Be));
      });
    }
    return Ce;
  }
  function fe(Ce, Ne) {
    if (!(Ce instanceof Ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function pe(Ce, Ne) {
    for (var Me = 0; Me < Ne.length; Me++) {
      var Be = Ne[Me];
      Be.enumerable = Be.enumerable || !1, Be.configurable = !0, "value" in Be && (Be.writable = !0), Object.defineProperty(Ce, Pe(Be.key), Be);
    }
  }
  function ye(Ce, Ne, Me) {
    return Ne && pe(Ce.prototype, Ne), Me && pe(Ce, Me), Object.defineProperty(Ce, "prototype", { writable: !1 }), Ce;
  }
  function me(Ce, Ne) {
    if (typeof Ne != "function" && Ne !== null)
      throw new TypeError("Super expression must either be null or a function");
    Ce.prototype = Object.create(Ne && Ne.prototype, { constructor: { value: Ce, writable: !0, configurable: !0 } }), Object.defineProperty(Ce, "prototype", { writable: !1 }), Ne && ve(Ce, Ne);
  }
  function ve(Ce, Ne) {
    return ve = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Be, We) {
      return Be.__proto__ = We, Be;
    }, ve(Ce, Ne);
  }
  function ge(Ce) {
    var Ne = Te();
    return function() {
      var Be = Se(Ce), We;
      if (Ne) {
        var Le = Se(this).constructor;
        We = Reflect.construct(Be, arguments, Le);
      } else
        We = Be.apply(this, arguments);
      return xe(this, We);
    };
  }
  function xe(Ce, Ne) {
    if (Ne && (oe(Ne) === "object" || typeof Ne == "function"))
      return Ne;
    if (Ne !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return Ee(Ce);
  }
  function Ee(Ce) {
    if (Ce === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Ce;
  }
  function Te() {
    try {
      var Ce = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (Te = function() {
      return !!Ce;
    })();
  }
  function Se(Ce) {
    return Se = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Me) {
      return Me.__proto__ || Object.getPrototypeOf(Me);
    }, Se(Ce);
  }
  function he(Ce, Ne, Me) {
    return Ne = Pe(Ne), Ne in Ce ? Object.defineProperty(Ce, Ne, { value: Me, enumerable: !0, configurable: !0, writable: !0 }) : Ce[Ne] = Me, Ce;
  }
  function Pe(Ce) {
    var Ne = Ie(Ce, "string");
    return oe(Ne) == "symbol" ? Ne : String(Ne);
  }
  function Ie(Ce, Ne) {
    if (oe(Ce) != "object" || !Ce)
      return Ce;
    var Me = Ce[Symbol.toPrimitive];
    if (Me !== void 0) {
      var Be = Me.call(Ce, Ne || "default");
      if (oe(Be) != "object")
        return Be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ne === "string" ? String : Number)(Ce);
  }
  var De = (0, se.canUseDOM)() && requireSrc();
  $.default = /* @__PURE__ */ function(Ce) {
    me(Me, Ce);
    var Ne = ge(Me);
    function Me(Be) {
      var We;
      return fe(this, Me), We = Ne.call(this, Be), he(Ee(We), "innerSliderRefHandler", function(Le) {
        return We.innerSlider = Le;
      }), he(Ee(We), "slickPrev", function() {
        return We.innerSlider.slickPrev();
      }), he(Ee(We), "slickNext", function() {
        return We.innerSlider.slickNext();
      }), he(Ee(We), "slickGoTo", function(Le) {
        var He = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        return We.innerSlider.slickGoTo(Le, He);
      }), he(Ee(We), "slickPause", function() {
        return We.innerSlider.pause("paused");
      }), he(Ee(We), "slickPlay", function() {
        return We.innerSlider.autoPlay("play");
      }), We.state = {
        breakpoint: null
      }, We._responsiveMediaHandlers = [], We;
    }
    return ye(Me, [{
      key: "media",
      value: function(We, Le) {
        De.register(We, Le), this._responsiveMediaHandlers.push({
          query: We,
          handler: Le
        });
      }
      // handles responsive breakpoints
    }, {
      key: "componentDidMount",
      value: function() {
        var We = this;
        if (this.props.responsive) {
          var Le = this.props.responsive.map(function(Ge) {
            return Ge.breakpoint;
          });
          Le.sort(function(Ge, Ze) {
            return Ge - Ze;
          }), Le.forEach(function(Ge, Ze) {
            var Ue;
            Ze === 0 ? Ue = (0, ne.default)({
              minWidth: 0,
              maxWidth: Ge
            }) : Ue = (0, ne.default)({
              minWidth: Le[Ze - 1] + 1,
              maxWidth: Ge
            }), (0, se.canUseDOM)() && We.media(Ue, function() {
              We.setState({
                breakpoint: Ge
              });
            });
          });
          var He = (0, ne.default)({
            minWidth: Le.slice(-1)[0]
          });
          (0, se.canUseDOM)() && this.media(He, function() {
            We.setState({
              breakpoint: null
            });
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this._responsiveMediaHandlers.forEach(function(We) {
          De.unregister(We.query, We.handler);
        });
      }
    }, {
      key: "render",
      value: function() {
        var We = this, Le, He;
        this.state.breakpoint ? (He = this.props.responsive.filter(function(Ae) {
          return Ae.breakpoint === We.state.breakpoint;
        }), Le = He[0].settings === "unslick" ? "unslick" : de(de(de({}, re.default), this.props), He[0].settings)) : Le = de(de({}, re.default), this.props), Le.centerMode && (Le.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(Le.slidesToScroll)), Le.slidesToScroll = 1), Le.fade && (Le.slidesToShow > 1 && process.env.NODE_ENV !== "production" && console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(Le.slidesToShow)), Le.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(Le.slidesToScroll)), Le.slidesToShow = 1, Le.slidesToScroll = 1);
        var Ge = ee.default.Children.toArray(this.props.children);
        Ge = Ge.filter(function(Ae) {
          return typeof Ae == "string" ? !!Ae.trim() : !!Ae;
        }), Le.variableWidth && (Le.rows > 1 || Le.slidesPerRow > 1) && (console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1"), Le.variableWidth = !1);
        for (var Ze = [], Ue = null, Qe = 0; Qe < Ge.length; Qe += Le.rows * Le.slidesPerRow) {
          for (var Je = [], Ot = Qe; Ot < Qe + Le.rows * Le.slidesPerRow; Ot += Le.slidesPerRow) {
            for (var At = [], ze = Ot; ze < Ot + Le.slidesPerRow && (Le.variableWidth && Ge[ze].props.style && (Ue = Ge[ze].props.style.width), !(ze >= Ge.length)); ze += 1)
              At.push(/* @__PURE__ */ ee.default.cloneElement(Ge[ze], {
                key: 100 * Qe + 10 * Ot + ze,
                tabIndex: -1,
                style: {
                  width: "".concat(100 / Le.slidesPerRow, "%"),
                  display: "inline-block"
                }
              }));
            Je.push(/* @__PURE__ */ ee.default.createElement("div", {
              key: 10 * Qe + Ot
            }, At));
          }
          Le.variableWidth ? Ze.push(/* @__PURE__ */ ee.default.createElement("div", {
            key: Qe,
            style: {
              width: Ue
            }
          }, Je)) : Ze.push(/* @__PURE__ */ ee.default.createElement("div", {
            key: Qe
          }, Je));
        }
        if (Le === "unslick") {
          var we = "regular slider " + (this.props.className || "");
          return /* @__PURE__ */ ee.default.createElement("div", {
            className: we
          }, Ge);
        } else
          Ze.length <= Le.slidesToShow && !Le.infinite && (Le.unslick = !0);
        return /* @__PURE__ */ ee.default.createElement(te.InnerSlider, le({
          style: this.props.style,
          ref: this.innerSliderRefHandler
        }, (0, se.filterSettings)(Le)), Ze);
      }
    }]), Me;
  }(ee.default.Component);
})(slider);
(function($) {
  Object.defineProperty($, "__esModule", {
    value: !0
  }), $.default = void 0;
  var ee = te(slider);
  function te(ne) {
    return ne && ne.__esModule ? ne : { default: ne };
  }
  $.default = ee.default;
})(lib);
const Slider = /* @__PURE__ */ getDefaultExportFromCjs(lib), pdfIcon = "data:image/svg+xml,%3csvg%20width='40'%20height='40'%20viewBox='0%200%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M30.7312%2038C32.5376%2038%2034%2036.5498%2034%2034.7583V10.2322H27.4194C26.9462%2010.2322%2026.6022%209.84834%2026.6022%209.4218V2H9.22581C7.46237%202%206%203.40758%206%205.19905V34.8009C6%2036.5498%207.41935%2038%209.22581%2038H30.7312ZM28.2365%203.27935V8.6111H33.0107L28.2365%203.27935Z'%20fill='%23EF6060'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.2375%2027.3398V24.1662H12.8782C13.9553%2024.1662%2014.7985%2023.9115%2015.4077%2023.4022C16.017%2022.8928%2016.3216%2022.1968%2016.3216%2021.3142C16.3216%2020.7327%2016.1823%2020.2141%2015.9037%2019.7584C15.625%2019.3026%2015.2268%2018.951%2014.7091%2018.7036C14.1913%2018.4561%2013.5914%2018.3324%2012.9094%2018.3324H9.36609V27.3398H11.2375ZM12.9094%2022.6629H11.2375V19.8357H12.953C13.4147%2019.8439%2013.7765%2019.9842%2014.0385%2020.2564C14.3005%2020.5286%2014.4315%2020.8853%2014.4315%2021.3266C14.4315%2021.7555%2014.3015%2022.0855%2014.0416%2022.3164C13.7817%2022.5474%2013.4043%2022.6629%2012.9094%2022.6629ZM22.5598%2026.7954C21.9277%2027.1542%2021.2144%2027.3357%2020.4201%2027.3398H17.6067V18.3324H20.4014C21.1999%2018.3324%2021.9141%2018.5108%2022.5442%2018.8675C23.1742%2019.2243%2023.666%2019.7316%2024.0195%2020.3894C24.373%2021.0472%2024.5498%2021.7947%2024.5498%2022.632V23.0464C24.5498%2023.8837%2024.3761%2024.6281%2024.0289%2025.2797C23.6816%2025.9314%2023.1919%2026.4366%2022.5598%2026.7954ZM20.3827%2025.8489H19.4781V19.8357H20.4014C21.1375%2019.8357%2021.6968%2020.0718%2022.0794%2020.544C22.462%2021.0163%2022.6533%2021.7102%2022.6533%2022.6258V23.1021C22.645%2023.9847%2022.4475%2024.6632%2022.0607%2025.1374C21.674%2025.6117%2021.1146%2025.8489%2020.3827%2025.8489ZM27.7811%2023.6589V27.3398H25.9097V18.3324H31.8234V19.8357H27.7811V22.1618H31.3743V23.6589H27.7811Z'%20fill='white'/%3e%3c/svg%3e", LMFeedAttachments = memo(
  ({ attachments: $, postId: ee }) => {
    const te = {
      dots: !0,
      infinite: !0,
      speed: 500,
      slidesToShow: 1,
      slidesToScroll: 1
    };
    return $.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "slider-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Slider, { ...te, lazyLoad: "anticipated", children: $.map((ne, re) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        "lm-feed-component-id": `lm-feed-post-attachments-zabcd-${ee}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RenderAttachment, { attachment: ne, postId: ee })
      },
      re
    )) }) }) : $.length === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(RenderAttachment, { attachment: $[0], postId: ee }) : null;
  }
), RenderAttachment = memo(({ attachment: $, postId: ee }) => {
  const { attachmentMeta: te, attachmentType: ne } = $, { name: re, url: se, ogTags: ie } = te;
  switch (ne) {
    case 1:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "attachment-image",
          "lm-feed-component-id": `lm-feed-post-attachments-efghi-${ee}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              loading: "lazy",
              src: se,
              alt: re,
              "lm-feed-component-id": `lm-feed-post-attachments-jklmn-${ee}`
            }
          )
        }
      );
    case 2:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "attachment-video",
          "lm-feed-component-id": `lm-feed-post-attachments-opqrs-${ee}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "video",
            {
              controls: !0,
              width: "100%",
              height: "auto",
              "lm-feed-component-id": `lm-feed-post-attachments-tuvwx-${ee}`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: se, type: "video/mp4" }),
                "Your browser does not support the video tag."
              ]
            }
          )
        }
      );
    case 3:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedDocumentAttachmentView, { postId: ee, attachment: $ });
    case 4:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedOGTagAttachmentView, { postId: ee, ogTags: ie });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "attachment-unsupported",
          "lm-feed-component-id": `lm-feed-post-attachments-defgh-${ee}`,
          children: "Unsupported attachment type"
        }
      );
  }
}), LMFeedOGTagAttachmentView = ({
  ogTags: $,
  postId: ee
}) => (
  // <div className="attachmentOGTag">
  //   {ogTags?.image ? (
  //     <img
  //       src={ogTags.image}
  //       alt="og tag image"
  //       className="attachmentOGTag__img"
  //     />
  //   ) : (
  //     <div className="attachmentOGTag__noImg">{ogTags?.url}</div>
  //   )}
  //   <div className="attachmentOGTag__content">
  //     <a href={ogTags.url} target="_blank">
  //       {truncateString(ogTags?.title, 100)}
  //     </a>
  //     <div className="attachmentOGTag__content--desc">
  //       {truncateString(ogTags?.description, 300)}
  //     </div>
  //     <div className="attachmentOGTag__content--url">{ogTags?.url}</div>
  //   </div>
  // </div>
  /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "attachmentOGTag",
      "lm-feed-component-id": `lm-feed-post-attachments-ijklm-${ee}`,
      children: [
        $ != null && $.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: $.image,
            alt: "og tag image",
            className: "attachmentOGTag__img",
            "lm-feed-component-id": `lm-feed-post-attachments-nopqr-${ee}`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "attachmentOGTag__noImg",
            "lm-feed-component-id": `lm-feed-post-attachments-stuvw-${ee}`,
            children: $ == null ? void 0 : $.url
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "attachmentOGTag__content",
            "lm-feed-component-id": `lm-feed-post-attachments-xyzab-${ee}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: $.url,
                  target: "_blank",
                  "lm-feed-component-id": `lm-feed-post-attachments-cdefg-${ee}`,
                  children: truncateString($ == null ? void 0 : $.title, 100)
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "attachmentOGTag__content--desc",
                  "lm-feed-component-id": `lm-feed-post-attachments-hijkl-${ee}`,
                  children: truncateString($ == null ? void 0 : $.description, 300)
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "attachmentOGTag__content--url",
                  "lm-feed-component-id": `lm-feed-post-attachments-mnopq-${ee}`,
                  children: $ == null ? void 0 : $.url
                }
              )
            ]
          }
        )
      ]
    }
  )
), LMFeedDocumentAttachmentView = ({
  attachment: $,
  postId: ee
}) => {
  const { attachmentMeta: te } = $, { name: ne, url: re, size: se } = te;
  return (
    // <div className="attachmentPdf">
    //   <Document file={attachmentMeta?.url}>
    //     <Page
    //       pageNumber={1}
    //       className={"pdfPage"}
    //       renderAnnotationLayer={false}
    //       renderTextLayer={false}
    //       // height={324}
    //     />
    //   </Document>
    //   <div className="attachmentPdf__content">
    //     <img
    //       src={pdfIcon}
    //       alt="pdf"
    //       className="attachmentOGTag__content--icon"
    //     />
    //     <div>
    //       <a
    //         className="attachmentPdf__content--title"
    //         target="_blank"
    //         href={url}
    //       >
    //         {name}
    //       </a>
    //       <div className="attachmentPdf__content--url">
    //         {formatFileSize(size)}
    //       </div>
    //     </div>
    //   </div>
    // </div>
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "attachmentPdf",
        "lm-feed-component-id": `lm-feed-post-attachments-rstuw-${ee}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Document$1, { file: te == null ? void 0 : te.url, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Page$1,
            {
              pageNumber: 1,
              renderAnnotationLayer: !1,
              renderTextLayer: !1,
              "lm-feed-component-id": `lm-feed-post-attachments-vwxyz-${ee}`
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "attachmentPdf__content",
              "lm-feed-component-id": `lm-feed-post-attachments-abcde-${ee}`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: pdfIcon,
                    alt: "pdf",
                    className: "attachmentOGTag__content--icon",
                    "lm-feed-component-id": `lm-feed-post-attachments-fghij-${ee}`
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { "lm-feed-component-id": `lm-feed-post-attachments-klmno-${ee}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "a",
                    {
                      className: "attachmentPdf__content--title",
                      target: "_blank",
                      href: re,
                      "lm-feed-component-id": `lm-feed-post-attachments-pqrst-${ee}`,
                      children: ne
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "attachmentPdf__content--url",
                      "lm-feed-component-id": `lm-feed-post-attachments-uvwxy-${ee}`,
                      children: formatFileSize(se)
                    }
                  )
                ] })
              ]
            }
          )
        ]
      }
    )
  );
}, LMFeedPostBody = () => {
  const { post: $ } = useContext(FeedPostContext), { text: ee, attachments: te, heading: ne } = $, { CustomComponents: re = {} } = useContext(CustomAgentProviderContext), { CustomPostViewAttachment: se } = re, [ie, oe] = useState(!1), le = useCallback(() => !te || te.length === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "attachments",
      "lm-feed-component-id": `lm-feed-post-body-dn2pl-${$ == null ? void 0 : $.Id}`,
      children: se ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        se,
        {
          postId: ($ == null ? void 0 : $.Id) || "",
          attachments: te
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        LMFeedAttachments,
        {
          postId: ($ == null ? void 0 : $.Id) || "",
          attachments: te
        }
      )
    }
  ), [se, te, $ == null ? void 0 : $.Id]);
  return (
    // <div className="lm-feed-wrapper__card__body">
    //   {heading.length > 0 && (
    //     <h1
    //       className="lm-feed-wrapper__card__body__heading"
    //       style={{
    //         cursor: !window.location.pathname.includes("/post")
    //           ? "pointer"
    //           : undefined,
    //         ...LMPostBodyStyles?.heading,
    //       }}
    //       onClick={() => {
    //         if (postHeadingClickCallback) {
    //           postHeadingClickCallback(navigate);
    //         } else {
    //           if (!window.location.pathname.includes("/post")) {
    //             navigate(
    //               `/community/post/${`${post?.Id}-${post?.heading}`.substring(0, 59)}`,
    //             );
    //           }
    //         }
    //       }}
    //     >
    //       {heading}
    //     </h1>
    //   )}
    //   {/* post text */}
    //   {text ? (
    //     <div
    //       className="lm-feed-wrapper__card__body__content"
    //       style={LMPostBodyStyles?.content}
    //     >
    //       {(() => {
    //         const processedText = textPreprocessor(text);
    //         if (processedText.showReadMore && !hasReadMoreTapped) {
    //           return (
    //             <>
    //               {parseAndReplaceTags(processedText.text)}
    //               <span
    //                 className="lm-feed-wrapper__card__body__content__read-more-tap-icon"
    //                 style={{
    //                   color: "gray",
    //                   fontWeight: "400",
    //                   cursor: "pointer",
    //                   fontSize: "14px",
    //                 }}
    //                 onClick={() => setHasReadMoreTapped(true)}
    //               >
    //                 ...ReadMore
    //               </span>
    //             </>
    //           );
    //         } else {
    //           return parseAndReplaceTags(text);
    //         }
    //       })()}
    //     </div>
    //   ) : null}
    //   {/* post text */}
    //   <div className="lm-feed-wrapper__card__body__attachment">
    //     {renderAttachments()}
    //   </div>
    // </div>
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "lm-feed-wrapper__card__body",
        "lm-feed-component-id": `lm-feed-post-body-vwxyz-${$ == null ? void 0 : $.Id}`,
        children: [
          ne.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "h1",
            {
              className: "lm-feed-wrapper__card__body__heading",
              style: {
                cursor: window.location.pathname.includes("/post") ? void 0 : "pointer"
              },
              "lm-feed-component-id": `lm-feed-post-body-abcde-${$ == null ? void 0 : $.Id}`,
              children: ne
            }
          ),
          ee ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lm-feed-wrapper__card__body__content",
              "lm-feed-component-id": `lm-feed-post-body-fghij-${$ == null ? void 0 : $.Id}`,
              children: (() => {
                const ue = textPreprocessor(ee);
                return ue.showReadMore && !ie ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  parseAndReplaceTags(ue.text),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "lm-feed-wrapper__card__body__content__read-more-tap-icon",
                      style: {
                        color: "gray",
                        fontWeight: "400",
                        cursor: "pointer",
                        fontSize: "14px"
                      },
                      onClick: () => oe(!0),
                      "lm-feed-component-id": `lm-feed-post-body-klmno-${$ == null ? void 0 : $.Id}`,
                      children: "...ReadMore"
                    }
                  )
                ] }) : parseAndReplaceTags(ee);
              })()
            }
          ) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "lm-feed-wrapper__card__body__attachment",
              "lm-feed-component-id": `lm-feed-post-body-pqrst-${$ == null ? void 0 : $.Id}`,
              children: le()
            }
          )
        ]
      }
    )
  );
}, like = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12.534%2019.8662L20.1278%2012.2725C21.9934%2010.3975%2022.2653%207.33187%2020.5028%205.37249C20.0607%204.87872%2019.5227%204.48026%2018.9215%204.20145C18.3203%203.92264%2017.6685%203.76933%2017.0061%203.75091C16.3436%203.73248%2015.6844%203.84932%2015.0686%204.09428C14.4528%204.33924%2013.8934%204.70718%2013.4246%205.17562L11.9996%206.60999L10.7715%205.37249C8.89652%203.50687%205.83089%203.23499%203.87152%204.99749C3.37774%205.43951%202.97928%205.97756%202.70047%206.57877C2.42166%207.17999%202.26836%207.83173%202.24993%208.49419C2.23151%209.15665%202.34834%209.81591%202.5933%2010.4317C2.83826%2011.0475%203.2062%2011.6068%203.67464%2012.0756L11.4653%2019.8662C11.6075%2020.0071%2011.7995%2020.0861%2011.9996%2020.0861C12.1998%2020.0861%2012.3918%2020.0071%2012.534%2019.8662Z'%20stroke='%23484F67'%20stroke-opacity='0.7'%20stroke-width='1.2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", postLiked = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M13.034%2019.8662L20.6278%2012.2725C22.4934%2010.3975%2022.7653%207.33187%2021.0028%205.37249C20.5607%204.87872%2020.0227%204.48026%2019.4215%204.20145C18.8203%203.92264%2018.1685%203.76933%2017.5061%203.75091C16.8436%203.73248%2016.1844%203.84932%2015.5686%204.09428C14.9528%204.33924%2014.3934%204.70718%2013.9246%205.17562L12.4996%206.60999L11.2715%205.37249C9.39652%203.50687%206.33089%203.23499%204.37152%204.99749C3.87774%205.43951%203.47928%205.97756%203.20047%206.57877C2.92166%207.17999%202.76836%207.83173%202.74993%208.49419C2.73151%209.15665%202.84834%209.81591%203.0933%2010.4317C3.33826%2011.0475%203.7062%2011.6068%204.17464%2012.0756L11.9653%2019.8662C12.1075%2020.0071%2012.2995%2020.0861%2012.4996%2020.0861C12.6998%2020.0861%2012.8918%2020.0071%2013.034%2019.8662Z'%20fill='%23FB1609'%20stroke='%23FB1609'%20stroke-width='1.2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", commnent = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4.2565%2016.5938C3.13983%2014.7098%202.74924%2012.483%203.15804%2010.3315C3.56684%208.17989%204.74693%206.25153%206.47677%204.90838C8.2066%203.56523%2010.3672%202.89967%2012.553%203.03666C14.7388%203.17364%2016.7994%204.10374%2018.348%205.65235C19.8966%207.20095%2020.8267%209.26157%2020.9637%2011.4473C21.1007%2013.6331%2020.4351%2015.7937%2019.0919%2017.5236C17.7488%2019.2534%2015.8204%2020.4335%2013.6689%2020.8423C11.5173%2021.2511%209.29049%2020.8605%207.4065%2019.7438V19.7438L4.294%2020.6251C4.16648%2020.6624%204.03128%2020.6647%203.90256%2020.6317C3.77384%2020.5988%203.65635%2020.5319%203.5624%2020.4379C3.46845%2020.344%203.4015%2020.2265%203.36858%2020.0978C3.33565%2019.969%203.33796%2019.8338%203.37525%2019.7063L4.2565%2016.5938Z'%20stroke='%23484F67'%20stroke-opacity='0.7'%20stroke-width='1.2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", likeIcon = "data:image/svg+xml,%3csvg%20width='15'%20height='14'%20viewBox='0%200%2015%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.48231%2012.299L12.5448%207.23651C13.7886%205.98651%2013.9698%203.94276%2012.7948%202.63651C12.5001%202.30733%2012.1414%202.04169%2011.7406%201.85581C11.3398%201.66994%2010.9053%201.56774%2010.4637%201.55546C10.022%201.54317%209.58254%201.62106%209.17202%201.78437C8.7615%201.94768%208.38858%202.19297%208.07606%202.50526L7.12606%203.46151L6.30731%202.63651C5.05731%201.39276%203.01356%201.21151%201.70731%202.38651C1.37813%202.68119%201.11249%203.03989%200.926615%203.4407C0.740742%203.84151%200.638541%204.276%200.626257%204.71764C0.613973%205.15928%200.691864%205.59879%200.85517%206.00931C1.01848%206.41983%201.26377%206.79274%201.57606%207.10526L6.76981%2012.299C6.86461%2012.3929%206.99264%2012.4456%207.12606%2012.4456C7.25949%2012.4456%207.38752%2012.3929%207.48231%2012.299Z'%20stroke='%23484F67'%20stroke-opacity='0.5'%20stroke-width='1.2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", commentLiked = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAOCAYAAADwikbvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADLSURBVHgBpZLdDYIwFIXvaSQB9IEXKo+MgBs4giOwghMAk+AIbiAb6Ag+El7kyRBqqC3RaMQfwJPcpPeenq9tUqJ/JX3HEdyOBLdOqqSYW7vanYbaE95sqft2rvwLt1Ppmb720G7g9l4hgg4VtCVJq+5xOBjFeYHaNUMAKQ29LWjNQAhohEDMZwSUNEZSloxYk9EITVizYUZeZQqT0CDJBHl1xL0V3IzVS6I+QaOoYr3C8/g34BF8Kw24fYiXMj+HvgN6BruAgcG+ugK9aFix+78F/wAAAABJRU5ErkJggg==", useReply = ($, ee) => {
  const { lmFeedclient: te, customEventClient: ne } = useContext(
    GlobalClientProviderContext
  ), { displaySnackbarMessage: re, message: se, showSnackbar: ie, closeSnackbar: oe } = useContext(GeneralContext), { RepliesCustomCallbacks: le = {} } = useContext(
    CustomAgentProviderContext
  ), { likeReplyCustomAction: ue, deleteReplyCustomAction: de } = le, { currentUser: fe, currentCommunity: pe, logoutUser: ye } = useContext(
    UserProviderContext
  ), me = useNavigate(), [ve, ge] = useState(null), [xe, Ee] = useState(1), [Te, Se] = useState(!0), [he, Pe] = useState([]), [Ie, De] = useState({}), Ce = useCallback(async () => {
    try {
      const He = await (te == null ? void 0 : te.getComments(
        $,
        st.builder().setpostId($).setcommentId(ee).setpage(1).setpageSize(10).build(),
        ee,
        1
      ));
      He.success && (ge({ ...He.data.comment }), De({ ...He.data.users }), Ee(2), Pe([...He.data.comment.replies]), He.data.comment.replies.length || Se(!1));
    } catch (He) {
      console.log(He);
    }
  }, [te, $, ee]), Ne = async () => {
    try {
      const He = await (te == null ? void 0 : te.getComments(
        $,
        st.builder().setpostId($).setcommentId(ee).setpage(xe).setpageSize(10).build(),
        ee,
        xe
      ));
      He.success && (De({ ...Ie, ...He.data.users }), Ee((Ge) => Ge + 1), Pe([...he, ...He.data.comment.replies]), He.data.comment.replies.length || Se(!1));
    } catch (He) {
      console.log(He);
    }
  }, Me = useCallback(
    async function(He) {
      try {
        if ((await (te == null ? void 0 : te.deleteComment(
          lt.builder().setcommentId(He).setpostId($).build()
        ))).success) {
          const Ze = [...he].filter((Qe) => Qe.Id !== He), Ue = { ...ve };
          Ue && Ue.commentsCount && Ue.commentsCount--, ne == null || ne.dispatchEvent(
            LMFeedCustomActionEvents.REPLY_DELETED,
            {
              replyId: ee
            }
          ), ge(Ue), Pe(Ze);
        }
      } catch (Ge) {
        console.log(Ge);
      }
    },
    [ne, te, $, he, ve, ee]
  ), Be = useCallback(
    async function(He) {
      try {
        if ((await (te == null ? void 0 : te.likeComment(
          ht.builder().setpostId($).setcommentId(He).build()
        ))).success) {
          const Ze = [...he].map((Ue) => (Ue.Id === He && (Ue.isLiked ? (Ue.isLiked = !1, Ue.likesCount--) : (Ue.isLiked = !0, Ue.likesCount++)), Ue));
          Pe(Ze);
        }
      } catch (Ge) {
        console.log(Ge);
      }
    },
    [te, $, he]
  ), We = useCallback(
    function(He, Ge) {
      const Ze = [...he].map(
        (Qe) => Qe.Id === He.Id ? He : Qe
      ), Ue = { ...Ie, ...Ge };
      Pe(Ze), De(Ue);
    },
    [he, Ie]
  );
  useEffect(() => (ne == null || ne.listen(
    LMFeedCustomActionEvents.REPLY_POSTED,
    (He) => {
      var Ue;
      const Ge = He.detail.comment, Ze = He.detail.users;
      if (((Ue = Ge.parentComment) == null ? void 0 : Ue.Id) === ee) {
        const Qe = [Ge, ...he], Je = { ...Ie, ...Ze };
        Pe(Qe), De(Je);
      }
    }
  ), () => ne == null ? void 0 : ne.remove(LMFeedCustomActionEvents.REPLY_POSTED)));
  const Le = useMemo(() => ({
    repliesDataStore: {
      reply: ve,
      setReply: ge,
      pageCount: xe,
      setPageCount: Ee,
      loadMoreReplies: Te,
      setLoadMoreReplies: Se,
      replies: he,
      setReplies: Pe,
      users: Ie,
      setUser: De
    },
    applicationGeneralStore: {
      userDataStore: {
        lmFeedUser: fe,
        lmFeedUserCurrentCommunity: pe,
        logOutUser: ye
      },
      generalDataStore: {
        displaySnackbarMessage: re,
        closeSnackbar: oe,
        showSnackbar: ie,
        message: se
      }
    },
    defaultActions: {
      updateReply: We,
      likeReply: Be,
      deleteReply: Me
    },
    navigate: me
  }), [
    me,
    oe,
    pe,
    fe,
    Me,
    re,
    Be,
    Te,
    ye,
    se,
    xe,
    he,
    ve,
    ie,
    We,
    Ie
  ]);
  return useEffect(() => {
    Ce();
  }, [Ce, $, ee]), {
    reply: ve,
    users: Ie,
    loadMoreReplies: Te,
    getNextPage: Ne,
    replies: he,
    deleteReply: de ? de.bind(null, Le) : Me,
    likeReply: ue ? ue.bind(null, Le) : Be,
    updateReply: We
  };
};
var LMFeedReplyMode = /* @__PURE__ */ (($) => ($.COMMENT = "COMMENT", $.REPLY = "REPLY", $))(LMFeedReplyMode || {});
const LMFeedRepliesScroller = ({
  replyId: $,
  postId: ee
}) => {
  const {
    replies: te = [],
    loadMoreReplies: ne = !1,
    getNextPage: re = () => {
    },
    users: se,
    deleteReply: ie,
    likeReply: oe,
    updateReply: le
  } = useReply(ee, $), { CustomComponents: ue } = useContext(CustomAgentProviderContext), de = () => te.map((fe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReplyContext.Provider,
    {
      value: {
        user: se[fe.uuid],
        reply: fe,
        deleteReply: ie,
        likeReply: oe,
        updateReply: le
      },
      children: (ue == null ? void 0 : ue.CustomReply) || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedReply, { mode: LMFeedReplyMode.REPLY })
    },
    fe.Id
  ));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    InfiniteScroll,
    {
      dataLength: te == null ? void 0 : te.length,
      hasMore: ne,
      loader: null,
      next: re,
      children: de()
    }
  ) });
}, replyAction = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.6535%2010.6837L4.85657%201.84307C4.59336%201.68958%204.29028%201.61828%203.98624%201.63832C3.68221%201.65837%203.3911%201.76885%203.15032%201.95557C2.90442%202.14958%202.72589%202.41613%202.64006%202.71736C2.55423%203.01859%202.56548%203.33921%202.6722%203.63369L5.30657%2010.9931C5.33322%2011.0664%205.38159%2011.13%205.44523%2011.1752C5.50886%2011.2204%205.58476%2011.2452%205.66282%2011.2462H12.4316C12.6262%2011.2431%2012.8147%2011.314%2012.9592%2011.4445C13.1036%2011.575%2013.1931%2011.7554%2013.2097%2011.9493C13.2161%2012.0517%2013.2015%2012.1543%2013.1666%2012.2507C13.1318%2012.3472%2013.0776%2012.4355%2013.0073%2012.5102C12.937%2012.5849%2012.8522%2012.6444%2012.758%2012.685C12.6638%2012.7256%2012.5623%2012.7464%2012.4597%2012.7462H5.66282C5.58476%2012.7472%205.50886%2012.772%205.44523%2012.8172C5.38159%2012.8624%205.33322%2012.9259%205.30657%2012.9993L2.6722%2020.3587C2.59315%2020.5854%202.56934%2020.8277%202.60272%2021.0655C2.63611%2021.3033%202.72574%2021.5296%202.86416%2021.7258C3.00259%2021.922%203.18582%2022.0823%203.39864%2022.1935C3.61146%2022.3046%203.84773%2022.3634%204.08782%2022.3649C4.34332%2022.3638%204.59455%2022.2994%204.81907%2022.1774L20.6535%2013.3087C20.8854%2013.177%2021.0783%2012.9861%2021.2126%2012.7555C21.3468%2012.525%2021.4175%2012.263%2021.4175%2011.9962C21.4175%2011.7294%2021.3468%2011.4674%2021.2126%2011.2369C21.0783%2011.0063%2020.8854%2010.8154%2020.6535%2010.6837Z'%20fill='%235046E5'/%3e%3c/svg%3e";
function useTagging() {
  const { lmFeedclient: $ } = useContext(GlobalClientProviderContext), [ee, te] = useState([]), [ne, re] = useState(1), [se, ie] = useState(null), [oe, le] = useState(!0);
  function ue() {
    te(() => []), ie(null), re(() => 1);
  }
  function de(pe) {
    ie(pe);
  }
  async function fe(pe) {
    try {
      const ye = await ($ == null ? void 0 : $.getTaggingList(
        G$1.builder().setpage(pe || ne).setpageSize(10).setsearchName(se || "").build()
      ));
      ye.success && (te((me) => [...me, ...ye.data.members]), re((me) => me + 1)), ye.data.members.length || le(!1);
    } catch (ye) {
      console.log(ye);
    }
  }
  return useEffect(() => {
    se !== null ? (le(!0), te((pe) => []), re(() => 1), fe(1)) : (te((pe) => []), re(() => 1));
  }, [se]), {
    taggingList: ee,
    clearTaggingList: ue,
    fetchTaggingList: fe,
    setTaggingString: de,
    fetchMoreTags: oe
  };
}
function useLMPostReply($, ee) {
  const { lmFeedclient: te, customEventClient: ne } = useContext(
    GlobalClientProviderContext
  ), { addNewComment: re, updateReplyOnPostReply: se } = useContext(FeedPostContext), { updateReply: ie } = useContext(ReplyContext), [oe, le] = useState(""), ue = useRef(null), de = useRef(null), fe = useCallback(function(ve) {
    le(ve);
  }, []);
  async function pe() {
    var ve;
    try {
      const ge = extractTextFromNode(ue.current).trim(), xe = await (te == null ? void 0 : te.replyComment(
        it.builder().setText(ge).setPostId($).setCommentId(ee || "").build()
      ));
      xe.success && (se && se(((ve = xe.data.comment.parentComment) == null ? void 0 : ve.Id) || ""), ne == null || ne.dispatchEvent(
        LMFeedCustomActionEvents.REPLY_POSTED,
        {
          comment: xe.data.comment,
          users: xe.data.users
        }
      ));
    } catch (ge) {
      console.log(ge);
    }
  }
  async function ye() {
    try {
      const ve = extractTextFromNode(ue.current).trim(), ge = await (te == null ? void 0 : te.addComment(
        tt.builder().settext(ve).setpostId($).build()
      ));
      ge.success && re && re(ge.data.comment, ge.data.users);
    } catch (ve) {
      console.log(ve);
    }
  }
  async function me() {
    try {
      const ve = extractTextFromNode(ue.current).trim(), ge = await (te == null ? void 0 : te.editComment(
        wt.builder().setcommentId(ee || "").setpostId($).settext(ve).build()
      ));
      ge.success && ie && ie(ge.data.comment, ge.data.users);
    } catch (ve) {
      console.log(ve);
    }
  }
  return {
    replyText: oe,
    setReplyText: fe,
    textFieldRef: ue,
    containerRef: de,
    postReply: pe,
    postComment: ye,
    editComment: me
  };
}
const LMFeedReplyTextArea = ({
  setReplyViewVisibility: $
}) => {
  const { reply: ee } = useContext(ReplyContext), { currentUser: te } = useContext(UserProviderContext), { id: ne } = useParams(), { name: re, imageUrl: se } = te, ie = getAvatar({
    imageUrl: se,
    name: re
  }), { taggingList: oe, clearTaggingList: le, fetchTaggingList: ue, setTaggingString: de } = useTagging(), {
    // replyText = "",
    setReplyText: fe,
    textFieldRef: pe,
    containerRef: ye,
    postReply: me,
    postComment: ve
  } = useLMPostReply((ne == null ? void 0 : ne.split("-")[0].toString()) || "", (ee == null ? void 0 : ee.Id) || "");
  function ge() {
    var xe, Ee;
    if ($)
      me(), $(!1);
    else
      for (ve(); (xe = pe.current) != null && xe.firstChild; )
        pe.current.removeChild((Ee = pe.current) == null ? void 0 : Ee.firstChild);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-reply-avatar", children: ie }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ye, className: "lm-flex-grow", children: [
      oe && (oe == null ? void 0 : oe.length) > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "taggingBox",
          id: "scrollableTaggingContainer",
          style: returnCSSForTagging(ye),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            InfiniteScroll,
            {
              loader: null,
              hasMore: !0,
              next: ue,
              dataLength: oe.length,
              scrollableTarget: "scrollableTaggingContainer",
              children: oe == null ? void 0 : oe.map((xe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "taggingTile",
                  onClick: (Ee) => {
                    Ee.preventDefault();
                    const Te = window.getSelection().focusNode;
                    if (Te === null)
                      return;
                    const Se = Te.parentElement, he = Se.childNodes;
                    if (Te === null || he.length === 0)
                      return;
                    const Pe = Te.textContent;
                    if (Pe === null)
                      return;
                    const Ie = findTag(Pe);
                    if (Ie === void 0)
                      return;
                    const { limitLeft: De, limitRight: Ce } = Ie, Ne = Pe.substring(
                      0,
                      De - 1
                    ), Me = Pe.substring(
                      Ce + 1
                    ), Be = document.createTextNode(Ne), We = document.createElement("a");
                    We.id = xe == null ? void 0 : xe.id.toString(), We.href = "#", We.textContent = `@${xe == null ? void 0 : xe.name.trim()}`, We.contentEditable = "false";
                    const Le = document.createTextNode(Me), He = document.createElement("span");
                    Se.replaceChild(Le, Te), Se.insertBefore(We, Le), Se.insertBefore(He, We), Se.insertBefore(Be, He), le(), setCursorAtEnd(pe);
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        alignItems: "center"
                      },
                      children: [
                        setTagUserImage(xe),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              padding: "0px 0.5rem",
                              textTransform: "capitalize",
                              overflowY: "hidden",
                              textOverflow: "ellipsis"
                            },
                            children: xe == null ? void 0 : xe.name
                          }
                        )
                      ]
                    }
                  )
                },
                (xe == null ? void 0 : xe.id.toString()) + Math.random().toString()
              ))
            }
          )
        }
      ) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: pe,
          contentEditable: !0,
          suppressContentEditableWarning: !0,
          tabIndex: 0,
          autoFocus: !0,
          "data-placeholder": "Write something here...",
          className: "reply-text-area",
          onKeyDown: (xe) => {
            xe.key === "Enter" && (document.execCommand("insertLineBreak"), xe.preventDefault());
          },
          onInput: (xe) => {
            const Ee = window.getSelection();
            if (fe(xe.currentTarget.textContent), Ee === null)
              return;
            const Te = Ee.focusNode;
            if (Te === null)
              return;
            const Se = Te.parentElement;
            if (Se === null)
              return;
            const he = Se.childNodes;
            if (Te === null || he.length === 0)
              return;
            const Pe = Te.textContent, Ie = findTag(Pe);
            (Ie == null ? void 0 : Ie.tagString) !== null && (Ie == null ? void 0 : Ie.tagString) !== void 0 ? de(Ie == null ? void 0 : Ie.tagString) : de(null);
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: replyAction,
        className: "lm-cursor-pointer",
        alt: "reply-action",
        onClick: ge
      }
    )
  ] });
}, repliesThreeDotMenu = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8%2012C8%2010.9%207.1%2010%206%2010C4.9%2010%204%2010.9%204%2012C4%2013.1%204.9%2014%206%2014C7.1%2014%208%2013.1%208%2012ZM10%2012C10%2013.1%2010.9%2014%2012%2014C13.1%2014%2014%2013.1%2014%2012C14%2010.9%2013.1%2010%2012%2010C10.9%2010%2010%2010.9%2010%2012ZM16%2012C16%2013.1%2016.9%2014%2018%2014C19.1%2014%2020%2013.1%2020%2012C20%2010.9%2019.1%2010%2018%2010C16.9%2010%2016%2010.9%2016%2012Z'%20fill='%23666666'/%3e%3c/svg%3e";
var LMFeedReplyMenuItems = /* @__PURE__ */ (($) => ($.DELETE = "6", $.REPORT = "7", $.EDIT = "8", $))(LMFeedReplyMenuItems || {});
const LMFeedReplyEditTextArea = ({
  closeEditMode: $
}) => {
  const { reply: ee } = useContext(ReplyContext), { id: te } = useParams(), { taggingList: ne, clearTaggingList: re, fetchTaggingList: se, setTaggingString: ie } = useTagging(), {
    // replyText = "",
    setReplyText: oe,
    textFieldRef: le,
    containerRef: ue,
    editComment: de
  } = useLMPostReply((te == null ? void 0 : te.split("-")[0].toString()) || "", (ee == null ? void 0 : ee.Id) || "");
  useEffect(() => {
    if (le != null && le.current) {
      le.current.innerHTML = convertTextToHTML(
        (ee == null ? void 0 : ee.text) || ""
      ).innerHTML, oe(le.current.textContent || ""), le.current.focus();
      const pe = document.createRange();
      pe.selectNodeContents(le.current), pe.collapse(!1);
      const ye = window.getSelection();
      ye && (ye.removeAllRanges(), ye.addRange(pe));
    }
  }, [le, oe]), useEffect(() => {
    function pe(ye) {
      var me;
      !((me = ue.current) != null && me.contains(ye.target)) && !(ye.target.classList.contains("lm-hover-effect") || ye.target.classList.contains("reply-editor")) && $ && $();
    }
    if (ue && ue.current)
      return document.addEventListener("click", pe), () => document.removeEventListener("click", pe);
  }, [ue, $, le]);
  function fe() {
    $ && (de(), $());
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-d-flex lm-flex-grow lm-align-items-center lm-feed-reply", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ue, className: "lm-flex-grow", children: [
      ne && (ne == null ? void 0 : ne.length) > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "taggingBox",
          id: "scrollableTaggingContainer",
          style: returnCSSForTagging(ue),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            InfiniteScroll,
            {
              loader: null,
              hasMore: !0,
              next: se,
              dataLength: ne.length,
              scrollableTarget: "scrollableTaggingContainer",
              children: ne == null ? void 0 : ne.map((pe) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "taggingTile reply-editor",
                  onClick: (ye) => {
                    ye.preventDefault();
                    const me = window.getSelection().focusNode;
                    if (me === null)
                      return;
                    const ve = me.parentElement, ge = ve.childNodes;
                    if (me === null || ge.length === 0)
                      return;
                    const xe = me.textContent;
                    if (xe === null)
                      return;
                    const Ee = findTag(xe);
                    if (Ee === void 0)
                      return;
                    const { limitLeft: Te, limitRight: Se } = Ee, he = xe.substring(
                      0,
                      Te - 1
                    ), Pe = xe.substring(
                      Se + 1
                    ), Ie = document.createTextNode(he), De = document.createElement("a");
                    De.id = pe == null ? void 0 : pe.id.toString(), De.href = "#", De.textContent = `@${pe == null ? void 0 : pe.name.trim()}`, De.contentEditable = "false";
                    const Ce = document.createTextNode(Pe), Ne = document.createElement("span");
                    ve.replaceChild(Ce, me), ve.insertBefore(De, Ce), ve.insertBefore(Ne, De), ve.insertBefore(Ie, Ne), re(), setCursorAtEnd(le);
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        alignItems: "center"
                      },
                      className: "tag-container reply-editor",
                      children: [
                        setTagUserImage(pe),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              padding: "0px 0.5rem",
                              textTransform: "capitalize",
                              overflowY: "hidden",
                              textOverflow: "ellipsis"
                            },
                            className: "tag-name reply-editor",
                            children: pe == null ? void 0 : pe.name
                          }
                        )
                      ]
                    }
                  )
                },
                (pe == null ? void 0 : pe.id.toString()) + Math.random().toString()
              ))
            }
          )
        }
      ) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: le,
          contentEditable: !0,
          suppressContentEditableWarning: !0,
          tabIndex: 0,
          autoFocus: !0,
          "data-placeholder": "Write something here...",
          className: "edit-reply-text-area",
          onKeyDown: (pe) => {
            pe.key === "Enter" && (document.execCommand("insertLineBreak"), pe.preventDefault());
          },
          onInput: (pe) => {
            const ye = window.getSelection();
            if (oe(pe.currentTarget.textContent), ye === null)
              return;
            const me = ye.focusNode;
            if (me === null)
              return;
            const ve = me.parentElement;
            if (ve === null)
              return;
            const ge = ve.childNodes;
            if (me === null || ge.length === 0)
              return;
            const xe = me.textContent, Ee = findTag(xe);
            (Ee == null ? void 0 : Ee.tagString) !== null && (Ee == null ? void 0 : Ee.tagString) !== void 0 ? ie(Ee == null ? void 0 : Ee.tagString) : ie(null);
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: replyAction,
        alt: "edit-reply-action",
        className: "lm-cursor-pointer",
        onClick: fe
      }
    )
  ] });
}, LMFeedReply = ({ mode: $ }) => {
  const { reply: ee, user: te, likeReply: ne } = useContext(ReplyContext), { LMFeedCustomIcons: re = {}, CustomComponents: se = {} } = useContext(
    CustomAgentProviderContext
  ), { id: ie = "" } = useParams(), { name: oe } = te || {}, [le, ue] = useState(!1), [de, fe] = useState(!1), [pe, ye] = useState(null), [me, ve] = useState(!1), [ge, xe] = useState(!1), [Ee, Te] = useState(!1);
  function Se() {
    Te(!1);
  }
  function he() {
    xe(!1);
  }
  function Pe() {
    xe(!0);
  }
  function Ie(Be) {
    const We = Be.currentTarget.id;
    switch (ye(null), We) {
      case LMFeedReplyMenuItems.DELETE: {
        Te(!0);
        break;
      }
      case LMFeedReplyMenuItems.REPORT: {
        Ce();
        break;
      }
      case LMFeedReplyMenuItems.EDIT: {
        Pe();
        break;
      }
    }
  }
  function De() {
    ve(!1);
  }
  function Ce() {
    ve(!0);
  }
  function Ne(Be) {
    ye(Be.currentTarget);
  }
  function Me() {
    ye(null);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-social-action-bar__lmReply", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$1, { open: Ee, onClose: Se, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LMFeedDeleteDialogBox,
      {
        onClose: Se,
        mode: $ === LMFeedReplyMode.COMMENT ? LMFeedDeletePostModes.COMMENT : LMFeedDeletePostModes.REPLY
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog$1, { open: me, onClose: De, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      LMFeedReportPostDialog,
      {
        entityType: $ === LMFeedReplyMode.COMMENT ? LMFeedEntityType.COMMENT : LMFeedEntityType.REPLY,
        closeReportDialog: De,
        entityId: (ee == null ? void 0 : ee.Id) || ""
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Menu$1,
      {
        open: !!pe,
        anchorEl: pe,
        anchorOrigin: {
          horizontal: "right",
          vertical: "top"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "right"
        },
        onClose: Me,
        children: ee == null ? void 0 : ee.menuItems.map((Be) => {
          var We;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "three-dot-menu-options lm-cursor-pointer lm-hover-effect",
              onClick: Ie,
              id: (We = Be == null ? void 0 : Be.id) == null ? void 0 : We.toString(),
              children: Be == null ? void 0 : Be.title
            },
            Be == null ? void 0 : Be.id
          );
        })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-social-action-bar__lmReply__userMeta lm-flex-direction", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-social-action-bar__lmReply__userMeta__content lm-mb-5", children: ge ? se.CustomEditReplyTextArea ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        se.CustomEditReplyTextArea,
        {
          closeEditMode: he
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedReplyEditTextArea, { closeEditMode: he }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content-area", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-social-action-bar__lmReply__userMeta__content--name", children: oe }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-social-action-bar__lmReply__userMeta__content--title", children: parseAndReplaceTags((ee == null ? void 0 : ee.text) || "") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: repliesThreeDotMenu,
            alt: "three-dot-menu",
            className: "three-dot-menu lm-cursor-pointer",
            onClick: Ne
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-d-flex lm-justify-content-space-between lm-align-items-center lm-mb-5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "like lm-d-flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "lm-feed-post-like-container",
              onClick: () => {
                ne && ne((ee == null ? void 0 : ee.Id) || "");
              },
              children: ee != null && ee.isLiked ? re.repliesLikesLikedCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(re.repliesLikesLikedCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: commentLiked,
                  className: "lm-cursor-pointer liked-comment",
                  alt: "Like",
                  loading: "lazy"
                }
              ) : re.repliesLikesNormalCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(re.repliesLikesNormalCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: likeIcon,
                  className: "lm-cursor-pointer",
                  alt: "Like",
                  loading: "lazy"
                }
              )
            }
          ),
          ee != null && ee.likesCount ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((ee == null ? void 0 : ee.likesCount) || 0) > 1 ? `${ee == null ? void 0 : ee.likesCount} ${LIKES}` : ((ee == null ? void 0 : ee.likesCount) || 0) === 1 ? `${ee == null ? void 0 : ee.likesCount} ${LIKE}` : "" }) : "",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipe", children: "|" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            ((ee == null ? void 0 : ee.level) || 0) < 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: "reply-badge lm-cursor-pointer",
                onClick: () => {
                  fe(!de);
                },
                children: [
                  "Reply",
                  " "
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: ((ee == null ? void 0 : ee.commentsCount) || 0) > 1 || ((ee == null ? void 0 : ee.commentsCount) || 0) === 1 ? "replies lm-cursor-pointer commentTitle bullet" : "replies lm-cursor-pointer commentTitle",
                onClick: () => {
                  ue((Be) => !Be);
                },
                children: ((ee == null ? void 0 : ee.commentsCount) || 0) > 1 ? `${ee == null ? void 0 : ee.commentsCount} Replies` : ((ee == null ? void 0 : ee.commentsCount) || 0) === 1 ? `${ee == null ? void 0 : ee.commentsCount} Reply` : ""
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "like", children: formatTimeAgo((ee == null ? void 0 : ee.createdAt) || 0) })
      ] }),
      de ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-d-flex lm-flex-grow lm-align-items-center lm-mb-5 lm-feed-reply", children: se.CustomPostReplyTextArea ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        se.CustomPostReplyTextArea,
        {
          setReplyViewVisibility: fe
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedReplyTextArea, { setReplyViewVisibility: fe }) }) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-social-action-bar__lmReply__commentsScroller", children: le && (se.CustomRepliesScroller || /* @__PURE__ */ jsxRuntimeExports.jsx(
      LMFeedRepliesScroller,
      {
        postId: ie.split("-")[0],
        replyId: (ee == null ? void 0 : ee.Id) || ""
      }
    )) })
  ] });
}, LMFeedCommentsScroller = () => {
  const {
    replies: $ = [],
    loadNextPage: ee = !1,
    getNextPage: te = () => {
    },
    users: ne,
    likeReply: re,
    updateReply: se
  } = useContext(FeedPostContext), { CustomComponents: ie } = useContext(CustomAgentProviderContext), oe = () => $.map((le) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReplyContext.Provider,
    {
      value: {
        user: ne[le.uuid],
        reply: le,
        likeReply: re,
        updateReply: se
      },
      children: (ie == null ? void 0 : ie.CustomReply) || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedReply, { mode: LMFeedReplyMode.COMMENT })
    },
    le.Id
  ));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    InfiniteScroll,
    {
      dataLength: $ == null ? void 0 : $.length,
      hasMore: ee,
      loader: null,
      next: te,
      children: oe()
    }
  ) });
}, LMFeedLikedMembers = ($) => {
  const { postId: ee } = $, { lmFeedclient: te, customEventClient: ne } = useContext(
    GlobalClientProviderContext
  ), [re, se] = useState([]), [ie, oe] = useState(!0), [le, ue] = useState(1), [de, fe] = useState(0), pe = [], ye = async (ve) => {
    try {
      const ge = await (te == null ? void 0 : te.getPostLikes(
        x$1.builder().setpage(ve).setpageSize(20).setpostId(ee).build()
      ));
      ge && ge.data && ge.data.likes && (ge.data.likes.length > 0 && (ge.data.likes.map((xe) => {
        const Ee = ge.data.users[xe.uuid];
        if (!Ee)
          throw new Error(`No user found with UUID: ${xe.uuid}`);
        return pe.push(Ee);
      }), se(pe), ue(ve), fe(ge.data.totalCount)), (ge.data.likes.length === 0 || re.length >= ge.data.totalCount) && oe(!1));
    } catch (ge) {
      console.log(ge), oe(!1);
    }
  };
  useEffect(() => {
    ye(1);
  }, [te]);
  const me = () => {
    ye(le + 1);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-member-wrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-member-wrapper__header", children: [
      "Likes (",
      de,
      ")"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body", id: "member-scroll-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InfiniteScroll,
      {
        dataLength: re ? re.length : 0,
        hasMore: ie,
        next: me,
        loader: null,
        scrollableTarget: "member-scroll-container",
        children: re ? re.map((ve) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "lm-member-wrapper__body__media lm-hover-effect lm-cursor-pointer",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__imgBox lm-avatar", children: getAvatar({
                imageUrl: ve.imageUrl,
                name: ve == null ? void 0 : ve.name
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__content--name", children: ve.name }) })
            ]
          },
          ve.uuid
        )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." })
      }
    ) })
  ] });
}, LMFeedPostFooter = () => {
  const { post: $, likePost: ee, clickNavigator: te } = useContext(FeedPostContext), [ne, re] = React__default.useState(!1), se = (pe) => () => {
    re(pe);
  }, { likesCount: ie, commentsCount: oe, Id: le } = $, { LMFeedCustomIcons: ue, CustomComponents: de = {} } = useContext(
    CustomAgentProviderContext
  );
  if (!$)
    return null;
  function fe() {
    return window.location.pathname.includes("post") ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, { className: "lm-footer-reply-divider" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          "lm-feed-component-id": `lm-feed-post-footer-zabcd-${$ == null ? void 0 : $.Id}`,
          className: "lm-d-flex lm-flex-grow lm-position-relative lm-align-items-center lm-mb-5 lm-feed-reply lm-pl-4 lm-pr-4 lm-pt-4 lm-pb-4",
          children: de.CustomPostReplyTextArea ? /* @__PURE__ */ jsxRuntimeExports.jsx(de.CustomPostReplyTextArea, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedReplyTextArea, {})
        }
      )
    ] }) : null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Drawer$1, { open: ne, onClose: se(!1), anchor: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lmLikedMemberWrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedLikedMembers, { postId: $ == null ? void 0 : $.Id }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "lm-feed-wrapper__card__footer",
        "lm-feed-component-id": `lm-feed-post-footer-vwxyz-${$ == null ? void 0 : $.Id}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-social-action-bar", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-social-action-bar__actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-d-flex lm-align-items-center lm-flex-gap lm-cursor-pointer", children: [
                $ != null && $.isLiked ? ue != null && ue.postLikesLikedCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ue.postLikesLikedCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    onClick: () => {
                      ee(le);
                    },
                    src: postLiked,
                    className: "lm-cursor-pointer",
                    alt: "Like",
                    "lm-feed-component-id": `lm-feed-post-footer-fghij-${$ == null ? void 0 : $.Id}`
                  }
                ) : ue != null && ue.postLikesNormalCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ue.postLikesNormalCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    onClick: () => {
                      ee(le);
                    },
                    src: like,
                    className: "lm-cursor-pointer",
                    alt: "Like",
                    "lm-feed-component-id": `lm-feed-post-footer-fghij-${$ == null ? void 0 : $.Id}`
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    className: "lm-feed-wrapper__card__footer_likes-count",
                    "lm-feed-component-id": `lm-feed-post-footer-klmno-${$ == null ? void 0 : $.Id}`,
                    onClick: se(!0),
                    children: [
                      " ",
                      `${ie ? ie.toString().concat(" ") : ""}${ie > 1 ? LIKES : LIKE}`
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "lm-d-flex lm-align-items-center lm-flex-gap lm-cursor-pointer",
                  onClick: () => {
                    te && te($);
                  },
                  children: [
                    ue != null && ue.postCommentsCustomIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ue.postCommentsCustomIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        className: "lm-cursor-pointer",
                        src: commnent,
                        alt: "commnent",
                        "lm-feed-component-id": `lm-feed-post-footer-pqrst-${$ == null ? void 0 : $.Id}`
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "comments lm-feed-wrapper__card__footer_comments-count",
                        "lm-feed-component-id": `lm-feed-post-footer-uvwxy-${$ == null ? void 0 : $.Id}`,
                        children: `${oe ? oe.toString().concat(" ") : ""}${oe > 1 ? COMMNENTS : COMMNENT}`
                      }
                    )
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-social-action-bar__actions" })
          ] }),
          fe(),
          (de == null ? void 0 : de.CustomRepliesScroller) || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCommentsScroller, {})
        ]
      }
    )
  ] });
}, LMFeedTopicsTile = ({ topic: $ }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-feed-topic-tile", children: $.name }), LMFeedPostTopicsWrapper = () => {
  const { post: $, topics: ee } = useContext(FeedPostContext), { topics: te } = $, { CustomComponents: ne } = useContext(CustomAgentProviderContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "lm-feed-wrapper__card__topic-view-wrapper  lm-mb-3",
      "lm-feed-component-id": `lm-feed-topic-wrapper-vwxyz-${$ == null ? void 0 : $.Id}`,
      children: te == null ? void 0 : te.map((re) => ne != null && ne.CustomPostTopicTile ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        ne.CustomPostTopicTile,
        {
          topic: ee[re]
        },
        re
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedTopicsTile, { topic: ee[re] }, re))
    }
  ) });
}, LMFeedPost = () => {
  const { CustomComponents: $ } = useContext(CustomAgentProviderContext), { post: ee, postComponentClickCustomCallback: te } = useContext(FeedPostContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "lm-feed-wrapper__card lm-mb-2",
      "lm-feed-data-id": ee == null ? void 0 : ee.Id,
      "lm-feed-component-id": `lm-feed-post-wrapper-${ee == null ? void 0 : ee.Id}`,
      onClick: (ne) => {
        te && te(ne);
      },
      children: [
        $ != null && $.CustomPostViewHeader ? $ == null ? void 0 : $.CustomPostViewHeader : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedPostHeader, {}),
        $ != null && $.CustomPostViewTopicsWrapper ? $ == null ? void 0 : $.CustomPostViewTopicsWrapper : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedPostTopicsWrapper, {}),
        $ != null && $.CustomPostViewBody ? $ == null ? void 0 : $.CustomPostViewBody : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedPostBody, {}),
        $ != null && $.CustomPostViewFooter ? $.CustomPostViewFooter : /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedPostFooter, {})
      ]
    }
  );
}, photo = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.75%209.375C15.75%209.67337%2015.6315%209.95952%2015.4205%2010.1705C15.2095%2010.3815%2014.9234%2010.5%2014.625%2010.5C14.3266%2010.5%2014.0405%2010.3815%2013.8295%2010.1705C13.6185%209.95952%2013.5%209.67337%2013.5%209.375C13.5%209.07663%2013.6185%208.79048%2013.8295%208.5795C14.0405%208.36853%2014.3266%208.25%2014.625%208.25C14.9234%208.25%2015.2095%208.36853%2015.4205%208.5795C15.6315%208.79048%2015.75%209.07663%2015.75%209.375ZM21.75%205.25V17.25V18.75C21.75%2019.1478%2021.592%2019.5294%2021.3107%2019.8107C21.0294%2020.092%2020.6478%2020.25%2020.25%2020.25H3.75C3.35218%2020.25%202.97064%2020.092%202.68934%2019.8107C2.40804%2019.5294%202.25%2019.1478%202.25%2018.75V15.75V5.25C2.25%204.85218%202.40804%204.47064%202.68934%204.18934C2.97064%203.90804%203.35218%203.75%203.75%203.75H20.25C20.6478%203.75%2021.0294%203.90804%2021.3107%204.18934C21.592%204.47064%2021.75%204.85218%2021.75%205.25ZM20.25%2015.4406V5.25H3.75V13.9406L7.19062%2010.5C7.47302%2010.2217%207.85355%2010.0658%208.25%2010.0658C8.64645%2010.0658%209.02698%2010.2217%209.30938%2010.5L13.5%2014.6906L15.4406%2012.75C15.723%2012.4717%2016.1036%2012.3158%2016.5%2012.3158C16.8964%2012.3158%2017.277%2012.4717%2017.5594%2012.75L20.25%2015.4406Z'%20fill='%23ED8031'/%3e%3c/svg%3e", video = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.5%208.625V17.625C16.5%2018.0228%2016.342%2018.4044%2016.0607%2018.6857C15.7794%2018.967%2015.3978%2019.125%2015%2019.125H4.5C4.00754%2019.125%203.51991%2019.028%203.06494%2018.8395C2.60997%2018.6511%202.19657%2018.3749%201.84835%2018.0267C1.14509%2017.3234%200.75%2016.3696%200.75%2015.375V6.375C0.75%205.97718%200.908035%205.59564%201.18934%205.31434C1.47064%205.03304%201.85218%204.875%202.25%204.875H12.75C13.7446%204.875%2014.6984%205.27009%2015.4017%205.97335C16.1049%206.67661%2016.5%207.63044%2016.5%208.625ZM22.875%206.85312C22.762%206.78442%2022.6323%206.74808%2022.5%206.74808C22.3677%206.74808%2022.238%206.78442%2022.125%206.85312L18.375%208.99063C18.26%209.05702%2018.1647%209.15276%2018.0988%209.26806C18.0329%209.38336%2017.9988%209.51408%2018%209.64688V14.3531C17.9988%2014.4859%2018.0329%2014.6166%2018.0988%2014.7319C18.1647%2014.8472%2018.26%2014.943%2018.375%2015.0094L22.125%2017.1469C22.2393%2017.2124%2022.3683%2017.2479%2022.5%2017.25C22.6319%2017.2492%2022.7612%2017.2136%2022.875%2017.1469C22.9899%2017.0828%2023.0854%2016.9888%2023.1514%2016.875C23.2174%2016.7611%2023.2515%2016.6316%2023.25%2016.5V7.5C23.2515%207.36841%2023.2174%207.23886%2023.1514%207.12501C23.0854%207.01116%2022.9899%206.91723%2022.875%206.85312Z'%20fill='%237B61FF'/%3e%3c/svg%3e", pdf = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M18%2017.25C18%2016.8358%2017.6642%2016.5%2017.25%2016.5H6.5C4.29%2016.5%202.5%2014.71%202.5%2012.5C2.5%2010.29%204.29%208.5%206.5%208.5H19C20.38%208.5%2021.5%209.62%2021.5%2011C21.5%2012.38%2020.38%2013.5%2019%2013.5H10.5C9.95%2013.5%209.5%2013.05%209.5%2012.5C9.5%2011.95%209.95%2011.5%2010.5%2011.5H17.25C17.6642%2011.5%2018%2011.1642%2018%2010.75C18%2010.3358%2017.6642%2010%2017.25%2010H10.5C9.12%2010%208%2011.12%208%2012.5C8%2013.88%209.12%2015%2010.5%2015H19C21.21%2015%2023%2013.21%2023%2011C23%208.79%2021.21%207%2019%207H6.5C3.46%207%201%209.46%201%2012.5C1%2015.54%203.46%2018%206.5%2018H17.25C17.6642%2018%2018%2017.6642%2018%2017.25Z'%20fill='%23484F67'/%3e%3c/svg%3e", LMFeedCreatePostContext = createContext({});
var LMFeedCreatePostMediaUploadMode = /* @__PURE__ */ (($) => ($.NULL = "", $.IMAGE = "IMAGE", $.VIDEO = "VIDEO", $.DOCUMENT = "FILE", $))(LMFeedCreatePostMediaUploadMode || {});
const getHttpHandlerExtensionConfiguration = ($) => {
  let ee = $.httpHandler;
  return {
    setHttpHandler(te) {
      ee = te;
    },
    httpHandler() {
      return ee;
    },
    updateHttpClientConfig(te, ne) {
      ee.updateHttpClientConfig(te, ne);
    },
    httpHandlerConfigs() {
      return ee.httpHandlerConfigs();
    }
  };
}, resolveHttpHandlerRuntimeConfig = ($) => ({
  httpHandler: $.httpHandler()
});
var HttpAuthLocation;
(function($) {
  $.HEADER = "header", $.QUERY = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));
var HttpApiKeyAuthLocation;
(function($) {
  $.HEADER = "header", $.QUERY = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
var EndpointURLScheme;
(function($) {
  $.HTTP = "http", $.HTTPS = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));
var AlgorithmId;
(function($) {
  $.MD5 = "md5", $.CRC32 = "crc32", $.CRC32C = "crc32c", $.SHA1 = "sha1", $.SHA256 = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
var FieldPosition;
(function($) {
  $[$.HEADER = 0] = "HEADER", $[$.TRAILER = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));
const SMITHY_CONTEXT_KEY = "__smithy_context";
var IniSectionType;
(function($) {
  $.PROFILE = "profile", $.SSO_SESSION = "sso-session", $.SERVICES = "services";
})(IniSectionType || (IniSectionType = {}));
var RequestHandlerProtocol;
(function($) {
  $.HTTP_0_9 = "http/0.9", $.HTTP_1_0 = "http/1.0", $.TDS_8_0 = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
class HttpRequest {
  constructor(ee) {
    this.method = ee.method || "GET", this.hostname = ee.hostname || "localhost", this.port = ee.port, this.query = ee.query || {}, this.headers = ee.headers || {}, this.body = ee.body, this.protocol = ee.protocol ? ee.protocol.slice(-1) !== ":" ? `${ee.protocol}:` : ee.protocol : "https:", this.path = ee.path ? ee.path.charAt(0) !== "/" ? `/${ee.path}` : ee.path : "/", this.username = ee.username, this.password = ee.password, this.fragment = ee.fragment;
  }
  static isInstance(ee) {
    if (!ee)
      return !1;
    const te = ee;
    return "method" in te && "protocol" in te && "hostname" in te && "path" in te && typeof te.query == "object" && typeof te.headers == "object";
  }
  clone() {
    const ee = new HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    return ee.query && (ee.query = cloneQuery$1(ee.query)), ee;
  }
}
function cloneQuery$1($) {
  return Object.keys($).reduce((ee, te) => {
    const ne = $[te];
    return {
      ...ee,
      [te]: Array.isArray(ne) ? [...ne] : ne
    };
  }, {});
}
class HttpResponse {
  constructor(ee) {
    this.statusCode = ee.statusCode, this.reason = ee.reason, this.headers = ee.headers || {}, this.body = ee.body;
  }
  static isInstance(ee) {
    if (!ee)
      return !1;
    const te = ee;
    return typeof te.statusCode == "number" && typeof te.headers == "object";
  }
}
function addExpectContinueMiddleware($) {
  return (ee) => async (te) => {
    const { request: ne } = te;
    return HttpRequest.isInstance(ne) && ne.body && $.runtime === "node" && (ne.headers = {
      ...ne.headers,
      Expect: "100-continue"
    }), ee({
      ...te,
      request: ne
    });
  };
}
const addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: !0
}, getAddExpectContinuePlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(addExpectContinueMiddleware($), addExpectContinueMiddlewareOptions);
  }
});
function resolveHostHeaderConfig($) {
  return $;
}
const hostHeaderMiddleware = ($) => (ee) => async (te) => {
  if (!HttpRequest.isInstance(te.request))
    return ee(te);
  const { request: ne } = te, { handlerProtocol: re = "" } = $.requestHandler.metadata || {};
  if (re.indexOf("h2") >= 0 && !ne.headers[":authority"])
    delete ne.headers.host, ne.headers[":authority"] = ne.hostname + (ne.port ? ":" + ne.port : "");
  else if (!ne.headers.host) {
    let se = ne.hostname;
    ne.port != null && (se += `:${ne.port}`), ne.headers.host = se;
  }
  return ee(te);
}, hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: !0
}, getHostHeaderPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(hostHeaderMiddleware($), hostHeaderMiddlewareOptions);
  }
}), loggerMiddleware = () => ($, ee) => async (te) => {
  var ne, re;
  try {
    const se = await $(te), { clientName: ie, commandName: oe, logger: le, dynamoDbDocumentClientOptions: ue = {} } = ee, { overrideInputFilterSensitiveLog: de, overrideOutputFilterSensitiveLog: fe } = ue, pe = de ?? ee.inputFilterSensitiveLog, ye = fe ?? ee.outputFilterSensitiveLog, { $metadata: me, ...ve } = se.output;
    return (ne = le == null ? void 0 : le.info) == null || ne.call(le, {
      clientName: ie,
      commandName: oe,
      input: pe(te.input),
      output: ye(ve),
      metadata: me
    }), se;
  } catch (se) {
    const { clientName: ie, commandName: oe, logger: le, dynamoDbDocumentClientOptions: ue = {} } = ee, { overrideInputFilterSensitiveLog: de } = ue, fe = de ?? ee.inputFilterSensitiveLog;
    throw (re = le == null ? void 0 : le.error) == null || re.call(le, {
      clientName: ie,
      commandName: oe,
      input: fe(te.input),
      error: se,
      metadata: se.$metadata
    }), se;
  }
}, loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: !0
}, getLoggerPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
}), TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id", ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME", ENV_TRACE_ID = "_X_AMZN_TRACE_ID", recursionDetectionMiddleware = ($) => (ee) => async (te) => {
  const { request: ne } = te;
  if (!HttpRequest.isInstance(ne) || $.runtime !== "node" || ne.headers.hasOwnProperty(TRACE_ID_HEADER_NAME))
    return ee(te);
  const re = process.env[ENV_LAMBDA_FUNCTION_NAME], se = process.env[ENV_TRACE_ID], ie = (oe) => typeof oe == "string" && oe.length > 0;
  return ie(re) && ie(se) && (ne.headers[TRACE_ID_HEADER_NAME] = se), ee({
    ...te,
    request: ne
  });
}, addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: !0,
  priority: "low"
}, getRecursionDetectionPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(recursionDetectionMiddleware($), addRecursionDetectionMiddlewareOptions);
  }
});
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const getAllAliases = ($, ee) => {
  const te = [];
  if ($ && te.push($), ee)
    for (const ne of ee)
      te.push(ne);
  return te;
}, getMiddlewareNameWithAliases = ($, ee) => `${$ || "anonymous"}${ee && ee.length > 0 ? ` (a.k.a. ${ee.join(",")})` : ""}`, constructStack = () => {
  let $ = [], ee = [], te = !1;
  const ne = /* @__PURE__ */ new Set(), re = (fe) => fe.sort((pe, ye) => stepWeights[ye.step] - stepWeights[pe.step] || priorityWeights[ye.priority || "normal"] - priorityWeights[pe.priority || "normal"]), se = (fe) => {
    let pe = !1;
    const ye = (me) => {
      const ve = getAllAliases(me.name, me.aliases);
      if (ve.includes(fe)) {
        pe = !0;
        for (const ge of ve)
          ne.delete(ge);
        return !1;
      }
      return !0;
    };
    return $ = $.filter(ye), ee = ee.filter(ye), pe;
  }, ie = (fe) => {
    let pe = !1;
    const ye = (me) => {
      if (me.middleware === fe) {
        pe = !0;
        for (const ve of getAllAliases(me.name, me.aliases))
          ne.delete(ve);
        return !1;
      }
      return !0;
    };
    return $ = $.filter(ye), ee = ee.filter(ye), pe;
  }, oe = (fe) => {
    var pe;
    return $.forEach((ye) => {
      fe.add(ye.middleware, { ...ye });
    }), ee.forEach((ye) => {
      fe.addRelativeTo(ye.middleware, { ...ye });
    }), (pe = fe.identifyOnResolve) == null || pe.call(fe, de.identifyOnResolve()), fe;
  }, le = (fe) => {
    const pe = [];
    return fe.before.forEach((ye) => {
      ye.before.length === 0 && ye.after.length === 0 ? pe.push(ye) : pe.push(...le(ye));
    }), pe.push(fe), fe.after.reverse().forEach((ye) => {
      ye.before.length === 0 && ye.after.length === 0 ? pe.push(ye) : pe.push(...le(ye));
    }), pe;
  }, ue = (fe = !1) => {
    const pe = [], ye = [], me = {};
    return $.forEach((ge) => {
      const xe = {
        ...ge,
        before: [],
        after: []
      };
      for (const Ee of getAllAliases(xe.name, xe.aliases))
        me[Ee] = xe;
      pe.push(xe);
    }), ee.forEach((ge) => {
      const xe = {
        ...ge,
        before: [],
        after: []
      };
      for (const Ee of getAllAliases(xe.name, xe.aliases))
        me[Ee] = xe;
      ye.push(xe);
    }), ye.forEach((ge) => {
      if (ge.toMiddleware) {
        const xe = me[ge.toMiddleware];
        if (xe === void 0) {
          if (fe)
            return;
          throw new Error(`${ge.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(ge.name, ge.aliases)} middleware ${ge.relation} ${ge.toMiddleware}`);
        }
        ge.relation === "after" && xe.after.push(ge), ge.relation === "before" && xe.before.push(ge);
      }
    }), re(pe).map(le).reduce((ge, xe) => (ge.push(...xe), ge), []);
  }, de = {
    add: (fe, pe = {}) => {
      const { name: ye, override: me, aliases: ve } = pe, ge = {
        step: "initialize",
        priority: "normal",
        middleware: fe,
        ...pe
      }, xe = getAllAliases(ye, ve);
      if (xe.length > 0) {
        if (xe.some((Ee) => ne.has(Ee))) {
          if (!me)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(ye, ve)}'`);
          for (const Ee of xe) {
            const Te = $.findIndex((he) => {
              var Pe;
              return he.name === Ee || ((Pe = he.aliases) == null ? void 0 : Pe.some((Ie) => Ie === Ee));
            });
            if (Te === -1)
              continue;
            const Se = $[Te];
            if (Se.step !== ge.step || ge.priority !== Se.priority)
              throw new Error(`"${getMiddlewareNameWithAliases(Se.name, Se.aliases)}" middleware with ${Se.priority} priority in ${Se.step} step cannot be overridden by "${getMiddlewareNameWithAliases(ye, ve)}" middleware with ${ge.priority} priority in ${ge.step} step.`);
            $.splice(Te, 1);
          }
        }
        for (const Ee of xe)
          ne.add(Ee);
      }
      $.push(ge);
    },
    addRelativeTo: (fe, pe) => {
      const { name: ye, override: me, aliases: ve } = pe, ge = {
        middleware: fe,
        ...pe
      }, xe = getAllAliases(ye, ve);
      if (xe.length > 0) {
        if (xe.some((Ee) => ne.has(Ee))) {
          if (!me)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(ye, ve)}'`);
          for (const Ee of xe) {
            const Te = ee.findIndex((he) => {
              var Pe;
              return he.name === Ee || ((Pe = he.aliases) == null ? void 0 : Pe.some((Ie) => Ie === Ee));
            });
            if (Te === -1)
              continue;
            const Se = ee[Te];
            if (Se.toMiddleware !== ge.toMiddleware || Se.relation !== ge.relation)
              throw new Error(`"${getMiddlewareNameWithAliases(Se.name, Se.aliases)}" middleware ${Se.relation} "${Se.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(ye, ve)}" middleware ${ge.relation} "${ge.toMiddleware}" middleware.`);
            ee.splice(Te, 1);
          }
        }
        for (const Ee of xe)
          ne.add(Ee);
      }
      ee.push(ge);
    },
    clone: () => oe(constructStack()),
    use: (fe) => {
      fe.applyToStack(de);
    },
    remove: (fe) => typeof fe == "string" ? se(fe) : ie(fe),
    removeByTag: (fe) => {
      let pe = !1;
      const ye = (me) => {
        const { tags: ve, name: ge, aliases: xe } = me;
        if (ve && ve.includes(fe)) {
          const Ee = getAllAliases(ge, xe);
          for (const Te of Ee)
            ne.delete(Te);
          return pe = !0, !1;
        }
        return !0;
      };
      return $ = $.filter(ye), ee = ee.filter(ye), pe;
    },
    concat: (fe) => {
      var ye;
      const pe = oe(constructStack());
      return pe.use(fe), pe.identifyOnResolve(te || pe.identifyOnResolve() || (((ye = fe.identifyOnResolve) == null ? void 0 : ye.call(fe)) ?? !1)), pe;
    },
    applyToStack: oe,
    identify: () => ue(!0).map((fe) => {
      const pe = fe.step ?? fe.relation + " " + fe.toMiddleware;
      return getMiddlewareNameWithAliases(fe.name, fe.aliases) + " - " + pe;
    }),
    identifyOnResolve(fe) {
      return typeof fe == "boolean" && (te = fe), te;
    },
    resolve: (fe, pe) => {
      for (const ye of ue().map((me) => me.middleware).reverse())
        fe = ye(fe, pe);
      return te && console.log(de.identify()), fe;
    }
  };
  return de;
}, stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
}, priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};
class Client {
  constructor(ee) {
    this.middlewareStack = constructStack(), this.config = ee;
  }
  send(ee, te, ne) {
    const re = typeof te != "function" ? te : void 0, se = typeof te == "function" ? te : ne, ie = ee.resolveMiddleware(this.middlewareStack, this.config, re);
    if (se)
      ie(ee).then((oe) => se(null, oe.output), (oe) => se(oe)).catch(() => {
      });
    else
      return ie(ee).then((oe) => oe.output);
  }
  destroy() {
    this.config.requestHandler.destroy && this.config.requestHandler.destroy();
  }
}
const alphabetByEncoding = {}, alphabetByValue = new Array(64);
for (let $ = 0, ee = 65, te = 90; $ + ee <= te; $++) {
  const ne = String.fromCharCode($ + ee);
  alphabetByEncoding[ne] = $, alphabetByValue[$] = ne;
}
for (let $ = 0, ee = 97, te = 122; $ + ee <= te; $++) {
  const ne = String.fromCharCode($ + ee), re = $ + 26;
  alphabetByEncoding[ne] = re, alphabetByValue[re] = ne;
}
for (let $ = 0; $ < 10; $++) {
  alphabetByEncoding[$.toString(10)] = $ + 52;
  const ee = $.toString(10), te = $ + 52;
  alphabetByEncoding[ee] = te, alphabetByValue[te] = ee;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
const bitsPerLetter = 6, bitsPerByte = 8, maxLetterValue = 63, fromBase64 = ($) => {
  let ee = $.length / 4 * 3;
  $.slice(-2) === "==" ? ee -= 2 : $.slice(-1) === "=" && ee--;
  const te = new ArrayBuffer(ee), ne = new DataView(te);
  for (let re = 0; re < $.length; re += 4) {
    let se = 0, ie = 0;
    for (let ue = re, de = re + 3; ue <= de; ue++)
      if ($[ue] !== "=") {
        if (!($[ue] in alphabetByEncoding))
          throw new TypeError(`Invalid character ${$[ue]} in base64 string.`);
        se |= alphabetByEncoding[$[ue]] << (de - ue) * bitsPerLetter, ie += bitsPerLetter;
      } else
        se >>= bitsPerLetter;
    const oe = re / 4 * 3;
    se >>= ie % bitsPerByte;
    const le = Math.floor(ie / bitsPerByte);
    for (let ue = 0; ue < le; ue++) {
      const de = (le - ue - 1) * bitsPerByte;
      ne.setUint8(oe + ue, (se & 255 << de) >> de);
    }
  }
  return new Uint8Array(te);
}, fromUtf8$3 = ($) => new TextEncoder().encode($), toUint8Array = ($) => typeof $ == "string" ? fromUtf8$3($) : ArrayBuffer.isView($) ? new Uint8Array($.buffer, $.byteOffset, $.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array($), toUtf8$3 = ($) => {
  if (typeof $ == "string")
    return $;
  if (typeof $ != "object" || typeof $.byteOffset != "number" || typeof $.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode($);
};
function toBase64($) {
  let ee;
  typeof $ == "string" ? ee = fromUtf8$3($) : ee = $;
  const te = typeof ee == "object" && typeof ee.length == "number", ne = typeof ee == "object" && typeof ee.byteOffset == "number" && typeof ee.byteLength == "number";
  if (!te && !ne)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let re = "";
  for (let se = 0; se < ee.length; se += 3) {
    let ie = 0, oe = 0;
    for (let ue = se, de = Math.min(se + 3, ee.length); ue < de; ue++)
      ie |= ee[ue] << (de - ue - 1) * bitsPerByte, oe += bitsPerByte;
    const le = Math.ceil(oe / bitsPerLetter);
    ie <<= le * bitsPerLetter - oe;
    for (let ue = 1; ue <= le; ue++) {
      const de = (le - ue) * bitsPerLetter;
      re += alphabetByValue[(ie & maxLetterValue << de) >> de];
    }
    re += "==".slice(0, 4 - le);
  }
  return re;
}
function transformToString($, ee = "utf-8") {
  return ee === "base64" ? toBase64($) : toUtf8$3($);
}
function transformFromString($, ee) {
  return ee === "base64" ? Uint8ArrayBlobAdapter.mutate(fromBase64($)) : Uint8ArrayBlobAdapter.mutate(fromUtf8$3($));
}
class Uint8ArrayBlobAdapter extends Uint8Array {
  static fromString(ee, te = "utf-8") {
    switch (typeof ee) {
      case "string":
        return transformFromString(ee, te);
      default:
        throw new Error(`Unsupported conversion from ${typeof ee} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(ee) {
    return Object.setPrototypeOf(ee, Uint8ArrayBlobAdapter.prototype), ee;
  }
  transformToString(ee = "utf-8") {
    return transformToString(this, ee);
  }
}
const getAwsChunkedEncodingStream = ($, ee) => {
  const { base64Encoder: te, bodyLengthChecker: ne, checksumAlgorithmFn: re, checksumLocationName: se, streamHasher: ie } = ee, oe = te !== void 0 && ne !== void 0 && re !== void 0 && se !== void 0 && ie !== void 0, le = oe ? ie(re, $) : void 0, ue = $.getReader();
  return new ReadableStream({
    async pull(de) {
      const { value: fe, done: pe } = await ue.read();
      if (pe) {
        if (de.enqueue(`0\r
`), oe) {
          const ye = te(await le);
          de.enqueue(`${se}:${ye}\r
`), de.enqueue(`\r
`);
        }
        de.close();
      } else
        de.enqueue(`${(ne(fe) || 0).toString(16)}\r
${fe}\r
`);
    }
  });
}, escapeUri = ($) => encodeURIComponent($).replace(/[!'()*]/g, hexEncode), hexEncode = ($) => `%${$.charCodeAt(0).toString(16).toUpperCase()}`;
function buildQueryString($) {
  const ee = [];
  for (let te of Object.keys($).sort()) {
    const ne = $[te];
    if (te = escapeUri(te), Array.isArray(ne))
      for (let re = 0, se = ne.length; re < se; re++)
        ee.push(`${te}=${escapeUri(ne[re])}`);
    else {
      let re = te;
      (ne || typeof ne == "string") && (re += `=${escapeUri(ne)}`), ee.push(re);
    }
  }
  return ee.join("&");
}
function requestTimeout($ = 0) {
  return new Promise((ee, te) => {
    $ && setTimeout(() => {
      const ne = new Error(`Request did not complete within ${$} ms`);
      ne.name = "TimeoutError", te(ne);
    }, $);
  });
}
const keepAliveSupport = {
  supported: typeof Request < "u" && "keepalive" in new Request("https://[::1]")
};
class FetchHttpHandler {
  static create(ee) {
    return typeof (ee == null ? void 0 : ee.handle) == "function" ? ee : new FetchHttpHandler(ee);
  }
  constructor(ee) {
    typeof ee == "function" ? this.configProvider = ee().then((te) => te || {}) : (this.config = ee ?? {}, this.configProvider = Promise.resolve(this.config));
  }
  destroy() {
  }
  async handle(ee, { abortSignal: te } = {}) {
    this.config || (this.config = await this.configProvider);
    const ne = this.config.requestTimeout, re = this.config.keepAlive === !0;
    if (te != null && te.aborted) {
      const ve = new Error("Request aborted");
      return ve.name = "AbortError", Promise.reject(ve);
    }
    let se = ee.path;
    const ie = buildQueryString(ee.query || {});
    ie && (se += `?${ie}`), ee.fragment && (se += `#${ee.fragment}`);
    let oe = "";
    if (ee.username != null || ee.password != null) {
      const ve = ee.username ?? "", ge = ee.password ?? "";
      oe = `${ve}:${ge}@`;
    }
    const { port: le, method: ue } = ee, de = `${ee.protocol}//${oe}${ee.hostname}${le ? `:${le}` : ""}${se}`, pe = { body: ue === "GET" || ue === "HEAD" ? void 0 : ee.body, headers: new Headers(ee.headers), method: ue };
    typeof AbortController < "u" && (pe.signal = te), keepAliveSupport.supported && (pe.keepalive = re);
    const ye = new Request(de, pe), me = [
      fetch(ye).then((ve) => {
        const ge = ve.headers, xe = {};
        for (const Te of ge.entries())
          xe[Te[0]] = Te[1];
        return ve.body != null ? {
          response: new HttpResponse({
            headers: xe,
            reason: ve.statusText,
            statusCode: ve.status,
            body: ve.body
          })
        } : ve.blob().then((Te) => ({
          response: new HttpResponse({
            headers: xe,
            reason: ve.statusText,
            statusCode: ve.status,
            body: Te
          })
        }));
      }),
      requestTimeout(ne)
    ];
    return te && me.push(new Promise((ve, ge) => {
      te.onabort = () => {
        const xe = new Error("Request aborted");
        xe.name = "AbortError", ge(xe);
      };
    })), Promise.race(me);
  }
  updateHttpClientConfig(ee, te) {
    this.config = void 0, this.configProvider = this.configProvider.then((ne) => (ne[ee] = te, ne));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const streamCollector = ($) => typeof Blob == "function" && $ instanceof Blob ? collectBlob($) : collectStream($);
async function collectBlob($) {
  const ee = await readToBase64($), te = fromBase64(ee);
  return new Uint8Array(te);
}
async function collectStream($) {
  let ee = new Uint8Array(0);
  const te = $.getReader();
  let ne = !1;
  for (; !ne; ) {
    const { done: re, value: se } = await te.read();
    if (se) {
      const ie = ee;
      ee = new Uint8Array(ie.length + se.length), ee.set(ie), ee.set(se, ie.length);
    }
    ne = re;
  }
  return ee;
}
function readToBase64($) {
  return new Promise((ee, te) => {
    const ne = new FileReader();
    ne.onloadend = () => {
      if (ne.readyState !== 2)
        return te(new Error("Reader aborted too early"));
      const re = ne.result ?? "", se = re.indexOf(","), ie = se > -1 ? se + 1 : re.length;
      ee(re.substring(ie));
    }, ne.onabort = () => te(new Error("Read aborted")), ne.onerror = () => te(ne.error), ne.readAsDataURL($);
  });
}
const SHORT_TO_HEX = {}, HEX_TO_SHORT = {};
for (let $ = 0; $ < 256; $++) {
  let ee = $.toString(16).toLowerCase();
  ee.length === 1 && (ee = `0${ee}`), SHORT_TO_HEX[$] = ee, HEX_TO_SHORT[ee] = $;
}
function fromHex($) {
  if ($.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const ee = new Uint8Array($.length / 2);
  for (let te = 0; te < $.length; te += 2) {
    const ne = $.slice(te, te + 2).toLowerCase();
    if (ne in HEX_TO_SHORT)
      ee[te / 2] = HEX_TO_SHORT[ne];
    else
      throw new Error(`Cannot decode unrecognized sequence ${ne} as hexadecimal`);
  }
  return ee;
}
function toHex($) {
  let ee = "";
  for (let te = 0; te < $.byteLength; te++)
    ee += SHORT_TO_HEX[$[te]];
  return ee;
}
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.", sdkStreamMixin = ($) => {
  var re, se;
  if (!isBlobInstance($) && !isReadableStreamInstance($)) {
    const ie = ((se = (re = $ == null ? void 0 : $.__proto__) == null ? void 0 : re.constructor) == null ? void 0 : se.name) || $;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${ie}`);
  }
  let ee = !1;
  const te = async () => {
    if (ee)
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    return ee = !0, await streamCollector($);
  }, ne = (ie) => {
    if (typeof ie.stream != "function")
      throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
    return ie.stream();
  };
  return Object.assign($, {
    transformToByteArray: te,
    transformToString: async (ie) => {
      const oe = await te();
      if (ie === "base64")
        return toBase64(oe);
      if (ie === "hex")
        return toHex(oe);
      if (ie === void 0 || ie === "utf8" || ie === "utf-8")
        return toUtf8$3(oe);
      if (typeof TextDecoder == "function")
        return new TextDecoder(ie).decode(oe);
      throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
    },
    transformToWebStream: () => {
      if (ee)
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      if (ee = !0, isBlobInstance($))
        return ne($);
      if (isReadableStreamInstance($))
        return $;
      throw new Error(`Cannot transform payload to web stream, got ${$}`);
    }
  });
}, isBlobInstance = ($) => typeof Blob == "function" && $ instanceof Blob, isReadableStreamInstance = ($) => typeof ReadableStream == "function" && $ instanceof ReadableStream, collectBody = async ($ = new Uint8Array(), ee) => {
  if ($ instanceof Uint8Array)
    return Uint8ArrayBlobAdapter.mutate($);
  if (!$)
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  const te = ee.streamCollector($);
  return Uint8ArrayBlobAdapter.mutate(await te);
};
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(ee, te, ne, { middlewareFn: re, clientName: se, commandName: ie, inputFilterSensitiveLog: oe, outputFilterSensitiveLog: le, smithyContext: ue, additionalContext: de, CommandCtor: fe }) {
    for (const ge of re.bind(this)(fe, ee, te, ne))
      this.middlewareStack.use(ge);
    const pe = ee.concat(this.middlewareStack), { logger: ye } = te, me = {
      logger: ye,
      clientName: se,
      commandName: ie,
      inputFilterSensitiveLog: oe,
      outputFilterSensitiveLog: le,
      [SMITHY_CONTEXT_KEY]: {
        ...ue
      },
      ...de
    }, { requestHandler: ve } = te;
    return pe.resolve((ge) => ve.handle(ge.request, ne || {}), me);
  }
}
class ClassBuilder {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (ee) => ee, this._outputFilterSensitiveLog = (ee) => ee, this._serializer = null, this._deserializer = null;
  }
  init(ee) {
    this._init = ee;
  }
  ep(ee) {
    return this._ep = ee, this;
  }
  m(ee) {
    return this._middlewareFn = ee, this;
  }
  s(ee, te, ne = {}) {
    return this._smithyContext = {
      service: ee,
      operation: te,
      ...ne
    }, this;
  }
  c(ee = {}) {
    return this._additionalContext = ee, this;
  }
  n(ee, te) {
    return this._clientName = ee, this._commandName = te, this;
  }
  f(ee = (ne) => ne, te = (ne) => ne) {
    return this._inputFilterSensitiveLog = ee, this._outputFilterSensitiveLog = te, this;
  }
  ser(ee) {
    return this._serializer = ee, this;
  }
  de(ee) {
    return this._deserializer = ee, this;
  }
  build() {
    const ee = this;
    let te;
    return te = class extends Command {
      static getEndpointParameterInstructions() {
        return ee._ep;
      }
      constructor(...[ne]) {
        super(), this.serialize = ee._serializer, this.deserialize = ee._deserializer, this.input = ne ?? {}, ee._init(this);
      }
      resolveMiddleware(ne, re, se) {
        return this.resolveMiddlewareWithContext(ne, re, se, {
          CommandCtor: te,
          middlewareFn: ee._middlewareFn,
          clientName: ee._clientName,
          commandName: ee._commandName,
          inputFilterSensitiveLog: ee._inputFilterSensitiveLog,
          outputFilterSensitiveLog: ee._outputFilterSensitiveLog,
          smithyContext: ee._smithyContext,
          additionalContext: ee._additionalContext
        });
      }
    };
  }
}
const SENSITIVE_STRING = "***SensitiveInformation***", parseBoolean = ($) => {
  switch ($) {
    case "true":
      return !0;
    case "false":
      return !1;
    default:
      throw new Error(`Unable to parse boolean value "${$}"`);
  }
}, expectNumber = ($) => {
  if ($ != null) {
    if (typeof $ == "string") {
      const ee = parseFloat($);
      if (!Number.isNaN(ee))
        return String(ee) !== String($) && logger.warn(stackTraceWarning(`Expected number but observed string: ${$}`)), ee;
    }
    if (typeof $ == "number")
      return $;
    throw new TypeError(`Expected number, got ${typeof $}: ${$}`);
  }
}, MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23)), expectFloat32 = ($) => {
  const ee = expectNumber($);
  if (ee !== void 0 && !Number.isNaN(ee) && ee !== 1 / 0 && ee !== -1 / 0 && Math.abs(ee) > MAX_FLOAT)
    throw new TypeError(`Expected 32-bit float, got ${$}`);
  return ee;
}, expectLong = ($) => {
  if ($ != null) {
    if (Number.isInteger($) && !Number.isNaN($))
      return $;
    throw new TypeError(`Expected integer, got ${typeof $}: ${$}`);
  }
}, expectShort = ($) => expectSizedInt($, 16), expectByte = ($) => expectSizedInt($, 8), expectSizedInt = ($, ee) => {
  const te = expectLong($);
  if (te !== void 0 && castInt(te, ee) !== te)
    throw new TypeError(`Expected ${ee}-bit integer, got ${$}`);
  return te;
}, castInt = ($, ee) => {
  switch (ee) {
    case 32:
      return Int32Array.of($)[0];
    case 16:
      return Int16Array.of($)[0];
    case 8:
      return Int8Array.of($)[0];
  }
}, expectNonNull = ($, ee) => {
  if ($ == null)
    throw ee ? new TypeError(`Expected a non-null value for ${ee}`) : new TypeError("Expected a non-null value");
  return $;
}, expectObject = ($) => {
  if ($ == null)
    return;
  if (typeof $ == "object" && !Array.isArray($))
    return $;
  const ee = Array.isArray($) ? "array" : typeof $;
  throw new TypeError(`Expected object, got ${ee}: ${$}`);
}, expectString = ($) => {
  if ($ != null) {
    if (typeof $ == "string")
      return $;
    if (["boolean", "number", "bigint"].includes(typeof $))
      return logger.warn(stackTraceWarning(`Expected string, got ${typeof $}: ${$}`)), String($);
    throw new TypeError(`Expected string, got ${typeof $}: ${$}`);
  }
}, strictParseDouble = ($) => expectNumber(typeof $ == "string" ? parseNumber($) : $), strictParseFloat32 = ($) => expectFloat32(typeof $ == "string" ? parseNumber($) : $), NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g, parseNumber = ($) => {
  const ee = $.match(NUMBER_REGEX);
  if (ee === null || ee[0].length !== $.length)
    throw new TypeError("Expected real number, got implicit NaN");
  return parseFloat($);
}, strictParseShort = ($) => expectShort(typeof $ == "string" ? parseNumber($) : $), strictParseByte = ($) => expectByte(typeof $ == "string" ? parseNumber($) : $), stackTraceWarning = ($) => String(new TypeError($).stack || $).split(`
`).slice(0, 5).filter((ee) => !ee.includes("stackTraceWarning")).join(`
`), logger = {
  warn: console.warn
}, DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString($) {
  const ee = $.getUTCFullYear(), te = $.getUTCMonth(), ne = $.getUTCDay(), re = $.getUTCDate(), se = $.getUTCHours(), ie = $.getUTCMinutes(), oe = $.getUTCSeconds(), le = re < 10 ? `0${re}` : `${re}`, ue = se < 10 ? `0${se}` : `${se}`, de = ie < 10 ? `0${ie}` : `${ie}`, fe = oe < 10 ? `0${oe}` : `${oe}`;
  return `${DAYS[ne]}, ${le} ${MONTHS[te]} ${ee} ${ue}:${de}:${fe} GMT`;
}
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/), parseRfc3339DateTimeWithOffset = ($) => {
  if ($ == null)
    return;
  if (typeof $ != "string")
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  const ee = RFC3339_WITH_OFFSET.exec($);
  if (!ee)
    throw new TypeError("Invalid RFC-3339 date-time value");
  const [te, ne, re, se, ie, oe, le, ue, de] = ee, fe = strictParseShort(stripLeadingZeroes(ne)), pe = parseDateValue(re, "month", 1, 12), ye = parseDateValue(se, "day", 1, 31), me = buildDate(fe, pe, ye, { hours: ie, minutes: oe, seconds: le, fractionalMilliseconds: ue });
  return de.toUpperCase() != "Z" && me.setTime(me.getTime() - parseOffsetToMilliseconds(de)), me;
}, parseEpochTimestamp = ($) => {
  if ($ == null)
    return;
  let ee;
  if (typeof $ == "number")
    ee = $;
  else if (typeof $ == "string")
    ee = strictParseDouble($);
  else
    throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
  if (Number.isNaN(ee) || ee === 1 / 0 || ee === -1 / 0)
    throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
  return new Date(Math.round(ee * 1e3));
}, buildDate = ($, ee, te, ne) => {
  const re = ee - 1;
  return validateDayOfMonth($, re, te), new Date(Date.UTC($, re, te, parseDateValue(ne.hours, "hour", 0, 23), parseDateValue(ne.minutes, "minute", 0, 59), parseDateValue(ne.seconds, "seconds", 0, 60), parseMilliseconds(ne.fractionalMilliseconds)));
}, DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], validateDayOfMonth = ($, ee, te) => {
  let ne = DAYS_IN_MONTH[ee];
  if (ee === 1 && isLeapYear($) && (ne = 29), te > ne)
    throw new TypeError(`Invalid day for ${MONTHS[ee]} in ${$}: ${te}`);
}, isLeapYear = ($) => $ % 4 === 0 && ($ % 100 !== 0 || $ % 400 === 0), parseDateValue = ($, ee, te, ne) => {
  const re = strictParseByte(stripLeadingZeroes($));
  if (re < te || re > ne)
    throw new TypeError(`${ee} must be between ${te} and ${ne}, inclusive`);
  return re;
}, parseMilliseconds = ($) => $ == null ? 0 : strictParseFloat32("0." + $) * 1e3, parseOffsetToMilliseconds = ($) => {
  const ee = $[0];
  let te = 1;
  if (ee == "+")
    te = 1;
  else if (ee == "-")
    te = -1;
  else
    throw new TypeError(`Offset direction, ${ee}, must be "+" or "-"`);
  const ne = Number($.substring(1, 3)), re = Number($.substring(4, 6));
  return te * (ne * 60 + re) * 60 * 1e3;
}, stripLeadingZeroes = ($) => {
  let ee = 0;
  for (; ee < $.length - 1 && $.charAt(ee) === "0"; )
    ee++;
  return ee === 0 ? $ : $.slice(ee);
};
class ServiceException extends Error {
  constructor(ee) {
    super(ee.message), Object.setPrototypeOf(this, ServiceException.prototype), this.name = ee.name, this.$fault = ee.$fault, this.$metadata = ee.$metadata;
  }
}
const decorateServiceException = ($, ee = {}) => {
  Object.entries(ee).filter(([, ne]) => ne !== void 0).forEach(([ne, re]) => {
    ($[ne] == null || $[ne] === "") && ($[ne] = re);
  });
  const te = $.message || $.Message || "UnknownError";
  return $.message = te, delete $.Message, $;
}, throwDefaultError$1 = ({ output: $, parsedBody: ee, exceptionCtor: te, errorCode: ne }) => {
  const re = deserializeMetadata$1($), se = re.httpStatusCode ? re.httpStatusCode + "" : void 0, ie = new te({
    name: (ee == null ? void 0 : ee.code) || (ee == null ? void 0 : ee.Code) || ne || se || "UnknownError",
    $fault: "client",
    $metadata: re
  });
  throw decorateServiceException(ie, ee);
}, withBaseException = ($) => ({ output: ee, parsedBody: te, errorCode: ne }) => {
  throwDefaultError$1({ output: ee, parsedBody: te, exceptionCtor: $, errorCode: ne });
}, deserializeMetadata$1 = ($) => ({
  httpStatusCode: $.statusCode,
  requestId: $.headers["x-amzn-requestid"] ?? $.headers["x-amzn-request-id"] ?? $.headers["x-amz-request-id"],
  extendedRequestId: $.headers["x-amz-id-2"],
  cfId: $.headers["x-amz-cf-id"]
}), loadConfigsForDefaultMode = ($) => {
  switch ($) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, getChecksumConfiguration = ($) => {
  const ee = [];
  for (const te in AlgorithmId) {
    const ne = AlgorithmId[te];
    $[ne] !== void 0 && ee.push({
      algorithmId: () => ne,
      checksumConstructor: () => $[ne]
    });
  }
  return {
    _checksumAlgorithms: ee,
    addChecksumAlgorithm(te) {
      this._checksumAlgorithms.push(te);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, resolveChecksumRuntimeConfig = ($) => {
  const ee = {};
  return $.checksumAlgorithms().forEach((te) => {
    ee[te.algorithmId()] = te.checksumConstructor();
  }), ee;
}, getRetryConfiguration = ($) => {
  let ee = $.retryStrategy;
  return {
    setRetryStrategy(te) {
      ee = te;
    },
    retryStrategy() {
      return ee;
    }
  };
}, resolveRetryRuntimeConfig = ($) => {
  const ee = {};
  return ee.retryStrategy = $.retryStrategy(), ee;
}, getDefaultExtensionConfiguration = ($) => ({
  ...getChecksumConfiguration($),
  ...getRetryConfiguration($)
}), resolveDefaultRuntimeConfig = ($) => ({
  ...resolveChecksumRuntimeConfig($),
  ...resolveRetryRuntimeConfig($)
});
function extendedEncodeURIComponent($) {
  return encodeURIComponent($).replace(/[!'()*]/g, function(ee) {
    return "%" + ee.charCodeAt(0).toString(16).toUpperCase();
  });
}
const getValueFromTextNode = ($) => {
  const ee = "#text";
  for (const te in $)
    $.hasOwnProperty(te) && $[te][ee] !== void 0 ? $[te] = $[te][ee] : typeof $[te] == "object" && $[te] !== null && ($[te] = getValueFromTextNode($[te]));
  return $;
}, StringWrapper = function() {
  const $ = Object.getPrototypeOf(this).constructor, ee = Function.bind.apply(String, [null, ...arguments]), te = new ee();
  return Object.setPrototypeOf(te, $.prototype), te;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: !1,
    writable: !0,
    configurable: !0
  }
});
Object.setPrototypeOf(StringWrapper, String);
function map($, ee, te) {
  let ne, re, se;
  if (typeof ee > "u" && typeof te > "u")
    ne = {}, se = $;
  else {
    if (ne = $, typeof ee == "function")
      return re = ee, se = te, mapWithFilter(ne, re, se);
    se = ee;
  }
  for (const ie of Object.keys(se)) {
    if (!Array.isArray(se[ie])) {
      ne[ie] = se[ie];
      continue;
    }
    applyInstruction(ne, null, se, ie);
  }
  return ne;
}
const take = ($, ee) => {
  const te = {};
  for (const ne in ee)
    applyInstruction(te, $, ee, ne);
  return te;
}, mapWithFilter = ($, ee, te) => map($, Object.entries(te).reduce((ne, [re, se]) => (Array.isArray(se) ? ne[re] = se : typeof se == "function" ? ne[re] = [ee, se()] : ne[re] = [ee, se], ne), {})), applyInstruction = ($, ee, te, ne) => {
  if (ee !== null) {
    let ie = te[ne];
    typeof ie == "function" && (ie = [, ie]);
    const [oe = nonNullish, le = pass, ue = ne] = ie;
    (typeof oe == "function" && oe(ee[ue]) || typeof oe != "function" && oe) && ($[ne] = le(ee[ue]));
    return;
  }
  let [re, se] = te[ne];
  if (typeof se == "function") {
    let ie;
    const oe = re === void 0 && (ie = se()) != null, le = typeof re == "function" && !!re(void 0) || typeof re != "function" && !!re;
    oe ? $[ne] = ie : le && ($[ne] = se());
  } else {
    const ie = re === void 0 && se != null, oe = typeof re == "function" && !!re(se) || typeof re != "function" && !!re;
    (ie || oe) && ($[ne] = se);
  }
}, nonNullish = ($) => $ != null, pass = ($) => $, resolvedPath = ($, ee, te, ne, re, se) => {
  if (ee != null && ee[te] !== void 0) {
    const ie = ne();
    if (ie.length <= 0)
      throw new Error("Empty value provided for input HTTP label: " + te + ".");
    $ = $.replace(re, se ? ie.split("/").map((oe) => extendedEncodeURIComponent(oe)).join("/") : extendedEncodeURIComponent(ie));
  } else
    throw new Error("No value provided for input HTTP label: " + te + ".");
  return $;
}, CONTENT_LENGTH_HEADER$1 = "content-length";
function checkContentLengthHeader() {
  return ($, ee) => async (te) => {
    var re;
    const { request: ne } = te;
    if (HttpRequest.isInstance(ne) && !(CONTENT_LENGTH_HEADER$1 in ne.headers)) {
      const se = "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
      typeof ((re = ee == null ? void 0 : ee.logger) == null ? void 0 : re.warn) == "function" && !(ee.logger instanceof NoOpLogger) ? ee.logger.warn(se) : console.warn(se);
    }
    return $({ ...te });
  };
}
const checkContentLengthHeaderMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: !0
}, getCheckContentLengthHeaderPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
  }
}), regionRedirectEndpointMiddleware = ($) => (ee, te) => async (ne) => {
  const re = await $.region(), se = $.region;
  te.__s3RegionRedirect && ($.region = async () => ($.region = se, te.__s3RegionRedirect));
  const ie = await ee(ne);
  if (te.__s3RegionRedirect) {
    const oe = await $.region();
    if (re !== oe)
      throw new Error("Region was not restored following S3 region redirect.");
  }
  return ie;
}, regionRedirectEndpointMiddlewareOptions = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: !0,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};
function regionRedirectMiddleware($) {
  return (ee, te) => async (ne) => {
    var re, se;
    try {
      return await ee(ne);
    } catch (ie) {
      if ($.followRegionRedirects && ((re = ie == null ? void 0 : ie.$metadata) == null ? void 0 : re.httpStatusCode) === 301) {
        try {
          const oe = ie.$response.headers["x-amz-bucket-region"];
          (se = te.logger) == null || se.debug(`Redirecting from ${await $.region()} to ${oe}`), te.__s3RegionRedirect = oe;
        } catch (oe) {
          throw new Error("Region redirect failed: " + oe);
        }
        return ee(ne);
      } else
        throw ie;
    }
  };
}
const regionRedirectMiddlewareOptions = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: !0
}, getRegionRedirectMiddlewarePlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(regionRedirectMiddleware($), regionRedirectMiddlewareOptions), ee.addRelativeTo(regionRedirectEndpointMiddleware($), regionRedirectEndpointMiddlewareOptions);
  }
});
class S3ExpressIdentityCache {
  constructor(ee = {}) {
    this.data = ee, this.lastPurgeTime = Date.now();
  }
  get(ee) {
    const te = this.data[ee];
    if (te)
      return te;
  }
  set(ee, te) {
    return this.data[ee] = te, te;
  }
  delete(ee) {
    delete this.data[ee];
  }
  async purgeExpired() {
    const ee = Date.now();
    if (!(this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > ee))
      for (const te in this.data) {
        const ne = this.data[te];
        if (!ne.isRefreshing) {
          const re = await ne.identity;
          re.expiration && re.expiration.getTime() < ee && delete this.data[te];
        }
      }
  }
}
S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
class S3ExpressIdentityCacheEntry {
  constructor(ee, te = !1, ne = Date.now()) {
    this._identity = ee, this.isRefreshing = te, this.accessed = ne;
  }
  get identity() {
    return this.accessed = Date.now(), this._identity;
  }
}
class S3ExpressIdentityProviderImpl {
  constructor(ee, te = new S3ExpressIdentityCache()) {
    this.createSessionFn = ee, this.cache = te;
  }
  async getS3ExpressIdentity(ee, te) {
    const ne = te.Bucket, { cache: re } = this, se = re.get(ne);
    return se ? se.identity.then((ie) => {
      var ue, de;
      return (((ue = ie.expiration) == null ? void 0 : ue.getTime()) ?? 0) < Date.now() ? re.set(ne, new S3ExpressIdentityCacheEntry(this.getIdentity(ne))).identity : ((((de = ie.expiration) == null ? void 0 : de.getTime()) ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS && !se.isRefreshing && (se.isRefreshing = !0, this.getIdentity(ne).then((fe) => {
        re.set(ne, new S3ExpressIdentityCacheEntry(Promise.resolve(fe)));
      })), ie);
    }) : re.set(ne, new S3ExpressIdentityCacheEntry(this.getIdentity(ne))).identity;
  }
  async getIdentity(ee) {
    var re, se;
    await this.cache.purgeExpired().catch((ie) => {
      console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
` + ie);
    });
    const te = await this.createSessionFn(ee);
    if (!((re = te.Credentials) != null && re.AccessKeyId) || !((se = te.Credentials) != null && se.SecretAccessKey))
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    return {
      accessKeyId: te.Credentials.AccessKeyId,
      secretAccessKey: te.Credentials.SecretAccessKey,
      sessionToken: te.Credentials.SessionToken,
      expiration: te.Credentials.Expiration ? new Date(te.Credentials.Expiration) : void 0
    };
  }
}
S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;
const getSmithyContext = ($) => $[SMITHY_CONTEXT_KEY] || ($[SMITHY_CONTEXT_KEY] = {}), normalizeProvider = ($) => {
  if (typeof $ == "function")
    return $;
  const ee = Promise.resolve($);
  return () => ee;
}, ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm", CREDENTIAL_QUERY_PARAM = "X-Amz-Credential", AMZ_DATE_QUERY_PARAM = "X-Amz-Date", SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders", EXPIRES_QUERY_PARAM = "X-Amz-Expires", SIGNATURE_QUERY_PARAM = "X-Amz-Signature", TOKEN_QUERY_PARAM = "X-Amz-Security-Token", AUTH_HEADER = "authorization", AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase(), DATE_HEADER = "date", GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER], SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase(), SHA256_HEADER = "x-amz-content-sha256", TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase(), ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: !0,
  "cache-control": !0,
  connection: !0,
  expect: !0,
  from: !0,
  "keep-alive": !0,
  "max-forwards": !0,
  pragma: !0,
  referer: !0,
  te: !0,
  trailer: !0,
  "transfer-encoding": !0,
  upgrade: !0,
  "user-agent": !0,
  "x-amzn-trace-id": !0
}, PROXY_HEADER_PATTERN = /^proxy-/, SEC_HEADER_PATTERN = /^sec-/, ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256", EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD", UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD", MAX_CACHE_SIZE = 50, KEY_TYPE_IDENTIFIER = "aws4_request", MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7, signingKeyCache = {}, cacheQueue = [], createScope = ($, ee, te) => `${$}/${ee}/${te}/${KEY_TYPE_IDENTIFIER}`, getSigningKey = async ($, ee, te, ne, re) => {
  const se = await hmac($, ee.secretAccessKey, ee.accessKeyId), ie = `${te}:${ne}:${re}:${toHex(se)}:${ee.sessionToken}`;
  if (ie in signingKeyCache)
    return signingKeyCache[ie];
  for (cacheQueue.push(ie); cacheQueue.length > MAX_CACHE_SIZE; )
    delete signingKeyCache[cacheQueue.shift()];
  let oe = `AWS4${ee.secretAccessKey}`;
  for (const le of [te, ne, re, KEY_TYPE_IDENTIFIER])
    oe = await hmac($, oe, le);
  return signingKeyCache[ie] = oe;
}, hmac = ($, ee, te) => {
  const ne = new $(ee);
  return ne.update(toUint8Array(te)), ne.digest();
}, getCanonicalHeaders = ({ headers: $ }, ee, te) => {
  const ne = {};
  for (const re of Object.keys($).sort()) {
    if ($[re] == null)
      continue;
    const se = re.toLowerCase();
    (se in ALWAYS_UNSIGNABLE_HEADERS || ee != null && ee.has(se) || PROXY_HEADER_PATTERN.test(se) || SEC_HEADER_PATTERN.test(se)) && (!te || te && !te.has(se)) || (ne[se] = $[re].trim().replace(/\s+/g, " "));
  }
  return ne;
}, getCanonicalQuery = ({ query: $ = {} }) => {
  const ee = [], te = {};
  for (const ne of Object.keys($).sort()) {
    if (ne.toLowerCase() === SIGNATURE_HEADER)
      continue;
    ee.push(ne);
    const re = $[ne];
    typeof re == "string" ? te[ne] = `${escapeUri(ne)}=${escapeUri(re)}` : Array.isArray(re) && (te[ne] = re.slice(0).reduce((se, ie) => se.concat([`${escapeUri(ne)}=${escapeUri(ie)}`]), []).sort().join("&"));
  }
  return ee.map((ne) => te[ne]).filter((ne) => ne).join("&");
}, isArrayBuffer = ($) => typeof ArrayBuffer == "function" && $ instanceof ArrayBuffer || Object.prototype.toString.call($) === "[object ArrayBuffer]", getPayloadHash = async ({ headers: $, body: ee }, te) => {
  for (const ne of Object.keys($))
    if (ne.toLowerCase() === SHA256_HEADER)
      return $[ne];
  if (ee == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof ee == "string" || ArrayBuffer.isView(ee) || isArrayBuffer(ee)) {
    const ne = new te();
    return ne.update(toUint8Array(ee)), toHex(await ne.digest());
  }
  return UNSIGNED_PAYLOAD;
};
class HeaderFormatter {
  format(ee) {
    const te = [];
    for (const se of Object.keys(ee)) {
      const ie = fromUtf8$3(se);
      te.push(Uint8Array.from([ie.byteLength]), ie, this.formatHeaderValue(ee[se]));
    }
    const ne = new Uint8Array(te.reduce((se, ie) => se + ie.byteLength, 0));
    let re = 0;
    for (const se of te)
      ne.set(se, re), re += se.byteLength;
    return ne;
  }
  formatHeaderValue(ee) {
    switch (ee.type) {
      case "boolean":
        return Uint8Array.from([ee.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, ee.value]);
      case "short":
        const te = new DataView(new ArrayBuffer(3));
        return te.setUint8(0, 3), te.setInt16(1, ee.value, !1), new Uint8Array(te.buffer);
      case "integer":
        const ne = new DataView(new ArrayBuffer(5));
        return ne.setUint8(0, 4), ne.setInt32(1, ee.value, !1), new Uint8Array(ne.buffer);
      case "long":
        const re = new Uint8Array(9);
        return re[0] = 5, re.set(ee.value.bytes, 1), re;
      case "binary":
        const se = new DataView(new ArrayBuffer(3 + ee.value.byteLength));
        se.setUint8(0, 6), se.setUint16(1, ee.value.byteLength, !1);
        const ie = new Uint8Array(se.buffer);
        return ie.set(ee.value, 3), ie;
      case "string":
        const oe = fromUtf8$3(ee.value), le = new DataView(new ArrayBuffer(3 + oe.byteLength));
        le.setUint8(0, 7), le.setUint16(1, oe.byteLength, !1);
        const ue = new Uint8Array(le.buffer);
        return ue.set(oe, 3), ue;
      case "timestamp":
        const de = new Uint8Array(9);
        return de[0] = 8, de.set(Int64$1.fromNumber(ee.value.valueOf()).bytes, 1), de;
      case "uuid":
        if (!UUID_PATTERN$1.test(ee.value))
          throw new Error(`Invalid UUID received: ${ee.value}`);
        const fe = new Uint8Array(17);
        return fe[0] = 9, fe.set(fromHex(ee.value.replace(/\-/g, "")), 1), fe;
    }
  }
}
var HEADER_VALUE_TYPE$1;
(function($) {
  $[$.boolTrue = 0] = "boolTrue", $[$.boolFalse = 1] = "boolFalse", $[$.byte = 2] = "byte", $[$.short = 3] = "short", $[$.integer = 4] = "integer", $[$.long = 5] = "long", $[$.byteArray = 6] = "byteArray", $[$.string = 7] = "string", $[$.timestamp = 8] = "timestamp", $[$.uuid = 9] = "uuid";
})(HEADER_VALUE_TYPE$1 || (HEADER_VALUE_TYPE$1 = {}));
const UUID_PATTERN$1 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
let Int64$1 = class Bs {
  constructor(ee) {
    if (this.bytes = ee, ee.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(ee) {
    if (ee > 9223372036854776e3 || ee < -9223372036854776e3)
      throw new Error(`${ee} is too large (or, if negative, too small) to represent as an Int64`);
    const te = new Uint8Array(8);
    for (let ne = 7, re = Math.abs(Math.round(ee)); ne > -1 && re > 0; ne--, re /= 256)
      te[ne] = re;
    return ee < 0 && negate$1(te), new Bs(te);
  }
  valueOf() {
    const ee = this.bytes.slice(0), te = ee[0] & 128;
    return te && negate$1(ee), parseInt(toHex(ee), 16) * (te ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate$1($) {
  for (let ee = 0; ee < 8; ee++)
    $[ee] ^= 255;
  for (let ee = 7; ee > -1 && ($[ee]++, $[ee] === 0); ee--)
    ;
}
const hasHeader$1 = ($, ee) => {
  $ = $.toLowerCase();
  for (const te of Object.keys(ee))
    if ($ === te.toLowerCase())
      return !0;
  return !1;
}, cloneRequest = ({ headers: $, query: ee, ...te }) => ({
  ...te,
  headers: { ...$ },
  query: ee ? cloneQuery(ee) : void 0
}), cloneQuery = ($) => Object.keys($).reduce((ee, te) => {
  const ne = $[te];
  return {
    ...ee,
    [te]: Array.isArray(ne) ? [...ne] : ne
  };
}, {}), moveHeadersToQuery = ($, ee = {}) => {
  var re;
  const { headers: te, query: ne = {} } = typeof $.clone == "function" ? $.clone() : cloneRequest($);
  for (const se of Object.keys(te)) {
    const ie = se.toLowerCase();
    ie.slice(0, 6) === "x-amz-" && !((re = ee.unhoistableHeaders) != null && re.has(ie)) && (ne[se] = te[se], delete te[se]);
  }
  return {
    ...$,
    headers: te,
    query: ne
  };
}, prepareRequest = ($) => {
  $ = typeof $.clone == "function" ? $.clone() : cloneRequest($);
  for (const ee of Object.keys($.headers))
    GENERATED_HEADERS.indexOf(ee.toLowerCase()) > -1 && delete $.headers[ee];
  return $;
}, iso8601 = ($) => toDate($).toISOString().replace(/\.\d{3}Z$/, "Z"), toDate = ($) => typeof $ == "number" ? new Date($ * 1e3) : typeof $ == "string" ? Number($) ? new Date(Number($) * 1e3) : new Date($) : $;
class SignatureV4 {
  constructor({ applyChecksum: ee, credentials: te, region: ne, service: re, sha256: se, uriEscapePath: ie = !0 }) {
    this.headerFormatter = new HeaderFormatter(), this.service = re, this.sha256 = se, this.uriEscapePath = ie, this.applyChecksum = typeof ee == "boolean" ? ee : !0, this.regionProvider = normalizeProvider(ne), this.credentialProvider = normalizeProvider(te);
  }
  async presign(ee, te = {}) {
    const { signingDate: ne = /* @__PURE__ */ new Date(), expiresIn: re = 3600, unsignableHeaders: se, unhoistableHeaders: ie, signableHeaders: oe, signingRegion: le, signingService: ue } = te, de = await this.credentialProvider();
    this.validateResolvedCredentials(de);
    const fe = le ?? await this.regionProvider(), { longDate: pe, shortDate: ye } = formatDate(ne);
    if (re > MAX_PRESIGNED_TTL)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const me = createScope(ye, fe, ue ?? this.service), ve = moveHeadersToQuery(prepareRequest(ee), { unhoistableHeaders: ie });
    de.sessionToken && (ve.query[TOKEN_QUERY_PARAM] = de.sessionToken), ve.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER, ve.query[CREDENTIAL_QUERY_PARAM] = `${de.accessKeyId}/${me}`, ve.query[AMZ_DATE_QUERY_PARAM] = pe, ve.query[EXPIRES_QUERY_PARAM] = re.toString(10);
    const ge = getCanonicalHeaders(ve, se, oe);
    return ve.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(ge), ve.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(pe, me, this.getSigningKey(de, fe, ye, ue), this.createCanonicalRequest(ve, ge, await getPayloadHash(ee, this.sha256))), ve;
  }
  async sign(ee, te) {
    return typeof ee == "string" ? this.signString(ee, te) : ee.headers && ee.payload ? this.signEvent(ee, te) : ee.message ? this.signMessage(ee, te) : this.signRequest(ee, te);
  }
  async signEvent({ headers: ee, payload: te }, { signingDate: ne = /* @__PURE__ */ new Date(), priorSignature: re, signingRegion: se, signingService: ie }) {
    const oe = se ?? await this.regionProvider(), { shortDate: le, longDate: ue } = formatDate(ne), de = createScope(le, oe, ie ?? this.service), fe = await getPayloadHash({ headers: {}, body: te }, this.sha256), pe = new this.sha256();
    pe.update(ee);
    const ye = toHex(await pe.digest()), me = [
      EVENT_ALGORITHM_IDENTIFIER,
      ue,
      de,
      re,
      ye,
      fe
    ].join(`
`);
    return this.signString(me, { signingDate: ne, signingRegion: oe, signingService: ie });
  }
  async signMessage(ee, { signingDate: te = /* @__PURE__ */ new Date(), signingRegion: ne, signingService: re }) {
    return this.signEvent({
      headers: this.headerFormatter.format(ee.message.headers),
      payload: ee.message.body
    }, {
      signingDate: te,
      signingRegion: ne,
      signingService: re,
      priorSignature: ee.priorSignature
    }).then((ie) => ({ message: ee.message, signature: ie }));
  }
  async signString(ee, { signingDate: te = /* @__PURE__ */ new Date(), signingRegion: ne, signingService: re } = {}) {
    const se = await this.credentialProvider();
    this.validateResolvedCredentials(se);
    const ie = ne ?? await this.regionProvider(), { shortDate: oe } = formatDate(te), le = new this.sha256(await this.getSigningKey(se, ie, oe, re));
    return le.update(toUint8Array(ee)), toHex(await le.digest());
  }
  async signRequest(ee, { signingDate: te = /* @__PURE__ */ new Date(), signableHeaders: ne, unsignableHeaders: re, signingRegion: se, signingService: ie } = {}) {
    const oe = await this.credentialProvider();
    this.validateResolvedCredentials(oe);
    const le = se ?? await this.regionProvider(), ue = prepareRequest(ee), { longDate: de, shortDate: fe } = formatDate(te), pe = createScope(fe, le, ie ?? this.service);
    ue.headers[AMZ_DATE_HEADER] = de, oe.sessionToken && (ue.headers[TOKEN_HEADER] = oe.sessionToken);
    const ye = await getPayloadHash(ue, this.sha256);
    !hasHeader$1(SHA256_HEADER, ue.headers) && this.applyChecksum && (ue.headers[SHA256_HEADER] = ye);
    const me = getCanonicalHeaders(ue, re, ne), ve = await this.getSignature(de, pe, this.getSigningKey(oe, le, fe, ie), this.createCanonicalRequest(ue, me, ye));
    return ue.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${oe.accessKeyId}/${pe}, SignedHeaders=${getCanonicalHeaderList(me)}, Signature=${ve}`, ue;
  }
  createCanonicalRequest(ee, te, ne) {
    const re = Object.keys(te).sort();
    return `${ee.method}
${this.getCanonicalPath(ee)}
${getCanonicalQuery(ee)}
${re.map((se) => `${se}:${te[se]}`).join(`
`)}

${re.join(";")}
${ne}`;
  }
  async createStringToSign(ee, te, ne) {
    const re = new this.sha256();
    re.update(toUint8Array(ne));
    const se = await re.digest();
    return `${ALGORITHM_IDENTIFIER}
${ee}
${te}
${toHex(se)}`;
  }
  getCanonicalPath({ path: ee }) {
    if (this.uriEscapePath) {
      const te = [];
      for (const se of ee.split("/"))
        (se == null ? void 0 : se.length) !== 0 && se !== "." && (se === ".." ? te.pop() : te.push(se));
      const ne = `${ee != null && ee.startsWith("/") ? "/" : ""}${te.join("/")}${te.length > 0 && (ee != null && ee.endsWith("/")) ? "/" : ""}`;
      return escapeUri(ne).replace(/%2F/g, "/");
    }
    return ee;
  }
  async getSignature(ee, te, ne, re) {
    const se = await this.createStringToSign(ee, te, re), ie = new this.sha256(await ne);
    return ie.update(toUint8Array(se)), toHex(await ie.digest());
  }
  getSigningKey(ee, te, ne, re) {
    return getSigningKey(this.sha256, ee, ne, te, re || this.service);
  }
  validateResolvedCredentials(ee) {
    if (typeof ee != "object" || typeof ee.accessKeyId != "string" || typeof ee.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
}
const formatDate = ($) => {
  const ee = iso8601($).replace(/[\-:]/g, "");
  return {
    longDate: ee,
    shortDate: ee.slice(0, 8)
  };
}, getCanonicalHeaderList = ($) => Object.keys($).sort().join(";");
var SelectorType;
(function($) {
  $.ENV = "env", $.CONFIG = "shared config entry";
})(SelectorType || (SelectorType = {}));
const S3_EXPRESS_BUCKET_TYPE = "Directory", S3_EXPRESS_BACKEND = "S3Express", S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express", SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token", SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
class SignatureV4S3Express extends SignatureV4 {
  async signWithCredentials(ee, te, ne) {
    const re = getCredentialsWithoutSessionToken(te);
    ee.headers[SESSION_TOKEN_HEADER] = te.sessionToken;
    const se = this;
    return setSingleOverride(se, re), se.signRequest(ee, ne ?? {});
  }
  async presignWithCredentials(ee, te, ne) {
    const re = getCredentialsWithoutSessionToken(te);
    return delete ee.headers[SESSION_TOKEN_HEADER], ee.headers[SESSION_TOKEN_QUERY_PARAM] = te.sessionToken, ee.query = ee.query ?? {}, ee.query[SESSION_TOKEN_QUERY_PARAM] = te.sessionToken, setSingleOverride(this, re), this.presign(ee, ne);
  }
}
function getCredentialsWithoutSessionToken($) {
  return {
    accessKeyId: $.accessKeyId,
    secretAccessKey: $.secretAccessKey,
    expiration: $.expiration
  };
}
function setSingleOverride($, ee) {
  const te = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10), ne = $.credentialProvider, re = () => (clearTimeout(te), $.credentialProvider = ne, Promise.resolve(ee));
  $.credentialProvider = re;
}
const s3ExpressMiddleware = ($) => (ee, te) => async (ne) => {
  var re, se, ie, oe, le;
  if (te.endpointV2) {
    const ue = te.endpointV2, de = ((ie = (se = (re = ue.properties) == null ? void 0 : re.authSchemes) == null ? void 0 : se[0]) == null ? void 0 : ie.name) === S3_EXPRESS_AUTH_SCHEME;
    if ((((oe = ue.properties) == null ? void 0 : oe.backend) === S3_EXPRESS_BACKEND || ((le = ue.properties) == null ? void 0 : le.bucketType) === S3_EXPRESS_BUCKET_TYPE) && (te.isS3ExpressBucket = !0), de) {
      const pe = ne.input.Bucket;
      if (pe) {
        const ye = await $.s3ExpressIdentityProvider.getS3ExpressIdentity(await $.credentials(), {
          Bucket: pe
        });
        te.s3ExpressIdentity = ye, HttpRequest.isInstance(ne.request) && ye.sessionToken && (ne.request.headers[SESSION_TOKEN_HEADER] = ye.sessionToken);
      }
    }
  }
  return ee(ne);
}, s3ExpressMiddlewareOptions = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: !0
}, getS3ExpressPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(s3ExpressMiddleware($), s3ExpressMiddlewareOptions);
  }
}), resolveS3Config = ($, { session: ee }) => {
  const [te, ne] = ee;
  return {
    ...$,
    forcePathStyle: $.forcePathStyle ?? !1,
    useAccelerateEndpoint: $.useAccelerateEndpoint ?? !1,
    disableMultiregionAccessPoints: $.disableMultiregionAccessPoints ?? !1,
    followRegionRedirects: $.followRegionRedirects ?? !1,
    s3ExpressIdentityProvider: $.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (re) => te().send(new ne({
      Bucket: re,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: $.bucketEndpoint ?? !1
  };
}, validate = ($) => typeof $ == "string" && $.indexOf("arn:") === 0 && $.split(":").length >= 6;
function bucketEndpointMiddleware($) {
  return (ee, te) => async (ne) => {
    var re, se, ie, oe;
    if ($.bucketEndpoint) {
      const le = te.endpointV2;
      if (le) {
        const ue = ne.input.Bucket;
        if (typeof ue == "string")
          try {
            const de = new URL(ue);
            le.url = de;
          } catch (de) {
            const fe = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${ue} could not be parsed as URL.`;
            throw ((se = (re = te.logger) == null ? void 0 : re.constructor) == null ? void 0 : se.name) === "NoOpLogger" ? console.warn(fe) : (oe = (ie = te.logger) == null ? void 0 : ie.warn) == null || oe.call(ie, fe), de;
          }
      }
    }
    return ee(ne);
  };
}
const bucketEndpointMiddlewareOptions = {
  name: "bucketEndpointMiddleware",
  override: !0,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};
function validateBucketNameMiddleware({ bucketEndpoint: $ }) {
  return (ee) => async (te) => {
    const { input: { Bucket: ne } } = te;
    if (!$ && typeof ne == "string" && !validate(ne) && ne.indexOf("/") >= 0) {
      const re = new Error(`Bucket name shouldn't contain '/', received '${ne}'`);
      throw re.name = "InvalidBucketName", re;
    }
    return ee({ ...te });
  };
}
const validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: !0
}, getValidateBucketNamePlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(validateBucketNameMiddleware($), validateBucketNameMiddlewareOptions), ee.addRelativeTo(bucketEndpointMiddleware($), bucketEndpointMiddlewareOptions);
  }
});
class ProviderError extends Error {
  constructor(ee, te = !0) {
    super(ee), this.tryNextLink = te, this.name = "ProviderError", Object.setPrototypeOf(this, ProviderError.prototype);
  }
  static from(ee, te = !0) {
    return Object.assign(new this(ee.message, te), ee);
  }
}
class CredentialsProviderError extends ProviderError {
  constructor(ee, te = !0) {
    super(ee, te), this.tryNextLink = te, this.name = "CredentialsProviderError", Object.setPrototypeOf(this, CredentialsProviderError.prototype);
  }
}
const memoize = ($, ee, te) => {
  let ne, re, se, ie = !1;
  const oe = async () => {
    re || (re = $());
    try {
      ne = await re, se = !0, ie = !1;
    } finally {
      re = void 0;
    }
    return ne;
  };
  return ee === void 0 ? async (le) => ((!se || le != null && le.forceRefresh) && (ne = await oe()), ne) : async (le) => ((!se || le != null && le.forceRefresh) && (ne = await oe()), ie ? ne : te && !te(ne) ? (ie = !0, ne) : (ee(ne) && await oe(), ne));
}, CREDENTIAL_EXPIRE_WINDOW = 3e5, resolveAwsAuthConfig = ($) => {
  const ee = $.credentials ? normalizeCredentialProvider($.credentials) : $.credentialDefaultProvider(Object.assign({}, $, {
    parentClientConfig: $
  })), { signingEscapePath: te = !0, systemClockOffset: ne = $.systemClockOffset || 0, sha256: re } = $;
  let se;
  return $.signer ? se = normalizeProvider($.signer) : $.regionInfoProvider ? se = () => normalizeProvider($.region)().then(async (ie) => [
    await $.regionInfoProvider(ie, {
      useFipsEndpoint: await $.useFipsEndpoint(),
      useDualstackEndpoint: await $.useDualstackEndpoint()
    }) || {},
    ie
  ]).then(([ie, oe]) => {
    const { signingRegion: le, signingService: ue } = ie;
    $.signingRegion = $.signingRegion || le || oe, $.signingName = $.signingName || ue || $.serviceId;
    const de = {
      ...$,
      credentials: ee,
      region: $.signingRegion,
      service: $.signingName,
      sha256: re,
      uriEscapePath: te
    }, fe = $.signerConstructor || SignatureV4;
    return new fe(de);
  }) : se = async (ie) => {
    ie = Object.assign({}, {
      name: "sigv4",
      signingName: $.signingName || $.defaultSigningName,
      signingRegion: await normalizeProvider($.region)(),
      properties: {}
    }, ie);
    const oe = (ie == null ? void 0 : ie.name) === "sigv4a", le = ie.signingRegion, ue = ie.signingName;
    let de;
    oe ? de = $.signingRegion || le : ($.signingRegion = $.signingRegion || le, de = $.signingRegion), $.signingName = $.signingName || ue || $.serviceId;
    const fe = {
      ...$,
      credentials: ee,
      region: de,
      service: $.signingName,
      sha256: re,
      uriEscapePath: te
    }, pe = $.signerConstructor || SignatureV4;
    return new pe(fe);
  }, {
    ...$,
    systemClockOffset: ne,
    signingEscapePath: te,
    credentials: ee,
    signer: se
  };
}, normalizeCredentialProvider = ($) => typeof $ == "function" ? memoize($, (ee) => ee.expiration !== void 0 && ee.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (ee) => ee.expiration !== void 0) : normalizeProvider($), getSkewCorrectedDate = ($) => new Date(Date.now() + $), isClockSkewed = ($, ee) => Math.abs(getSkewCorrectedDate(ee).getTime() - $) >= 3e5, getUpdatedSystemClockOffset = ($, ee) => {
  const te = Date.parse($);
  return isClockSkewed(te, ee) ? te - Date.now() : ee;
}, awsAuthMiddleware = ($) => (ee, te) => async function(ne) {
  var me, ve, ge, xe, Ee, Te, Se;
  if (!HttpRequest.isInstance(ne.request))
    return ee(ne);
  let re, se;
  const ie = (ge = (ve = (me = te.endpointV2) == null ? void 0 : me.properties) == null ? void 0 : ve.authSchemes) == null ? void 0 : ge[0], oe = (Te = (Ee = (xe = te.endpointV2) == null ? void 0 : xe.properties) == null ? void 0 : Ee.authSchemes) == null ? void 0 : Te[1];
  if ((ie == null ? void 0 : ie.name) === "sigv4a" && oe) {
    se = await $.signer(re = ie);
    const he = se;
    (() => {
      var Ie;
      if (typeof (he == null ? void 0 : he.getSigv4aSigner) == "function") {
        if (((Ie = he == null ? void 0 : he.signerOptions) == null ? void 0 : Ie.runtime) !== "node")
          return !1;
        try {
          return he.getSigv4aSigner(), !0;
        } catch {
        }
      }
      return !1;
    })() || (se = await $.signer(re = oe));
  } else
    se = await $.signer(re = ie);
  let ue;
  const de = (re == null ? void 0 : re.name) === "sigv4a" ? (Se = re == null ? void 0 : re.signingRegionSet) == null ? void 0 : Se.join(",") : void 0, fe = {
    signingDate: getSkewCorrectedDate($.systemClockOffset),
    signingRegion: de || te.signing_region,
    signingService: te.signing_service
  };
  if (te.s3ExpressIdentity) {
    if (ue = await se.signWithCredentials(ne.request, te.s3ExpressIdentity, fe), ue.headers["X-Amz-Security-Token"] || ue.headers["x-amz-security-token"])
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  } else
    ue = await se.sign(ne.request, fe);
  const pe = await ee({
    ...ne,
    request: ue
  }).catch((he) => {
    const Pe = he.ServerTime ?? getDateHeader(he.$response);
    throw Pe && ($.systemClockOffset = getUpdatedSystemClockOffset(Pe, $.systemClockOffset)), he;
  }), ye = getDateHeader(pe.response);
  return ye && ($.systemClockOffset = getUpdatedSystemClockOffset(ye, $.systemClockOffset)), pe;
}, getDateHeader = ($) => {
  var ee, te;
  return HttpResponse.isInstance($) ? ((ee = $.headers) == null ? void 0 : ee.date) ?? ((te = $.headers) == null ? void 0 : te.Date) : void 0;
}, awsAuthMiddlewareOptions = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: !0
}, getAwsAuthPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.addRelativeTo(awsAuthMiddleware($), awsAuthMiddlewareOptions);
  }
});
function resolveUserAgentConfig($) {
  return {
    ...$,
    customUserAgent: typeof $.customUserAgent == "string" ? [[$.customUserAgent]] : $.customUserAgent
  };
}
const IP_V4_REGEX = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), isIpAddress = ($) => IP_V4_REGEX.test($) || $.startsWith("[") && $.endsWith("]"), VALID_HOST_LABEL_REGEX = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), isValidHostLabel = ($, ee = !1) => {
  if (!ee)
    return VALID_HOST_LABEL_REGEX.test($);
  const te = $.split(".");
  for (const ne of te)
    if (!isValidHostLabel(ne))
      return !1;
  return !0;
}, customEndpointFunctions = {}, debugId = "endpoints";
function toDebugString($) {
  return typeof $ != "object" || $ == null ? $ : "ref" in $ ? `$${toDebugString($.ref)}` : "fn" in $ ? `${$.fn}(${($.argv || []).map(toDebugString).join(", ")})` : JSON.stringify($, null, 2);
}
class EndpointError extends Error {
  constructor(ee) {
    super(ee), this.name = "EndpointError";
  }
}
const booleanEquals = ($, ee) => $ === ee, getAttrPathList = ($) => {
  const ee = $.split("."), te = [];
  for (const ne of ee) {
    const re = ne.indexOf("[");
    if (re !== -1) {
      if (ne.indexOf("]") !== ne.length - 1)
        throw new EndpointError(`Path: '${$}' does not end with ']'`);
      const se = ne.slice(re + 1, -1);
      if (Number.isNaN(parseInt(se)))
        throw new EndpointError(`Invalid array index: '${se}' in path: '${$}'`);
      re !== 0 && te.push(ne.slice(0, re)), te.push(se);
    } else
      te.push(ne);
  }
  return te;
}, getAttr = ($, ee) => getAttrPathList(ee).reduce((te, ne) => {
  if (typeof te != "object")
    throw new EndpointError(`Index '${ne}' in '${ee}' not found in '${JSON.stringify($)}'`);
  return Array.isArray(te) ? te[parseInt(ne)] : te[ne];
}, $), isSet = ($) => $ != null, not = ($) => !$, DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
}, parseURL = ($) => {
  const ee = (() => {
    try {
      if ($ instanceof URL)
        return $;
      if (typeof $ == "object" && "hostname" in $) {
        const { hostname: pe, port: ye, protocol: me = "", path: ve = "", query: ge = {} } = $, xe = new URL(`${me}//${pe}${ye ? `:${ye}` : ""}${ve}`);
        return xe.search = Object.entries(ge).map(([Ee, Te]) => `${Ee}=${Te}`).join("&"), xe;
      }
      return new URL($);
    } catch {
      return null;
    }
  })();
  if (!ee)
    return console.error(`Unable to parse ${JSON.stringify($)} as a whatwg URL.`), null;
  const te = ee.href, { host: ne, hostname: re, pathname: se, protocol: ie, search: oe } = ee;
  if (oe)
    return null;
  const le = ie.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(le))
    return null;
  const ue = isIpAddress(re), de = te.includes(`${ne}:${DEFAULT_PORTS[le]}`) || typeof $ == "string" && $.includes(`${ne}:${DEFAULT_PORTS[le]}`), fe = `${ne}${de ? `:${DEFAULT_PORTS[le]}` : ""}`;
  return {
    scheme: le,
    authority: fe,
    path: se,
    normalizedPath: se.endsWith("/") ? se : `${se}/`,
    isIp: ue
  };
}, stringEquals = ($, ee) => $ === ee, substring = ($, ee, te, ne) => ee >= te || $.length < te ? null : ne ? $.substring($.length - te, $.length - ee) : $.substring(ee, te), uriEncode = ($) => encodeURIComponent($).replace(/[!*'()]/g, (ee) => `%${ee.charCodeAt(0).toString(16).toUpperCase()}`), endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not,
  parseURL,
  stringEquals,
  substring,
  uriEncode
}, evaluateTemplate = ($, ee) => {
  const te = [], ne = {
    ...ee.endpointParams,
    ...ee.referenceRecord
  };
  let re = 0;
  for (; re < $.length; ) {
    const se = $.indexOf("{", re);
    if (se === -1) {
      te.push($.slice(re));
      break;
    }
    te.push($.slice(re, se));
    const ie = $.indexOf("}", se);
    if (ie === -1) {
      te.push($.slice(se));
      break;
    }
    $[se + 1] === "{" && $[ie + 1] === "}" && (te.push($.slice(se + 1, ie)), re = ie + 2);
    const oe = $.substring(se + 1, ie);
    if (oe.includes("#")) {
      const [le, ue] = oe.split("#");
      te.push(getAttr(ne[le], ue));
    } else
      te.push(ne[oe]);
    re = ie + 1;
  }
  return te.join("");
}, getReferenceValue = ({ ref: $ }, ee) => ({
  ...ee.endpointParams,
  ...ee.referenceRecord
})[$], evaluateExpression = ($, ee, te) => {
  if (typeof $ == "string")
    return evaluateTemplate($, te);
  if ($.fn)
    return callFunction($, te);
  if ($.ref)
    return getReferenceValue($, te);
  throw new EndpointError(`'${ee}': ${String($)} is not a string, function or reference.`);
}, callFunction = ({ fn: $, argv: ee }, te) => {
  const ne = ee.map((se) => ["boolean", "number"].includes(typeof se) ? se : evaluateExpression(se, "arg", te)), re = $.split(".");
  return re[0] in customEndpointFunctions && re[1] != null ? customEndpointFunctions[re[0]][re[1]](...ne) : endpointFunctions[$](...ne);
}, evaluateCondition = ({ assign: $, ...ee }, te) => {
  var re, se;
  if ($ && $ in te.referenceRecord)
    throw new EndpointError(`'${$}' is already defined in Reference Record.`);
  const ne = callFunction(ee, te);
  return (se = (re = te.logger) == null ? void 0 : re.debug) == null || se.call(re, debugId, `evaluateCondition: ${toDebugString(ee)} = ${toDebugString(ne)}`), {
    result: ne === "" ? !0 : !!ne,
    ...$ != null && { toAssign: { name: $, value: ne } }
  };
}, evaluateConditions = ($ = [], ee) => {
  var ne, re;
  const te = {};
  for (const se of $) {
    const { result: ie, toAssign: oe } = evaluateCondition(se, {
      ...ee,
      referenceRecord: {
        ...ee.referenceRecord,
        ...te
      }
    });
    if (!ie)
      return { result: ie };
    oe && (te[oe.name] = oe.value, (re = (ne = ee.logger) == null ? void 0 : ne.debug) == null || re.call(ne, debugId, `assign: ${oe.name} := ${toDebugString(oe.value)}`));
  }
  return { result: !0, referenceRecord: te };
}, getEndpointHeaders = ($, ee) => Object.entries($).reduce((te, [ne, re]) => ({
  ...te,
  [ne]: re.map((se) => {
    const ie = evaluateExpression(se, "Header value entry", ee);
    if (typeof ie != "string")
      throw new EndpointError(`Header '${ne}' value '${ie}' is not a string`);
    return ie;
  })
}), {}), getEndpointProperty = ($, ee) => {
  if (Array.isArray($))
    return $.map((te) => getEndpointProperty(te, ee));
  switch (typeof $) {
    case "string":
      return evaluateTemplate($, ee);
    case "object":
      if ($ === null)
        throw new EndpointError(`Unexpected endpoint property: ${$}`);
      return getEndpointProperties($, ee);
    case "boolean":
      return $;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof $}`);
  }
}, getEndpointProperties = ($, ee) => Object.entries($).reduce((te, [ne, re]) => ({
  ...te,
  [ne]: getEndpointProperty(re, ee)
}), {}), getEndpointUrl = ($, ee) => {
  const te = evaluateExpression($, "Endpoint URL", ee);
  if (typeof te == "string")
    try {
      return new URL(te);
    } catch (ne) {
      throw console.error(`Failed to construct URL with ${te}`, ne), ne;
    }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof te}`);
}, evaluateEndpointRule = ($, ee) => {
  var de, fe;
  const { conditions: te, endpoint: ne } = $, { result: re, referenceRecord: se } = evaluateConditions(te, ee);
  if (!re)
    return;
  const ie = {
    ...ee,
    referenceRecord: { ...ee.referenceRecord, ...se }
  }, { url: oe, properties: le, headers: ue } = ne;
  return (fe = (de = ee.logger) == null ? void 0 : de.debug) == null || fe.call(de, debugId, `Resolving endpoint from template: ${toDebugString(ne)}`), {
    ...ue != null && {
      headers: getEndpointHeaders(ue, ie)
    },
    ...le != null && {
      properties: getEndpointProperties(le, ie)
    },
    url: getEndpointUrl(oe, ie)
  };
}, evaluateErrorRule = ($, ee) => {
  const { conditions: te, error: ne } = $, { result: re, referenceRecord: se } = evaluateConditions(te, ee);
  if (re)
    throw new EndpointError(evaluateExpression(ne, "Error", {
      ...ee,
      referenceRecord: { ...ee.referenceRecord, ...se }
    }));
}, evaluateTreeRule = ($, ee) => {
  const { conditions: te, rules: ne } = $, { result: re, referenceRecord: se } = evaluateConditions(te, ee);
  if (re)
    return evaluateRules(ne, {
      ...ee,
      referenceRecord: { ...ee.referenceRecord, ...se }
    });
}, evaluateRules = ($, ee) => {
  for (const te of $)
    if (te.type === "endpoint") {
      const ne = evaluateEndpointRule(te, ee);
      if (ne)
        return ne;
    } else if (te.type === "error")
      evaluateErrorRule(te, ee);
    else if (te.type === "tree") {
      const ne = evaluateTreeRule(te, ee);
      if (ne)
        return ne;
    } else
      throw new EndpointError(`Unknown endpoint rule: ${te}`);
  throw new EndpointError("Rules evaluation failed");
}, resolveEndpoint = ($, ee) => {
  var ue, de, fe, pe, ye;
  const { endpointParams: te, logger: ne } = ee, { parameters: re, rules: se } = $;
  (de = (ue = ee.logger) == null ? void 0 : ue.debug) == null || de.call(ue, `${debugId} Initial EndpointParams: ${toDebugString(te)}`);
  const ie = Object.entries(re).filter(([, me]) => me.default != null).map(([me, ve]) => [me, ve.default]);
  if (ie.length > 0)
    for (const [me, ve] of ie)
      te[me] = te[me] ?? ve;
  const oe = Object.entries(re).filter(([, me]) => me.required).map(([me]) => me);
  for (const me of oe)
    if (te[me] == null)
      throw new EndpointError(`Missing required parameter: '${me}'`);
  const le = evaluateRules(se, { endpointParams: te, logger: ne, referenceRecord: {} });
  if ((fe = ee.endpointParams) != null && fe.Endpoint)
    try {
      const me = new URL(ee.endpointParams.Endpoint), { protocol: ve, port: ge } = me;
      le.url.protocol = ve, le.url.port = ge;
    } catch {
    }
  return (ye = (pe = ee.logger) == null ? void 0 : pe.debug) == null || ye.call(pe, `${debugId} Resolved endpoint: ${toDebugString(le)}`), le;
}, isVirtualHostableS3Bucket = ($, ee = !1) => {
  if (ee) {
    for (const te of $.split("."))
      if (!isVirtualHostableS3Bucket(te))
        return !1;
    return !0;
  }
  return !(!isValidHostLabel($) || $.length < 3 || $.length > 63 || $ !== $.toLowerCase() || isIpAddress($));
}, parseArn = ($) => {
  const ee = $.split(":");
  if (ee.length < 6)
    return null;
  const [te, ne, re, se, ie, ...oe] = ee;
  return te !== "arn" || ne === "" || re === "" || oe[0] === "" ? null : {
    partition: ne,
    service: re,
    region: se,
    accountId: ie,
    resourceId: oe[0].includes("/") ? oe[0].split("/") : oe
  };
}, partitions = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
], version$1 = "1.1", partitionsInfo = {
  partitions,
  version: version$1
};
let selectedPartitionsInfo = partitionsInfo;
const partition = ($) => {
  const { partitions: ee } = selectedPartitionsInfo;
  for (const ne of ee) {
    const { regions: re, outputs: se } = ne;
    for (const [ie, oe] of Object.entries(re))
      if (ie === $)
        return {
          ...se,
          ...oe
        };
  }
  for (const ne of ee) {
    const { regionRegex: re, outputs: se } = ne;
    if (new RegExp(re).test($))
      return {
        ...se
      };
  }
  const te = ee.find((ne) => ne.id === "aws");
  if (!te)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...te.outputs
  };
}, awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;
const USER_AGENT = "user-agent", X_AMZ_USER_AGENT = "x-amz-user-agent", SPACE = " ", UA_NAME_SEPARATOR = "/", UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g, UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g, UA_ESCAPE_CHAR = "-", userAgentMiddleware = ($) => (ee, te) => async (ne) => {
  var fe, pe;
  const { request: re } = ne;
  if (!HttpRequest.isInstance(re))
    return ee(ne);
  const { headers: se } = re, ie = ((fe = te == null ? void 0 : te.userAgent) == null ? void 0 : fe.map(escapeUserAgent)) || [], oe = (await $.defaultUserAgentProvider()).map(escapeUserAgent), le = ((pe = $ == null ? void 0 : $.customUserAgent) == null ? void 0 : pe.map(escapeUserAgent)) || [], ue = [].concat([...oe, ...ie, ...le]).join(SPACE), de = [
    ...oe.filter((ye) => ye.startsWith("aws-sdk-")),
    ...le
  ].join(SPACE);
  return $.runtime !== "browser" ? (de && (se[X_AMZ_USER_AGENT] = se[X_AMZ_USER_AGENT] ? `${se[USER_AGENT]} ${de}` : de), se[USER_AGENT] = ue) : se[X_AMZ_USER_AGENT] = ue, ee({
    ...ne,
    request: re
  });
}, escapeUserAgent = ($) => {
  var ie;
  const ee = $[0].split(UA_NAME_SEPARATOR).map((oe) => oe.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR), te = (ie = $[1]) == null ? void 0 : ie.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR), ne = ee.indexOf(UA_NAME_SEPARATOR), re = ee.substring(0, ne);
  let se = ee.substring(ne + 1);
  return re === "api" && (se = se.toLowerCase()), [re, se, te].filter((oe) => oe && oe.length > 0).reduce((oe, le, ue) => {
    switch (ue) {
      case 0:
        return le;
      case 1:
        return `${oe}/${le}`;
      default:
        return `${oe}#${le}`;
    }
  }, "");
}, getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: !0
}, getUserAgentPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(userAgentMiddleware($), getUserAgentMiddlewareOptions);
  }
}), DEFAULT_USE_DUALSTACK_ENDPOINT = !1, DEFAULT_USE_FIPS_ENDPOINT = !1, isFipsRegion = ($) => typeof $ == "string" && ($.startsWith("fips-") || $.endsWith("-fips")), getRealRegion = ($) => isFipsRegion($) ? ["fips-aws-global", "aws-fips"].includes($) ? "us-east-1" : $.replace(/fips-(dkr-|prod-)?|-fips/, "") : $, resolveRegionConfig = ($) => {
  const { region: ee, useFipsEndpoint: te } = $;
  if (!ee)
    throw new Error("Region is missing");
  return {
    ...$,
    region: async () => {
      if (typeof ee == "string")
        return getRealRegion(ee);
      const ne = await ee();
      return getRealRegion(ne);
    },
    useFipsEndpoint: async () => {
      const ne = typeof ee == "string" ? ee : await ee();
      return isFipsRegion(ne) ? !0 : typeof te != "function" ? Promise.resolve(!!te) : te();
    }
  };
}, resolveEventStreamSerdeConfig = ($) => ({
  ...$,
  eventStreamMarshaller: $.eventStreamSerdeProvider($)
}), CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware($) {
  return (ee) => async (te) => {
    const ne = te.request;
    if (HttpRequest.isInstance(ne)) {
      const { body: re, headers: se } = ne;
      if (re && Object.keys(se).map((ie) => ie.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1)
        try {
          const ie = $(re);
          ne.headers = {
            ...ne.headers,
            [CONTENT_LENGTH_HEADER]: String(ie)
          };
        } catch {
        }
    }
    return ee({
      ...te,
      request: ne
    });
  };
}
const contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: !0
}, getContentLengthPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(contentLengthMiddleware($.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
}), resolveParamsForS3 = async ($) => {
  const ee = ($ == null ? void 0 : $.Bucket) || "";
  if (typeof $.Bucket == "string" && ($.Bucket = ee.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), isArnBucketName(ee)) {
    if ($.ForcePathStyle === !0)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else
    (!isDnsCompatibleBucketName(ee) || ee.indexOf(".") !== -1 && !String($.Endpoint).startsWith("http:") || ee.toLowerCase() !== ee || ee.length < 3) && ($.ForcePathStyle = !0);
  return $.DisableMultiRegionAccessPoints && ($.disableMultiRegionAccessPoints = !0, $.DisableMRAP = !0), $;
}, DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/, DOTS_PATTERN = /\.\./, isDnsCompatibleBucketName = ($) => DOMAIN_PATTERN.test($) && !IP_ADDRESS_PATTERN.test($) && !DOTS_PATTERN.test($), isArnBucketName = ($) => {
  const [ee, te, ne, , , re] = $.split(":"), se = ee === "arn" && $.split(":").length >= 6, ie = !!(se && te && ne && re);
  if (se && !ie)
    throw new Error(`Invalid ARN: ${$} was an invalid ARN.`);
  return ie;
}, createConfigValueProvider = ($, ee, te) => {
  const ne = async () => {
    const re = te[$] ?? te[ee];
    return typeof re == "function" ? re() : re;
  };
  return $ === "credentialScope" || ee === "CredentialScope" ? async () => {
    const re = typeof te.credentials == "function" ? await te.credentials() : te.credentials;
    return (re == null ? void 0 : re.credentialScope) ?? (re == null ? void 0 : re.CredentialScope);
  } : $ === "endpoint" || ee === "endpoint" ? async () => {
    const re = await ne();
    if (re && typeof re == "object") {
      if ("url" in re)
        return re.url.href;
      if ("hostname" in re) {
        const { protocol: se, hostname: ie, port: oe, path: le } = re;
        return `${se}//${ie}${oe ? ":" + oe : ""}${le}`;
      }
    }
    return re;
  } : ne;
}, getEndpointFromConfig = async ($) => {
};
function parseQueryString($) {
  const ee = {};
  if ($ = $.replace(/^\?/, ""), $)
    for (const te of $.split("&")) {
      let [ne, re = null] = te.split("=");
      ne = decodeURIComponent(ne), re && (re = decodeURIComponent(re)), ne in ee ? Array.isArray(ee[ne]) ? ee[ne].push(re) : ee[ne] = [ee[ne], re] : ee[ne] = re;
    }
  return ee;
}
const parseUrl = ($) => {
  if (typeof $ == "string")
    return parseUrl(new URL($));
  const { hostname: ee, pathname: te, port: ne, protocol: re, search: se } = $;
  let ie;
  return se && (ie = parseQueryString(se)), {
    hostname: ee,
    port: ne ? parseInt(ne) : void 0,
    protocol: re,
    path: te,
    query: ie
  };
}, toEndpointV1 = ($) => typeof $ == "object" ? "url" in $ ? parseUrl($.url) : $ : parseUrl($), getEndpointFromInstructions = async ($, ee, te, ne) => {
  if (!te.endpoint) {
    const ie = await getEndpointFromConfig(te.serviceId || "");
    ie && (te.endpoint = () => Promise.resolve(toEndpointV1(ie)));
  }
  const re = await resolveParams($, ee, te);
  if (typeof te.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return te.endpointProvider(re, ne);
}, resolveParams = async ($, ee, te) => {
  var se;
  const ne = {}, re = ((se = ee == null ? void 0 : ee.getEndpointParameterInstructions) == null ? void 0 : se.call(ee)) || {};
  for (const [ie, oe] of Object.entries(re))
    switch (oe.type) {
      case "staticContextParams":
        ne[ie] = oe.value;
        break;
      case "contextParams":
        ne[ie] = $[oe.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        ne[ie] = await createConfigValueProvider(oe.name, ie, te)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(oe));
    }
  return Object.keys(re).length === 0 && Object.assign(ne, te), String(te.serviceId).toLowerCase() === "s3" && await resolveParamsForS3(ne), ne;
}, endpointMiddleware = ({ config: $, instructions: ee }) => (te, ne) => async (re) => {
  var oe, le, ue;
  const se = await getEndpointFromInstructions(re.input, {
    getEndpointParameterInstructions() {
      return ee;
    }
  }, { ...$ }, ne);
  ne.endpointV2 = se, ne.authSchemes = (oe = se.properties) == null ? void 0 : oe.authSchemes;
  const ie = (le = ne.authSchemes) == null ? void 0 : le[0];
  if (ie) {
    ne.signing_region = ie.signingRegion, ne.signing_service = ie.signingName;
    const de = getSmithyContext(ne), fe = (ue = de == null ? void 0 : de.selectedHttpAuthScheme) == null ? void 0 : ue.httpAuthOption;
    fe && (fe.signingProperties = Object.assign(fe.signingProperties || {}, {
      signing_region: ie.signingRegion,
      signingRegion: ie.signingRegion,
      signing_service: ie.signingName,
      signingName: ie.signingName,
      signingRegionSet: ie.signingRegionSet
    }, ie.properties));
  }
  return te({
    ...re
  });
}, deserializerMiddleware = ($, ee) => (te, ne) => async (re) => {
  const { response: se } = await te(re);
  try {
    const ie = await ee(se, $);
    return {
      response: se,
      output: ie
    };
  } catch (ie) {
    if (Object.defineProperty(ie, "$response", {
      value: se
    }), !("$metadata" in ie)) {
      const oe = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      ie.message += `
  ` + oe, typeof ie.$responseBodyText < "u" && ie.$response && (ie.$response.body = ie.$responseBodyText);
    }
    throw ie;
  }
}, serializerMiddleware = ($, ee) => (te, ne) => async (re) => {
  var oe;
  const se = (oe = ne.endpointV2) != null && oe.url && $.urlParser ? async () => $.urlParser(ne.endpointV2.url) : $.endpoint;
  if (!se)
    throw new Error("No valid endpoint provider available.");
  const ie = await ee(re.input, { ...$, endpoint: se });
  return te({
    ...re,
    request: ie
  });
}, deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: !0
}, serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: !0
};
function getSerdePlugin($, ee, te) {
  return {
    applyToStack: (ne) => {
      ne.add(deserializerMiddleware($, te), deserializerMiddlewareOption), ne.add(serializerMiddleware($, ee), serializerMiddlewareOption);
    }
  };
}
const endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: !0,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
}, getEndpointPlugin = ($, ee) => ({
  applyToStack: (te) => {
    te.addRelativeTo(endpointMiddleware({
      config: $,
      instructions: ee
    }), endpointMiddlewareOptions);
  }
}), resolveEndpointConfig = ($) => {
  const ee = $.tls ?? !0, { endpoint: te } = $, ne = te != null ? async () => toEndpointV1(await normalizeProvider(te)()) : void 0;
  return {
    ...$,
    endpoint: ne,
    tls: ee,
    isCustomEndpoint: !!te,
    useDualstackEndpoint: normalizeProvider($.useDualstackEndpoint ?? !1),
    useFipsEndpoint: normalizeProvider($.useFipsEndpoint ?? !1)
  };
};
var RETRY_MODES;
(function($) {
  $.STANDARD = "standard", $.ADAPTIVE = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3, DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD, THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
], TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504], NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], isClockSkewCorrectedError = ($) => {
  var ee;
  return (ee = $.$metadata) == null ? void 0 : ee.clockSkewCorrected;
}, isThrottlingError = ($) => {
  var ee, te;
  return ((ee = $.$metadata) == null ? void 0 : ee.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes($.name) || ((te = $.$retryable) == null ? void 0 : te.throttling) == !0;
}, isTransientError = ($) => {
  var ee;
  return isClockSkewCorrectedError($) || TRANSIENT_ERROR_CODES.includes($.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(($ == null ? void 0 : $.code) || "") || TRANSIENT_ERROR_STATUS_CODES.includes(((ee = $.$metadata) == null ? void 0 : ee.httpStatusCode) || 0);
}, isServerError = ($) => {
  var ee;
  if (((ee = $.$metadata) == null ? void 0 : ee.httpStatusCode) !== void 0) {
    const te = $.$metadata.httpStatusCode;
    return 500 <= te && te <= 599 && !isTransientError($);
  }
  return !1;
};
class DefaultRateLimiter {
  constructor(ee) {
    this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = (ee == null ? void 0 : ee.beta) ?? 0.7, this.minCapacity = (ee == null ? void 0 : ee.minCapacity) ?? 1, this.minFillRate = (ee == null ? void 0 : ee.minFillRate) ?? 0.5, this.scaleConstant = (ee == null ? void 0 : ee.scaleConstant) ?? 0.4, this.smooth = (ee == null ? void 0 : ee.smooth) ?? 0.8;
    const te = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = te, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(ee) {
    if (this.enabled) {
      if (this.refillTokenBucket(), ee > this.currentCapacity) {
        const te = (ee - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((ne) => setTimeout(ne, te));
      }
      this.currentCapacity = this.currentCapacity - ee;
    }
  }
  refillTokenBucket() {
    const ee = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = ee;
      return;
    }
    const te = (ee - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + te), this.lastTimestamp = ee;
  }
  updateClientSendingRate(ee) {
    let te;
    if (this.updateMeasuredRate(), isThrottlingError(ee)) {
      const re = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = re, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), te = this.cubicThrottle(re), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), te = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const ne = Math.min(te, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(ne);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(ee) {
    return this.getPrecise(ee * this.beta);
  }
  cubicSuccess(ee) {
    return this.getPrecise(this.scaleConstant * Math.pow(ee - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = !0;
  }
  updateTokenBucketRate(ee) {
    this.refillTokenBucket(), this.fillRate = Math.max(ee, this.minFillRate), this.maxCapacity = Math.max(ee, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const ee = this.getCurrentTimeInSeconds(), te = Math.floor(ee * 2) / 2;
    if (this.requestCount++, te > this.lastTxRateBucket) {
      const ne = this.requestCount / (te - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(ne * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = te;
    }
  }
  getPrecise(ee) {
    return parseFloat(ee.toFixed(8));
  }
}
const DEFAULT_RETRY_DELAY_BASE = 100, MAXIMUM_RETRY_DELAY = 20 * 1e3, THROTTLING_RETRY_DELAY_BASE = 500, INITIAL_RETRY_TOKENS = 500, RETRY_COST = 5, TIMEOUT_RETRY_COST = 10, NO_RETRY_INCREMENT = 1, INVOCATION_ID_HEADER = "amz-sdk-invocation-id", REQUEST_HEADER = "amz-sdk-request", getDefaultRetryBackoffStrategy = () => {
  let $ = DEFAULT_RETRY_DELAY_BASE;
  return {
    computeNextBackoffDelay: (ne) => Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** ne * $)),
    setDelayBase: (ne) => {
      $ = ne;
    }
  };
}, createDefaultRetryToken = ({ retryDelay: $, retryCount: ee, retryCost: te }) => ({
  getRetryCount: () => ee,
  getRetryDelay: () => Math.min(MAXIMUM_RETRY_DELAY, $),
  getRetryCost: () => te
});
class StandardRetryStrategy {
  constructor(ee) {
    this.maxAttempts = ee, this.mode = RETRY_MODES.STANDARD, this.capacity = INITIAL_RETRY_TOKENS, this.retryBackoffStrategy = getDefaultRetryBackoffStrategy(), this.maxAttemptsProvider = typeof ee == "function" ? ee : async () => ee;
  }
  async acquireInitialRetryToken(ee) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(ee, te) {
    const ne = await this.getMaxAttempts();
    if (this.shouldRetry(ee, te, ne)) {
      const re = te.errorType;
      this.retryBackoffStrategy.setDelayBase(re === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const se = this.retryBackoffStrategy.computeNextBackoffDelay(ee.getRetryCount()), ie = te.retryAfterHint ? Math.max(te.retryAfterHint.getTime() - Date.now() || 0, se) : se, oe = this.getCapacityCost(re);
      return this.capacity -= oe, createDefaultRetryToken({
        retryDelay: ie,
        retryCount: ee.getRetryCount() + 1,
        retryCost: oe
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(ee) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (ee.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`), DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(ee, te, ne) {
    return ee.getRetryCount() + 1 < ne && this.capacity >= this.getCapacityCost(te.errorType) && this.isRetryableError(te.errorType);
  }
  getCapacityCost(ee) {
    return ee === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(ee) {
    return ee === "THROTTLING" || ee === "TRANSIENT";
  }
}
class AdaptiveRetryStrategy {
  constructor(ee, te) {
    this.maxAttemptsProvider = ee, this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter: ne } = te ?? {};
    this.rateLimiter = ne ?? new DefaultRateLimiter(), this.standardRetryStrategy = new StandardRetryStrategy(ee);
  }
  async acquireInitialRetryToken(ee) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(ee);
  }
  async refreshRetryTokenForRetry(ee, te) {
    return this.rateLimiter.updateClientSendingRate(te), this.standardRetryStrategy.refreshRetryTokenForRetry(ee, te);
  }
  recordSuccess(ee) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(ee);
  }
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let $ = 0; $ < 256; ++$)
  byteToHex.push(($ + 256).toString(16).slice(1));
function unsafeStringify($, ee = 0) {
  return byteToHex[$[ee + 0]] + byteToHex[$[ee + 1]] + byteToHex[$[ee + 2]] + byteToHex[$[ee + 3]] + "-" + byteToHex[$[ee + 4]] + byteToHex[$[ee + 5]] + "-" + byteToHex[$[ee + 6]] + byteToHex[$[ee + 7]] + "-" + byteToHex[$[ee + 8]] + byteToHex[$[ee + 9]] + "-" + byteToHex[$[ee + 10]] + byteToHex[$[ee + 11]] + byteToHex[$[ee + 12]] + byteToHex[$[ee + 13]] + byteToHex[$[ee + 14]] + byteToHex[$[ee + 15]];
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4($, ee, te) {
  if (native.randomUUID && !ee && !$)
    return native.randomUUID();
  $ = $ || {};
  const ne = $.random || ($.rng || rng)();
  if (ne[6] = ne[6] & 15 | 64, ne[8] = ne[8] & 63 | 128, ee) {
    te = te || 0;
    for (let re = 0; re < 16; ++re)
      ee[te + re] = ne[re];
    return ee;
  }
  return unsafeStringify(ne);
}
const asSdkError = ($) => $ instanceof Error ? $ : $ instanceof Object ? Object.assign(new Error(), $) : typeof $ == "string" ? new Error($) : new Error(`AWS SDK error wrapper for ${$}`), resolveRetryConfig = ($) => {
  const { retryStrategy: ee } = $, te = normalizeProvider($.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...$,
    maxAttempts: te,
    retryStrategy: async () => ee || (await normalizeProvider($.retryMode)() === RETRY_MODES.ADAPTIVE ? new AdaptiveRetryStrategy(te) : new StandardRetryStrategy(te))
  };
}, isStreamingPayload = ($) => ($ == null ? void 0 : $.body) instanceof ReadableStream, retryMiddleware = ($) => (ee, te) => async (ne) => {
  var ie;
  let re = await $.retryStrategy();
  const se = await $.maxAttempts();
  if (isRetryStrategyV2(re)) {
    re = re;
    let oe = await re.acquireInitialRetryToken(te.partition_id), le = new Error(), ue = 0, de = 0;
    const { request: fe } = ne, pe = HttpRequest.isInstance(fe);
    for (pe && (fe.headers[INVOCATION_ID_HEADER] = v4()); ; )
      try {
        pe && (fe.headers[REQUEST_HEADER] = `attempt=${ue + 1}; max=${se}`);
        const { response: ye, output: me } = await ee(ne);
        return re.recordSuccess(oe), me.$metadata.attempts = ue + 1, me.$metadata.totalRetryDelay = de, { response: ye, output: me };
      } catch (ye) {
        const me = getRetryErrorInfo(ye);
        if (le = asSdkError(ye), pe && isStreamingPayload(fe))
          throw (ie = te.logger instanceof NoOpLogger ? console : te.logger) == null || ie.warn("An error was encountered in a non-retryable streaming request."), le;
        try {
          oe = await re.refreshRetryTokenForRetry(oe, me);
        } catch {
          throw le.$metadata || (le.$metadata = {}), le.$metadata.attempts = ue + 1, le.$metadata.totalRetryDelay = de, le;
        }
        ue = oe.getRetryCount();
        const ve = oe.getRetryDelay();
        de += ve, await new Promise((ge) => setTimeout(ge, ve));
      }
  } else
    return re = re, re != null && re.mode && (te.userAgent = [...te.userAgent || [], ["cfg/retry-mode", re.mode]]), re.retry(ee, ne);
}, isRetryStrategyV2 = ($) => typeof $.acquireInitialRetryToken < "u" && typeof $.refreshRetryTokenForRetry < "u" && typeof $.recordSuccess < "u", getRetryErrorInfo = ($) => {
  const ee = {
    error: $,
    errorType: getRetryErrorType($)
  }, te = getRetryAfterHint($.$response);
  return te && (ee.retryAfterHint = te), ee;
}, getRetryErrorType = ($) => isThrottlingError($) ? "THROTTLING" : isTransientError($) ? "TRANSIENT" : isServerError($) ? "SERVER_ERROR" : "CLIENT_ERROR", retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: !0
}, getRetryPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(retryMiddleware($), retryMiddlewareOptions);
  }
}), getRetryAfterHint = ($) => {
  if (!HttpResponse.isInstance($))
    return;
  const ee = Object.keys($.headers).find((se) => se.toLowerCase() === "retry-after");
  if (!ee)
    return;
  const te = $.headers[ee], ne = Number(te);
  return Number.isNaN(ne) ? new Date(te) : new Date(ne * 1e3);
}, resolveClientEndpointParameters = ($) => ({
  ...$,
  useFipsEndpoint: $.useFipsEndpoint ?? !1,
  useDualstackEndpoint: $.useDualstackEndpoint ?? !1,
  forcePathStyle: $.forcePathStyle ?? !1,
  useAccelerateEndpoint: $.useAccelerateEndpoint ?? !1,
  useGlobalEndpoint: $.useGlobalEndpoint ?? !1,
  disableMultiregionAccessPoints: $.disableMultiregionAccessPoints ?? !1,
  defaultSigningName: "s3"
}), commonParams = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
class S3ServiceException extends ServiceException {
  constructor(ee) {
    super(ee), Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
}
class NoSuchUpload extends S3ServiceException {
  constructor(ee) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...ee
    }), this.name = "NoSuchUpload", this.$fault = "client", Object.setPrototypeOf(this, NoSuchUpload.prototype);
  }
}
class ObjectNotInActiveTierError extends S3ServiceException {
  constructor(ee) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...ee
    }), this.name = "ObjectNotInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
}
class BucketAlreadyExists extends S3ServiceException {
  constructor(ee) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...ee
    }), this.name = "BucketAlreadyExists", this.$fault = "client", Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
  }
}
class BucketAlreadyOwnedByYou extends S3ServiceException {
  constructor(ee) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...ee
    }), this.name = "BucketAlreadyOwnedByYou", this.$fault = "client", Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
  }
}
class NoSuchBucket extends S3ServiceException {
  constructor(ee) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...ee
    }), this.name = "NoSuchBucket", this.$fault = "client", Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
}
var AnalyticsFilter;
(function($) {
  $.visit = (ee, te) => ee.Prefix !== void 0 ? te.Prefix(ee.Prefix) : ee.Tag !== void 0 ? te.Tag(ee.Tag) : ee.And !== void 0 ? te.And(ee.And) : te._(ee.$unknown[0], ee.$unknown[1]);
})(AnalyticsFilter || (AnalyticsFilter = {}));
var LifecycleRuleFilter;
(function($) {
  $.visit = (ee, te) => ee.Prefix !== void 0 ? te.Prefix(ee.Prefix) : ee.Tag !== void 0 ? te.Tag(ee.Tag) : ee.ObjectSizeGreaterThan !== void 0 ? te.ObjectSizeGreaterThan(ee.ObjectSizeGreaterThan) : ee.ObjectSizeLessThan !== void 0 ? te.ObjectSizeLessThan(ee.ObjectSizeLessThan) : ee.And !== void 0 ? te.And(ee.And) : te._(ee.$unknown[0], ee.$unknown[1]);
})(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
var MetricsFilter;
(function($) {
  $.visit = (ee, te) => ee.Prefix !== void 0 ? te.Prefix(ee.Prefix) : ee.Tag !== void 0 ? te.Tag(ee.Tag) : ee.AccessPointArn !== void 0 ? te.AccessPointArn(ee.AccessPointArn) : ee.And !== void 0 ? te.And(ee.And) : te._(ee.$unknown[0], ee.$unknown[1]);
})(MetricsFilter || (MetricsFilter = {}));
var ReplicationRuleFilter;
(function($) {
  $.visit = (ee, te) => ee.Prefix !== void 0 ? te.Prefix(ee.Prefix) : ee.Tag !== void 0 ? te.Tag(ee.Tag) : ee.And !== void 0 ? te.And(ee.And) : te._(ee.$unknown[0], ee.$unknown[1]);
})(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
class InvalidObjectState extends S3ServiceException {
  constructor(ee) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...ee
    }), this.name = "InvalidObjectState", this.$fault = "client", Object.setPrototypeOf(this, InvalidObjectState.prototype), this.StorageClass = ee.StorageClass, this.AccessTier = ee.AccessTier;
  }
}
class NoSuchKey extends S3ServiceException {
  constructor(ee) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...ee
    }), this.name = "NoSuchKey", this.$fault = "client", Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
}
class NotFound extends S3ServiceException {
  constructor(ee) {
    super({
      name: "NotFound",
      $fault: "client",
      ...ee
    }), this.name = "NotFound", this.$fault = "client", Object.setPrototypeOf(this, NotFound.prototype);
  }
}
const SessionCredentialsFilterSensitiveLog = ($) => ({
  ...$,
  ...$.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
  ...$.SessionToken && { SessionToken: SENSITIVE_STRING }
}), CreateSessionOutputFilterSensitiveLog = ($) => ({
  ...$,
  ...$.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog($.Credentials) }
});
function convertHttpAuthSchemesToMap($) {
  const ee = /* @__PURE__ */ new Map();
  for (const te of $)
    ee.set(te.schemeId, te);
  return ee;
}
const httpAuthSchemeMiddleware = ($, ee) => (te, ne) => async (re) => {
  var ue;
  const se = $.httpAuthSchemeProvider(await ee.httpAuthSchemeParametersProvider($, ne, re.input)), ie = convertHttpAuthSchemesToMap($.httpAuthSchemes), oe = getSmithyContext(ne), le = [];
  for (const de of se) {
    const fe = ie.get(de.schemeId);
    if (!fe) {
      le.push(`HttpAuthScheme \`${de.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const pe = fe.identityProvider(await ee.identityProviderConfigProvider($));
    if (!pe) {
      le.push(`HttpAuthScheme \`${de.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties: ye = {}, signingProperties: me = {} } = ((ue = de.propertiesExtractor) == null ? void 0 : ue.call(de, $, ne)) || {};
    de.identityProperties = Object.assign(de.identityProperties || {}, ye), de.signingProperties = Object.assign(de.signingProperties || {}, me), oe.selectedHttpAuthScheme = {
      httpAuthOption: de,
      identity: await pe(de.identityProperties),
      signer: fe.signer
    };
    break;
  }
  if (!oe.selectedHttpAuthScheme)
    throw new Error(le.join(`
`));
  return te(re);
}, httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: !0,
  relation: "before",
  toMiddleware: endpointMiddlewareOptions.name
}, getHttpAuthSchemeEndpointRuleSetPlugin = ($, { httpAuthSchemeParametersProvider: ee, identityProviderConfigProvider: te }) => ({
  applyToStack: (ne) => {
    ne.addRelativeTo(httpAuthSchemeMiddleware($, {
      httpAuthSchemeParametersProvider: ee,
      identityProviderConfigProvider: te
    }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
  }
});
serializerMiddlewareOption.name;
const defaultErrorHandler = ($) => (ee) => {
  throw ee;
}, defaultSuccessHandler = ($, ee) => {
}, httpSigningMiddleware = ($) => (ee, te) => async (ne) => {
  if (!HttpRequest.isInstance(ne.request))
    return ee(ne);
  const se = getSmithyContext(te).selectedHttpAuthScheme;
  if (!se)
    throw new Error("No HttpAuthScheme was selected: unable to sign request");
  const { httpAuthOption: { signingProperties: ie = {} }, identity: oe, signer: le } = se, ue = await ee({
    ...ne,
    request: await le.sign(ne.request, oe, ie)
  }).catch((le.errorHandler || defaultErrorHandler)(ie));
  return (le.successHandler || defaultSuccessHandler)(ue.response, ie), ue;
}, httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: !0,
  relation: "after",
  toMiddleware: retryMiddlewareOptions.name
}, getHttpSigningPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
  }
});
function requestBuilder($, ee) {
  return new RequestBuilder($, ee);
}
class RequestBuilder {
  constructor(ee, te) {
    this.input = ee, this.context = te, this.query = {}, this.method = "", this.headers = {}, this.path = "", this.body = null, this.hostname = "", this.resolvePathStack = [];
  }
  async build() {
    const { hostname: ee, protocol: te = "https", port: ne, path: re } = await this.context.endpoint();
    this.path = re;
    for (const se of this.resolvePathStack)
      se(this.path);
    return new HttpRequest({
      protocol: te,
      hostname: this.hostname || ee,
      port: ne,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(ee) {
    return this.hostname = ee, this;
  }
  bp(ee) {
    return this.resolvePathStack.push((te) => {
      this.path = `${te != null && te.endsWith("/") ? te.slice(0, -1) : te || ""}` + ee;
    }), this;
  }
  p(ee, te, ne, re) {
    return this.resolvePathStack.push((se) => {
      this.path = resolvedPath(se, this.input, ee, te, ne, re);
    }), this;
  }
  h(ee) {
    return this.headers = ee, this;
  }
  q(ee) {
    return this.query = ee, this;
  }
  b(ee) {
    return this.body = ee, this;
  }
  m(ee) {
    return this.method = ee, this;
  }
}
const collectBodyString = ($, ee) => collectBody($, ee).then((te) => ee.utf8Encoder(te));
var validator$2 = {}, util$3 = {};
(function($) {
  const ee = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", te = ee + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ne = "[" + ee + "][" + te + "]*", re = new RegExp("^" + ne + "$"), se = function(oe, le) {
    const ue = [];
    let de = le.exec(oe);
    for (; de; ) {
      const fe = [];
      fe.startIndex = le.lastIndex - de[0].length;
      const pe = de.length;
      for (let ye = 0; ye < pe; ye++)
        fe.push(de[ye]);
      ue.push(fe), de = le.exec(oe);
    }
    return ue;
  }, ie = function(oe) {
    const le = re.exec(oe);
    return !(le === null || typeof le > "u");
  };
  $.isExist = function(oe) {
    return typeof oe < "u";
  }, $.isEmptyObject = function(oe) {
    return Object.keys(oe).length === 0;
  }, $.merge = function(oe, le, ue) {
    if (le) {
      const de = Object.keys(le), fe = de.length;
      for (let pe = 0; pe < fe; pe++)
        ue === "strict" ? oe[de[pe]] = [le[de[pe]]] : oe[de[pe]] = le[de[pe]];
    }
  }, $.getValue = function(oe) {
    return $.isExist(oe) ? oe : "";
  }, $.isName = ie, $.getAllMatches = se, $.nameRegexp = ne;
})(util$3);
const util$2 = util$3, defaultOptions$2 = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
validator$2.validate = function($, ee) {
  ee = Object.assign({}, defaultOptions$2, ee);
  const te = [];
  let ne = !1, re = !1;
  $[0] === "\uFEFF" && ($ = $.substr(1));
  for (let se = 0; se < $.length; se++)
    if ($[se] === "<" && $[se + 1] === "?") {
      if (se += 2, se = readPI($, se), se.err)
        return se;
    } else if ($[se] === "<") {
      let ie = se;
      if (se++, $[se] === "!") {
        se = readCommentAndCDATA($, se);
        continue;
      } else {
        let oe = !1;
        $[se] === "/" && (oe = !0, se++);
        let le = "";
        for (; se < $.length && $[se] !== ">" && $[se] !== " " && $[se] !== "	" && $[se] !== `
` && $[se] !== "\r"; se++)
          le += $[se];
        if (le = le.trim(), le[le.length - 1] === "/" && (le = le.substring(0, le.length - 1), se--), !validateTagName(le)) {
          let fe;
          return le.trim().length === 0 ? fe = "Invalid space after '<'." : fe = "Tag '" + le + "' is an invalid name.", getErrorObject("InvalidTag", fe, getLineNumberForPosition($, se));
        }
        const ue = readAttributeStr($, se);
        if (ue === !1)
          return getErrorObject("InvalidAttr", "Attributes for '" + le + "' have open quote.", getLineNumberForPosition($, se));
        let de = ue.value;
        if (se = ue.index, de[de.length - 1] === "/") {
          const fe = se - de.length;
          de = de.substring(0, de.length - 1);
          const pe = validateAttributeString(de, ee);
          if (pe === !0)
            ne = !0;
          else
            return getErrorObject(pe.err.code, pe.err.msg, getLineNumberForPosition($, fe + pe.err.line));
        } else if (oe)
          if (ue.tagClosed) {
            if (de.trim().length > 0)
              return getErrorObject("InvalidTag", "Closing tag '" + le + "' can't have attributes or invalid starting.", getLineNumberForPosition($, ie));
            {
              const fe = te.pop();
              if (le !== fe.tagName) {
                let pe = getLineNumberForPosition($, fe.tagStartPos);
                return getErrorObject(
                  "InvalidTag",
                  "Expected closing tag '" + fe.tagName + "' (opened in line " + pe.line + ", col " + pe.col + ") instead of closing tag '" + le + "'.",
                  getLineNumberForPosition($, ie)
                );
              }
              te.length == 0 && (re = !0);
            }
          } else
            return getErrorObject("InvalidTag", "Closing tag '" + le + "' doesn't have proper closing.", getLineNumberForPosition($, se));
        else {
          const fe = validateAttributeString(de, ee);
          if (fe !== !0)
            return getErrorObject(fe.err.code, fe.err.msg, getLineNumberForPosition($, se - de.length + fe.err.line));
          if (re === !0)
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition($, se));
          ee.unpairedTags.indexOf(le) !== -1 || te.push({ tagName: le, tagStartPos: ie }), ne = !0;
        }
        for (se++; se < $.length; se++)
          if ($[se] === "<")
            if ($[se + 1] === "!") {
              se++, se = readCommentAndCDATA($, se);
              continue;
            } else if ($[se + 1] === "?") {
              if (se = readPI($, ++se), se.err)
                return se;
            } else
              break;
          else if ($[se] === "&") {
            const fe = validateAmpersand($, se);
            if (fe == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition($, se));
            se = fe;
          } else if (re === !0 && !isWhiteSpace($[se]))
            return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition($, se));
        $[se] === "<" && se--;
      }
    } else {
      if (isWhiteSpace($[se]))
        continue;
      return getErrorObject("InvalidChar", "char '" + $[se] + "' is not expected.", getLineNumberForPosition($, se));
    }
  if (ne) {
    if (te.length == 1)
      return getErrorObject("InvalidTag", "Unclosed tag '" + te[0].tagName + "'.", getLineNumberForPosition($, te[0].tagStartPos));
    if (te.length > 0)
      return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(te.map((se) => se.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function isWhiteSpace($) {
  return $ === " " || $ === "	" || $ === `
` || $ === "\r";
}
function readPI($, ee) {
  const te = ee;
  for (; ee < $.length; ee++)
    if ($[ee] == "?" || $[ee] == " ") {
      const ne = $.substr(te, ee - te);
      if (ee > 5 && ne === "xml")
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition($, ee));
      if ($[ee] == "?" && $[ee + 1] == ">") {
        ee++;
        break;
      } else
        continue;
    }
  return ee;
}
function readCommentAndCDATA($, ee) {
  if ($.length > ee + 5 && $[ee + 1] === "-" && $[ee + 2] === "-") {
    for (ee += 3; ee < $.length; ee++)
      if ($[ee] === "-" && $[ee + 1] === "-" && $[ee + 2] === ">") {
        ee += 2;
        break;
      }
  } else if ($.length > ee + 8 && $[ee + 1] === "D" && $[ee + 2] === "O" && $[ee + 3] === "C" && $[ee + 4] === "T" && $[ee + 5] === "Y" && $[ee + 6] === "P" && $[ee + 7] === "E") {
    let te = 1;
    for (ee += 8; ee < $.length; ee++)
      if ($[ee] === "<")
        te++;
      else if ($[ee] === ">" && (te--, te === 0))
        break;
  } else if ($.length > ee + 9 && $[ee + 1] === "[" && $[ee + 2] === "C" && $[ee + 3] === "D" && $[ee + 4] === "A" && $[ee + 5] === "T" && $[ee + 6] === "A" && $[ee + 7] === "[") {
    for (ee += 8; ee < $.length; ee++)
      if ($[ee] === "]" && $[ee + 1] === "]" && $[ee + 2] === ">") {
        ee += 2;
        break;
      }
  }
  return ee;
}
const doubleQuote = '"', singleQuote = "'";
function readAttributeStr($, ee) {
  let te = "", ne = "", re = !1;
  for (; ee < $.length; ee++) {
    if ($[ee] === doubleQuote || $[ee] === singleQuote)
      ne === "" ? ne = $[ee] : ne !== $[ee] || (ne = "");
    else if ($[ee] === ">" && ne === "") {
      re = !0;
      break;
    }
    te += $[ee];
  }
  return ne !== "" ? !1 : {
    value: te,
    index: ee,
    tagClosed: re
  };
}
const validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString($, ee) {
  const te = util$2.getAllMatches($, validAttrStrRegxp), ne = {};
  for (let re = 0; re < te.length; re++) {
    if (te[re][1].length === 0)
      return getErrorObject("InvalidAttr", "Attribute '" + te[re][2] + "' has no space in starting.", getPositionFromMatch(te[re]));
    if (te[re][3] !== void 0 && te[re][4] === void 0)
      return getErrorObject("InvalidAttr", "Attribute '" + te[re][2] + "' is without value.", getPositionFromMatch(te[re]));
    if (te[re][3] === void 0 && !ee.allowBooleanAttributes)
      return getErrorObject("InvalidAttr", "boolean attribute '" + te[re][2] + "' is not allowed.", getPositionFromMatch(te[re]));
    const se = te[re][2];
    if (!validateAttrName(se))
      return getErrorObject("InvalidAttr", "Attribute '" + se + "' is an invalid name.", getPositionFromMatch(te[re]));
    if (!ne.hasOwnProperty(se))
      ne[se] = 1;
    else
      return getErrorObject("InvalidAttr", "Attribute '" + se + "' is repeated.", getPositionFromMatch(te[re]));
  }
  return !0;
}
function validateNumberAmpersand($, ee) {
  let te = /\d/;
  for ($[ee] === "x" && (ee++, te = /[\da-fA-F]/); ee < $.length; ee++) {
    if ($[ee] === ";")
      return ee;
    if (!$[ee].match(te))
      break;
  }
  return -1;
}
function validateAmpersand($, ee) {
  if (ee++, $[ee] === ";")
    return -1;
  if ($[ee] === "#")
    return ee++, validateNumberAmpersand($, ee);
  let te = 0;
  for (; ee < $.length; ee++, te++)
    if (!($[ee].match(/\w/) && te < 20)) {
      if ($[ee] === ";")
        break;
      return -1;
    }
  return ee;
}
function getErrorObject($, ee, te) {
  return {
    err: {
      code: $,
      msg: ee,
      line: te.line || te,
      col: te.col
    }
  };
}
function validateAttrName($) {
  return util$2.isName($);
}
function validateTagName($) {
  return util$2.isName($);
}
function getLineNumberForPosition($, ee) {
  const te = $.substring(0, ee).split(/\r?\n/);
  return {
    line: te.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: te[te.length - 1].length + 1
  };
}
function getPositionFromMatch($) {
  return $.startIndex + $[1].length;
}
var OptionsBuilder = {};
const defaultOptions$1 = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function($, ee) {
    return ee;
  },
  attributeValueProcessor: function($, ee) {
    return ee;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function($, ee, te) {
    return $;
  }
  // skipEmptyListItem: false
}, buildOptions$1 = function($) {
  return Object.assign({}, defaultOptions$1, $);
};
OptionsBuilder.buildOptions = buildOptions$1;
OptionsBuilder.defaultOptions = defaultOptions$1;
class XmlNode {
  constructor(ee) {
    this.tagname = ee, this.child = [], this[":@"] = {};
  }
  add(ee, te) {
    ee === "__proto__" && (ee = "#__proto__"), this.child.push({ [ee]: te });
  }
  addChild(ee) {
    ee.tagname === "__proto__" && (ee.tagname = "#__proto__"), ee[":@"] && Object.keys(ee[":@"]).length > 0 ? this.child.push({ [ee.tagname]: ee.child, ":@": ee[":@"] }) : this.child.push({ [ee.tagname]: ee.child });
  }
}
var xmlNode$1 = XmlNode;
const util$1 = util$3;
function readDocType$1($, ee) {
  const te = {};
  if ($[ee + 3] === "O" && $[ee + 4] === "C" && $[ee + 5] === "T" && $[ee + 6] === "Y" && $[ee + 7] === "P" && $[ee + 8] === "E") {
    ee = ee + 9;
    let ne = 1, re = !1, se = !1, ie = "";
    for (; ee < $.length; ee++)
      if ($[ee] === "<" && !se) {
        if (re && isEntity($, ee))
          ee += 7, [entityName, val, ee] = readEntityExp($, ee + 1), val.indexOf("&") === -1 && (te[validateEntityName(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (re && isElement($, ee))
          ee += 8;
        else if (re && isAttlist($, ee))
          ee += 8;
        else if (re && isNotation($, ee))
          ee += 9;
        else if (isComment)
          se = !0;
        else
          throw new Error("Invalid DOCTYPE");
        ne++, ie = "";
      } else if ($[ee] === ">") {
        if (se ? $[ee - 1] === "-" && $[ee - 2] === "-" && (se = !1, ne--) : ne--, ne === 0)
          break;
      } else
        $[ee] === "[" ? re = !0 : ie += $[ee];
    if (ne !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: te, i: ee };
}
function readEntityExp($, ee) {
  let te = "";
  for (; ee < $.length && $[ee] !== "'" && $[ee] !== '"'; ee++)
    te += $[ee];
  if (te = te.trim(), te.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const ne = $[ee++];
  let re = "";
  for (; ee < $.length && $[ee] !== ne; ee++)
    re += $[ee];
  return [te, re, ee];
}
function isComment($, ee) {
  return $[ee + 1] === "!" && $[ee + 2] === "-" && $[ee + 3] === "-";
}
function isEntity($, ee) {
  return $[ee + 1] === "!" && $[ee + 2] === "E" && $[ee + 3] === "N" && $[ee + 4] === "T" && $[ee + 5] === "I" && $[ee + 6] === "T" && $[ee + 7] === "Y";
}
function isElement($, ee) {
  return $[ee + 1] === "!" && $[ee + 2] === "E" && $[ee + 3] === "L" && $[ee + 4] === "E" && $[ee + 5] === "M" && $[ee + 6] === "E" && $[ee + 7] === "N" && $[ee + 8] === "T";
}
function isAttlist($, ee) {
  return $[ee + 1] === "!" && $[ee + 2] === "A" && $[ee + 3] === "T" && $[ee + 4] === "T" && $[ee + 5] === "L" && $[ee + 6] === "I" && $[ee + 7] === "S" && $[ee + 8] === "T";
}
function isNotation($, ee) {
  return $[ee + 1] === "!" && $[ee + 2] === "N" && $[ee + 3] === "O" && $[ee + 4] === "T" && $[ee + 5] === "A" && $[ee + 6] === "T" && $[ee + 7] === "I" && $[ee + 8] === "O" && $[ee + 9] === "N";
}
function validateEntityName($) {
  if (util$1.isName($))
    return $;
  throw new Error(`Invalid entity name ${$}`);
}
var DocTypeReader = readDocType$1;
const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/, numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const consider = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function toNumber$1($, ee = {}) {
  if (ee = Object.assign({}, consider, ee), !$ || typeof $ != "string")
    return $;
  let te = $.trim();
  if (ee.skipLike !== void 0 && ee.skipLike.test(te))
    return $;
  if (ee.hex && hexRegex.test(te))
    return Number.parseInt(te, 16);
  {
    const ne = numRegex.exec(te);
    if (ne) {
      const re = ne[1], se = ne[2];
      let ie = trimZeros(ne[3]);
      const oe = ne[4] || ne[6];
      if (!ee.leadingZeros && se.length > 0 && re && te[2] !== ".")
        return $;
      if (!ee.leadingZeros && se.length > 0 && !re && te[1] !== ".")
        return $;
      {
        const le = Number(te), ue = "" + le;
        return ue.search(/[eE]/) !== -1 || oe ? ee.eNotation ? le : $ : te.indexOf(".") !== -1 ? ue === "0" && ie === "" || ue === ie || re && ue === "-" + ie ? le : $ : se ? ie === ue || re + ie === ue ? le : $ : te === ue || te === re + ue ? le : $;
      }
    } else
      return $;
  }
}
function trimZeros($) {
  return $ && $.indexOf(".") !== -1 && ($ = $.replace(/0+$/, ""), $ === "." ? $ = "0" : $[0] === "." ? $ = "0" + $ : $[$.length - 1] === "." && ($ = $.substr(0, $.length - 1))), $;
}
var strnum = toNumber$1;
const util = util$3, xmlNode = xmlNode$1, readDocType = DocTypeReader, toNumber = strnum;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util.nameRegexp);
let OrderedObjParser$1 = class {
  constructor(ee) {
    this.options = ee, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" }
    }, this.addExternalEntities = addExternalEntities, this.parseXml = parseXml, this.parseTextData = parseTextData, this.resolveNameSpace = resolveNameSpace, this.buildAttributesMap = buildAttributesMap, this.isItStopNode = isItStopNode, this.replaceEntitiesValue = replaceEntitiesValue$1, this.readStopNodeData = readStopNodeData, this.saveTextToParentTag = saveTextToParentTag, this.addChild = addChild;
  }
};
function addExternalEntities($) {
  const ee = Object.keys($);
  for (let te = 0; te < ee.length; te++) {
    const ne = ee[te];
    this.lastEntities[ne] = {
      regex: new RegExp("&" + ne + ";", "g"),
      val: $[ne]
    };
  }
}
function parseTextData($, ee, te, ne, re, se, ie) {
  if ($ !== void 0 && (this.options.trimValues && !ne && ($ = $.trim()), $.length > 0)) {
    ie || ($ = this.replaceEntitiesValue($));
    const oe = this.options.tagValueProcessor(ee, $, te, re, se);
    return oe == null ? $ : typeof oe != typeof $ || oe !== $ ? oe : this.options.trimValues ? parseValue($, this.options.parseTagValue, this.options.numberParseOptions) : $.trim() === $ ? parseValue($, this.options.parseTagValue, this.options.numberParseOptions) : $;
  }
}
function resolveNameSpace($) {
  if (this.options.removeNSPrefix) {
    const ee = $.split(":"), te = $.charAt(0) === "/" ? "/" : "";
    if (ee[0] === "xmlns")
      return "";
    ee.length === 2 && ($ = te + ee[1]);
  }
  return $;
}
const attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap($, ee, te) {
  if (!this.options.ignoreAttributes && typeof $ == "string") {
    const ne = util.getAllMatches($, attrsRegx), re = ne.length, se = {};
    for (let ie = 0; ie < re; ie++) {
      const oe = this.resolveNameSpace(ne[ie][1]);
      let le = ne[ie][4], ue = this.options.attributeNamePrefix + oe;
      if (oe.length)
        if (this.options.transformAttributeName && (ue = this.options.transformAttributeName(ue)), ue === "__proto__" && (ue = "#__proto__"), le !== void 0) {
          this.options.trimValues && (le = le.trim()), le = this.replaceEntitiesValue(le);
          const de = this.options.attributeValueProcessor(oe, le, ee);
          de == null ? se[ue] = le : typeof de != typeof le || de !== le ? se[ue] = de : se[ue] = parseValue(
            le,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (se[ue] = !0);
    }
    if (!Object.keys(se).length)
      return;
    if (this.options.attributesGroupName) {
      const ie = {};
      return ie[this.options.attributesGroupName] = se, ie;
    }
    return se;
  }
}
const parseXml = function($) {
  $ = $.replace(/\r\n?/g, `
`);
  const ee = new xmlNode("!xml");
  let te = ee, ne = "", re = "";
  for (let se = 0; se < $.length; se++)
    if ($[se] === "<")
      if ($[se + 1] === "/") {
        const oe = findClosingIndex($, ">", se, "Closing Tag is not closed.");
        let le = $.substring(se + 2, oe).trim();
        if (this.options.removeNSPrefix) {
          const fe = le.indexOf(":");
          fe !== -1 && (le = le.substr(fe + 1));
        }
        this.options.transformTagName && (le = this.options.transformTagName(le)), te && (ne = this.saveTextToParentTag(ne, te, re));
        const ue = re.substring(re.lastIndexOf(".") + 1);
        if (le && this.options.unpairedTags.indexOf(le) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${le}>`);
        let de = 0;
        ue && this.options.unpairedTags.indexOf(ue) !== -1 ? (de = re.lastIndexOf(".", re.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : de = re.lastIndexOf("."), re = re.substring(0, de), te = this.tagsNodeStack.pop(), ne = "", se = oe;
      } else if ($[se + 1] === "?") {
        let oe = readTagExp($, se, !1, "?>");
        if (!oe)
          throw new Error("Pi Tag is not closed.");
        if (ne = this.saveTextToParentTag(ne, te, re), !(this.options.ignoreDeclaration && oe.tagName === "?xml" || this.options.ignorePiTags)) {
          const le = new xmlNode(oe.tagName);
          le.add(this.options.textNodeName, ""), oe.tagName !== oe.tagExp && oe.attrExpPresent && (le[":@"] = this.buildAttributesMap(oe.tagExp, re, oe.tagName)), this.addChild(te, le, re);
        }
        se = oe.closeIndex + 1;
      } else if ($.substr(se + 1, 3) === "!--") {
        const oe = findClosingIndex($, "-->", se + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const le = $.substring(se + 4, oe - 2);
          ne = this.saveTextToParentTag(ne, te, re), te.add(this.options.commentPropName, [{ [this.options.textNodeName]: le }]);
        }
        se = oe;
      } else if ($.substr(se + 1, 2) === "!D") {
        const oe = readDocType($, se);
        this.docTypeEntities = oe.entities, se = oe.i;
      } else if ($.substr(se + 1, 2) === "![") {
        const oe = findClosingIndex($, "]]>", se, "CDATA is not closed.") - 2, le = $.substring(se + 9, oe);
        if (ne = this.saveTextToParentTag(ne, te, re), this.options.cdataPropName)
          te.add(this.options.cdataPropName, [{ [this.options.textNodeName]: le }]);
        else {
          let ue = this.parseTextData(le, te.tagname, re, !0, !1, !0);
          ue == null && (ue = ""), te.add(this.options.textNodeName, ue);
        }
        se = oe + 2;
      } else {
        let oe = readTagExp($, se, this.options.removeNSPrefix), le = oe.tagName, ue = oe.tagExp, de = oe.attrExpPresent, fe = oe.closeIndex;
        this.options.transformTagName && (le = this.options.transformTagName(le)), te && ne && te.tagname !== "!xml" && (ne = this.saveTextToParentTag(ne, te, re, !1));
        const pe = te;
        if (pe && this.options.unpairedTags.indexOf(pe.tagname) !== -1 && (te = this.tagsNodeStack.pop(), re = re.substring(0, re.lastIndexOf("."))), le !== ee.tagname && (re += re ? "." + le : le), this.isItStopNode(this.options.stopNodes, re, le)) {
          let ye = "";
          if (ue.length > 0 && ue.lastIndexOf("/") === ue.length - 1)
            se = oe.closeIndex;
          else if (this.options.unpairedTags.indexOf(le) !== -1)
            se = oe.closeIndex;
          else {
            const ve = this.readStopNodeData($, le, fe + 1);
            if (!ve)
              throw new Error(`Unexpected end of ${le}`);
            se = ve.i, ye = ve.tagContent;
          }
          const me = new xmlNode(le);
          le !== ue && de && (me[":@"] = this.buildAttributesMap(ue, re, le)), ye && (ye = this.parseTextData(ye, le, re, !0, de, !0, !0)), re = re.substr(0, re.lastIndexOf(".")), me.add(this.options.textNodeName, ye), this.addChild(te, me, re);
        } else {
          if (ue.length > 0 && ue.lastIndexOf("/") === ue.length - 1) {
            le[le.length - 1] === "/" ? (le = le.substr(0, le.length - 1), ue = le) : ue = ue.substr(0, ue.length - 1), this.options.transformTagName && (le = this.options.transformTagName(le));
            const ye = new xmlNode(le);
            le !== ue && de && (ye[":@"] = this.buildAttributesMap(ue, re, le)), this.addChild(te, ye, re), re = re.substr(0, re.lastIndexOf("."));
          } else {
            const ye = new xmlNode(le);
            this.tagsNodeStack.push(te), le !== ue && de && (ye[":@"] = this.buildAttributesMap(ue, re, le)), this.addChild(te, ye, re), te = ye;
          }
          ne = "", se = fe;
        }
      }
    else
      ne += $[se];
  return ee.child;
};
function addChild($, ee, te) {
  const ne = this.options.updateTag(ee.tagname, te, ee[":@"]);
  ne === !1 || (typeof ne == "string" && (ee.tagname = ne), $.addChild(ee));
}
const replaceEntitiesValue$1 = function($) {
  if (this.options.processEntities) {
    for (let ee in this.docTypeEntities) {
      const te = this.docTypeEntities[ee];
      $ = $.replace(te.regx, te.val);
    }
    for (let ee in this.lastEntities) {
      const te = this.lastEntities[ee];
      $ = $.replace(te.regex, te.val);
    }
    if (this.options.htmlEntities)
      for (let ee in this.htmlEntities) {
        const te = this.htmlEntities[ee];
        $ = $.replace(te.regex, te.val);
      }
    $ = $.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return $;
};
function saveTextToParentTag($, ee, te, ne) {
  return $ && (ne === void 0 && (ne = Object.keys(ee.child).length === 0), $ = this.parseTextData(
    $,
    ee.tagname,
    te,
    !1,
    ee[":@"] ? Object.keys(ee[":@"]).length !== 0 : !1,
    ne
  ), $ !== void 0 && $ !== "" && ee.add(this.options.textNodeName, $), $ = ""), $;
}
function isItStopNode($, ee, te) {
  const ne = "*." + te;
  for (const re in $) {
    const se = $[re];
    if (ne === se || ee === se)
      return !0;
  }
  return !1;
}
function tagExpWithClosingIndex($, ee, te = ">") {
  let ne, re = "";
  for (let se = ee; se < $.length; se++) {
    let ie = $[se];
    if (ne)
      ie === ne && (ne = "");
    else if (ie === '"' || ie === "'")
      ne = ie;
    else if (ie === te[0])
      if (te[1]) {
        if ($[se + 1] === te[1])
          return {
            data: re,
            index: se
          };
      } else
        return {
          data: re,
          index: se
        };
    else
      ie === "	" && (ie = " ");
    re += ie;
  }
}
function findClosingIndex($, ee, te, ne) {
  const re = $.indexOf(ee, te);
  if (re === -1)
    throw new Error(ne);
  return re + ee.length - 1;
}
function readTagExp($, ee, te, ne = ">") {
  const re = tagExpWithClosingIndex($, ee + 1, ne);
  if (!re)
    return;
  let se = re.data;
  const ie = re.index, oe = se.search(/\s/);
  let le = se, ue = !0;
  if (oe !== -1 && (le = se.substr(0, oe).replace(/\s\s*$/, ""), se = se.substr(oe + 1)), te) {
    const de = le.indexOf(":");
    de !== -1 && (le = le.substr(de + 1), ue = le !== re.data.substr(de + 1));
  }
  return {
    tagName: le,
    tagExp: se,
    closeIndex: ie,
    attrExpPresent: ue
  };
}
function readStopNodeData($, ee, te) {
  const ne = te;
  let re = 1;
  for (; te < $.length; te++)
    if ($[te] === "<")
      if ($[te + 1] === "/") {
        const se = findClosingIndex($, ">", te, `${ee} is not closed`);
        if ($.substring(te + 2, se).trim() === ee && (re--, re === 0))
          return {
            tagContent: $.substring(ne, te),
            i: se
          };
        te = se;
      } else if ($[te + 1] === "?")
        te = findClosingIndex($, "?>", te + 1, "StopNode is not closed.");
      else if ($.substr(te + 1, 3) === "!--")
        te = findClosingIndex($, "-->", te + 3, "StopNode is not closed.");
      else if ($.substr(te + 1, 2) === "![")
        te = findClosingIndex($, "]]>", te, "StopNode is not closed.") - 2;
      else {
        const se = readTagExp($, te, ">");
        se && ((se && se.tagName) === ee && se.tagExp[se.tagExp.length - 1] !== "/" && re++, te = se.closeIndex);
      }
}
function parseValue($, ee, te) {
  if (ee && typeof $ == "string") {
    const ne = $.trim();
    return ne === "true" ? !0 : ne === "false" ? !1 : toNumber($, te);
  } else
    return util.isExist($) ? $ : "";
}
var OrderedObjParser_1 = OrderedObjParser$1, node2json = {};
function prettify$1($, ee) {
  return compress($, ee);
}
function compress($, ee, te) {
  let ne;
  const re = {};
  for (let se = 0; se < $.length; se++) {
    const ie = $[se], oe = propName$1(ie);
    let le = "";
    if (te === void 0 ? le = oe : le = te + "." + oe, oe === ee.textNodeName)
      ne === void 0 ? ne = ie[oe] : ne += "" + ie[oe];
    else {
      if (oe === void 0)
        continue;
      if (ie[oe]) {
        let ue = compress(ie[oe], ee, le);
        const de = isLeafTag(ue, ee);
        ie[":@"] ? assignAttributes(ue, ie[":@"], le, ee) : Object.keys(ue).length === 1 && ue[ee.textNodeName] !== void 0 && !ee.alwaysCreateTextNode ? ue = ue[ee.textNodeName] : Object.keys(ue).length === 0 && (ee.alwaysCreateTextNode ? ue[ee.textNodeName] = "" : ue = ""), re[oe] !== void 0 && re.hasOwnProperty(oe) ? (Array.isArray(re[oe]) || (re[oe] = [re[oe]]), re[oe].push(ue)) : ee.isArray(oe, le, de) ? re[oe] = [ue] : re[oe] = ue;
      }
    }
  }
  return typeof ne == "string" ? ne.length > 0 && (re[ee.textNodeName] = ne) : ne !== void 0 && (re[ee.textNodeName] = ne), re;
}
function propName$1($) {
  const ee = Object.keys($);
  for (let te = 0; te < ee.length; te++) {
    const ne = ee[te];
    if (ne !== ":@")
      return ne;
  }
}
function assignAttributes($, ee, te, ne) {
  if (ee) {
    const re = Object.keys(ee), se = re.length;
    for (let ie = 0; ie < se; ie++) {
      const oe = re[ie];
      ne.isArray(oe, te + "." + oe, !0, !0) ? $[oe] = [ee[oe]] : $[oe] = ee[oe];
    }
  }
}
function isLeafTag($, ee) {
  const { textNodeName: te } = ee, ne = Object.keys($).length;
  return !!(ne === 0 || ne === 1 && ($[te] || typeof $[te] == "boolean" || $[te] === 0));
}
node2json.prettify = prettify$1;
const { buildOptions } = OptionsBuilder, OrderedObjParser = OrderedObjParser_1, { prettify } = node2json, validator$1 = validator$2;
let XMLParser$1 = class {
  constructor(ee) {
    this.externalEntities = {}, this.options = buildOptions(ee);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(ee, te) {
    if (typeof ee != "string")
      if (ee.toString)
        ee = ee.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (te) {
      te === !0 && (te = {});
      const se = validator$1.validate(ee, te);
      if (se !== !0)
        throw Error(`${se.err.msg}:${se.err.line}:${se.err.col}`);
    }
    const ne = new OrderedObjParser(this.options);
    ne.addExternalEntities(this.externalEntities);
    const re = ne.parseXml(ee);
    return this.options.preserveOrder || re === void 0 ? re : prettify(re, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(ee, te) {
    if (te.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (ee.indexOf("&") !== -1 || ee.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (te === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[ee] = te;
  }
};
var XMLParser_1 = XMLParser$1;
const EOL = `
`;
function toXml($, ee) {
  let te = "";
  return ee.format && ee.indentBy.length > 0 && (te = EOL), arrToStr($, ee, "", te);
}
function arrToStr($, ee, te, ne) {
  let re = "", se = !1;
  for (let ie = 0; ie < $.length; ie++) {
    const oe = $[ie], le = propName(oe);
    let ue = "";
    if (te.length === 0 ? ue = le : ue = `${te}.${le}`, le === ee.textNodeName) {
      let me = oe[le];
      isStopNode(ue, ee) || (me = ee.tagValueProcessor(le, me), me = replaceEntitiesValue(me, ee)), se && (re += ne), re += me, se = !1;
      continue;
    } else if (le === ee.cdataPropName) {
      se && (re += ne), re += `<![CDATA[${oe[le][0][ee.textNodeName]}]]>`, se = !1;
      continue;
    } else if (le === ee.commentPropName) {
      re += ne + `<!--${oe[le][0][ee.textNodeName]}-->`, se = !0;
      continue;
    } else if (le[0] === "?") {
      const me = attr_to_str(oe[":@"], ee), ve = le === "?xml" ? "" : ne;
      let ge = oe[le][0][ee.textNodeName];
      ge = ge.length !== 0 ? " " + ge : "", re += ve + `<${le}${ge}${me}?>`, se = !0;
      continue;
    }
    let de = ne;
    de !== "" && (de += ee.indentBy);
    const fe = attr_to_str(oe[":@"], ee), pe = ne + `<${le}${fe}`, ye = arrToStr(oe[le], ee, ue, de);
    ee.unpairedTags.indexOf(le) !== -1 ? ee.suppressUnpairedNode ? re += pe + ">" : re += pe + "/>" : (!ye || ye.length === 0) && ee.suppressEmptyNode ? re += pe + "/>" : ye && ye.endsWith(">") ? re += pe + `>${ye}${ne}</${le}>` : (re += pe + ">", ye && ne !== "" && (ye.includes("/>") || ye.includes("</")) ? re += ne + ee.indentBy + ye + ne : re += ye, re += `</${le}>`), se = !0;
  }
  return re;
}
function propName($) {
  const ee = Object.keys($);
  for (let te = 0; te < ee.length; te++) {
    const ne = ee[te];
    if (ne !== ":@")
      return ne;
  }
}
function attr_to_str($, ee) {
  let te = "";
  if ($ && !ee.ignoreAttributes)
    for (let ne in $) {
      let re = ee.attributeValueProcessor(ne, $[ne]);
      re = replaceEntitiesValue(re, ee), re === !0 && ee.suppressBooleanAttributes ? te += ` ${ne.substr(ee.attributeNamePrefix.length)}` : te += ` ${ne.substr(ee.attributeNamePrefix.length)}="${re}"`;
    }
  return te;
}
function isStopNode($, ee) {
  $ = $.substr(0, $.length - ee.textNodeName.length - 1);
  let te = $.substr($.lastIndexOf(".") + 1);
  for (let ne in ee.stopNodes)
    if (ee.stopNodes[ne] === $ || ee.stopNodes[ne] === "*." + te)
      return !0;
  return !1;
}
function replaceEntitiesValue($, ee) {
  if ($ && $.length > 0 && ee.processEntities)
    for (let te = 0; te < ee.entities.length; te++) {
      const ne = ee.entities[te];
      $ = $.replace(ne.regex, ne.val);
    }
  return $;
}
var orderedJs2Xml = toXml;
const buildFromOrderedJs = orderedJs2Xml, defaultOptions = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function($, ee) {
    return ee;
  },
  attributeValueProcessor: function($, ee) {
    return ee;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function Builder($) {
  this.options = Object.assign({}, defaultOptions, $), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = isAttribute), this.processTextOrObjNode = processTextOrObjNode, this.options.format ? (this.indentate = indentate, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
Builder.prototype.build = function($) {
  return this.options.preserveOrder ? buildFromOrderedJs($, this.options) : (Array.isArray($) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && ($ = {
    [this.options.arrayNodeName]: $
  }), this.j2x($, 0).val);
};
Builder.prototype.j2x = function($, ee) {
  let te = "", ne = "";
  for (let re in $)
    if (!(typeof $[re] > "u"))
      if ($[re] === null)
        re[0] === "?" ? ne += this.indentate(ee) + "<" + re + "?" + this.tagEndChar : ne += this.indentate(ee) + "<" + re + "/" + this.tagEndChar;
      else if ($[re] instanceof Date)
        ne += this.buildTextValNode($[re], re, "", ee);
      else if (typeof $[re] != "object") {
        const se = this.isAttribute(re);
        if (se)
          te += this.buildAttrPairStr(se, "" + $[re]);
        else if (re === this.options.textNodeName) {
          let ie = this.options.tagValueProcessor(re, "" + $[re]);
          ne += this.replaceEntitiesValue(ie);
        } else
          ne += this.buildTextValNode($[re], re, "", ee);
      } else if (Array.isArray($[re])) {
        const se = $[re].length;
        let ie = "";
        for (let oe = 0; oe < se; oe++) {
          const le = $[re][oe];
          typeof le > "u" || (le === null ? re[0] === "?" ? ne += this.indentate(ee) + "<" + re + "?" + this.tagEndChar : ne += this.indentate(ee) + "<" + re + "/" + this.tagEndChar : typeof le == "object" ? this.options.oneListGroup ? ie += this.j2x(le, ee + 1).val : ie += this.processTextOrObjNode(le, re, ee) : ie += this.buildTextValNode(le, re, "", ee));
        }
        this.options.oneListGroup && (ie = this.buildObjectNode(ie, re, "", ee)), ne += ie;
      } else if (this.options.attributesGroupName && re === this.options.attributesGroupName) {
        const se = Object.keys($[re]), ie = se.length;
        for (let oe = 0; oe < ie; oe++)
          te += this.buildAttrPairStr(se[oe], "" + $[re][se[oe]]);
      } else
        ne += this.processTextOrObjNode($[re], re, ee);
  return { attrStr: te, val: ne };
};
Builder.prototype.buildAttrPairStr = function($, ee) {
  return ee = this.options.attributeValueProcessor($, "" + ee), ee = this.replaceEntitiesValue(ee), this.options.suppressBooleanAttributes && ee === "true" ? " " + $ : " " + $ + '="' + ee + '"';
};
function processTextOrObjNode($, ee, te) {
  const ne = this.j2x($, te + 1);
  return $[this.options.textNodeName] !== void 0 && Object.keys($).length === 1 ? this.buildTextValNode($[this.options.textNodeName], ee, ne.attrStr, te) : this.buildObjectNode(ne.val, ee, ne.attrStr, te);
}
Builder.prototype.buildObjectNode = function($, ee, te, ne) {
  if ($ === "")
    return ee[0] === "?" ? this.indentate(ne) + "<" + ee + te + "?" + this.tagEndChar : this.indentate(ne) + "<" + ee + te + this.closeTag(ee) + this.tagEndChar;
  {
    let re = "</" + ee + this.tagEndChar, se = "";
    return ee[0] === "?" && (se = "?", re = ""), te && $.indexOf("<") === -1 ? this.indentate(ne) + "<" + ee + te + se + ">" + $ + re : this.options.commentPropName !== !1 && ee === this.options.commentPropName && se.length === 0 ? this.indentate(ne) + `<!--${$}-->` + this.newLine : this.indentate(ne) + "<" + ee + te + se + this.tagEndChar + $ + this.indentate(ne) + re;
  }
};
Builder.prototype.closeTag = function($) {
  let ee = "";
  return this.options.unpairedTags.indexOf($) !== -1 ? this.options.suppressUnpairedNode || (ee = "/") : this.options.suppressEmptyNode ? ee = "/" : ee = `></${$}`, ee;
};
Builder.prototype.buildTextValNode = function($, ee, te, ne) {
  if (this.options.cdataPropName !== !1 && ee === this.options.cdataPropName)
    return this.indentate(ne) + `<![CDATA[${$}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && ee === this.options.commentPropName)
    return this.indentate(ne) + `<!--${$}-->` + this.newLine;
  if (ee[0] === "?")
    return this.indentate(ne) + "<" + ee + te + "?" + this.tagEndChar;
  {
    let re = this.options.tagValueProcessor(ee, $);
    return re = this.replaceEntitiesValue(re), re === "" ? this.indentate(ne) + "<" + ee + te + this.closeTag(ee) + this.tagEndChar : this.indentate(ne) + "<" + ee + te + ">" + re + "</" + ee + this.tagEndChar;
  }
};
Builder.prototype.replaceEntitiesValue = function($) {
  if ($ && $.length > 0 && this.options.processEntities)
    for (let ee = 0; ee < this.options.entities.length; ee++) {
      const te = this.options.entities[ee];
      $ = $.replace(te.regex, te.val);
    }
  return $;
};
function indentate($) {
  return this.options.indentBy.repeat($);
}
function isAttribute($) {
  return $.startsWith(this.options.attributeNamePrefix) ? $.substr(this.attrPrefixLen) : !1;
}
var json2xml = Builder;
const validator = validator$2, XMLParser = XMLParser_1, XMLBuilder = json2xml;
var fxp = {
  XMLParser,
  XMLValidator: validator,
  XMLBuilder
};
const parseXmlBody = ($, ee) => collectBodyString($, ee).then((te) => {
  if (te.length) {
    const ne = new fxp.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: !0,
      ignoreAttributes: !1,
      ignoreDeclaration: !0,
      parseTagValue: !1,
      trimValues: !1,
      tagValueProcessor: (le, ue) => ue.trim() === "" && ue.includes(`
`) ? "" : void 0
    });
    ne.addEntity("#xD", "\r"), ne.addEntity("#10", `
`);
    let re;
    try {
      re = ne.parse(te, !0);
    } catch (le) {
      throw le && typeof le == "object" && Object.defineProperty(le, "$responseBodyText", {
        value: te
      }), le;
    }
    const se = "#text", ie = Object.keys(re)[0], oe = re[ie];
    return oe[se] && (oe[ie] = oe[se], delete oe[se]), getValueFromTextNode(oe);
  }
  return {};
}), parseXmlErrorBody = async ($, ee) => {
  const te = await parseXmlBody($, ee);
  return te.Error && (te.Error.message = te.Error.message ?? te.Error.Message), te;
}, loadRestXmlErrorCode = ($, ee) => {
  var te;
  if (((te = ee == null ? void 0 : ee.Error) == null ? void 0 : te.Code) !== void 0)
    return ee.Error.Code;
  if ((ee == null ? void 0 : ee.Code) !== void 0)
    return ee.Code;
  if ($.statusCode == 404)
    return "NotFound";
};
class ObjectAlreadyInActiveTierError extends S3ServiceException {
  constructor(ee) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...ee
    }), this.name = "ObjectAlreadyInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
  }
}
var SelectObjectContentEventStream;
(function($) {
  $.visit = (ee, te) => ee.Records !== void 0 ? te.Records(ee.Records) : ee.Stats !== void 0 ? te.Stats(ee.Stats) : ee.Progress !== void 0 ? te.Progress(ee.Progress) : ee.Cont !== void 0 ? te.Cont(ee.Cont) : ee.End !== void 0 ? te.End(ee.End) : te._(ee.$unknown[0], ee.$unknown[1]);
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
const PutObjectOutputFilterSensitiveLog = ($) => ({
  ...$,
  ...$.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...$.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
}), PutObjectRequestFilterSensitiveLog = ($) => ({
  ...$,
  ...$.SSECustomerKey && { SSECustomerKey: SENSITIVE_STRING },
  ...$.SSEKMSKeyId && { SSEKMSKeyId: SENSITIVE_STRING },
  ...$.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: SENSITIVE_STRING }
}), se_CreateSessionCommand = async ($, ee) => {
  const te = requestBuilder($, ee), ne = map({}, isSerializableHeaderValue, {
    [_xacsm]: $[_SM]
  });
  te.bp("/"), te.p("Bucket", () => $.Bucket, "{Bucket}", !1);
  const re = map({
    [_s]: [, ""]
  });
  return te.m("GET").h(ne).q(re).b(void 0), te.build();
}, se_PutObjectCommand = async ($, ee) => {
  const te = requestBuilder($, ee), ne = map({}, isSerializableHeaderValue, {
    [_ct]: $[_CT] || "application/octet-stream",
    [_xaa]: $[_ACL],
    [_cc]: $[_CC],
    [_cd]: $[_CD],
    [_ce]: $[_CE],
    [_cl]: $[_CL],
    [_cl_]: [() => isSerializableHeaderValue($[_CLo]), () => $[_CLo].toString()],
    [_cm]: $[_CMD],
    [_xasca]: $[_CA],
    [_xacc]: $[_CCRC],
    [_xacc_]: $[_CCRCC],
    [_xacs]: $[_CSHA],
    [_xacs_]: $[_CSHAh],
    [_e]: [() => isSerializableHeaderValue($[_E]), () => dateToUtcString($[_E]).toString()],
    [_xagfc]: $[_GFC],
    [_xagr]: $[_GR],
    [_xagra]: $[_GRACP],
    [_xagwa]: $[_GWACP],
    [_xasse]: $[_SSE],
    [_xasc]: $[_SC],
    [_xawrl]: $[_WRL],
    [_xasseca]: $[_SSECA],
    [_xasseck]: $[_SSECK],
    [_xasseckm]: $[_SSECKMD],
    [_xasseakki]: $[_SSEKMSKI],
    [_xassec]: $[_SSEKMSEC],
    [_xassebke]: [() => isSerializableHeaderValue($[_BKE]), () => $[_BKE].toString()],
    [_xarp]: $[_RP],
    [_xat]: $[_T],
    [_xaolm]: $[_OLM],
    [_xaolrud]: [
      () => isSerializableHeaderValue($[_OLRUD]),
      () => ($[_OLRUD].toISOString().split(".")[0] + "Z").toString()
    ],
    [_xaollh]: $[_OLLHS],
    [_xaebo]: $[_EBO],
    ...$.Metadata !== void 0 && Object.keys($.Metadata).reduce((oe, le) => (oe[`x-amz-meta-${le.toLowerCase()}`] = $.Metadata[le], oe), {})
  });
  te.bp("/{Key+}"), te.p("Bucket", () => $.Bucket, "{Bucket}", !1), te.p("Key", () => $.Key, "{Key+}", !0);
  const re = map({
    [_xi]: [, "PutObject"]
  });
  let se, ie;
  return $.Body !== void 0 && (ie = $.Body, se = ie), te.m("PUT").h(ne).q(re).b(se), te.build();
}, de_CreateSessionCommand = async ($, ee) => {
  if ($.statusCode !== 200 && $.statusCode >= 300)
    return de_CommandError($, ee);
  const te = map({
    $metadata: deserializeMetadata($)
  }), ne = expectNonNull(expectObject(await parseXmlBody($.body, ee)), "body");
  return ne[_C] != null && (te[_C] = de_SessionCredentials(ne[_C])), te;
}, de_PutObjectCommand = async ($, ee) => {
  if ($.statusCode !== 200 && $.statusCode >= 300)
    return de_CommandError($, ee);
  const te = map({
    $metadata: deserializeMetadata($),
    [_Exp]: [, $.headers[_xae]],
    [_ETa]: [, $.headers[_eta]],
    [_CCRC]: [, $.headers[_xacc]],
    [_CCRCC]: [, $.headers[_xacc_]],
    [_CSHA]: [, $.headers[_xacs]],
    [_CSHAh]: [, $.headers[_xacs_]],
    [_SSE]: [, $.headers[_xasse]],
    [_VI]: [, $.headers[_xavi]],
    [_SSECA]: [, $.headers[_xasseca]],
    [_SSECKMD]: [, $.headers[_xasseckm]],
    [_SSEKMSKI]: [, $.headers[_xasseakki]],
    [_SSEKMSEC]: [, $.headers[_xassec]],
    [_BKE]: [() => $.headers[_xassebke] !== void 0, () => parseBoolean($.headers[_xassebke])],
    [_RC]: [, $.headers[_xarc]]
  });
  return await collectBody($.body, ee), te;
}, de_CommandError = async ($, ee) => {
  const te = {
    ...$,
    body: await parseXmlErrorBody($.body, ee)
  }, ne = loadRestXmlErrorCode($, te.body);
  switch (ne) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await de_NoSuchUploadRes(te);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await de_ObjectNotInActiveTierErrorRes(te);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await de_BucketAlreadyExistsRes(te);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await de_BucketAlreadyOwnedByYouRes(te);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await de_NoSuchBucketRes(te);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await de_InvalidObjectStateRes(te);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await de_NoSuchKeyRes(te);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await de_NotFoundRes(te);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await de_ObjectAlreadyInActiveTierErrorRes(te);
    default:
      const re = te.body;
      return throwDefaultError({
        output: $,
        parsedBody: re,
        errorCode: ne
      });
  }
}, throwDefaultError = withBaseException(S3ServiceException), de_BucketAlreadyExistsRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new BucketAlreadyExists({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_BucketAlreadyOwnedByYouRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new BucketAlreadyOwnedByYou({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_InvalidObjectStateRes = async ($, ee) => {
  const te = map({}), ne = $.body;
  ne[_AT] != null && (te[_AT] = expectString(ne[_AT])), ne[_SC] != null && (te[_SC] = expectString(ne[_SC]));
  const re = new InvalidObjectState({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(re, $.body);
}, de_NoSuchBucketRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new NoSuchBucket({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_NoSuchKeyRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new NoSuchKey({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_NoSuchUploadRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new NoSuchUpload({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_NotFoundRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new NotFound({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_ObjectAlreadyInActiveTierErrorRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new ObjectAlreadyInActiveTierError({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_ObjectNotInActiveTierErrorRes = async ($, ee) => {
  const te = map({});
  $.body;
  const ne = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata($),
    ...te
  });
  return decorateServiceException(ne, $.body);
}, de_SessionCredentials = ($, ee) => {
  const te = {};
  return $[_AKI] != null && (te[_AKI] = expectString($[_AKI])), $[_SAK] != null && (te[_SAK] = expectString($[_SAK])), $[_ST] != null && (te[_ST] = expectString($[_ST])), $[_Exp] != null && (te[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset($[_Exp]))), te;
}, deserializeMetadata = ($) => ({
  httpStatusCode: $.statusCode,
  requestId: $.headers["x-amzn-requestid"] ?? $.headers["x-amzn-request-id"] ?? $.headers["x-amz-request-id"],
  extendedRequestId: $.headers["x-amz-id-2"],
  cfId: $.headers["x-amz-cf-id"]
}), isSerializableHeaderValue = ($) => $ != null && $ !== "" && (!Object.getOwnPropertyNames($).includes("length") || $.length != 0) && (!Object.getOwnPropertyNames($).includes("size") || $.size != 0), _ACL = "ACL", _AKI = "AccessKeyId", _AT = "AccessTier", _BKE = "BucketKeyEnabled", _C = "Credentials", _CA = "ChecksumAlgorithm", _CC = "CacheControl", _CCRC = "ChecksumCRC32", _CCRCC = "ChecksumCRC32C", _CD = "ContentDisposition", _CE = "ContentEncoding", _CL = "ContentLanguage", _CLo = "ContentLength", _CMD = "ContentMD5", _CSHA = "ChecksumSHA1", _CSHAh = "ChecksumSHA256", _CT = "ContentType", _E = "Expires", _EBO = "ExpectedBucketOwner", _ETa = "ETag", _Exp = "Expiration", _GFC = "GrantFullControl", _GR = "GrantRead", _GRACP = "GrantReadACP", _GWACP = "GrantWriteACP", _OLLHS = "ObjectLockLegalHoldStatus", _OLM = "ObjectLockMode", _OLRUD = "ObjectLockRetainUntilDate", _RC = "RequestCharged", _RP = "RequestPayer", _SAK = "SecretAccessKey", _SC = "StorageClass", _SM = "SessionMode", _SSE = "ServerSideEncryption", _SSECA = "SSECustomerAlgorithm", _SSECK = "SSECustomerKey", _SSECKMD = "SSECustomerKeyMD5", _SSEKMSEC = "SSEKMSEncryptionContext", _SSEKMSKI = "SSEKMSKeyId", _ST = "SessionToken", _T = "Tagging", _VI = "VersionId", _WRL = "WebsiteRedirectLocation", _cc = "cache-control", _cd = "content-disposition", _ce = "content-encoding", _cl = "content-language", _cl_ = "content-length", _cm = "content-md5", _ct = "content-type", _e = "expires", _eta = "etag", _s = "session", _xaa = "x-amz-acl", _xacc = "x-amz-checksum-crc32", _xacc_ = "x-amz-checksum-crc32c", _xacs = "x-amz-checksum-sha1", _xacs_ = "x-amz-checksum-sha256", _xacsm = "x-amz-create-session-mode", _xae = "x-amz-expiration", _xaebo = "x-amz-expected-bucket-owner", _xagfc = "x-amz-grant-full-control", _xagr = "x-amz-grant-read", _xagra = "x-amz-grant-read-acp", _xagwa = "x-amz-grant-write-acp", _xaollh = "x-amz-object-lock-legal-hold", _xaolm = "x-amz-object-lock-mode", _xaolrud = "x-amz-object-lock-retain-until-date", _xarc = "x-amz-request-charged", _xarp = "x-amz-request-payer", _xasc = "x-amz-storage-class", _xasca = "x-amz-sdk-checksum-algorithm", _xasse = "x-amz-server-side-encryption", _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id", _xassebke = "x-amz-server-side-encryption-bucket-key-enabled", _xassec = "x-amz-server-side-encryption-context", _xasseca = "x-amz-server-side-encryption-customer-algorithm", _xasseck = "x-amz-server-side-encryption-customer-key", _xasseckm = "x-amz-server-side-encryption-customer-key-md5", _xat = "x-amz-tagging", _xavi = "x-amz-version-id", _xawrl = "x-amz-website-redirect-location", _xi = "x-id";
class CreateSessionCommand extends Command.classBuilder().ep({
  ...commonParams,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(ee, te, ne, re) {
  return [
    getSerdePlugin(ne, this.serialize, this.deserialize),
    getEndpointPlugin(ne, ee.getEndpointParameterInstructions())
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
}
const name = "@aws-sdk/client-s3", description = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native", version = "3.556.0", scripts = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "node ../../scripts/compilation/inline client-s3",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
  test: "yarn test:unit",
  "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
  "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
  "test:e2e:node": "jest --c jest.config.e2e.js",
  "test:unit": "ts-mocha test/unit/**/*.spec.ts"
}, main = "./dist-cjs/index.js", types = "./dist-types/index.d.ts", module = "./dist-es/index.js", sideEffects = !1, dependencies = {
  "@aws-crypto/sha1-browser": "3.0.0",
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sts": "3.556.0",
  "@aws-sdk/core": "3.556.0",
  "@aws-sdk/credential-provider-node": "3.556.0",
  "@aws-sdk/middleware-bucket-endpoint": "3.535.0",
  "@aws-sdk/middleware-expect-continue": "3.535.0",
  "@aws-sdk/middleware-flexible-checksums": "3.535.0",
  "@aws-sdk/middleware-host-header": "3.535.0",
  "@aws-sdk/middleware-location-constraint": "3.535.0",
  "@aws-sdk/middleware-logger": "3.535.0",
  "@aws-sdk/middleware-recursion-detection": "3.535.0",
  "@aws-sdk/middleware-sdk-s3": "3.556.0",
  "@aws-sdk/middleware-signing": "3.556.0",
  "@aws-sdk/middleware-ssec": "3.537.0",
  "@aws-sdk/middleware-user-agent": "3.540.0",
  "@aws-sdk/region-config-resolver": "3.535.0",
  "@aws-sdk/signature-v4-multi-region": "3.556.0",
  "@aws-sdk/types": "3.535.0",
  "@aws-sdk/util-endpoints": "3.540.0",
  "@aws-sdk/util-user-agent-browser": "3.535.0",
  "@aws-sdk/util-user-agent-node": "3.535.0",
  "@aws-sdk/xml-builder": "3.535.0",
  "@smithy/config-resolver": "^2.2.0",
  "@smithy/core": "^1.4.2",
  "@smithy/eventstream-serde-browser": "^2.2.0",
  "@smithy/eventstream-serde-config-resolver": "^2.2.0",
  "@smithy/eventstream-serde-node": "^2.2.0",
  "@smithy/fetch-http-handler": "^2.5.0",
  "@smithy/hash-blob-browser": "^2.2.0",
  "@smithy/hash-node": "^2.2.0",
  "@smithy/hash-stream-node": "^2.2.0",
  "@smithy/invalid-dependency": "^2.2.0",
  "@smithy/md5-js": "^2.2.0",
  "@smithy/middleware-content-length": "^2.2.0",
  "@smithy/middleware-endpoint": "^2.5.1",
  "@smithy/middleware-retry": "^2.3.1",
  "@smithy/middleware-serde": "^2.3.0",
  "@smithy/middleware-stack": "^2.2.0",
  "@smithy/node-config-provider": "^2.3.0",
  "@smithy/node-http-handler": "^2.5.0",
  "@smithy/protocol-http": "^3.3.0",
  "@smithy/smithy-client": "^2.5.1",
  "@smithy/types": "^2.12.0",
  "@smithy/url-parser": "^2.2.0",
  "@smithy/util-base64": "^2.3.0",
  "@smithy/util-body-length-browser": "^2.2.0",
  "@smithy/util-body-length-node": "^2.3.0",
  "@smithy/util-defaults-mode-browser": "^2.2.1",
  "@smithy/util-defaults-mode-node": "^2.3.1",
  "@smithy/util-endpoints": "^1.2.0",
  "@smithy/util-retry": "^2.2.0",
  "@smithy/util-stream": "^2.2.0",
  "@smithy/util-utf8": "^2.3.0",
  "@smithy/util-waiter": "^2.2.0",
  tslib: "^2.6.2"
}, devDependencies = {
  "@aws-sdk/signature-v4-crt": "3.556.0",
  "@smithy/service-client-documentation-generator": "^2.2.0",
  "@tsconfig/node14": "1.0.3",
  "@types/chai": "^4.2.11",
  "@types/mocha": "^8.0.4",
  "@types/node": "^14.14.31",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typescript: "~4.9.5"
}, engines = {
  node: ">=14.0.0"
}, typesVersions = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
}, files = [
  "dist-*/**"
], author = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
}, license = "Apache-2.0", browser$1 = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
}, homepage = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3", repository = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-s3"
}, packageInfo = {
  name,
  description,
  version,
  scripts,
  main,
  types,
  module,
  sideEffects,
  dependencies,
  devDependencies,
  engines,
  typesVersions,
  files,
  author,
  license,
  browser: browser$1,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage,
  repository
};
var build$7 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$6 = function($, ee) {
  return extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$6($, ee);
};
function __extends$6($, ee) {
  extendStatics$6($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$6 = function() {
  return __assign$6 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$6.apply(this, arguments);
};
function __rest$6($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$6($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$6($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$6($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$6($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$6($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$6($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$6($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$6($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$6($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$6() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$6(arguments[ee]));
  return $;
}
function __spreadArrays$6() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$6($) {
  return this instanceof __await$6 ? (this.v = $, this) : new __await$6($);
}
function __asyncGenerator$6($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$6 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$6($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$6($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$6($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$6 == "function" ? __values$6($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$6($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$6($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$6($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$6($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$6($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$6;
  },
  __asyncDelegator: __asyncDelegator$6,
  __asyncGenerator: __asyncGenerator$6,
  __asyncValues: __asyncValues$6,
  __await: __await$6,
  __awaiter: __awaiter$6,
  __classPrivateFieldGet: __classPrivateFieldGet$6,
  __classPrivateFieldSet: __classPrivateFieldSet$6,
  __createBinding: __createBinding$6,
  __decorate: __decorate$6,
  __exportStar: __exportStar$6,
  __extends: __extends$6,
  __generator: __generator$6,
  __importDefault: __importDefault$6,
  __importStar: __importStar$6,
  __makeTemplateObject: __makeTemplateObject$6,
  __metadata: __metadata$6,
  __param: __param$6,
  __read: __read$6,
  __rest: __rest$6,
  __spread: __spread$6,
  __spreadArrays: __spreadArrays$6,
  __values: __values$6
}, Symbol.toStringTag, { value: "Module" })), require$$0$6 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$6);
var crossPlatformSha1 = {}, ie11Sha1 = {}, isEmptyData$3 = {}, hasRequiredIsEmptyData$2;
function requireIsEmptyData$2() {
  if (hasRequiredIsEmptyData$2)
    return isEmptyData$3;
  hasRequiredIsEmptyData$2 = 1, Object.defineProperty(isEmptyData$3, "__esModule", { value: !0 }), isEmptyData$3.isEmptyData = void 0;
  function $(ee) {
    return typeof ee == "string" ? ee.length === 0 : ee.byteLength === 0;
  }
  return isEmptyData$3.isEmptyData = $, isEmptyData$3;
}
var constants$2 = {}, hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 }), $.EMPTY_DATA_SHA_1 = $.SHA_1_HMAC_ALGO = $.SHA_1_HASH = void 0, $.SHA_1_HASH = { name: "SHA-1" }, $.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: $.SHA_1_HASH
    }, $.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }(constants$2)), constants$2;
}
const fromUtf8$2 = ($) => {
  const ee = [];
  for (let te = 0, ne = $.length; te < ne; te++) {
    const re = $.charCodeAt(te);
    if (re < 128)
      ee.push(re);
    else if (re < 2048)
      ee.push(re >> 6 | 192, re & 63 | 128);
    else if (te + 1 < $.length && (re & 64512) === 55296 && ($.charCodeAt(te + 1) & 64512) === 56320) {
      const se = 65536 + ((re & 1023) << 10) + ($.charCodeAt(++te) & 1023);
      ee.push(se >> 18 | 240, se >> 12 & 63 | 128, se >> 6 & 63 | 128, se & 63 | 128);
    } else
      ee.push(re >> 12 | 224, re >> 6 & 63 | 128, re & 63 | 128);
  }
  return Uint8Array.from(ee);
}, toUtf8$2 = ($) => {
  let ee = "";
  for (let te = 0, ne = $.length; te < ne; te++) {
    const re = $[te];
    if (re < 128)
      ee += String.fromCharCode(re);
    else if (192 <= re && re < 224) {
      const se = $[++te];
      ee += String.fromCharCode((re & 31) << 6 | se & 63);
    } else if (240 <= re && re < 365) {
      const ie = "%" + [re, $[++te], $[++te], $[++te]].map((oe) => oe.toString(16)).join("%");
      ee += decodeURIComponent(ie);
    } else
      ee += String.fromCharCode((re & 15) << 12 | ($[++te] & 63) << 6 | $[++te] & 63);
  }
  return ee;
};
function fromUtf8$1($) {
  return new TextEncoder().encode($);
}
function toUtf8$1($) {
  return new TextDecoder("utf-8").decode($);
}
const fromUtf8 = ($) => typeof TextEncoder == "function" ? fromUtf8$1($) : fromUtf8$2($), toUtf8 = ($) => typeof TextDecoder == "function" ? toUtf8$1($) : toUtf8$2($), distEs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromUtf8,
  toUtf8
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(distEs$1), fallbackWindow = {};
function locateWindow() {
  return typeof window < "u" ? window : typeof self < "u" ? self : fallbackWindow;
}
const distEs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  locateWindow
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(distEs);
var hasRequiredIe11Sha1;
function requireIe11Sha1() {
  if (hasRequiredIe11Sha1)
    return ie11Sha1;
  hasRequiredIe11Sha1 = 1, Object.defineProperty(ie11Sha1, "__esModule", { value: !0 }), ie11Sha1.Sha1 = void 0;
  var $ = requireIsEmptyData$2(), ee = requireConstants$2(), te = require$$2, ne = require$$5, re = (
    /** @class */
    function() {
      function oe(le) {
        this.secret = le, this.reset();
      }
      return oe.prototype.update = function(le) {
        var ue = this;
        (0, $.isEmptyData)(le) || (this.operation = this.operation.then(function(de) {
          return de.onerror = function() {
            ue.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, de.process(ie(le)), de;
        }), this.operation.catch(function() {
        }));
      }, oe.prototype.digest = function() {
        return this.operation.then(function(le) {
          return new Promise(function(ue, de) {
            le.onerror = function() {
              de(new Error("Error encountered finalizing hash"));
            }, le.oncomplete = function() {
              le.result && ue(new Uint8Array(le.result)), de(new Error("Error encountered finalizing hash"));
            }, le.finish();
          });
        });
      }, oe.prototype.reset = function() {
        this.secret ? (this.operation = se(this.secret).then(function(le) {
          return (0, ne.locateWindow)().msCrypto.subtle.sign(ee.SHA_1_HMAC_ALGO, le);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, ne.locateWindow)().msCrypto.subtle.digest("SHA-1"));
      }, oe;
    }()
  );
  ie11Sha1.Sha1 = re;
  function se(oe) {
    return new Promise(function(le, ue) {
      var de = (0, ne.locateWindow)().msCrypto.subtle.importKey("raw", ie(oe), ee.SHA_1_HMAC_ALGO, !1, ["sign"]);
      de.oncomplete = function() {
        de.result && le(de.result), ue(new Error("ImportKey completed without importing key."));
      }, de.onerror = function() {
        ue(new Error("ImportKey failed to import key."));
      };
    });
  }
  function ie(oe) {
    return typeof oe == "string" ? (0, te.fromUtf8)(oe) : ArrayBuffer.isView(oe) ? new Uint8Array(oe.buffer, oe.byteOffset, oe.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(oe);
  }
  return ie11Sha1;
}
var webCryptoSha1 = {}, hasRequiredWebCryptoSha1;
function requireWebCryptoSha1() {
  if (hasRequiredWebCryptoSha1)
    return webCryptoSha1;
  hasRequiredWebCryptoSha1 = 1, Object.defineProperty(webCryptoSha1, "__esModule", { value: !0 }), webCryptoSha1.Sha1 = void 0;
  var $ = require$$2, ee = requireIsEmptyData$2(), te = requireConstants$2(), ne = require$$5, re = (
    /** @class */
    function() {
      function ie(oe) {
        this.toHash = new Uint8Array(0), oe !== void 0 && (this.key = new Promise(function(le, ue) {
          (0, ne.locateWindow)().crypto.subtle.importKey("raw", se(oe), te.SHA_1_HMAC_ALGO, !1, ["sign"]).then(le, ue);
        }), this.key.catch(function() {
        }));
      }
      return ie.prototype.update = function(oe) {
        if (!(0, ee.isEmptyData)(oe)) {
          var le = se(oe), ue = new Uint8Array(this.toHash.byteLength + le.byteLength);
          ue.set(this.toHash, 0), ue.set(le, this.toHash.byteLength), this.toHash = ue;
        }
      }, ie.prototype.digest = function() {
        var oe = this;
        return this.key ? this.key.then(function(le) {
          return (0, ne.locateWindow)().crypto.subtle.sign(te.SHA_1_HMAC_ALGO, le, oe.toHash).then(function(ue) {
            return new Uint8Array(ue);
          });
        }) : (0, ee.isEmptyData)(this.toHash) ? Promise.resolve(te.EMPTY_DATA_SHA_1) : Promise.resolve().then(function() {
          return (0, ne.locateWindow)().crypto.subtle.digest(te.SHA_1_HASH, oe.toHash);
        }).then(function(le) {
          return Promise.resolve(new Uint8Array(le));
        });
      }, ie.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      }, ie;
    }()
  );
  webCryptoSha1.Sha1 = re;
  function se(ie) {
    return typeof ie == "string" ? (0, $.fromUtf8)(ie) : ArrayBuffer.isView(ie) ? new Uint8Array(ie.buffer, ie.byteOffset, ie.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(ie);
  }
  return webCryptoSha1;
}
var build$6 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$5 = function($, ee) {
  return extendStatics$5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$5($, ee);
};
function __extends$5($, ee) {
  extendStatics$5($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$5 = function() {
  return __assign$5 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$5.apply(this, arguments);
};
function __rest$5($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$5($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$5($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$5($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$5($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$5($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$5($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$5($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$5($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$5($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$5() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$5(arguments[ee]));
  return $;
}
function __spreadArrays$5() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$5($) {
  return this instanceof __await$5 ? (this.v = $, this) : new __await$5($);
}
function __asyncGenerator$5($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$5 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$5($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$5($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$5($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$5 == "function" ? __values$5($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$5($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$5($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$5($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$5($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$5($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$5;
  },
  __asyncDelegator: __asyncDelegator$5,
  __asyncGenerator: __asyncGenerator$5,
  __asyncValues: __asyncValues$5,
  __await: __await$5,
  __awaiter: __awaiter$5,
  __classPrivateFieldGet: __classPrivateFieldGet$5,
  __classPrivateFieldSet: __classPrivateFieldSet$5,
  __createBinding: __createBinding$5,
  __decorate: __decorate$5,
  __exportStar: __exportStar$5,
  __extends: __extends$5,
  __generator: __generator$5,
  __importDefault: __importDefault$5,
  __importStar: __importStar$5,
  __makeTemplateObject: __makeTemplateObject$5,
  __metadata: __metadata$5,
  __param: __param$5,
  __read: __read$5,
  __rest: __rest$5,
  __spread: __spread$5,
  __spreadArrays: __spreadArrays$5,
  __values: __values$5
}, Symbol.toStringTag, { value: "Module" })), require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$5);
var supportsWebCrypto = {}, hasRequiredSupportsWebCrypto;
function requireSupportsWebCrypto() {
  if (hasRequiredSupportsWebCrypto)
    return supportsWebCrypto;
  hasRequiredSupportsWebCrypto = 1, Object.defineProperty(supportsWebCrypto, "__esModule", { value: !0 }), supportsWebCrypto.supportsZeroByteGCM = supportsWebCrypto.supportsSubtleCrypto = supportsWebCrypto.supportsSecureRandom = supportsWebCrypto.supportsWebCrypto = void 0;
  var $ = require$$0$5, ee = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function te(ie) {
    if (ne(ie) && typeof ie.crypto.subtle == "object") {
      var oe = ie.crypto.subtle;
      return re(oe);
    }
    return !1;
  }
  supportsWebCrypto.supportsWebCrypto = te;
  function ne(ie) {
    if (typeof ie == "object" && typeof ie.crypto == "object") {
      var oe = ie.crypto.getRandomValues;
      return typeof oe == "function";
    }
    return !1;
  }
  supportsWebCrypto.supportsSecureRandom = ne;
  function re(ie) {
    return ie && ee.every(function(oe) {
      return typeof ie[oe] == "function";
    });
  }
  supportsWebCrypto.supportsSubtleCrypto = re;
  function se(ie) {
    return $.__awaiter(this, void 0, void 0, function() {
      var oe, le;
      return $.__generator(this, function(ue) {
        switch (ue.label) {
          case 0:
            if (!re(ie))
              return [2, !1];
            ue.label = 1;
          case 1:
            return ue.trys.push([1, 4, , 5]), [4, ie.generateKey({ name: "AES-GCM", length: 128 }, !1, ["encrypt"])];
          case 2:
            return oe = ue.sent(), [4, ie.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, oe, new Uint8Array(0))];
          case 3:
            return le = ue.sent(), [2, le.byteLength === 16];
          case 4:
            return ue.sent(), [2, !1];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return supportsWebCrypto.supportsZeroByteGCM = se, supportsWebCrypto;
}
var hasRequiredBuild$5;
function requireBuild$5() {
  return hasRequiredBuild$5 || (hasRequiredBuild$5 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 });
    var ee = require$$0$5;
    ee.__exportStar(requireSupportsWebCrypto(), $);
  }(build$6)), build$6;
}
var build$5 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$4 = function($, ee) {
  return extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$4($, ee);
};
function __extends$4($, ee) {
  extendStatics$4($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$4 = function() {
  return __assign$4 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$4.apply(this, arguments);
};
function __rest$4($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$4($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$4($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$4($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$4($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$4($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$4($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$4($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$4($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$4($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$4() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$4(arguments[ee]));
  return $;
}
function __spreadArrays$4() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$4($) {
  return this instanceof __await$4 ? (this.v = $, this) : new __await$4($);
}
function __asyncGenerator$4($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$4 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$4($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$4($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$4($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$4 == "function" ? __values$4($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$4($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$4($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$4($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$4($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$4($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$4;
  },
  __asyncDelegator: __asyncDelegator$4,
  __asyncGenerator: __asyncGenerator$4,
  __asyncValues: __asyncValues$4,
  __await: __await$4,
  __awaiter: __awaiter$4,
  __classPrivateFieldGet: __classPrivateFieldGet$4,
  __classPrivateFieldSet: __classPrivateFieldSet$4,
  __createBinding: __createBinding$4,
  __decorate: __decorate$4,
  __exportStar: __exportStar$4,
  __extends: __extends$4,
  __generator: __generator$4,
  __importDefault: __importDefault$4,
  __importStar: __importStar$4,
  __makeTemplateObject: __makeTemplateObject$4,
  __metadata: __metadata$4,
  __param: __param$4,
  __read: __read$4,
  __rest: __rest$4,
  __spread: __spread$4,
  __spreadArrays: __spreadArrays$4,
  __values: __values$4
}, Symbol.toStringTag, { value: "Module" })), require$$0$4 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$4);
var CryptoOperation = {}, hasRequiredCryptoOperation;
function requireCryptoOperation() {
  return hasRequiredCryptoOperation || (hasRequiredCryptoOperation = 1, Object.defineProperty(CryptoOperation, "__esModule", { value: !0 })), CryptoOperation;
}
var Key = {}, hasRequiredKey;
function requireKey() {
  return hasRequiredKey || (hasRequiredKey = 1, Object.defineProperty(Key, "__esModule", { value: !0 })), Key;
}
var KeyOperation = {}, hasRequiredKeyOperation;
function requireKeyOperation() {
  return hasRequiredKeyOperation || (hasRequiredKeyOperation = 1, Object.defineProperty(KeyOperation, "__esModule", { value: !0 })), KeyOperation;
}
var MsSubtleCrypto = {}, hasRequiredMsSubtleCrypto;
function requireMsSubtleCrypto() {
  return hasRequiredMsSubtleCrypto || (hasRequiredMsSubtleCrypto = 1, Object.defineProperty(MsSubtleCrypto, "__esModule", { value: !0 })), MsSubtleCrypto;
}
var MsWindow = {}, hasRequiredMsWindow;
function requireMsWindow() {
  if (hasRequiredMsWindow)
    return MsWindow;
  hasRequiredMsWindow = 1, Object.defineProperty(MsWindow, "__esModule", { value: !0 }), MsWindow.isMsWindow = void 0;
  var $ = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function ee(ne) {
    return "MSInputMethodContext" in ne && "msCrypto" in ne;
  }
  function te(ne) {
    if (ee(ne) && ne.msCrypto.subtle !== void 0) {
      var re = ne.msCrypto, se = re.getRandomValues, ie = re.subtle;
      return $.map(function(oe) {
        return ie[oe];
      }).concat(se).every(function(oe) {
        return typeof oe == "function";
      });
    }
    return !1;
  }
  return MsWindow.isMsWindow = te, MsWindow;
}
var hasRequiredBuild$4;
function requireBuild$4() {
  return hasRequiredBuild$4 || (hasRequiredBuild$4 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 });
    var ee = require$$0$4;
    ee.__exportStar(requireCryptoOperation(), $), ee.__exportStar(requireKey(), $), ee.__exportStar(requireKeyOperation(), $), ee.__exportStar(requireMsSubtleCrypto(), $), ee.__exportStar(requireMsWindow(), $);
  }(build$5)), build$5;
}
var build$4 = {}, convertToBuffer$1 = {}, hasRequiredConvertToBuffer;
function requireConvertToBuffer() {
  if (hasRequiredConvertToBuffer)
    return convertToBuffer$1;
  hasRequiredConvertToBuffer = 1, Object.defineProperty(convertToBuffer$1, "__esModule", { value: !0 }), convertToBuffer$1.convertToBuffer = void 0;
  var $ = require$$2, ee = typeof Buffer < "u" && Buffer.from ? function(ne) {
    return Buffer.from(ne, "utf8");
  } : $.fromUtf8;
  function te(ne) {
    return ne instanceof Uint8Array ? ne : typeof ne == "string" ? ee(ne) : ArrayBuffer.isView(ne) ? new Uint8Array(ne.buffer, ne.byteOffset, ne.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(ne);
  }
  return convertToBuffer$1.convertToBuffer = te, convertToBuffer$1;
}
var isEmptyData$2 = {}, hasRequiredIsEmptyData$1;
function requireIsEmptyData$1() {
  if (hasRequiredIsEmptyData$1)
    return isEmptyData$2;
  hasRequiredIsEmptyData$1 = 1, Object.defineProperty(isEmptyData$2, "__esModule", { value: !0 }), isEmptyData$2.isEmptyData = void 0;
  function $(ee) {
    return typeof ee == "string" ? ee.length === 0 : ee.byteLength === 0;
  }
  return isEmptyData$2.isEmptyData = $, isEmptyData$2;
}
var numToUint8 = {}, hasRequiredNumToUint8;
function requireNumToUint8() {
  if (hasRequiredNumToUint8)
    return numToUint8;
  hasRequiredNumToUint8 = 1, Object.defineProperty(numToUint8, "__esModule", { value: !0 }), numToUint8.numToUint8 = void 0;
  function $(ee) {
    return new Uint8Array([
      (ee & 4278190080) >> 24,
      (ee & 16711680) >> 16,
      (ee & 65280) >> 8,
      ee & 255
    ]);
  }
  return numToUint8.numToUint8 = $, numToUint8;
}
var uint32ArrayFrom = {}, hasRequiredUint32ArrayFrom;
function requireUint32ArrayFrom() {
  if (hasRequiredUint32ArrayFrom)
    return uint32ArrayFrom;
  hasRequiredUint32ArrayFrom = 1, Object.defineProperty(uint32ArrayFrom, "__esModule", { value: !0 }), uint32ArrayFrom.uint32ArrayFrom = void 0;
  function $(ee) {
    if (!Uint32Array.from) {
      for (var te = new Uint32Array(ee.length), ne = 0; ne < ee.length; )
        te[ne] = ee[ne], ne += 1;
      return te;
    }
    return Uint32Array.from(ee);
  }
  return uint32ArrayFrom.uint32ArrayFrom = $, uint32ArrayFrom;
}
var hasRequiredBuild$3;
function requireBuild$3() {
  return hasRequiredBuild$3 || (hasRequiredBuild$3 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 }), $.uint32ArrayFrom = $.numToUint8 = $.isEmptyData = $.convertToBuffer = void 0;
    var ee = requireConvertToBuffer();
    Object.defineProperty($, "convertToBuffer", { enumerable: !0, get: function() {
      return ee.convertToBuffer;
    } });
    var te = requireIsEmptyData$1();
    Object.defineProperty($, "isEmptyData", { enumerable: !0, get: function() {
      return te.isEmptyData;
    } });
    var ne = requireNumToUint8();
    Object.defineProperty($, "numToUint8", { enumerable: !0, get: function() {
      return ne.numToUint8;
    } });
    var re = requireUint32ArrayFrom();
    Object.defineProperty($, "uint32ArrayFrom", { enumerable: !0, get: function() {
      return re.uint32ArrayFrom;
    } });
  }(build$4)), build$4;
}
var hasRequiredCrossPlatformSha1;
function requireCrossPlatformSha1() {
  if (hasRequiredCrossPlatformSha1)
    return crossPlatformSha1;
  hasRequiredCrossPlatformSha1 = 1, Object.defineProperty(crossPlatformSha1, "__esModule", { value: !0 }), crossPlatformSha1.Sha1 = void 0;
  var $ = requireIe11Sha1(), ee = requireWebCryptoSha1(), te = requireBuild$5(), ne = requireBuild$4(), re = require$$5, se = requireBuild$3(), ie = (
    /** @class */
    function() {
      function oe(le) {
        if ((0, te.supportsWebCrypto)((0, re.locateWindow)()))
          this.hash = new ee.Sha1(le);
        else if ((0, ne.isMsWindow)((0, re.locateWindow)()))
          this.hash = new $.Sha1(le);
        else
          throw new Error("SHA1 not supported");
      }
      return oe.prototype.update = function(le, ue) {
        this.hash.update((0, se.convertToBuffer)(le));
      }, oe.prototype.digest = function() {
        return this.hash.digest();
      }, oe.prototype.reset = function() {
        this.hash.reset();
      }, oe;
    }()
  );
  return crossPlatformSha1.Sha1 = ie, crossPlatformSha1;
}
(function($) {
  Object.defineProperty($, "__esModule", { value: !0 }), $.WebCryptoSha1 = $.Ie11Sha1 = void 0;
  var ee = require$$0$6;
  ee.__exportStar(requireCrossPlatformSha1(), $);
  var te = requireIe11Sha1();
  Object.defineProperty($, "Ie11Sha1", { enumerable: !0, get: function() {
    return te.Sha1;
  } });
  var ne = requireWebCryptoSha1();
  Object.defineProperty($, "WebCryptoSha1", { enumerable: !0, get: function() {
    return ne.Sha1;
  } });
})(build$7);
var build$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$3 = function($, ee) {
  return extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$3($, ee);
};
function __extends$3($, ee) {
  extendStatics$3($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$3 = function() {
  return __assign$3 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$3.apply(this, arguments);
};
function __rest$3($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$3($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$3($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$3($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$3($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$3($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$3($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$3($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$3($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$3($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$3() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$3(arguments[ee]));
  return $;
}
function __spreadArrays$3() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$3($) {
  return this instanceof __await$3 ? (this.v = $, this) : new __await$3($);
}
function __asyncGenerator$3($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$3 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$3($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$3($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$3($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$3 == "function" ? __values$3($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$3($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$3($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$3($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$3($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$3($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$3;
  },
  __asyncDelegator: __asyncDelegator$3,
  __asyncGenerator: __asyncGenerator$3,
  __asyncValues: __asyncValues$3,
  __await: __await$3,
  __awaiter: __awaiter$3,
  __classPrivateFieldGet: __classPrivateFieldGet$3,
  __classPrivateFieldSet: __classPrivateFieldSet$3,
  __createBinding: __createBinding$3,
  __decorate: __decorate$3,
  __exportStar: __exportStar$3,
  __extends: __extends$3,
  __generator: __generator$3,
  __importDefault: __importDefault$3,
  __importStar: __importStar$3,
  __makeTemplateObject: __makeTemplateObject$3,
  __metadata: __metadata$3,
  __param: __param$3,
  __read: __read$3,
  __rest: __rest$3,
  __spread: __spread$3,
  __spreadArrays: __spreadArrays$3,
  __values: __values$3
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$3);
var crossPlatformSha256 = {}, ie11Sha256 = {}, isEmptyData$1 = {}, hasRequiredIsEmptyData;
function requireIsEmptyData() {
  if (hasRequiredIsEmptyData)
    return isEmptyData$1;
  hasRequiredIsEmptyData = 1, Object.defineProperty(isEmptyData$1, "__esModule", { value: !0 }), isEmptyData$1.isEmptyData = void 0;
  function $(ee) {
    return typeof ee == "string" ? ee.length === 0 : ee.byteLength === 0;
  }
  return isEmptyData$1.isEmptyData = $, isEmptyData$1;
}
var constants$1 = {}, hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 }), $.EMPTY_DATA_SHA_256 = $.SHA_256_HMAC_ALGO = $.SHA_256_HASH = void 0, $.SHA_256_HASH = { name: "SHA-256" }, $.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: $.SHA_256_HASH
    }, $.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }(constants$1)), constants$1;
}
var hasRequiredIe11Sha256;
function requireIe11Sha256() {
  if (hasRequiredIe11Sha256)
    return ie11Sha256;
  hasRequiredIe11Sha256 = 1, Object.defineProperty(ie11Sha256, "__esModule", { value: !0 }), ie11Sha256.Sha256 = void 0;
  var $ = requireIsEmptyData(), ee = requireConstants$1(), te = require$$2, ne = require$$5, re = (
    /** @class */
    function() {
      function oe(le) {
        this.secret = le, this.reset();
      }
      return oe.prototype.update = function(le) {
        var ue = this;
        (0, $.isEmptyData)(le) || (this.operation = this.operation.then(function(de) {
          return de.onerror = function() {
            ue.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, de.process(ie(le)), de;
        }), this.operation.catch(function() {
        }));
      }, oe.prototype.digest = function() {
        return this.operation.then(function(le) {
          return new Promise(function(ue, de) {
            le.onerror = function() {
              de(new Error("Error encountered finalizing hash"));
            }, le.oncomplete = function() {
              le.result && ue(new Uint8Array(le.result)), de(new Error("Error encountered finalizing hash"));
            }, le.finish();
          });
        });
      }, oe.prototype.reset = function() {
        this.secret ? (this.operation = se(this.secret).then(function(le) {
          return (0, ne.locateWindow)().msCrypto.subtle.sign(ee.SHA_256_HMAC_ALGO, le);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, ne.locateWindow)().msCrypto.subtle.digest("SHA-256"));
      }, oe;
    }()
  );
  ie11Sha256.Sha256 = re;
  function se(oe) {
    return new Promise(function(le, ue) {
      var de = (0, ne.locateWindow)().msCrypto.subtle.importKey("raw", ie(oe), ee.SHA_256_HMAC_ALGO, !1, ["sign"]);
      de.oncomplete = function() {
        de.result && le(de.result), ue(new Error("ImportKey completed without importing key."));
      }, de.onerror = function() {
        ue(new Error("ImportKey failed to import key."));
      };
    });
  }
  function ie(oe) {
    return typeof oe == "string" ? (0, te.fromUtf8)(oe) : ArrayBuffer.isView(oe) ? new Uint8Array(oe.buffer, oe.byteOffset, oe.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(oe);
  }
  return ie11Sha256;
}
var webCryptoSha256 = {}, hasRequiredWebCryptoSha256;
function requireWebCryptoSha256() {
  if (hasRequiredWebCryptoSha256)
    return webCryptoSha256;
  hasRequiredWebCryptoSha256 = 1, Object.defineProperty(webCryptoSha256, "__esModule", { value: !0 }), webCryptoSha256.Sha256 = void 0;
  var $ = requireBuild$3(), ee = requireConstants$1(), te = require$$5, ne = (
    /** @class */
    function() {
      function re(se) {
        this.toHash = new Uint8Array(0), this.secret = se, this.reset();
      }
      return re.prototype.update = function(se) {
        if (!(0, $.isEmptyData)(se)) {
          var ie = (0, $.convertToBuffer)(se), oe = new Uint8Array(this.toHash.byteLength + ie.byteLength);
          oe.set(this.toHash, 0), oe.set(ie, this.toHash.byteLength), this.toHash = oe;
        }
      }, re.prototype.digest = function() {
        var se = this;
        return this.key ? this.key.then(function(ie) {
          return (0, te.locateWindow)().crypto.subtle.sign(ee.SHA_256_HMAC_ALGO, ie, se.toHash).then(function(oe) {
            return new Uint8Array(oe);
          });
        }) : (0, $.isEmptyData)(this.toHash) ? Promise.resolve(ee.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
          return (0, te.locateWindow)().crypto.subtle.digest(ee.SHA_256_HASH, se.toHash);
        }).then(function(ie) {
          return Promise.resolve(new Uint8Array(ie));
        });
      }, re.prototype.reset = function() {
        var se = this;
        this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(ie, oe) {
          (0, te.locateWindow)().crypto.subtle.importKey("raw", (0, $.convertToBuffer)(se.secret), ee.SHA_256_HMAC_ALGO, !1, ["sign"]).then(ie, oe);
        }), this.key.catch(function() {
        }));
      }, re;
    }()
  );
  return webCryptoSha256.Sha256 = ne, webCryptoSha256;
}
var build$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function($, ee) {
  return extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$2($, ee);
};
function __extends$2($, ee) {
  extendStatics$2($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$2 = function() {
  return __assign$2 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$2.apply(this, arguments);
};
function __rest$2($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$2($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$2($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$2($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$2($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$2($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$2($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$2($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$2($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$2($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$2() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$2(arguments[ee]));
  return $;
}
function __spreadArrays$2() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$2($) {
  return this instanceof __await$2 ? (this.v = $, this) : new __await$2($);
}
function __asyncGenerator$2($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$2 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$2($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$2($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$2($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$2 == "function" ? __values$2($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$2($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$2($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$2($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$2($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$2($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$2;
  },
  __asyncDelegator: __asyncDelegator$2,
  __asyncGenerator: __asyncGenerator$2,
  __asyncValues: __asyncValues$2,
  __await: __await$2,
  __awaiter: __awaiter$2,
  __classPrivateFieldGet: __classPrivateFieldGet$2,
  __classPrivateFieldSet: __classPrivateFieldSet$2,
  __createBinding: __createBinding$2,
  __decorate: __decorate$2,
  __exportStar: __exportStar$2,
  __extends: __extends$2,
  __generator: __generator$2,
  __importDefault: __importDefault$2,
  __importStar: __importStar$2,
  __makeTemplateObject: __makeTemplateObject$2,
  __metadata: __metadata$2,
  __param: __param$2,
  __read: __read$2,
  __rest: __rest$2,
  __spread: __spread$2,
  __spreadArrays: __spreadArrays$2,
  __values: __values$2
}, Symbol.toStringTag, { value: "Module" })), require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$2);
var jsSha256 = {}, constants = {}, hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, Object.defineProperty(constants, "__esModule", { value: !0 }), constants.MAX_HASHABLE_LENGTH = constants.INIT = constants.KEY = constants.DIGEST_LENGTH = constants.BLOCK_SIZE = void 0, constants.BLOCK_SIZE = 64, constants.DIGEST_LENGTH = 32, constants.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), constants.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], constants.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1), constants;
}
var RawSha256 = {}, hasRequiredRawSha256;
function requireRawSha256() {
  if (hasRequiredRawSha256)
    return RawSha256;
  hasRequiredRawSha256 = 1, Object.defineProperty(RawSha256, "__esModule", { value: !0 }), RawSha256.RawSha256 = void 0;
  var $ = requireConstants(), ee = (
    /** @class */
    function() {
      function te() {
        this.state = Int32Array.from($.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
      }
      return te.prototype.update = function(ne) {
        if (this.finished)
          throw new Error("Attempted to update an already finished hash.");
        var re = 0, se = ne.byteLength;
        if (this.bytesHashed += se, this.bytesHashed * 8 > $.MAX_HASHABLE_LENGTH)
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; se > 0; )
          this.buffer[this.bufferLength++] = ne[re++], se--, this.bufferLength === $.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
      }, te.prototype.digest = function() {
        if (!this.finished) {
          var ne = this.bytesHashed * 8, re = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), se = this.bufferLength;
          if (re.setUint8(this.bufferLength++, 128), se % $.BLOCK_SIZE >= $.BLOCK_SIZE - 8) {
            for (var ie = this.bufferLength; ie < $.BLOCK_SIZE; ie++)
              re.setUint8(ie, 0);
            this.hashBuffer(), this.bufferLength = 0;
          }
          for (var ie = this.bufferLength; ie < $.BLOCK_SIZE - 8; ie++)
            re.setUint8(ie, 0);
          re.setUint32($.BLOCK_SIZE - 8, Math.floor(ne / 4294967296), !0), re.setUint32($.BLOCK_SIZE - 4, ne), this.hashBuffer(), this.finished = !0;
        }
        for (var oe = new Uint8Array($.DIGEST_LENGTH), ie = 0; ie < 8; ie++)
          oe[ie * 4] = this.state[ie] >>> 24 & 255, oe[ie * 4 + 1] = this.state[ie] >>> 16 & 255, oe[ie * 4 + 2] = this.state[ie] >>> 8 & 255, oe[ie * 4 + 3] = this.state[ie] >>> 0 & 255;
        return oe;
      }, te.prototype.hashBuffer = function() {
        for (var ne = this, re = ne.buffer, se = ne.state, ie = se[0], oe = se[1], le = se[2], ue = se[3], de = se[4], fe = se[5], pe = se[6], ye = se[7], me = 0; me < $.BLOCK_SIZE; me++) {
          if (me < 16)
            this.temp[me] = (re[me * 4] & 255) << 24 | (re[me * 4 + 1] & 255) << 16 | (re[me * 4 + 2] & 255) << 8 | re[me * 4 + 3] & 255;
          else {
            var ve = this.temp[me - 2], ge = (ve >>> 17 | ve << 15) ^ (ve >>> 19 | ve << 13) ^ ve >>> 10;
            ve = this.temp[me - 15];
            var xe = (ve >>> 7 | ve << 25) ^ (ve >>> 18 | ve << 14) ^ ve >>> 3;
            this.temp[me] = (ge + this.temp[me - 7] | 0) + (xe + this.temp[me - 16] | 0);
          }
          var Ee = (((de >>> 6 | de << 26) ^ (de >>> 11 | de << 21) ^ (de >>> 25 | de << 7)) + (de & fe ^ ~de & pe) | 0) + (ye + ($.KEY[me] + this.temp[me] | 0) | 0) | 0, Te = ((ie >>> 2 | ie << 30) ^ (ie >>> 13 | ie << 19) ^ (ie >>> 22 | ie << 10)) + (ie & oe ^ ie & le ^ oe & le) | 0;
          ye = pe, pe = fe, fe = de, de = ue + Ee | 0, ue = le, le = oe, oe = ie, ie = Ee + Te | 0;
        }
        se[0] += ie, se[1] += oe, se[2] += le, se[3] += ue, se[4] += de, se[5] += fe, se[6] += pe, se[7] += ye;
      }, te;
    }()
  );
  return RawSha256.RawSha256 = ee, RawSha256;
}
var hasRequiredJsSha256;
function requireJsSha256() {
  if (hasRequiredJsSha256)
    return jsSha256;
  hasRequiredJsSha256 = 1, Object.defineProperty(jsSha256, "__esModule", { value: !0 }), jsSha256.Sha256 = void 0;
  var $ = require$$0$2, ee = requireConstants(), te = requireRawSha256(), ne = requireBuild$3(), re = (
    /** @class */
    function() {
      function ie(oe) {
        this.secret = oe, this.hash = new te.RawSha256(), this.reset();
      }
      return ie.prototype.update = function(oe) {
        if (!((0, ne.isEmptyData)(oe) || this.error))
          try {
            this.hash.update((0, ne.convertToBuffer)(oe));
          } catch (le) {
            this.error = le;
          }
      }, ie.prototype.digestSync = function() {
        if (this.error)
          throw this.error;
        return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
      }, ie.prototype.digest = function() {
        return $.__awaiter(this, void 0, void 0, function() {
          return $.__generator(this, function(oe) {
            return [2, this.digestSync()];
          });
        });
      }, ie.prototype.reset = function() {
        if (this.hash = new te.RawSha256(), this.secret) {
          this.outer = new te.RawSha256();
          var oe = se(this.secret), le = new Uint8Array(ee.BLOCK_SIZE);
          le.set(oe);
          for (var ue = 0; ue < ee.BLOCK_SIZE; ue++)
            oe[ue] ^= 54, le[ue] ^= 92;
          this.hash.update(oe), this.outer.update(le);
          for (var ue = 0; ue < oe.byteLength; ue++)
            oe[ue] = 0;
        }
      }, ie;
    }()
  );
  jsSha256.Sha256 = re;
  function se(ie) {
    var oe = (0, ne.convertToBuffer)(ie);
    if (oe.byteLength > ee.BLOCK_SIZE) {
      var le = new te.RawSha256();
      le.update(oe), oe = le.digest();
    }
    var ue = new Uint8Array(ee.BLOCK_SIZE);
    return ue.set(oe), ue;
  }
  return jsSha256;
}
var hasRequiredBuild$2;
function requireBuild$2() {
  return hasRequiredBuild$2 || (hasRequiredBuild$2 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 });
    var ee = require$$0$2;
    ee.__exportStar(requireJsSha256(), $);
  }(build$2)), build$2;
}
var hasRequiredCrossPlatformSha256;
function requireCrossPlatformSha256() {
  if (hasRequiredCrossPlatformSha256)
    return crossPlatformSha256;
  hasRequiredCrossPlatformSha256 = 1, Object.defineProperty(crossPlatformSha256, "__esModule", { value: !0 }), crossPlatformSha256.Sha256 = void 0;
  var $ = requireIe11Sha256(), ee = requireWebCryptoSha256(), te = requireBuild$2(), ne = requireBuild$5(), re = requireBuild$4(), se = require$$5, ie = requireBuild$3(), oe = (
    /** @class */
    function() {
      function le(ue) {
        (0, ne.supportsWebCrypto)((0, se.locateWindow)()) ? this.hash = new ee.Sha256(ue) : (0, re.isMsWindow)((0, se.locateWindow)()) ? this.hash = new $.Sha256(ue) : this.hash = new te.Sha256(ue);
      }
      return le.prototype.update = function(ue, de) {
        this.hash.update((0, ie.convertToBuffer)(ue));
      }, le.prototype.digest = function() {
        return this.hash.digest();
      }, le.prototype.reset = function() {
        this.hash.reset();
      }, le;
    }()
  );
  return crossPlatformSha256.Sha256 = oe, crossPlatformSha256;
}
(function($) {
  Object.defineProperty($, "__esModule", { value: !0 }), $.WebCryptoSha256 = $.Ie11Sha256 = void 0;
  var ee = require$$0$3;
  ee.__exportStar(requireCrossPlatformSha256(), $);
  var te = requireIe11Sha256();
  Object.defineProperty($, "Ie11Sha256", { enumerable: !0, get: function() {
    return te.Sha256;
  } });
  var ne = requireWebCryptoSha256();
  Object.defineProperty($, "WebCryptoSha256", { enumerable: !0, get: function() {
    return ne.Sha256;
  } });
})(build$3);
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(ee, te) {
    const ne = te.match(ee);
    return ne && ne.length > 0 && ne[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(ee, te) {
    const ne = te.match(ee);
    return ne && ne.length > 1 && ne[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(ee, te, ne) {
    if (ee.test(te))
      return ne;
  }
  static getWindowsVersionName(ee) {
    switch (ee) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(ee) {
    const te = ee.split(".").splice(0, 2).map((ne) => parseInt(ne, 10) || 0);
    if (te.push(0), te[0] === 10)
      switch (te[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(ee) {
    const te = ee.split(".").splice(0, 2).map((ne) => parseInt(ne, 10) || 0);
    if (te.push(0), !(te[0] === 1 && te[1] < 5)) {
      if (te[0] === 1 && te[1] < 6)
        return "Cupcake";
      if (te[0] === 1 && te[1] >= 6)
        return "Donut";
      if (te[0] === 2 && te[1] < 2)
        return "Eclair";
      if (te[0] === 2 && te[1] === 2)
        return "Froyo";
      if (te[0] === 2 && te[1] > 2)
        return "Gingerbread";
      if (te[0] === 3)
        return "Honeycomb";
      if (te[0] === 4 && te[1] < 1)
        return "Ice Cream Sandwich";
      if (te[0] === 4 && te[1] < 4)
        return "Jelly Bean";
      if (te[0] === 4 && te[1] >= 4)
        return "KitKat";
      if (te[0] === 5)
        return "Lollipop";
      if (te[0] === 6)
        return "Marshmallow";
      if (te[0] === 7)
        return "Nougat";
      if (te[0] === 8)
        return "Oreo";
      if (te[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(ee) {
    return ee.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(ee, te, ne = !1) {
    const re = Utils.getVersionPrecision(ee), se = Utils.getVersionPrecision(te);
    let ie = Math.max(re, se), oe = 0;
    const le = Utils.map([ee, te], (ue) => {
      const de = ie - Utils.getVersionPrecision(ue), fe = ue + new Array(de + 1).join(".0");
      return Utils.map(fe.split("."), (pe) => new Array(20 - pe.length).join("0") + pe).reverse();
    });
    for (ne && (oe = ie - Math.min(re, se)), ie -= 1; ie >= oe; ) {
      if (le[0][ie] > le[1][ie])
        return 1;
      if (le[0][ie] === le[1][ie]) {
        if (ie === oe)
          return 0;
        ie -= 1;
      } else if (le[0][ie] < le[1][ie])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(ee, te) {
    const ne = [];
    let re;
    if (Array.prototype.map)
      return Array.prototype.map.call(ee, te);
    for (re = 0; re < ee.length; re += 1)
      ne.push(te(ee[re]));
    return ne;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(ee, te) {
    let ne, re;
    if (Array.prototype.find)
      return Array.prototype.find.call(ee, te);
    for (ne = 0, re = ee.length; ne < re; ne += 1) {
      const se = ee[ne];
      if (te(se, ne))
        return se;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(ee, ...te) {
    const ne = ee;
    let re, se;
    if (Object.assign)
      return Object.assign(ee, ...te);
    for (re = 0, se = te.length; re < se; re += 1) {
      const ie = te[re];
      typeof ie == "object" && ie !== null && Object.keys(ie).forEach((le) => {
        ne[le] = ie[le];
      });
    }
    return ee;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(ee) {
    return BROWSER_ALIASES_MAP[ee];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(ee) {
    return BROWSER_MAP[ee] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i, browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe($) {
      const ee = {
        name: "Googlebot"
      }, te = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe($) {
      const ee = {
        name: "Opera"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe($) {
      const ee = {
        name: "Opera"
      }, te = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe($) {
      const ee = {
        name: "Samsung Internet for Android"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/Whale/i],
    describe($) {
      const ee = {
        name: "NAVER Whale Browser"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/MZBrowser/i],
    describe($) {
      const ee = {
        name: "MZ Browser"
      }, te = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/focus/i],
    describe($) {
      const ee = {
        name: "Focus"
      }, te = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/swing/i],
    describe($) {
      const ee = {
        name: "Swing"
      }, te = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/coast/i],
    describe($) {
      const ee = {
        name: "Opera Coast"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe($) {
      const ee = {
        name: "Opera Touch"
      }, te = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/yabrowser/i],
    describe($) {
      const ee = {
        name: "Yandex Browser"
      }, te = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/ucbrowser/i],
    describe($) {
      const ee = {
        name: "UC Browser"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe($) {
      const ee = {
        name: "Maxthon"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/epiphany/i],
    describe($) {
      const ee = {
        name: "Epiphany"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/puffin/i],
    describe($) {
      const ee = {
        name: "Puffin"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/sleipnir/i],
    describe($) {
      const ee = {
        name: "Sleipnir"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/k-meleon/i],
    describe($) {
      const ee = {
        name: "K-Meleon"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/micromessenger/i],
    describe($) {
      const ee = {
        name: "WeChat"
      }, te = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/qqbrowser/i],
    describe($) {
      const ee = {
        name: /qqbrowserlite/i.test($) ? "QQ Browser Lite" : "QQ Browser"
      }, te = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/msie|trident/i],
    describe($) {
      const ee = {
        name: "Internet Explorer"
      }, te = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/\sedg\//i],
    describe($) {
      const ee = {
        name: "Microsoft Edge"
      }, te = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe($) {
      const ee = {
        name: "Microsoft Edge"
      }, te = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/vivaldi/i],
    describe($) {
      const ee = {
        name: "Vivaldi"
      }, te = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/seamonkey/i],
    describe($) {
      const ee = {
        name: "SeaMonkey"
      }, te = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/sailfish/i],
    describe($) {
      const ee = {
        name: "Sailfish"
      }, te = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/silk/i],
    describe($) {
      const ee = {
        name: "Amazon Silk"
      }, te = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/phantom/i],
    describe($) {
      const ee = {
        name: "PhantomJS"
      }, te = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/slimerjs/i],
    describe($) {
      const ee = {
        name: "SlimerJS"
      }, te = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe($) {
      const ee = {
        name: "BlackBerry"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe($) {
      const ee = {
        name: "WebOS Browser"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/bada/i],
    describe($) {
      const ee = {
        name: "Bada"
      }, te = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/tizen/i],
    describe($) {
      const ee = {
        name: "Tizen"
      }, te = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/qupzilla/i],
    describe($) {
      const ee = {
        name: "QupZilla"
      }, te = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe($) {
      const ee = {
        name: "Firefox"
      }, te = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/electron/i],
    describe($) {
      const ee = {
        name: "Electron"
      }, te = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe($) {
      const ee = {
        name: "Miui"
      }, te = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/chromium/i],
    describe($) {
      const ee = {
        name: "Chromium"
      }, te = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, $) || Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe($) {
      const ee = {
        name: "Chrome"
      }, te = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  {
    test: [/GSA/i],
    describe($) {
      const ee = {
        name: "Google Search"
      }, te = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Android Browser */
  {
    test($) {
      const ee = !$.test(/like android/i), te = $.test(/android/i);
      return ee && te;
    },
    describe($) {
      const ee = {
        name: "Android Browser"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe($) {
      const ee = {
        name: "PlayStation 4"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe($) {
      const ee = {
        name: "Safari"
      }, te = Utils.getFirstMatch(commonVersionIdentifier, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe($) {
      const ee = /^(.*)\/(.*) /, te = /^(.*)\/(.*)[ \t]\((.*)/, re = $.search("\\(") !== -1 ? te : ee;
      return {
        name: Utils.getFirstMatch(re, $),
        version: Utils.getSecondMatch(re, $)
      };
    }
  }
], osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe($) {
      const ee = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, $);
      return {
        name: OS_MAP.Roku,
        version: ee
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe($) {
      const ee = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, $);
      return {
        name: OS_MAP.WindowsPhone,
        version: ee
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe($) {
      const ee = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, $), te = Utils.getWindowsVersionName(ee);
      return {
        name: OS_MAP.Windows,
        version: ee,
        versionName: te
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe($) {
      const ee = {
        name: OS_MAP.iOS
      }, te = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, $);
      return te && (ee.version = te), ee;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe($) {
      const ee = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, $).replace(/[_\s]/g, "."), te = Utils.getMacOSVersionName(ee), ne = {
        name: OS_MAP.MacOS,
        version: ee
      };
      return te && (ne.versionName = te), ne;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe($) {
      const ee = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, $).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: ee
      };
    }
  },
  /* Android */
  {
    test($) {
      const ee = !$.test(/like android/i), te = $.test(/android/i);
      return ee && te;
    },
    describe($) {
      const ee = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, $), te = Utils.getAndroidVersionName(ee), ne = {
        name: OS_MAP.Android,
        version: ee
      };
      return te && (ne.versionName = te), ne;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe($) {
      const ee = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, $), te = {
        name: OS_MAP.WebOS
      };
      return ee && ee.length && (te.version = ee), te;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe($) {
      const ee = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, $) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, $) || Utils.getFirstMatch(/\bbb(\d+)/i, $);
      return {
        name: OS_MAP.BlackBerry,
        version: ee
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe($) {
      const ee = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, $);
      return {
        name: OS_MAP.Bada,
        version: ee
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe($) {
      const ee = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, $);
      return {
        name: OS_MAP.Tizen,
        version: ee
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe($) {
      const ee = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, $);
      return {
        name: OS_MAP.PlayStation4,
        version: ee
      };
    }
  }
], platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe($) {
      const ee = Utils.getFirstMatch(/(can-l01)/i, $) && "Nova", te = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      return ee && (te.model = ee), te;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test($) {
      const ee = $.test(/ipod|iphone/i), te = $.test(/like (ipod|iphone)/i);
      return ee && !te;
    },
    describe($) {
      const ee = Utils.getFirstMatch(/(ipod|iphone)/i, $);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model: ee
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test($) {
      return $.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test($) {
      return $.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test($) {
      return $.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test($) {
      const ee = Number(String($.getOSVersion()).split(".")[0]);
      return $.getOSName(!0) === "android" && ee >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test($) {
      return $.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test($) {
      return $.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test($) {
      return $.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test($) {
      return $.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test($) {
      return $.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test($) {
      return $.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
], enginesParsersList = [
  /* EdgeHTML */
  {
    test($) {
      return $.getBrowserName(!0) === "microsoft edge";
    },
    describe($) {
      if (/\sedg\//i.test($))
        return {
          name: ENGINE_MAP.Blink
        };
      const te = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, $);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: te
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe($) {
      const ee = {
        name: ENGINE_MAP.Trident
      }, te = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Presto */
  {
    test($) {
      return $.test(/presto/i);
    },
    describe($) {
      const ee = {
        name: ENGINE_MAP.Presto
      }, te = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Gecko */
  {
    test($) {
      const ee = $.test(/gecko/i), te = $.test(/like gecko/i);
      return ee && !te;
    },
    describe($) {
      const ee = {
        name: ENGINE_MAP.Gecko
      }, te = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe($) {
      const ee = {
        name: ENGINE_MAP.WebKit
      }, te = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, $);
      return te && (ee.version = te), ee;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(ee, te = !1) {
    if (ee == null || ee === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = ee, this.parsedResult = {}, te !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(ee) {
    return ee.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const ee = Utils.find(browsersList, (te) => {
      if (typeof te.test == "function")
        return te.test(this);
      if (te.test instanceof Array)
        return te.test.some((ne) => this.test(ne));
      throw new Error("Browser's test function is not valid");
    });
    return ee && (this.parsedResult.browser = ee.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(ee) {
    return ee ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const ee = Utils.find(osParsersList, (te) => {
      if (typeof te.test == "function")
        return te.test(this);
      if (te.test instanceof Array)
        return te.test.some((ne) => this.test(ne));
      throw new Error("Browser's test function is not valid");
    });
    return ee && (this.parsedResult.os = ee.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(ee) {
    const { name: te } = this.getOS();
    return ee ? String(te).toLowerCase() || "" : te || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(ee = !1) {
    const { type: te } = this.getPlatform();
    return ee ? String(te).toLowerCase() || "" : te || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const ee = Utils.find(platformParsersList, (te) => {
      if (typeof te.test == "function")
        return te.test(this);
      if (te.test instanceof Array)
        return te.test.some((ne) => this.test(ne));
      throw new Error("Browser's test function is not valid");
    });
    return ee && (this.parsedResult.platform = ee.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(ee) {
    return ee ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const ee = Utils.find(enginesParsersList, (te) => {
      if (typeof te.test == "function")
        return te.test(this);
      if (te.test instanceof Array)
        return te.test.some((ne) => this.test(ne));
      throw new Error("Browser's test function is not valid");
    });
    return ee && (this.parsedResult.engine = ee.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(ee) {
    const te = {};
    let ne = 0;
    const re = {};
    let se = 0;
    if (Object.keys(ee).forEach((oe) => {
      const le = ee[oe];
      typeof le == "string" ? (re[oe] = le, se += 1) : typeof le == "object" && (te[oe] = le, ne += 1);
    }), ne > 0) {
      const oe = Object.keys(te), le = Utils.find(oe, (de) => this.isOS(de));
      if (le) {
        const de = this.satisfies(te[le]);
        if (de !== void 0)
          return de;
      }
      const ue = Utils.find(
        oe,
        (de) => this.isPlatform(de)
      );
      if (ue) {
        const de = this.satisfies(te[ue]);
        if (de !== void 0)
          return de;
      }
    }
    if (se > 0) {
      const oe = Object.keys(re), le = Utils.find(oe, (ue) => this.isBrowser(ue, !0));
      if (le !== void 0)
        return this.compareVersion(re[le]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(ee, te = !1) {
    const ne = this.getBrowserName().toLowerCase();
    let re = ee.toLowerCase();
    const se = Utils.getBrowserTypeByAlias(re);
    return te && se && (re = se.toLowerCase()), re === ne;
  }
  compareVersion(ee) {
    let te = [0], ne = ee, re = !1;
    const se = this.getBrowserVersion();
    if (typeof se == "string")
      return ee[0] === ">" || ee[0] === "<" ? (ne = ee.substr(1), ee[1] === "=" ? (re = !0, ne = ee.substr(2)) : te = [], ee[0] === ">" ? te.push(1) : te.push(-1)) : ee[0] === "=" ? ne = ee.substr(1) : ee[0] === "~" && (re = !0, ne = ee.substr(1)), te.indexOf(
        Utils.compareVersions(se, ne, re)
      ) > -1;
  }
  isOS(ee) {
    return this.getOSName(!0) === String(ee).toLowerCase();
  }
  isPlatform(ee) {
    return this.getPlatformType(!0) === String(ee).toLowerCase();
  }
  isEngine(ee) {
    return this.getEngineName(!0) === String(ee).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(ee, te = !1) {
    return this.isBrowser(ee, te) || this.isOS(ee) || this.isPlatform(ee);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(ee = []) {
    return ee.some((te) => this.is(te));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(ee, te = !1) {
    if (typeof ee != "string")
      throw new Error("UserAgent should be a string");
    return new Parser(ee, te);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(ee) {
    return new Parser(ee).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const defaultUserAgent = ({ serviceId: $, clientVersion: ee }) => async () => {
  var re, se, ie, oe, le;
  const te = typeof window < "u" && ((re = window == null ? void 0 : window.navigator) != null && re.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0, ne = [
    ["aws-sdk-js", ee],
    ["ua", "2.0"],
    [`os/${((se = te == null ? void 0 : te.os) == null ? void 0 : se.name) || "other"}`, (ie = te == null ? void 0 : te.os) == null ? void 0 : ie.version],
    ["lang/js"],
    ["md/browser", `${((oe = te == null ? void 0 : te.browser) == null ? void 0 : oe.name) ?? "unknown"}_${((le = te == null ? void 0 : te.browser) == null ? void 0 : le.version) ?? "unknown"}`]
  ];
  return $ && ne.push([`api/${$}`, ee]), ne;
};
var build$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function($, ee) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics$1($, ee);
};
function __extends$1($, ee) {
  extendStatics$1($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign$1.apply(this, arguments);
};
function __rest$1($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate$1($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param$1($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata$1($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter$1($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator$1($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding$1($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar$1($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values$1($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread$1() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read$1(arguments[ee]));
  return $;
}
function __spreadArrays$1() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await$1($) {
  return this instanceof __await$1 ? (this.v = $, this) : new __await$1($);
}
function __asyncGenerator$1($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await$1 ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator$1($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await$1($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues$1($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values$1 == "function" ? __values$1($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject$1($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar$1($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault$1($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet$1($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet$1($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign$1;
  },
  __asyncDelegator: __asyncDelegator$1,
  __asyncGenerator: __asyncGenerator$1,
  __asyncValues: __asyncValues$1,
  __await: __await$1,
  __awaiter: __awaiter$1,
  __classPrivateFieldGet: __classPrivateFieldGet$1,
  __classPrivateFieldSet: __classPrivateFieldSet$1,
  __createBinding: __createBinding$1,
  __decorate: __decorate$1,
  __exportStar: __exportStar$1,
  __extends: __extends$1,
  __generator: __generator$1,
  __importDefault: __importDefault$1,
  __importStar: __importStar$1,
  __makeTemplateObject: __makeTemplateObject$1,
  __metadata: __metadata$1,
  __param: __param$1,
  __read: __read$1,
  __rest: __rest$1,
  __spread: __spread$1,
  __spreadArrays: __spreadArrays$1,
  __values: __values$1
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var aws_crc32 = {}, hasRequiredAws_crc32;
function requireAws_crc32() {
  if (hasRequiredAws_crc32)
    return aws_crc32;
  hasRequiredAws_crc32 = 1, Object.defineProperty(aws_crc32, "__esModule", { value: !0 }), aws_crc32.AwsCrc32 = void 0;
  var $ = require$$0$1, ee = requireBuild$3(), te = requireBuild$1(), ne = (
    /** @class */
    function() {
      function re() {
        this.crc32 = new te.Crc32();
      }
      return re.prototype.update = function(se) {
        (0, ee.isEmptyData)(se) || this.crc32.update((0, ee.convertToBuffer)(se));
      }, re.prototype.digest = function() {
        return $.__awaiter(this, void 0, void 0, function() {
          return $.__generator(this, function(se) {
            return [2, (0, ee.numToUint8)(this.crc32.digest())];
          });
        });
      }, re.prototype.reset = function() {
        this.crc32 = new te.Crc32();
      }, re;
    }()
  );
  return aws_crc32.AwsCrc32 = ne, aws_crc32;
}
var hasRequiredBuild$1;
function requireBuild$1() {
  return hasRequiredBuild$1 || (hasRequiredBuild$1 = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 }), $.AwsCrc32 = $.Crc32 = $.crc32 = void 0;
    var ee = require$$0$1, te = requireBuild$3();
    function ne(le) {
      return new re().update(le).digest();
    }
    $.crc32 = ne;
    var re = (
      /** @class */
      function() {
        function le() {
          this.checksum = 4294967295;
        }
        return le.prototype.update = function(ue) {
          var de, fe;
          try {
            for (var pe = ee.__values(ue), ye = pe.next(); !ye.done; ye = pe.next()) {
              var me = ye.value;
              this.checksum = this.checksum >>> 8 ^ ie[(this.checksum ^ me) & 255];
            }
          } catch (ve) {
            de = { error: ve };
          } finally {
            try {
              ye && !ye.done && (fe = pe.return) && fe.call(pe);
            } finally {
              if (de)
                throw de.error;
            }
          }
          return this;
        }, le.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, le;
      }()
    );
    $.Crc32 = re;
    var se = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ], ie = (0, te.uint32ArrayFrom)(se), oe = requireAws_crc32();
    Object.defineProperty($, "AwsCrc32", { enumerable: !0, get: function() {
      return oe.AwsCrc32;
    } });
  }(build$1)), build$1;
}
var buildExports$1 = requireBuild$1();
class Int64 {
  constructor(ee) {
    if (this.bytes = ee, ee.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(ee) {
    if (ee > 9223372036854776e3 || ee < -9223372036854776e3)
      throw new Error(`${ee} is too large (or, if negative, too small) to represent as an Int64`);
    const te = new Uint8Array(8);
    for (let ne = 7, re = Math.abs(Math.round(ee)); ne > -1 && re > 0; ne--, re /= 256)
      te[ne] = re;
    return ee < 0 && negate(te), new Int64(te);
  }
  valueOf() {
    const ee = this.bytes.slice(0), te = ee[0] & 128;
    return te && negate(ee), parseInt(toHex(ee), 16) * (te ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate($) {
  for (let ee = 0; ee < 8; ee++)
    $[ee] ^= 255;
  for (let ee = 7; ee > -1 && ($[ee]++, $[ee] === 0); ee--)
    ;
}
class HeaderMarshaller {
  constructor(ee, te) {
    this.toUtf8 = ee, this.fromUtf8 = te;
  }
  format(ee) {
    const te = [];
    for (const se of Object.keys(ee)) {
      const ie = this.fromUtf8(se);
      te.push(Uint8Array.from([ie.byteLength]), ie, this.formatHeaderValue(ee[se]));
    }
    const ne = new Uint8Array(te.reduce((se, ie) => se + ie.byteLength, 0));
    let re = 0;
    for (const se of te)
      ne.set(se, re), re += se.byteLength;
    return ne;
  }
  formatHeaderValue(ee) {
    switch (ee.type) {
      case "boolean":
        return Uint8Array.from([ee.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, ee.value]);
      case "short":
        const te = new DataView(new ArrayBuffer(3));
        return te.setUint8(0, 3), te.setInt16(1, ee.value, !1), new Uint8Array(te.buffer);
      case "integer":
        const ne = new DataView(new ArrayBuffer(5));
        return ne.setUint8(0, 4), ne.setInt32(1, ee.value, !1), new Uint8Array(ne.buffer);
      case "long":
        const re = new Uint8Array(9);
        return re[0] = 5, re.set(ee.value.bytes, 1), re;
      case "binary":
        const se = new DataView(new ArrayBuffer(3 + ee.value.byteLength));
        se.setUint8(0, 6), se.setUint16(1, ee.value.byteLength, !1);
        const ie = new Uint8Array(se.buffer);
        return ie.set(ee.value, 3), ie;
      case "string":
        const oe = this.fromUtf8(ee.value), le = new DataView(new ArrayBuffer(3 + oe.byteLength));
        le.setUint8(0, 7), le.setUint16(1, oe.byteLength, !1);
        const ue = new Uint8Array(le.buffer);
        return ue.set(oe, 3), ue;
      case "timestamp":
        const de = new Uint8Array(9);
        return de[0] = 8, de.set(Int64.fromNumber(ee.value.valueOf()).bytes, 1), de;
      case "uuid":
        if (!UUID_PATTERN.test(ee.value))
          throw new Error(`Invalid UUID received: ${ee.value}`);
        const fe = new Uint8Array(17);
        return fe[0] = 9, fe.set(fromHex(ee.value.replace(/\-/g, "")), 1), fe;
    }
  }
  parse(ee) {
    const te = {};
    let ne = 0;
    for (; ne < ee.byteLength; ) {
      const re = ee.getUint8(ne++), se = this.toUtf8(new Uint8Array(ee.buffer, ee.byteOffset + ne, re));
      switch (ne += re, ee.getUint8(ne++)) {
        case 0:
          te[se] = {
            type: BOOLEAN_TAG,
            value: !0
          };
          break;
        case 1:
          te[se] = {
            type: BOOLEAN_TAG,
            value: !1
          };
          break;
        case 2:
          te[se] = {
            type: BYTE_TAG,
            value: ee.getInt8(ne++)
          };
          break;
        case 3:
          te[se] = {
            type: SHORT_TAG,
            value: ee.getInt16(ne, !1)
          }, ne += 2;
          break;
        case 4:
          te[se] = {
            type: INT_TAG,
            value: ee.getInt32(ne, !1)
          }, ne += 4;
          break;
        case 5:
          te[se] = {
            type: LONG_TAG,
            value: new Int64(new Uint8Array(ee.buffer, ee.byteOffset + ne, 8))
          }, ne += 8;
          break;
        case 6:
          const ie = ee.getUint16(ne, !1);
          ne += 2, te[se] = {
            type: BINARY_TAG,
            value: new Uint8Array(ee.buffer, ee.byteOffset + ne, ie)
          }, ne += ie;
          break;
        case 7:
          const oe = ee.getUint16(ne, !1);
          ne += 2, te[se] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(ee.buffer, ee.byteOffset + ne, oe))
          }, ne += oe;
          break;
        case 8:
          te[se] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int64(new Uint8Array(ee.buffer, ee.byteOffset + ne, 8)).valueOf())
          }, ne += 8;
          break;
        case 9:
          const le = new Uint8Array(ee.buffer, ee.byteOffset + ne, 16);
          ne += 16, te[se] = {
            type: UUID_TAG,
            value: `${toHex(le.subarray(0, 4))}-${toHex(le.subarray(4, 6))}-${toHex(le.subarray(6, 8))}-${toHex(le.subarray(8, 10))}-${toHex(le.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return te;
  }
}
var HEADER_VALUE_TYPE;
(function($) {
  $[$.boolTrue = 0] = "boolTrue", $[$.boolFalse = 1] = "boolFalse", $[$.byte = 2] = "byte", $[$.short = 3] = "short", $[$.integer = 4] = "integer", $[$.long = 5] = "long", $[$.byteArray = 6] = "byteArray", $[$.string = 7] = "string", $[$.timestamp = 8] = "timestamp", $[$.uuid = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean", BYTE_TAG = "byte", SHORT_TAG = "short", INT_TAG = "integer", LONG_TAG = "long", BINARY_TAG = "binary", STRING_TAG = "string", TIMESTAMP_TAG = "timestamp", UUID_TAG = "uuid", UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/, PRELUDE_MEMBER_LENGTH = 4, PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2, CHECKSUM_LENGTH = 4, MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength: $, byteOffset: ee, buffer: te }) {
  if ($ < MINIMUM_MESSAGE_LENGTH)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const ne = new DataView(te, ee, $), re = ne.getUint32(0, !1);
  if ($ !== re)
    throw new Error("Reported message length does not match received message length");
  const se = ne.getUint32(PRELUDE_MEMBER_LENGTH, !1), ie = ne.getUint32(PRELUDE_LENGTH, !1), oe = ne.getUint32($ - CHECKSUM_LENGTH, !1), le = new buildExports$1.Crc32().update(new Uint8Array(te, ee, PRELUDE_LENGTH));
  if (ie !== le.digest())
    throw new Error(`The prelude checksum specified in the message (${ie}) does not match the calculated CRC32 checksum (${le.digest()})`);
  if (le.update(new Uint8Array(te, ee + PRELUDE_LENGTH, $ - (PRELUDE_LENGTH + CHECKSUM_LENGTH))), oe !== le.digest())
    throw new Error(`The message checksum (${le.digest()}) did not match the expected value of ${oe}`);
  return {
    headers: new DataView(te, ee + PRELUDE_LENGTH + CHECKSUM_LENGTH, se),
    body: new Uint8Array(te, ee + PRELUDE_LENGTH + CHECKSUM_LENGTH + se, re - se - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}
class EventStreamCodec {
  constructor(ee, te) {
    this.headerMarshaller = new HeaderMarshaller(ee, te), this.messageBuffer = [], this.isEndOfStream = !1;
  }
  feed(ee) {
    this.messageBuffer.push(this.decode(ee));
  }
  endOfStream() {
    this.isEndOfStream = !0;
  }
  getMessage() {
    const ee = this.messageBuffer.pop(), te = this.isEndOfStream;
    return {
      getMessage() {
        return ee;
      },
      isEndOfStream() {
        return te;
      }
    };
  }
  getAvailableMessages() {
    const ee = this.messageBuffer;
    this.messageBuffer = [];
    const te = this.isEndOfStream;
    return {
      getMessages() {
        return ee;
      },
      isEndOfStream() {
        return te;
      }
    };
  }
  encode({ headers: ee, body: te }) {
    const ne = this.headerMarshaller.format(ee), re = ne.byteLength + te.byteLength + 16, se = new Uint8Array(re), ie = new DataView(se.buffer, se.byteOffset, se.byteLength), oe = new buildExports$1.Crc32();
    return ie.setUint32(0, re, !1), ie.setUint32(4, ne.byteLength, !1), ie.setUint32(8, oe.update(se.subarray(0, 8)).digest(), !1), se.set(ne, 12), se.set(te, ne.byteLength + 12), ie.setUint32(re - 4, oe.update(se.subarray(8, re - 4)).digest(), !1), se;
  }
  decode(ee) {
    const { headers: te, body: ne } = splitMessage(ee);
    return { headers: this.headerMarshaller.parse(te), body: ne };
  }
  formatHeaders(ee) {
    return this.headerMarshaller.format(ee);
  }
}
class MessageDecoderStream {
  constructor(ee) {
    this.options = ee;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const ee of this.options.inputStream)
      yield this.options.decoder.decode(ee);
  }
}
class MessageEncoderStream {
  constructor(ee) {
    this.options = ee;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const ee of this.options.messageStream)
      yield this.options.encoder.encode(ee);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
}
class SmithyMessageDecoderStream {
  constructor(ee) {
    this.options = ee;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const ee of this.options.messageStream) {
      const te = await this.options.deserializer(ee);
      te !== void 0 && (yield te);
    }
  }
}
class SmithyMessageEncoderStream {
  constructor(ee) {
    this.options = ee;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const ee of this.options.inputStream)
      yield this.options.serializer(ee);
  }
}
function getChunkedStream($) {
  let ee = 0, te = 0, ne = null, re = null;
  const se = (oe) => {
    if (typeof oe != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + oe);
    ee = oe, te = 4, ne = new Uint8Array(oe), new DataView(ne.buffer).setUint32(0, oe, !1);
  }, ie = async function* () {
    const oe = $[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: le, done: ue } = await oe.next();
      if (ue) {
        if (ee)
          if (ee === te)
            yield ne;
          else
            throw new Error("Truncated event message received.");
        else
          return;
        return;
      }
      const de = le.length;
      let fe = 0;
      for (; fe < de; ) {
        if (!ne) {
          const ye = de - fe;
          re || (re = new Uint8Array(4));
          const me = Math.min(4 - te, ye);
          if (re.set(le.slice(fe, fe + me), te), te += me, fe += me, te < 4)
            break;
          se(new DataView(re.buffer).getUint32(0, !1)), re = null;
        }
        const pe = Math.min(ee - te, de - fe);
        ne.set(le.slice(fe, fe + pe), te), te += pe, fe += pe, ee && ee === te && (yield ne, ne = null, ee = 0, te = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: ie
  };
}
function getMessageUnmarshaller($, ee) {
  return async function(te) {
    const { value: ne } = te.headers[":message-type"];
    if (ne === "error") {
      const re = new Error(te.headers[":error-message"].value || "UnknownError");
      throw re.name = te.headers[":error-code"].value, re;
    } else if (ne === "exception") {
      const re = te.headers[":exception-type"].value, se = { [re]: te }, ie = await $(se);
      if (ie.$unknown) {
        const oe = new Error(ee(te.body));
        throw oe.name = re, oe;
      }
      throw ie[re];
    } else if (ne === "event") {
      const re = {
        [te.headers[":event-type"].value]: te
      }, se = await $(re);
      return se.$unknown ? void 0 : se;
    } else
      throw Error(`Unrecognizable event type: ${te.headers[":event-type"].value}`);
  };
}
let EventStreamMarshaller$1 = class {
  constructor({ utf8Encoder: ee, utf8Decoder: te }) {
    this.eventStreamCodec = new EventStreamCodec(ee, te), this.utfEncoder = ee;
  }
  deserialize(ee, te) {
    const ne = getChunkedStream(ee);
    return new SmithyMessageDecoderStream({
      messageStream: new MessageDecoderStream({ inputStream: ne, decoder: this.eventStreamCodec }),
      deserializer: getMessageUnmarshaller(te, this.utfEncoder)
    });
  }
  serialize(ee, te) {
    return new MessageEncoderStream({
      messageStream: new SmithyMessageEncoderStream({ inputStream: ee, serializer: te }),
      encoder: this.eventStreamCodec,
      includeEndFrame: !0
    });
  }
};
const readableStreamtoIterable = ($) => ({
  [Symbol.asyncIterator]: async function* () {
    const ee = $.getReader();
    try {
      for (; ; ) {
        const { done: te, value: ne } = await ee.read();
        if (te)
          return;
        yield ne;
      }
    } finally {
      ee.releaseLock();
    }
  }
}), iterableToReadableStream = ($) => {
  const ee = $[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(te) {
      const { done: ne, value: re } = await ee.next();
      if (ne)
        return te.close();
      te.enqueue(re);
    }
  });
};
class EventStreamMarshaller {
  constructor({ utf8Encoder: ee, utf8Decoder: te }) {
    this.universalMarshaller = new EventStreamMarshaller$1({
      utf8Decoder: te,
      utf8Encoder: ee
    });
  }
  deserialize(ee, te) {
    const ne = isReadableStream(ee) ? readableStreamtoIterable(ee) : ee;
    return this.universalMarshaller.deserialize(ne, te);
  }
  serialize(ee, te) {
    const ne = this.universalMarshaller.serialize(ee, te);
    return typeof ReadableStream == "function" ? iterableToReadableStream(ne) : ne;
  }
}
const isReadableStream = ($) => typeof ReadableStream == "function" && $ instanceof ReadableStream, eventStreamSerdeProvider = ($) => new EventStreamMarshaller($);
function blobReader($, ee, te = 1024 * 1024) {
  return new Promise((ne, re) => {
    const se = new FileReader();
    se.addEventListener("error", re), se.addEventListener("abort", re);
    const ie = $.size;
    let oe = 0;
    function le() {
      if (oe >= ie) {
        ne();
        return;
      }
      se.readAsArrayBuffer($.slice(oe, Math.min(ie, oe + te)));
    }
    se.addEventListener("load", (ue) => {
      const de = ue.target.result;
      ee(new Uint8Array(de)), oe += de.byteLength, le();
    }), le();
  });
}
const blobHasher = async function $(ee, te) {
  const ne = new ee();
  return await blobReader(te, (re) => {
    ne.update(re);
  }), ne.digest();
}, invalidProvider = ($) => () => Promise.reject($), BLOCK_SIZE = 64, DIGEST_LENGTH = 16, INIT = [1732584193, 4023233417, 2562383102, 271733878];
class Md5 {
  constructor() {
    this.reset();
  }
  update(ee) {
    if (isEmptyData(ee))
      return;
    if (this.finished)
      throw new Error("Attempted to update an already finished hash.");
    const te = convertToBuffer(ee);
    let ne = 0, { byteLength: re } = te;
    for (this.bytesHashed += re; re > 0; )
      this.buffer.setUint8(this.bufferLength++, te[ne++]), re--, this.bufferLength === BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
  }
  async digest() {
    if (!this.finished) {
      const { buffer: te, bufferLength: ne, bytesHashed: re } = this, se = re * 8;
      if (te.setUint8(this.bufferLength++, 128), ne % BLOCK_SIZE >= BLOCK_SIZE - 8) {
        for (let ie = this.bufferLength; ie < BLOCK_SIZE; ie++)
          te.setUint8(ie, 0);
        this.hashBuffer(), this.bufferLength = 0;
      }
      for (let ie = this.bufferLength; ie < BLOCK_SIZE - 8; ie++)
        te.setUint8(ie, 0);
      te.setUint32(BLOCK_SIZE - 8, se >>> 0, !0), te.setUint32(BLOCK_SIZE - 4, Math.floor(se / 4294967296), !0), this.hashBuffer(), this.finished = !0;
    }
    const ee = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (let te = 0; te < 4; te++)
      ee.setUint32(te * 4, this.state[te], !0);
    return new Uint8Array(ee.buffer, ee.byteOffset, ee.byteLength);
  }
  hashBuffer() {
    const { buffer: ee, state: te } = this;
    let ne = te[0], re = te[1], se = te[2], ie = te[3];
    ne = ff(ne, re, se, ie, ee.getUint32(0, !0), 7, 3614090360), ie = ff(ie, ne, re, se, ee.getUint32(4, !0), 12, 3905402710), se = ff(se, ie, ne, re, ee.getUint32(8, !0), 17, 606105819), re = ff(re, se, ie, ne, ee.getUint32(12, !0), 22, 3250441966), ne = ff(ne, re, se, ie, ee.getUint32(16, !0), 7, 4118548399), ie = ff(ie, ne, re, se, ee.getUint32(20, !0), 12, 1200080426), se = ff(se, ie, ne, re, ee.getUint32(24, !0), 17, 2821735955), re = ff(re, se, ie, ne, ee.getUint32(28, !0), 22, 4249261313), ne = ff(ne, re, se, ie, ee.getUint32(32, !0), 7, 1770035416), ie = ff(ie, ne, re, se, ee.getUint32(36, !0), 12, 2336552879), se = ff(se, ie, ne, re, ee.getUint32(40, !0), 17, 4294925233), re = ff(re, se, ie, ne, ee.getUint32(44, !0), 22, 2304563134), ne = ff(ne, re, se, ie, ee.getUint32(48, !0), 7, 1804603682), ie = ff(ie, ne, re, se, ee.getUint32(52, !0), 12, 4254626195), se = ff(se, ie, ne, re, ee.getUint32(56, !0), 17, 2792965006), re = ff(re, se, ie, ne, ee.getUint32(60, !0), 22, 1236535329), ne = gg(ne, re, se, ie, ee.getUint32(4, !0), 5, 4129170786), ie = gg(ie, ne, re, se, ee.getUint32(24, !0), 9, 3225465664), se = gg(se, ie, ne, re, ee.getUint32(44, !0), 14, 643717713), re = gg(re, se, ie, ne, ee.getUint32(0, !0), 20, 3921069994), ne = gg(ne, re, se, ie, ee.getUint32(20, !0), 5, 3593408605), ie = gg(ie, ne, re, se, ee.getUint32(40, !0), 9, 38016083), se = gg(se, ie, ne, re, ee.getUint32(60, !0), 14, 3634488961), re = gg(re, se, ie, ne, ee.getUint32(16, !0), 20, 3889429448), ne = gg(ne, re, se, ie, ee.getUint32(36, !0), 5, 568446438), ie = gg(ie, ne, re, se, ee.getUint32(56, !0), 9, 3275163606), se = gg(se, ie, ne, re, ee.getUint32(12, !0), 14, 4107603335), re = gg(re, se, ie, ne, ee.getUint32(32, !0), 20, 1163531501), ne = gg(ne, re, se, ie, ee.getUint32(52, !0), 5, 2850285829), ie = gg(ie, ne, re, se, ee.getUint32(8, !0), 9, 4243563512), se = gg(se, ie, ne, re, ee.getUint32(28, !0), 14, 1735328473), re = gg(re, se, ie, ne, ee.getUint32(48, !0), 20, 2368359562), ne = hh(ne, re, se, ie, ee.getUint32(20, !0), 4, 4294588738), ie = hh(ie, ne, re, se, ee.getUint32(32, !0), 11, 2272392833), se = hh(se, ie, ne, re, ee.getUint32(44, !0), 16, 1839030562), re = hh(re, se, ie, ne, ee.getUint32(56, !0), 23, 4259657740), ne = hh(ne, re, se, ie, ee.getUint32(4, !0), 4, 2763975236), ie = hh(ie, ne, re, se, ee.getUint32(16, !0), 11, 1272893353), se = hh(se, ie, ne, re, ee.getUint32(28, !0), 16, 4139469664), re = hh(re, se, ie, ne, ee.getUint32(40, !0), 23, 3200236656), ne = hh(ne, re, se, ie, ee.getUint32(52, !0), 4, 681279174), ie = hh(ie, ne, re, se, ee.getUint32(0, !0), 11, 3936430074), se = hh(se, ie, ne, re, ee.getUint32(12, !0), 16, 3572445317), re = hh(re, se, ie, ne, ee.getUint32(24, !0), 23, 76029189), ne = hh(ne, re, se, ie, ee.getUint32(36, !0), 4, 3654602809), ie = hh(ie, ne, re, se, ee.getUint32(48, !0), 11, 3873151461), se = hh(se, ie, ne, re, ee.getUint32(60, !0), 16, 530742520), re = hh(re, se, ie, ne, ee.getUint32(8, !0), 23, 3299628645), ne = ii(ne, re, se, ie, ee.getUint32(0, !0), 6, 4096336452), ie = ii(ie, ne, re, se, ee.getUint32(28, !0), 10, 1126891415), se = ii(se, ie, ne, re, ee.getUint32(56, !0), 15, 2878612391), re = ii(re, se, ie, ne, ee.getUint32(20, !0), 21, 4237533241), ne = ii(ne, re, se, ie, ee.getUint32(48, !0), 6, 1700485571), ie = ii(ie, ne, re, se, ee.getUint32(12, !0), 10, 2399980690), se = ii(se, ie, ne, re, ee.getUint32(40, !0), 15, 4293915773), re = ii(re, se, ie, ne, ee.getUint32(4, !0), 21, 2240044497), ne = ii(ne, re, se, ie, ee.getUint32(32, !0), 6, 1873313359), ie = ii(ie, ne, re, se, ee.getUint32(60, !0), 10, 4264355552), se = ii(se, ie, ne, re, ee.getUint32(24, !0), 15, 2734768916), re = ii(re, se, ie, ne, ee.getUint32(52, !0), 21, 1309151649), ne = ii(ne, re, se, ie, ee.getUint32(16, !0), 6, 4149444226), ie = ii(ie, ne, re, se, ee.getUint32(44, !0), 10, 3174756917), se = ii(se, ie, ne, re, ee.getUint32(8, !0), 15, 718787259), re = ii(re, se, ie, ne, ee.getUint32(36, !0), 21, 3951481745), te[0] = ne + te[0] & 4294967295, te[1] = re + te[1] & 4294967295, te[2] = se + te[2] & 4294967295, te[3] = ie + te[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(INIT), this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE)), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
  }
}
function cmn($, ee, te, ne, re, se) {
  return ee = (ee + $ & 4294967295) + (ne + se & 4294967295) & 4294967295, (ee << re | ee >>> 32 - re) + te & 4294967295;
}
function ff($, ee, te, ne, re, se, ie) {
  return cmn(ee & te | ~ee & ne, $, ee, re, se, ie);
}
function gg($, ee, te, ne, re, se, ie) {
  return cmn(ee & ne | te & ~ne, $, ee, re, se, ie);
}
function hh($, ee, te, ne, re, se, ie) {
  return cmn(ee ^ te ^ ne, $, ee, re, se, ie);
}
function ii($, ee, te, ne, re, se, ie) {
  return cmn(te ^ (ee | ~ne), $, ee, re, se, ie);
}
function isEmptyData($) {
  return typeof $ == "string" ? $.length === 0 : $.byteLength === 0;
}
function convertToBuffer($) {
  return typeof $ == "string" ? fromUtf8$3($) : ArrayBuffer.isView($) ? new Uint8Array($.buffer, $.byteOffset, $.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array($);
}
const TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null, calculateBodyLength = ($) => {
  if (typeof $ == "string") {
    if (TEXT_ENCODER)
      return TEXT_ENCODER.encode($).byteLength;
    let ee = $.length;
    for (let te = ee - 1; te >= 0; te--) {
      const ne = $.charCodeAt(te);
      ne > 127 && ne <= 2047 ? ee++ : ne > 2047 && ne <= 65535 && (ee += 2), ne >= 56320 && ne <= 57343 && te--;
    }
    return ee;
  } else {
    if (typeof $.byteLength == "number")
      return $.byteLength;
    if (typeof $.size == "number")
      return $.size;
  }
  throw new Error(`Body Length computation failed for ${$}`);
}, signatureV4CrtContainer = {
  CrtSignerV4: null
};
class SignatureV4MultiRegion {
  constructor(ee) {
    this.sigv4Signer = new SignatureV4S3Express(ee), this.signerOptions = ee;
  }
  async sign(ee, te = {}) {
    if (te.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(ee, te);
    }
    return this.sigv4Signer.sign(ee, te);
  }
  async signWithCredentials(ee, te, ne = {}) {
    if (ne.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(ee, te, ne);
    }
    return this.sigv4Signer.signWithCredentials(ee, te, ne);
  }
  async presign(ee, te = {}) {
    if (te.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(ee, te);
    }
    return this.sigv4Signer.presign(ee, te);
  }
  async presignWithCredentials(ee, te, ne = {}) {
    if (ne.signingRegion === "*")
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    return this.sigv4Signer.presignWithCredentials(ee, te, ne);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let ee = null;
      try {
        if (ee = signatureV4CrtContainer.CrtSignerV4, typeof ee != "function")
          throw new Error();
      } catch (te) {
        throw te.message = `${te.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`, te;
      }
      this.sigv4aSigner = new ee({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
}
const ce = "required", cf = "type", cg = "conditions", ch = "fn", ci = "argv", cj = "ref", ck = "assign", cl = "url", cm = "properties", cn = "backend", co = "authSchemes", cp = "disableDoubleEncoding", cq = "signingName", cr = "signingRegion", cs = "headers", ct = "signingRegionSet", a = !1, b = !0, c = "isSet", d = "booleanEquals", e = "error", f = "aws.partition", g = "stringEquals", h = "getAttr", i = "name", j = "substring", k = "bucketSuffix", l = "parseURL", m = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", n = "endpoint", o = "tree", p = "aws.isVirtualHostableS3Bucket", q = "{url#scheme}://{Bucket}.{url#authority}{url#path}", r = "not", s = "{url#scheme}://{url#authority}{url#path}", t = "hardwareType", u = "regionPrefix", v = "bucketAliasSuffix", w = "outpostId", x = "isValidHostLabel", y = "sigv4a", z = "s3-outposts", A = "s3", B = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", C = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", D = "https://{Bucket}.s3.{partitionResult#dnsSuffix}", E = "aws.parseArn", F = "bucketArn", G = "arnType", H = "", I = "s3-object-lambda", J = "accesspoint", K = "accessPointName", L = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}", M = "mrapPartition", N = "outpostType", O = "arnPrefix", P = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", Q = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", R = "https://s3.{partitionResult#dnsSuffix}", S = { [ce]: !1, [cf]: "String" }, T = { [ce]: !0, default: !1, [cf]: "Boolean" }, U = { [ce]: !1, [cf]: "Boolean" }, V = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, !0] }, W = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, !0] }, X = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, !0] }, Y = { [ch]: c, [ci]: [{ [cj]: "Endpoint" }] }, Z = { [ch]: f, [ci]: [{ [cj]: "Region" }], [ck]: "partitionResult" }, aa = { [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }, "aws-cn"] }, ab = { [ch]: c, [ci]: [{ [cj]: "Bucket" }] }, ac = { [cj]: "Bucket" }, ad = { [ch]: l, [ci]: [{ [cj]: "Endpoint" }], [ck]: "url" }, ae = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "url" }, "isIp"] }, !0] }, af = { [cj]: "url" }, ag = { [ch]: "uriEncode", [ci]: [ac], [ck]: "uri_encoded_bucket" }, ah = { [cn]: "S3Express", [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: "s3express", [cr]: "{Region}" }] }, ai = {}, aj = { [ch]: p, [ci]: [ac, !1] }, ak = { [e]: "S3Express bucket name is not a valid virtual hostable name.", [cf]: e }, al = { [cn]: "S3Express", [co]: [{ [cp]: !0, [i]: "sigv4-s3express", [cq]: "s3express", [cr]: "{Region}" }] }, am = { [ch]: c, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }] }, an = { [ch]: d, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }, !0] }, ao = { [ch]: r, [ci]: [Y] }, ap = { [e]: "Unrecognized S3Express bucket name format.", [cf]: e }, aq = { [ch]: r, [ci]: [ab] }, ar = { [cj]: t }, as = { [cg]: [ao], [e]: "Expected a endpoint to be specified but no endpoint was found", [cf]: e }, at = { [co]: [{ [cp]: !0, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: !0, [i]: "sigv4", [cq]: z, [cr]: "{Region}" }] }, au = { [ch]: d, [ci]: [{ [cj]: "ForcePathStyle" }, !1] }, av = { [cj]: "ForcePathStyle" }, aw = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, !1] }, ax = { [ch]: g, [ci]: [{ [cj]: "Region" }, "aws-global"] }, ay = { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: A, [cr]: "us-east-1" }] }, az = { [ch]: r, [ci]: [ax] }, aA = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, !0] }, aB = { [cl]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] }, [cs]: {} }, aC = { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] }, aD = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, !1] }, aE = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, !1] }, aF = { [cl]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, aG = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, !1] }, aH = { [cl]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, aI = { [cl]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, aJ = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [af, "isIp"] }, !1] }, aK = { [cl]: B, [cm]: aC, [cs]: {} }, aL = { [cl]: q, [cm]: aC, [cs]: {} }, aM = { [n]: aL, [cf]: n }, aN = { [cl]: C, [cm]: aC, [cs]: {} }, aO = { [cl]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, aP = { [e]: "Invalid region: region was not a valid DNS name.", [cf]: e }, aQ = { [cj]: F }, aR = { [cj]: G }, aS = { [ch]: h, [ci]: [aQ, "service"] }, aT = { [cj]: K }, aU = { [cg]: [X], [e]: "S3 Object Lambda does not support Dual-stack", [cf]: e }, aV = { [cg]: [V], [e]: "S3 Object Lambda does not support S3 Accelerate", [cf]: e }, aW = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "DisableAccessPoints" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableAccessPoints" }, !0] }], [e]: "Access points are not supported for this operation", [cf]: e }, aX = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "UseArnRegion" }] }, { [ch]: d, [ci]: [{ [cj]: "UseArnRegion" }, !1] }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, "{Region}"] }] }], [e]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cf]: e }, aY = { [ch]: h, [ci]: [{ [cj]: "bucketPartition" }, i] }, aZ = { [ch]: h, [ci]: [aQ, "accountId"] }, ba = { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: I, [cr]: "{bucketArn#region}" }] }, bb = { [e]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cf]: e }, bc = { [e]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cf]: e }, bd = { [e]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cf]: e }, be = { [e]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cf]: e }, bf = { [e]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cf]: e }, bg = { [e]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cf]: e }, bh = { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: A, [cr]: "{bucketArn#region}" }] }, bi = { [co]: [{ [cp]: !0, [i]: y, [cq]: z, [ct]: ["*"] }, { [cp]: !0, [i]: "sigv4", [cq]: z, [cr]: "{bucketArn#region}" }] }, bj = { [ch]: E, [ci]: [ac] }, bk = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} }, bl = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} }, bm = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} }, bn = { [cl]: P, [cm]: aC, [cs]: {} }, bo = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} }, bp = { [cj]: "UseObjectLambdaEndpoint" }, bq = { [co]: [{ [cp]: !0, [i]: "sigv4", [cq]: I, [cr]: "{Region}" }] }, br = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, bs = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, bt = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, bu = { [cl]: s, [cm]: aC, [cs]: {} }, bv = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} }, bw = [{ [cj]: "Region" }], bx = [{ [cj]: "Endpoint" }], by = [ac], bz = [X], bA = [V], bB = [Y, ad], bC = [{ [ch]: c, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }, !0] }], bD = [ae], bE = [ag], bF = [aj], bG = [W], bH = [{ [ch]: j, [ci]: [ac, 6, 14, !0], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 14, 16, !0], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }], bI = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }], bJ = [{ [ch]: j, [ci]: [ac, 6, 15, !0], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 15, 17, !0], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }], bK = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }], bL = [ab], bM = [{ [ch]: x, [ci]: [{ [cj]: w }, !1] }], bN = [{ [ch]: g, [ci]: [{ [cj]: u }, "beta"] }], bO = ["*"], bP = [Z], bQ = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, !1] }], bR = [{ [ch]: g, [ci]: [{ [cj]: "Region" }, "us-east-1"] }], bS = [{ [ch]: g, [ci]: [aR, J] }], bT = [{ [ch]: h, [ci]: [aQ, "resourceId[1]"], [ck]: K }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aT, H] }] }], bU = [aQ, "resourceId[1]"], bV = [{ [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, H] }] }], bW = [{ [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[2]"] }] }] }], bX = [aQ, "resourceId[2]"], bY = [{ [ch]: f, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }], [ck]: "bucketPartition" }], bZ = [{ [ch]: g, [ci]: [aY, { [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }] }], ca = [{ [ch]: x, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, !0] }], cb = [{ [ch]: x, [ci]: [aZ, !1] }], cc = [{ [ch]: x, [ci]: [aT, !1] }], cd = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, !0] }], _data = { version: "1.0", parameters: { Bucket: S, Region: S, UseFIPS: T, UseDualStack: T, Endpoint: S, ForcePathStyle: T, Accelerate: T, UseGlobalEndpoint: T, UseObjectLambdaEndpoint: U, Key: S, Prefix: S, DisableAccessPoints: U, DisableMultiRegionAccessPoints: T, UseArnRegion: U, UseS3ExpressControlEndpoint: U, DisableS3ExpressSessionAuth: U }, rules: [{ [cg]: [{ [ch]: c, [ci]: bw }], rules: [{ [cg]: [V, W], error: "Accelerate cannot be used with FIPS", [cf]: e }, { [cg]: [X, Y], error: "Cannot set dual-stack in combination with a custom endpoint.", [cf]: e }, { [cg]: [Y, W], error: "A custom endpoint cannot be combined with FIPS", [cf]: e }, { [cg]: [Y, V], error: "A custom endpoint cannot be combined with S3 Accelerate", [cf]: e }, { [cg]: [W, Z, aa], error: "Partition does not support FIPS", [cf]: e }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 0, 6, b], [ck]: k }, { [ch]: g, [ci]: [{ [cj]: k }, "--x-s3"] }], rules: [{ [cg]: bz, error: "S3Express does not support Dual-stack.", [cf]: e }, { [cg]: bA, error: "S3Express does not support S3 Accelerate.", [cf]: e }, { [cg]: bB, rules: [{ [cg]: bC, rules: [{ [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: [am, an], rules: [{ [cg]: [ag, ao], rules: [{ [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ [cg]: bC, rules: [{ [cg]: bH, rules: bI, [cf]: o }, { [cg]: bJ, rules: bI, [cf]: o }, ap], [cf]: o }, { [cg]: bH, rules: bK, [cf]: o }, { [cg]: bJ, rules: bK, [cf]: o }, ap], [cf]: o }, ak], [cf]: o }, { [cg]: [aq, am, an], rules: [{ [cg]: bB, endpoint: { [cl]: s, [cm]: ah, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 49, 50, b], [ck]: t }, { [ch]: j, [ci]: [ac, 8, 12, b], [ck]: u }, { [ch]: j, [ci]: [ac, 0, 7, b], [ck]: v }, { [ch]: j, [ci]: [ac, 32, 49, b], [ck]: w }, { [ch]: f, [ci]: bw, [ck]: "regionPartition" }, { [ch]: g, [ci]: [{ [cj]: v }, "--op-s3"] }], rules: [{ [cg]: bM, rules: [{ [cg]: [{ [ch]: g, [ci]: [ar, "e"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.ec2.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [ar, "o"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cf]: e }], [cf]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cf]: e }], [cf]: o }, { [cg]: bL, rules: [{ [cg]: [Y, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: l, [ci]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cf]: e }, { [cg]: [au, aj], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [{ [cg]: [V, aa], error: "S3 Accelerate cannot be used in this region", [cf]: e }, { [cg]: [X, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, W, aw, ao, az, aA], rules: [{ endpoint: aB, [cf]: n }], [cf]: o }, { [cg]: [X, W, aw, ao, az, aD], endpoint: aB, [cf]: n }, { [cg]: [aE, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, W, aw, ao, az, aA], rules: [{ endpoint: aF, [cf]: n }], [cf]: o }, { [cg]: [aE, W, aw, ao, az, aD], endpoint: aF, [cf]: n }, { [cg]: [X, aG, V, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, V, ao, az, aA], rules: [{ endpoint: aH, [cf]: n }], [cf]: o }, { [cg]: [X, aG, V, ao, az, aD], endpoint: aH, [cf]: n }, { [cg]: [X, aG, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, aw, ao, az, aA], rules: [{ endpoint: aI, [cf]: n }], [cf]: o }, { [cg]: [X, aG, aw, ao, az, aD], endpoint: aI, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, ax], endpoint: { [cl]: B, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, ax], endpoint: { [cl]: q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aA], rules: [{ [cg]: bR, endpoint: aK, [cf]: n }, { endpoint: aK, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aA], rules: [{ [cg]: bR, endpoint: aL, [cf]: n }, aM], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aD], endpoint: aK, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aD], endpoint: aL, [cf]: n }, { [cg]: [aE, aG, V, ao, ax], endpoint: { [cl]: C, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, V, ao, az, aA], rules: [{ [cg]: bR, endpoint: aN, [cf]: n }, { endpoint: aN, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, V, ao, az, aD], endpoint: aN, [cf]: n }, { [cg]: [aE, aG, aw, ao, ax], endpoint: { [cl]: D, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: D, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: aO, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, ao, az, aD], endpoint: aO, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [Y, ad, { [ch]: g, [ci]: [{ [ch]: h, [ci]: [af, "scheme"] }, "http"] }, { [ch]: p, [ci]: [ac, b] }, au, aG, aE, aw], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [aM], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [au, { [ch]: E, [ci]: by, [ck]: F }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[0]"], [ck]: G }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aR, H] }] }], rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, I] }], rules: [{ [cg]: bS, rules: [{ [cg]: bT, rules: [aU, aV, { [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aZ, H] }], error: "Invalid ARN: Missing account id", [cf]: e }, { [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bB, endpoint: { [cl]: L, [cm]: ba, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [cf]: e }], [cf]: o }, bg], [cf]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cf]: e }], [cf]: o }, { [cg]: bS, rules: [{ [cg]: bT, rules: [{ [cg]: bV, rules: [{ [cg]: bS, rules: [{ [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: [{ [ch]: g, [ci]: [aY, "{partitionResult#name}"] }], rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, A] }], rules: [{ [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bA, error: "Access Points do not support S3 Accelerate", [cf]: e }, { [cg]: [W, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [W, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad], endpoint: { [cl]: L, [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cf]: e }], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: x, [ci]: [aT, b] }], rules: [{ [cg]: bz, error: "S3 MRAP does not support dual-stack", [cf]: e }, { [cg]: bG, error: "S3 MRAP does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 MRAP does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [{ [cj]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cf]: e }, { [cg]: [{ [ch]: f, [ci]: bw, [ck]: M }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: M }, i] }, { [ch]: h, [ci]: [aQ, "partition"] }] }], rules: [{ endpoint: { [cl]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cm]: { [co]: [{ [cp]: b, name: y, [cq]: A, [ct]: bO }] }, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cf]: e }], [cf]: o }], [cf]: o }, { error: "Invalid Access Point Name", [cf]: e }], [cf]: o }, bg], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [aS, z] }], rules: [{ [cg]: bz, error: "S3 Outposts does not support Dual-stack", [cf]: e }, { [cg]: bG, error: "S3 Outposts does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 Outposts does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cf]: e }, { [cg]: [{ [ch]: h, [ci]: bU, [ck]: w }], rules: [{ [cg]: bM, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: cb, rules: [{ [cg]: [{ [ch]: h, [ci]: bX, [ck]: N }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[3]"], [ck]: K }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [cj]: N }, J] }], rules: [{ [cg]: bB, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cm]: bi, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bi, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cf]: e }], [cf]: o }, { error: "Invalid ARN: expected an access point name", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Expected a 4-component resource", [cf]: e }], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cf]: e }], [cf]: o }, { error: "Invalid ARN: The Outpost Id was not set", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cf]: e }], [cf]: o }, { error: "Invalid ARN: No ARN type specified", [cf]: e }], [cf]: o }, { [cg]: [{ [ch]: j, [ci]: [ac, 0, 4, a], [ck]: O }, { [ch]: g, [ci]: [{ [cj]: O }, "arn:"] }, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [bj] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [av, b] }, bj], error: "Path-style addressing cannot be used with ARN buckets", [cf]: e }, { [cg]: bE, rules: [{ [cg]: bP, rules: [{ [cg]: [aw], rules: [{ [cg]: [X, ao, W, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, W, az, aA], rules: [{ endpoint: bk, [cf]: n }], [cf]: o }, { [cg]: [X, ao, W, az, aD], endpoint: bk, [cf]: n }, { [cg]: [aE, ao, W, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, W, az, aA], rules: [{ endpoint: bl, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, W, az, aD], endpoint: bl, [cf]: n }, { [cg]: [X, ao, aG, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, aG, az, aA], rules: [{ endpoint: bm, [cf]: n }], [cf]: o }, { [cg]: [X, ao, aG, az, aD], endpoint: bm, [cf]: n }, { [cg]: [aE, Y, ad, aG, ax], endpoint: { [cl]: P, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, Y, ad, aG, az, aA], rules: [{ [cg]: bR, endpoint: bn, [cf]: n }, { endpoint: bn, [cf]: n }], [cf]: o }, { [cg]: [aE, Y, ad, aG, az, aD], endpoint: bn, [cf]: n }, { [cg]: [aE, ao, aG, ax], endpoint: { [cl]: Q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, aG, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: Q, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bo, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, aG, az, aD], endpoint: bo, [cf]: n }], [cf]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cf]: e }], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: c, [ci]: [bp] }, { [ch]: d, [ci]: [bp, b] }], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [aU, aV, { [cg]: bB, endpoint: { [cl]: s, [cm]: bq, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [aq], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [{ [cg]: [W, X, ao, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, X, ao, az, aA], rules: [{ endpoint: br, [cf]: n }], [cf]: o }, { [cg]: [W, X, ao, az, aD], endpoint: br, [cf]: n }, { [cg]: [W, aE, ao, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, aE, ao, az, aA], rules: [{ endpoint: bs, [cf]: n }], [cf]: o }, { [cg]: [W, aE, ao, az, aD], endpoint: bs, [cf]: n }, { [cg]: [aG, X, ao, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, X, ao, az, aA], rules: [{ endpoint: bt, [cf]: n }], [cf]: o }, { [cg]: [aG, X, ao, az, aD], endpoint: bt, [cf]: n }, { [cg]: [aG, aE, Y, ad, ax], endpoint: { [cl]: s, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad, az, aA], rules: [{ [cg]: bR, endpoint: bu, [cf]: n }, { endpoint: bu, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, Y, ad, az, aD], endpoint: bu, [cf]: n }, { [cg]: [aG, aE, ao, ax], endpoint: { [cl]: R, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: R, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bv, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, ao, az, aD], endpoint: bv, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }], [cf]: o }, { error: "A region must be set when sending requests to S3.", [cf]: e }] }, ruleSet = _data, defaultEndpointResolver = ($, ee = {}) => resolveEndpoint(ruleSet, {
  endpointParams: $,
  logger: ee.logger
});
customEndpointFunctions.aws = awsEndpointFunctions;
const getRuntimeConfig$1 = ($) => ({
  apiVersion: "2006-03-01",
  base64Decoder: ($ == null ? void 0 : $.base64Decoder) ?? fromBase64,
  base64Encoder: ($ == null ? void 0 : $.base64Encoder) ?? toBase64,
  disableHostPrefix: ($ == null ? void 0 : $.disableHostPrefix) ?? !1,
  endpointProvider: ($ == null ? void 0 : $.endpointProvider) ?? defaultEndpointResolver,
  extensions: ($ == null ? void 0 : $.extensions) ?? [],
  getAwsChunkedEncodingStream: ($ == null ? void 0 : $.getAwsChunkedEncodingStream) ?? getAwsChunkedEncodingStream,
  logger: ($ == null ? void 0 : $.logger) ?? new NoOpLogger(),
  sdkStreamMixin: ($ == null ? void 0 : $.sdkStreamMixin) ?? sdkStreamMixin,
  serviceId: ($ == null ? void 0 : $.serviceId) ?? "S3",
  signerConstructor: ($ == null ? void 0 : $.signerConstructor) ?? SignatureV4MultiRegion,
  signingEscapePath: ($ == null ? void 0 : $.signingEscapePath) ?? !1,
  urlParser: ($ == null ? void 0 : $.urlParser) ?? parseUrl,
  useArnRegion: ($ == null ? void 0 : $.useArnRegion) ?? !1,
  utf8Decoder: ($ == null ? void 0 : $.utf8Decoder) ?? fromUtf8$3,
  utf8Encoder: ($ == null ? void 0 : $.utf8Encoder) ?? toUtf8$3
}), DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"], resolveDefaultsModeConfig = ({ defaultsMode: $ } = {}) => memoize(async () => {
  const ee = typeof $ == "function" ? await $() : $;
  switch (ee == null ? void 0 : ee.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(ee == null ? void 0 : ee.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${ee}`);
  }
}), isMobileBrowser = () => {
  var te, ne;
  const $ = typeof window < "u" && ((te = window == null ? void 0 : window.navigator) != null && te.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0, ee = (ne = $ == null ? void 0 : $.platform) == null ? void 0 : ne.type;
  return ee === "tablet" || ee === "mobile";
}, getRuntimeConfig = ($) => {
  const ee = resolveDefaultsModeConfig($), te = () => ee().then(loadConfigsForDefaultMode), ne = getRuntimeConfig$1($);
  return {
    ...ne,
    ...$,
    runtime: "browser",
    defaultsMode: ee,
    bodyLengthChecker: ($ == null ? void 0 : $.bodyLengthChecker) ?? calculateBodyLength,
    credentialDefaultProvider: ($ == null ? void 0 : $.credentialDefaultProvider) ?? ((re) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: ($ == null ? void 0 : $.defaultUserAgentProvider) ?? defaultUserAgent({ serviceId: ne.serviceId, clientVersion: packageInfo.version }),
    eventStreamSerdeProvider: ($ == null ? void 0 : $.eventStreamSerdeProvider) ?? eventStreamSerdeProvider,
    maxAttempts: ($ == null ? void 0 : $.maxAttempts) ?? DEFAULT_MAX_ATTEMPTS,
    md5: ($ == null ? void 0 : $.md5) ?? Md5,
    region: ($ == null ? void 0 : $.region) ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create(($ == null ? void 0 : $.requestHandler) ?? te),
    retryMode: ($ == null ? void 0 : $.retryMode) ?? (async () => (await te()).retryMode || DEFAULT_RETRY_MODE),
    sha1: ($ == null ? void 0 : $.sha1) ?? build$7.Sha1,
    sha256: ($ == null ? void 0 : $.sha256) ?? build$3.Sha256,
    streamCollector: ($ == null ? void 0 : $.streamCollector) ?? streamCollector,
    streamHasher: ($ == null ? void 0 : $.streamHasher) ?? blobHasher,
    useDualstackEndpoint: ($ == null ? void 0 : $.useDualstackEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: ($ == null ? void 0 : $.useFipsEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
}, getAwsRegionExtensionConfiguration = ($) => {
  let ee = async () => {
    if ($.region === void 0)
      throw new Error("Region is missing from runtimeConfig");
    const te = $.region;
    return typeof te == "string" ? te : te();
  };
  return {
    setRegion(te) {
      ee = te;
    },
    region() {
      return ee;
    }
  };
}, resolveAwsRegionExtensionConfiguration = ($) => ({
  region: $.region()
}), asPartial = ($) => $, resolveRuntimeExtensions = ($, ee) => {
  const te = {
    ...asPartial(getAwsRegionExtensionConfiguration($)),
    ...asPartial(getDefaultExtensionConfiguration($)),
    ...asPartial(getHttpHandlerExtensionConfiguration($))
  };
  return ee.forEach((ne) => ne.configure(te)), {
    ...$,
    ...resolveAwsRegionExtensionConfiguration(te),
    ...resolveDefaultRuntimeConfig(te),
    ...resolveHttpHandlerRuntimeConfig(te)
  };
};
class S3Client extends Client {
  constructor(...[ee]) {
    const te = getRuntimeConfig(ee || {}), ne = resolveClientEndpointParameters(te), re = resolveRegionConfig(ne), se = resolveEndpointConfig(re), ie = resolveRetryConfig(se), oe = ie, le = resolveAwsAuthConfig(oe), ue = resolveS3Config(le, { session: [() => this, CreateSessionCommand] }), de = resolveUserAgentConfig(ue), fe = resolveEventStreamSerdeConfig(de), pe = resolveRuntimeExtensions(fe, (ee == null ? void 0 : ee.extensions) || []);
    super(pe), this.config = pe, this.middlewareStack.use(getRetryPlugin(this.config)), this.middlewareStack.use(getContentLengthPlugin(this.config)), this.middlewareStack.use(getHostHeaderPlugin(this.config)), this.middlewareStack.use(getLoggerPlugin(this.config)), this.middlewareStack.use(getRecursionDetectionPlugin(this.config)), this.middlewareStack.use(getAwsAuthPlugin(this.config)), this.middlewareStack.use(getValidateBucketNamePlugin(this.config)), this.middlewareStack.use(getAddExpectContinuePlugin(this.config)), this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config)), this.middlewareStack.use(getS3ExpressPlugin(this.config)), this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}
function ssecMiddleware($) {
  return (ee) => async (te) => {
    const ne = { ...te.input }, re = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const se of re) {
      const ie = ne[se.target];
      if (ie) {
        let oe;
        typeof ie == "string" ? isValidBase64EncodedSSECustomerKey(ie, $) ? oe = $.base64Decoder(ie) : (oe = $.utf8Decoder(ie), ne[se.target] = $.base64Encoder(oe)) : (oe = ArrayBuffer.isView(ie) ? new Uint8Array(ie.buffer, ie.byteOffset, ie.byteLength) : new Uint8Array(ie), ne[se.target] = $.base64Encoder(oe));
        const le = new $.md5();
        le.update(oe), ne[se.hash] = $.base64Encoder(await le.digest());
      }
    }
    return ee({
      ...te,
      input: ne
    });
  };
}
const ssecMiddlewareOptions = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: !0
}, getSsecPlugin = ($) => ({
  applyToStack: (ee) => {
    ee.add(ssecMiddleware($), ssecMiddlewareOptions);
  }
});
function isValidBase64EncodedSSECustomerKey($, ee) {
  if (!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test($))
    return !1;
  try {
    return ee.base64Decoder($).length === 32;
  } catch {
    return !1;
  }
}
var ChecksumAlgorithm;
(function($) {
  $.MD5 = "MD5", $.CRC32 = "CRC32", $.CRC32C = "CRC32C", $.SHA1 = "SHA1", $.SHA256 = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function($) {
  $.HEADER = "header", $.TRAILER = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));
const DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.MD5, S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32, CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
], PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
], getChecksumAlgorithmForRequest = ($, { requestChecksumRequired: ee, requestAlgorithmMember: te }, ne) => {
  const re = ne ? S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM : DEFAULT_CHECKSUM_ALGORITHM;
  if (!te || !$[te])
    return ee ? re : void 0;
  const se = $[te];
  if (!CLIENT_SUPPORTED_ALGORITHMS.includes(se))
    throw new Error(`The checksum algorithm "${se}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
  return se;
}, getChecksumLocationName = ($) => $ === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${$.toLowerCase()}`, hasHeader = ($, ee) => {
  const te = $.toLowerCase();
  for (const ne of Object.keys(ee))
    if (te === ne.toLowerCase())
      return !0;
  return !1;
}, isStreaming = ($) => $ !== void 0 && typeof $ != "string" && !ArrayBuffer.isView($) && !isArrayBuffer($);
var build = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function($, ee) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(te, ne) {
    te.__proto__ = ne;
  } || function(te, ne) {
    for (var re in ne)
      ne.hasOwnProperty(re) && (te[re] = ne[re]);
  }, extendStatics($, ee);
};
function __extends($, ee) {
  extendStatics($, ee);
  function te() {
    this.constructor = $;
  }
  $.prototype = ee === null ? Object.create(ee) : (te.prototype = ee.prototype, new te());
}
var __assign = function() {
  return __assign = Object.assign || function(ee) {
    for (var te, ne = 1, re = arguments.length; ne < re; ne++) {
      te = arguments[ne];
      for (var se in te)
        Object.prototype.hasOwnProperty.call(te, se) && (ee[se] = te[se]);
    }
    return ee;
  }, __assign.apply(this, arguments);
};
function __rest($, ee) {
  var te = {};
  for (var ne in $)
    Object.prototype.hasOwnProperty.call($, ne) && ee.indexOf(ne) < 0 && (te[ne] = $[ne]);
  if ($ != null && typeof Object.getOwnPropertySymbols == "function")
    for (var re = 0, ne = Object.getOwnPropertySymbols($); re < ne.length; re++)
      ee.indexOf(ne[re]) < 0 && Object.prototype.propertyIsEnumerable.call($, ne[re]) && (te[ne[re]] = $[ne[re]]);
  return te;
}
function __decorate($, ee, te, ne) {
  var re = arguments.length, se = re < 3 ? ee : ne === null ? ne = Object.getOwnPropertyDescriptor(ee, te) : ne, ie;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    se = Reflect.decorate($, ee, te, ne);
  else
    for (var oe = $.length - 1; oe >= 0; oe--)
      (ie = $[oe]) && (se = (re < 3 ? ie(se) : re > 3 ? ie(ee, te, se) : ie(ee, te)) || se);
  return re > 3 && se && Object.defineProperty(ee, te, se), se;
}
function __param($, ee) {
  return function(te, ne) {
    ee(te, ne, $);
  };
}
function __metadata($, ee) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata($, ee);
}
function __awaiter($, ee, te, ne) {
  function re(se) {
    return se instanceof te ? se : new te(function(ie) {
      ie(se);
    });
  }
  return new (te || (te = Promise))(function(se, ie) {
    function oe(de) {
      try {
        ue(ne.next(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function le(de) {
      try {
        ue(ne.throw(de));
      } catch (fe) {
        ie(fe);
      }
    }
    function ue(de) {
      de.done ? se(de.value) : re(de.value).then(oe, le);
    }
    ue((ne = ne.apply($, ee || [])).next());
  });
}
function __generator($, ee) {
  var te = { label: 0, sent: function() {
    if (se[0] & 1)
      throw se[1];
    return se[1];
  }, trys: [], ops: [] }, ne, re, se, ie;
  return ie = { next: oe(0), throw: oe(1), return: oe(2) }, typeof Symbol == "function" && (ie[Symbol.iterator] = function() {
    return this;
  }), ie;
  function oe(ue) {
    return function(de) {
      return le([ue, de]);
    };
  }
  function le(ue) {
    if (ne)
      throw new TypeError("Generator is already executing.");
    for (; te; )
      try {
        if (ne = 1, re && (se = ue[0] & 2 ? re.return : ue[0] ? re.throw || ((se = re.return) && se.call(re), 0) : re.next) && !(se = se.call(re, ue[1])).done)
          return se;
        switch (re = 0, se && (ue = [ue[0] & 2, se.value]), ue[0]) {
          case 0:
          case 1:
            se = ue;
            break;
          case 4:
            return te.label++, { value: ue[1], done: !1 };
          case 5:
            te.label++, re = ue[1], ue = [0];
            continue;
          case 7:
            ue = te.ops.pop(), te.trys.pop();
            continue;
          default:
            if (se = te.trys, !(se = se.length > 0 && se[se.length - 1]) && (ue[0] === 6 || ue[0] === 2)) {
              te = 0;
              continue;
            }
            if (ue[0] === 3 && (!se || ue[1] > se[0] && ue[1] < se[3])) {
              te.label = ue[1];
              break;
            }
            if (ue[0] === 6 && te.label < se[1]) {
              te.label = se[1], se = ue;
              break;
            }
            if (se && te.label < se[2]) {
              te.label = se[2], te.ops.push(ue);
              break;
            }
            se[2] && te.ops.pop(), te.trys.pop();
            continue;
        }
        ue = ee.call($, te);
      } catch (de) {
        ue = [6, de], re = 0;
      } finally {
        ne = se = 0;
      }
    if (ue[0] & 5)
      throw ue[1];
    return { value: ue[0] ? ue[1] : void 0, done: !0 };
  }
}
function __createBinding($, ee, te, ne) {
  ne === void 0 && (ne = te), $[ne] = ee[te];
}
function __exportStar($, ee) {
  for (var te in $)
    te !== "default" && !ee.hasOwnProperty(te) && (ee[te] = $[te]);
}
function __values($) {
  var ee = typeof Symbol == "function" && Symbol.iterator, te = ee && $[ee], ne = 0;
  if (te)
    return te.call($);
  if ($ && typeof $.length == "number")
    return {
      next: function() {
        return $ && ne >= $.length && ($ = void 0), { value: $ && $[ne++], done: !$ };
      }
    };
  throw new TypeError(ee ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read($, ee) {
  var te = typeof Symbol == "function" && $[Symbol.iterator];
  if (!te)
    return $;
  var ne = te.call($), re, se = [], ie;
  try {
    for (; (ee === void 0 || ee-- > 0) && !(re = ne.next()).done; )
      se.push(re.value);
  } catch (oe) {
    ie = { error: oe };
  } finally {
    try {
      re && !re.done && (te = ne.return) && te.call(ne);
    } finally {
      if (ie)
        throw ie.error;
    }
  }
  return se;
}
function __spread() {
  for (var $ = [], ee = 0; ee < arguments.length; ee++)
    $ = $.concat(__read(arguments[ee]));
  return $;
}
function __spreadArrays() {
  for (var $ = 0, ee = 0, te = arguments.length; ee < te; ee++)
    $ += arguments[ee].length;
  for (var ne = Array($), re = 0, ee = 0; ee < te; ee++)
    for (var se = arguments[ee], ie = 0, oe = se.length; ie < oe; ie++, re++)
      ne[re] = se[ie];
  return ne;
}
function __await($) {
  return this instanceof __await ? (this.v = $, this) : new __await($);
}
function __asyncGenerator($, ee, te) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ne = te.apply($, ee || []), re, se = [];
  return re = {}, ie("next"), ie("throw"), ie("return"), re[Symbol.asyncIterator] = function() {
    return this;
  }, re;
  function ie(pe) {
    ne[pe] && (re[pe] = function(ye) {
      return new Promise(function(me, ve) {
        se.push([pe, ye, me, ve]) > 1 || oe(pe, ye);
      });
    });
  }
  function oe(pe, ye) {
    try {
      le(ne[pe](ye));
    } catch (me) {
      fe(se[0][3], me);
    }
  }
  function le(pe) {
    pe.value instanceof __await ? Promise.resolve(pe.value.v).then(ue, de) : fe(se[0][2], pe);
  }
  function ue(pe) {
    oe("next", pe);
  }
  function de(pe) {
    oe("throw", pe);
  }
  function fe(pe, ye) {
    pe(ye), se.shift(), se.length && oe(se[0][0], se[0][1]);
  }
}
function __asyncDelegator($) {
  var ee, te;
  return ee = {}, ne("next"), ne("throw", function(re) {
    throw re;
  }), ne("return"), ee[Symbol.iterator] = function() {
    return this;
  }, ee;
  function ne(re, se) {
    ee[re] = $[re] ? function(ie) {
      return (te = !te) ? { value: __await($[re](ie)), done: re === "return" } : se ? se(ie) : ie;
    } : se;
  }
}
function __asyncValues($) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var ee = $[Symbol.asyncIterator], te;
  return ee ? ee.call($) : ($ = typeof __values == "function" ? __values($) : $[Symbol.iterator](), te = {}, ne("next"), ne("throw"), ne("return"), te[Symbol.asyncIterator] = function() {
    return this;
  }, te);
  function ne(se) {
    te[se] = $[se] && function(ie) {
      return new Promise(function(oe, le) {
        ie = $[se](ie), re(oe, le, ie.done, ie.value);
      });
    };
  }
  function re(se, ie, oe, le) {
    Promise.resolve(le).then(function(ue) {
      se({ value: ue, done: oe });
    }, ie);
  }
}
function __makeTemplateObject($, ee) {
  return Object.defineProperty ? Object.defineProperty($, "raw", { value: ee }) : $.raw = ee, $;
}
function __importStar($) {
  if ($ && $.__esModule)
    return $;
  var ee = {};
  if ($ != null)
    for (var te in $)
      Object.hasOwnProperty.call($, te) && (ee[te] = $[te]);
  return ee.default = $, ee;
}
function __importDefault($) {
  return $ && $.__esModule ? $ : { default: $ };
}
function __classPrivateFieldGet($, ee) {
  if (!ee.has($))
    throw new TypeError("attempted to get private field on non-instance");
  return ee.get($);
}
function __classPrivateFieldSet($, ee, te) {
  if (!ee.has($))
    throw new TypeError("attempted to set private field on non-instance");
  return ee.set($, te), te;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var aws_crc32c = {}, hasRequiredAws_crc32c;
function requireAws_crc32c() {
  if (hasRequiredAws_crc32c)
    return aws_crc32c;
  hasRequiredAws_crc32c = 1, Object.defineProperty(aws_crc32c, "__esModule", { value: !0 }), aws_crc32c.AwsCrc32c = void 0;
  var $ = require$$0, ee = requireBuild$3(), te = requireBuild(), ne = (
    /** @class */
    function() {
      function re() {
        this.crc32c = new te.Crc32c();
      }
      return re.prototype.update = function(se) {
        (0, ee.isEmptyData)(se) || this.crc32c.update((0, ee.convertToBuffer)(se));
      }, re.prototype.digest = function() {
        return $.__awaiter(this, void 0, void 0, function() {
          return $.__generator(this, function(se) {
            return [2, (0, ee.numToUint8)(this.crc32c.digest())];
          });
        });
      }, re.prototype.reset = function() {
        this.crc32c = new te.Crc32c();
      }, re;
    }()
  );
  return aws_crc32c.AwsCrc32c = ne, aws_crc32c;
}
var hasRequiredBuild;
function requireBuild() {
  return hasRequiredBuild || (hasRequiredBuild = 1, function($) {
    Object.defineProperty($, "__esModule", { value: !0 }), $.AwsCrc32c = $.Crc32c = $.crc32c = void 0;
    var ee = require$$0, te = requireBuild$3();
    function ne(le) {
      return new re().update(le).digest();
    }
    $.crc32c = ne;
    var re = (
      /** @class */
      function() {
        function le() {
          this.checksum = 4294967295;
        }
        return le.prototype.update = function(ue) {
          var de, fe;
          try {
            for (var pe = ee.__values(ue), ye = pe.next(); !ye.done; ye = pe.next()) {
              var me = ye.value;
              this.checksum = this.checksum >>> 8 ^ ie[(this.checksum ^ me) & 255];
            }
          } catch (ve) {
            de = { error: ve };
          } finally {
            try {
              ye && !ye.done && (fe = pe.return) && fe.call(pe);
            } finally {
              if (de)
                throw de.error;
            }
          }
          return this;
        }, le.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, le;
      }()
    );
    $.Crc32c = re;
    var se = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ], ie = (0, te.uint32ArrayFrom)(se), oe = requireAws_crc32c();
    Object.defineProperty($, "AwsCrc32c", { enumerable: !0, get: function() {
      return oe.AwsCrc32c;
    } });
  }(build)), build;
}
var buildExports = requireBuild();
const selectChecksumAlgorithmFunction = ($, ee) => ({
  [ChecksumAlgorithm.MD5]: ee.md5,
  [ChecksumAlgorithm.CRC32]: buildExports$1.AwsCrc32,
  [ChecksumAlgorithm.CRC32C]: buildExports.AwsCrc32c,
  [ChecksumAlgorithm.SHA1]: ee.sha1,
  [ChecksumAlgorithm.SHA256]: ee.sha256
})[$], stringHasher = ($, ee) => {
  const te = new $();
  return te.update(toUint8Array(ee || "")), te.digest();
}, flexibleChecksumsMiddlewareOptions = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: !0
}, flexibleChecksumsMiddleware = ($, ee) => (te, ne) => async (re) => {
  if (!HttpRequest.isInstance(re.request))
    return te(re);
  const { request: se } = re, { body: ie, headers: oe } = se, { base64Encoder: le, streamHasher: ue } = $, { input: de, requestChecksumRequired: fe, requestAlgorithmMember: pe } = ee, ye = getChecksumAlgorithmForRequest(de, {
    requestChecksumRequired: fe,
    requestAlgorithmMember: pe
  }, !!ne.isS3ExpressBucket);
  let me = ie, ve = oe;
  if (ye) {
    const xe = getChecksumLocationName(ye), Ee = selectChecksumAlgorithmFunction(ye, $);
    if (isStreaming(ie)) {
      const { getAwsChunkedEncodingStream: Te, bodyLengthChecker: Se } = $;
      me = Te(ie, {
        base64Encoder: le,
        bodyLengthChecker: Se,
        checksumLocationName: xe,
        checksumAlgorithmFn: Ee,
        streamHasher: ue
      }), ve = {
        ...oe,
        "content-encoding": oe["content-encoding"] ? `${oe["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": oe["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": xe
      }, delete ve["content-length"];
    } else if (!hasHeader(xe, oe)) {
      const Te = await stringHasher(Ee, ie);
      ve = {
        ...oe,
        [xe]: le(Te)
      };
    }
  }
  return await te({
    ...re,
    request: {
      ...se,
      headers: ve,
      body: me
    }
  });
}, getChecksumAlgorithmListForResponse = ($ = []) => {
  const ee = [];
  for (const te of PRIORITY_ORDER_ALGORITHMS)
    !$.includes(te) || !CLIENT_SUPPORTED_ALGORITHMS.includes(te) || ee.push(te);
  return ee;
}, isChecksumWithPartNumber = ($) => {
  const ee = $.lastIndexOf("-");
  if (ee !== -1) {
    const te = $.slice(ee + 1);
    if (!te.startsWith("0")) {
      const ne = parseInt(te, 10);
      if (!isNaN(ne) && ne >= 1 && ne <= 1e4)
        return !0;
    }
  }
  return !1;
};
function createReadStreamOnBuffer($) {
  return new Blob([$]).stream();
}
const getChecksum = async ($, { streamHasher: ee, checksumAlgorithmFn: te, base64Encoder: ne }) => {
  const re = isStreaming($) ? ee(te, $) : stringHasher(te, $);
  return ne(await re);
}, validateChecksumFromResponse = async ($, { config: ee, responseAlgorithms: te }) => {
  const ne = getChecksumAlgorithmListForResponse(te), { body: re, headers: se } = $;
  for (const ie of ne) {
    const oe = getChecksumLocationName(ie), le = se[oe];
    if (le) {
      const ue = selectChecksumAlgorithmFunction(ie, ee), { streamHasher: de, base64Encoder: fe } = ee, pe = await getChecksum(re, { streamHasher: de, checksumAlgorithmFn: ue, base64Encoder: fe });
      if (pe === le)
        break;
      throw new Error(`Checksum mismatch: expected "${pe}" but received "${le}" in response header "${oe}".`);
    }
  }
}, flexibleChecksumsResponseMiddlewareOptions = {
  name: "flexibleChecksumsResponseMiddleware",
  toMiddleware: "deserializerMiddleware",
  relation: "after",
  tags: ["BODY_CHECKSUM"],
  override: !0
}, flexibleChecksumsResponseMiddleware = ($, ee) => (te, ne) => async (re) => {
  if (!HttpRequest.isInstance(re.request))
    return te(re);
  const se = re.input, ie = await te(re), oe = ie.response;
  let le;
  const { requestValidationModeMember: ue, responseAlgorithms: de } = ee;
  if (ue && se[ue] === "ENABLED") {
    const { clientName: fe, commandName: pe } = ne;
    if (fe === "S3Client" && pe === "GetObjectCommand" && getChecksumAlgorithmListForResponse(de).every((ve) => {
      const ge = getChecksumLocationName(ve), xe = oe.headers[ge];
      return !xe || isChecksumWithPartNumber(xe);
    }))
      return ie;
    const me = isStreaming(oe.body);
    me && (le = await $.streamCollector(oe.body), oe.body = createReadStreamOnBuffer(le)), await validateChecksumFromResponse(ie.response, {
      config: $,
      responseAlgorithms: de
    }), me && le && (oe.body = createReadStreamOnBuffer(le));
  }
  return ie;
}, getFlexibleChecksumsPlugin = ($, ee) => ({
  applyToStack: (te) => {
    te.add(flexibleChecksumsMiddleware($, ee), flexibleChecksumsMiddlewareOptions), te.addRelativeTo(flexibleChecksumsResponseMiddleware($, ee), flexibleChecksumsResponseMiddlewareOptions);
  }
});
class PutObjectCommand extends Command.classBuilder().ep({
  ...commonParams,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(ee, te, ne, re) {
  return [
    getSerdePlugin(ne, this.serialize, this.deserialize),
    getEndpointPlugin(ne, ee.getEndpointParameterInstructions()),
    getCheckContentLengthHeaderPlugin(),
    getSsecPlugin(ne),
    getFlexibleChecksumsPlugin(ne, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: !1
    })
  ];
}).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
}
function resolveLogins($) {
  return Promise.all(Object.keys($).reduce((ee, te) => {
    const ne = $[te];
    return typeof ne == "string" ? ee.push([te, ne]) : ee.push(ne().then((re) => [te, re])), ee;
  }, [])).then((ee) => ee.reduce((te, [ne, re]) => (te[ne] = re, te), {}));
}
function fromCognitoIdentity($) {
  return async () => {
    var oe, le, ue;
    (oe = $.logger) == null || oe.debug("@aws-sdk/credential-provider-cognito-identity", "fromCognitoIdentity");
    const { GetCredentialsForIdentityCommand: ee, CognitoIdentityClient: te } = await import("./loadCognitoIdentity-BuEdB0fp.js"), { Credentials: { AccessKeyId: ne = throwOnMissingAccessKeyId(), Expiration: re, SecretKey: se = throwOnMissingSecretKey(), SessionToken: ie } = throwOnMissingCredentials() } = await ($.client ?? new te(Object.assign({}, $.clientConfig ?? {}, {
      region: ((le = $.clientConfig) == null ? void 0 : le.region) ?? ((ue = $.parentClientConfig) == null ? void 0 : ue.region)
    }))).send(new ee({
      CustomRoleArn: $.customRoleArn,
      IdentityId: $.identityId,
      Logins: $.logins ? await resolveLogins($.logins) : void 0
    }));
    return {
      identityId: $.identityId,
      accessKeyId: ne,
      secretAccessKey: se,
      sessionToken: ie,
      expiration: re
    };
  };
}
function throwOnMissingAccessKeyId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID");
}
function throwOnMissingCredentials() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials");
}
function throwOnMissingSecretKey() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key");
}
const STORE_NAME = "IdentityIds";
class IndexedDbStorage {
  constructor(ee = "aws:cognito-identity-ids") {
    this.dbName = ee;
  }
  getItem(ee) {
    return this.withObjectStore("readonly", (te) => {
      const ne = te.get(ee);
      return new Promise((re) => {
        ne.onerror = () => re(null), ne.onsuccess = () => re(ne.result ? ne.result.value : null);
      });
    }).catch(() => null);
  }
  removeItem(ee) {
    return this.withObjectStore("readwrite", (te) => {
      const ne = te.delete(ee);
      return new Promise((re, se) => {
        ne.onerror = () => se(ne.error), ne.onsuccess = () => re();
      });
    });
  }
  setItem(ee, te) {
    return this.withObjectStore("readwrite", (ne) => {
      const re = ne.put({ id: ee, value: te });
      return new Promise((se, ie) => {
        re.onerror = () => ie(re.error), re.onsuccess = () => se();
      });
    });
  }
  getDb() {
    const ee = self.indexedDB.open(this.dbName, 1);
    return new Promise((te, ne) => {
      ee.onsuccess = () => {
        te(ee.result);
      }, ee.onerror = () => {
        ne(ee.error);
      }, ee.onblocked = () => {
        ne(new Error("Unable to access DB"));
      }, ee.onupgradeneeded = () => {
        const re = ee.result;
        re.onerror = () => {
          ne(new Error("Failed to create object store"));
        }, re.createObjectStore(STORE_NAME, { keyPath: "id" });
      };
    });
  }
  withObjectStore(ee, te) {
    return this.getDb().then((ne) => {
      const re = ne.transaction(STORE_NAME, ee);
      return re.oncomplete = () => ne.close(), new Promise((se, ie) => {
        re.onerror = () => ie(re.error), se(te(re.objectStore(STORE_NAME)));
      }).catch((se) => {
        throw ne.close(), se;
      });
    });
  }
}
class InMemoryStorage {
  constructor(ee = {}) {
    this.store = ee;
  }
  getItem(ee) {
    return ee in this.store ? this.store[ee] : null;
  }
  removeItem(ee) {
    delete this.store[ee];
  }
  setItem(ee, te) {
    this.store[ee] = te;
  }
}
const inMemoryStorage = new InMemoryStorage();
function localStorage() {
  return typeof self == "object" && self.indexedDB ? new IndexedDbStorage() : typeof window == "object" && window.localStorage ? window.localStorage : inMemoryStorage;
}
function fromCognitoIdentityPool({ accountId: $, cache: ee = localStorage(), client: te, clientConfig: ne, customRoleArn: re, identityPoolId: se, logins: ie, userIdentifier: oe = !ie || Object.keys(ie).length === 0 ? "ANONYMOUS" : void 0, logger: le, parentClientConfig: ue }) {
  le == null || le.debug("@aws-sdk/credential-provider-cognito-identity", "fromCognitoIdentity");
  const de = oe ? `aws:cognito-identity-credentials:${se}:${oe}` : void 0;
  let fe = async () => {
    const { GetIdCommand: pe, CognitoIdentityClient: ye } = await import("./loadCognitoIdentity-BuEdB0fp.js"), me = te ?? new ye(Object.assign({}, ne ?? {}, { region: (ne == null ? void 0 : ne.region) ?? (ue == null ? void 0 : ue.region) }));
    let ve = de && await ee.getItem(de);
    if (!ve) {
      const { IdentityId: ge = throwOnMissingId() } = await me.send(new pe({
        AccountId: $,
        IdentityPoolId: se,
        Logins: ie ? await resolveLogins(ie) : void 0
      }));
      ve = ge, de && Promise.resolve(ee.setItem(de, ve)).catch(() => {
      });
    }
    return fe = fromCognitoIdentity({
      client: me,
      customRoleArn: re,
      logins: ie,
      identityId: ve
    }), fe();
  };
  return () => fe().catch(async (pe) => {
    throw de && Promise.resolve(ee.removeItem(de)).catch(() => {
    }), pe;
  });
}
function throwOnMissingId() {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID");
}
var LMAppAwsKeys = /* @__PURE__ */ (($) => ($.identityPoolIdBeta = "ap-south-1:181963ba-f2db-450b-8199-964a941b38c2", $.identityPoolIdProd = "ap-south-1:d73bc2ed-bede-42c8-bab7-0abe0a001325", $.bucketNameBeta = "beta-likeminds-media", $.bucketNameProd = "prod-likeminds-media", $.region = "ap-south-1", $))(LMAppAwsKeys || {});
class HelperFunctionsClass {
  static detectLinks(ee) {
    const te = new RegExp("\\b(?:https?:\\/\\/)?(?:[\\w.]+\\.\\w+)(?:(?<=\\\\n)|\\b)", "g"), ne = ee == null ? void 0 : ee.match(te);
    return ne || [];
  }
  static parseDataLayerResponse(ee) {
    return {
      ...ee
    };
  }
  logError(ee) {
    process.env.NODE_ENV === "development" && console.log(`%c ${ee}`, 'background: #222; color: "white";');
  }
  static getAWS() {
    const ee = fromCognitoIdentityPool({
      identityPoolId: LMAppAwsKeys.identityPoolIdProd,
      clientConfig: {
        region: LMAppAwsKeys.region
      }
    });
    return new S3Client({ region: LMAppAwsKeys.region, credentials: ee });
  }
  static async uploadMedia(ee, te) {
    const ne = this.getAWS(), { Key: re, Bucket: se, Body: ie, ACL: oe, ContentType: le } = this.buildUploadParams(
      ee,
      te
    ), ue = new PutObjectCommand({
      Key: re,
      Bucket: se,
      Body: ie,
      ACL: oe,
      ContentType: le
    });
    return ne.send(ue);
  }
  static buildUploadParams(ee, te) {
    return {
      Key: `files/post/${te}/${ee.name}`,
      Bucket: LMAppAwsKeys.bucketNameProd,
      Body: ee,
      ACL: "public-read-write",
      ContentType: ee.type
    };
  }
  // static getAWS() {
  //   // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  //   const s3 = new S3({
  //     apiVersion: "2006-03-01",
  //     params: { Bucket: "beta-likeminds-media" },
  //     credentials: new CognitoIdentityCredentials({
  //       IdentityPoolId: "ap-south-1:181963ba-f2db-450b-8199-964a941b38c2",
  //     }),
  //   });
  //   return s3;
  // }
  // static uploadMedia(media: any, userUniqueId: any) {
  //   const mediaObject = this.getAWS().upload({
  //     Key: `files/post/${userUniqueId}/${media.name}`,
  //     Bucket: "beta-likeminds-media",
  //     Body: media,
  //     ACL: "public-read-write",
  //     ContentType: media.type,
  //   });
  //   return mediaObject.promise();
  // }
}
function useCreatePost() {
  const { lmFeedclient: $, customEventClient: ee, lmfeedAnalyticsClient: te } = useContext(
    GlobalClientProviderContext
  ), { currentCommunity: ne, currentUser: re, logoutUser: se } = useContext(
    UserProviderContext
  ), { displaySnackbarMessage: ie, closeSnackbar: oe, showSnackbar: le, message: ue } = useContext(GeneralContext), {
    PostCreationCustomCallbacks: de = {},
    createPostComponentClickCustomCallback: fe
  } = useContext(CustomAgentProviderContext), { postFeedCustomAction: pe, editPostCustomAction: ye } = de, me = useNavigate(), [ve, ge] = useState(!1), [xe, Ee] = useState(!0), [Te, Se] = useState(""), [he, Pe] = useState(null), [Ie, De] = useState([]), [Ce, Ne] = useState([]), [Me, Be] = useState([]), [We, Le] = useState(
    LMFeedCreatePostMediaUploadMode.NULL
  ), [He, Ge] = useState(null), Ze = useRef(null), Ue = useRef(null);
  function Qe($e) {
    Le($e);
  }
  function Je() {
    Ee(!0), Se(null), Pe(null), De([]), Be([]), Ne([]), Le(LMFeedCreatePostMediaUploadMode.NULL), Ge(null);
  }
  function Ot($e) {
    Se($e);
  }
  function At($e) {
    const qe = $e.target.files, Ye = [...Ie, ...Array.from(qe)];
    De(Ye);
  }
  function ze($e) {
    const qe = [...Ie];
    qe.splice($e, 1), De(qe);
  }
  function we() {
    De([]);
  }
  function Ae() {
    Ee(!1);
  }
  const Re = useCallback(
    async function() {
      var $e, qe, Ye;
      try {
        ge(!1);
        const Ke = extractTextFromNode(
          Ze.current
        ).trim(), Tt = [];
        for (let Bt = 0; Bt < Ie.length; Bt++) {
          const Vt = Ie[Bt], qt = await HelperFunctionsClass.uploadMedia(
            Vt,
            (re == null ? void 0 : re.uuid) || ""
          ), nn = `https://${LMAppAwsKeys.bucketNameProd}.s3.${LMAppAwsKeys.region}.amazonaws.com/${`files/post/${(re == null ? void 0 : re.uuid) || ""}/${Vt.name}`}`;
          switch (Vt.type.includes("image") ? 1 : Vt.type.includes("video") ? 2 : Vt.type.includes("pdf") ? 3 : 4) {
            case 1: {
              Tt.push(
                S$1.builder().setAttachmentType(1).setAttachmentMeta(
                  A$1.builder().seturl(nn).setformat(($e = Vt == null ? void 0 : Vt.name) == null ? void 0 : $e.split(".").slice(-1).toString()).setsize(Vt.size).setname(Vt.name).build()
                ).build()
              );
              break;
            }
            case 2: {
              Tt.push(
                S$1.builder().setAttachmentType(2).setAttachmentMeta(
                  A$1.builder().seturl(nn).setformat((qe = Vt == null ? void 0 : Vt.name) == null ? void 0 : qe.split(".").slice(-1).toString()).setsize(Vt.size).setname(Vt.name).setduration(10).build()
                ).build()
              );
              break;
            }
            case 3: {
              Tt.push(
                S$1.builder().setAttachmentType(3).setAttachmentMeta(
                  A$1.builder().seturl(nn).setformat((Ye = Vt == null ? void 0 : Vt.name) == null ? void 0 : Ye.split(".").slice(-1).toString()).setsize(Vt.size).setname(Vt.name).build()
                ).build()
              );
              break;
            }
          }
        }
        !Ie.length && He && Tt.push(
          S$1.builder().setAttachmentType(4).setAttachmentMeta(
            A$1.builder().setogTags(He).build()
          ).build()
        );
        const pt = await ($ == null ? void 0 : $.addPost(
          I$1.builder().setAttachments(Tt).setText(Ke).setTopicIds(Ce).setTempId(Date.now().toString()).build()
        ));
        pt.success && (te == null || te.sendPostCreatedEvent(pt.data.post), ee == null || ee.dispatchEvent(
          LMFeedCustomActionEvents.POST_CREATED
        ));
      } catch (Ke) {
        console.log(Ke);
      }
    },
    [
      re == null ? void 0 : re.uuid,
      ee,
      $,
      Ie,
      He,
      Ce
    ]
  ), je = useCallback(
    async function() {
      try {
        ge(!1);
        const $e = extractTextFromNode(
          Ze.current
        ).trim(), qe = he != null && he.attachments ? he.attachments : [];
        He ? qe.some(
          (Ke) => Ke.attachmentType === 1 || Ke.attachmentType === 2 || Ke.attachmentType === 3
        ) || (qe.pop(), qe.push(
          S$1.builder().setAttachmentType(4).setAttachmentMeta(
            A$1.builder().setogTags(He).build()
          ).build()
        )) : qe.some(
          (Ke) => Ke.attachmentType === 4
        ) && qe.pop();
        const Ye = await ($ == null ? void 0 : $.editPost(
          z$1.builder().setattachments(qe).settext($e).setTopicIds(Ce).setpostId((he == null ? void 0 : he.Id) || "").build()
        ));
        Ye.success && (te == null || te.sendPostEditedEvent(Ye.data.post), ee == null || ee.dispatchEvent(
          LMFeedCustomActionEvents.POST_EDITED,
          {
            post: Ye.data.post,
            usersMap: Ye.data.users,
            topicsMap: Ye.data.topics
          }
        ), ee == null || ee.dispatchEvent(
          LMFeedCustomActionEvents.POST_EDITED_TARGET_DETAILS,
          {
            post: Ye.data.post,
            usersMap: Ye.data.users,
            topicsMap: Ye.data.topics
          }
        ));
      } catch ($e) {
        console.log($e);
      }
    },
    [
      ee,
      $,
      He,
      Ce,
      he == null ? void 0 : he.Id,
      he == null ? void 0 : he.attachments
    ]
  );
  useEffect(() => {
    const $e = setTimeout(async () => {
      try {
        const qe = HelperFunctionsClass.detectLinks(Te || "");
        if (qe.length) {
          const Ye = qe[0];
          if (Ye.toString() !== (He == null ? void 0 : He.url.toString())) {
            const Ke = await ($ == null ? void 0 : $.decodeURL(
              C$1.builder().setURL(Ye).build()
            ));
            Ke != null && Ke.success && Ge(Ke.data.og_tags);
          }
        } else
          He !== null && Ge(null);
      } catch (qe) {
        console.log(qe);
      }
    }, 500);
    return () => clearTimeout($e);
  }, [$, Te]), useEffect(() => (ee == null || ee.listen(
    LMFeedCustomActionEvents.OPEN_CREATE_POST_DIALOUGE,
    ($e) => {
      var Bt;
      ge(!0);
      const qe = $e.detail, Ye = qe.post, Ke = qe.topics;
      Pe(Ye);
      const Tt = Ye.topics.map((Vt) => Ke[Vt]), pt = (Bt = Ye == null ? void 0 : Ye.attachments) == null ? void 0 : Bt.filter(
        (Vt) => Vt.attachmentType === 4
      );
      pt.length && Ge(pt[0].attachmentMeta.ogTags), Be(Tt);
    }
  ), () => {
    ee == null || ee.remove("OPEN_MENU");
  }), [ee]), useEffect(() => {
    ve || Je();
  }, [ve]);
  const Fe = useMemo(() => ({
    postCreationDataStore: {
      openCreatePostDialog: ve,
      setOpenCreatePostDialog: ge,
      showOGTagViewContainer: xe,
      setShowOGTagViewContainer: Ee,
      text: Te,
      setText: Se,
      temporaryPost: he,
      setTemporaryPost: Pe,
      mediaList: Ie,
      setMediaList: De,
      selectedTopicIds: Ce,
      setSelectedTopicIds: Ne,
      preSelectedTopics: Me,
      setPreSelectedTopics: Be,
      mediaUploadMode: We,
      setMediaUploadMode: Le,
      ogTag: He,
      setOgtag: Ge,
      textFieldRef: Ze,
      containerRef: Ue
    },
    applicationGeneralStore: {
      userDataStore: {
        lmFeedUser: re,
        lmFeedUserCurrentCommunity: ne,
        logOutUser: se
      },
      generalDataStore: {
        displaySnackbarMessage: ie,
        closeSnackbar: oe,
        showSnackbar: le,
        message: ue
      }
    },
    defaultActions: {
      postFeed: Re,
      editPost: je
    },
    navigate: me
  }), [
    me,
    oe,
    ne,
    re,
    ie,
    je,
    se,
    Ie,
    We,
    ue,
    He,
    ve,
    Re,
    Me,
    Ce,
    xe,
    le,
    he,
    Te
  ]);
  return useEffect(() => {
    ve && (te == null || te.sendPostCreationStartedEvent());
  }, [te, ve]), useEffect(() => {
    he ? te == null || te.sendClickedOnAttachmentEvent(
      he.Id,
      We
    ) : te == null || te.sendClickedOnAttachmentEvent(
      null,
      We
    );
  }, [te, We, he]), useEffect(() => {
    He && he ? te == null || te.sendLinkAttachedEvent(He.url, he.Id) : He && (te == null || te.sendLinkAttachedEvent(He.url));
  }, [te, He, he]), {
    postText: Te,
    mediaList: Ie,
    setPostText: Ot,
    addMediaItem: At,
    removeMedia: ze,
    clearMedia: we,
    mediaUploadMode: We,
    changeMediaUploadMode: Qe,
    textFieldRef: Ze,
    containerRef: Ue,
    postFeed: pe ? pe.bind(null, Fe) : Re,
    editPost: ye ? ye.bind(null, Fe) : je,
    ogTag: He,
    openCreatePostDialog: ve,
    setOpenCreatePostDialog: ge,
    temporaryPost: he,
    selectedTopicIds: Ce,
    setSelectedTopicIds: Ne,
    preSelectedTopics: Me,
    setPreSelectedTopics: Be,
    showOGTagViewContainer: xe,
    closeOGTagContainer: Ae,
    createPostComponentClickCustomCallback: fe ? fe.bind(
      null,
      Fe
    ) : void 0
  };
}
const LMFeedTextArea = () => {
  const {
    taggingList: $,
    clearTaggingList: ee,
    fetchTaggingList: te,
    setTaggingString: ne,
    fetchMoreTags: re
  } = useTagging(), { setPostText: se, textFieldRef: ie, containerRef: oe, temporaryPost: le } = useContext(
    LMFeedCreatePostContext
  );
  function ue() {
    if (ie != null && ie.current) {
      ie.current.focus();
      const de = document.createRange();
      de.selectNodeContents(ie.current), de.collapse(!1);
      const fe = window.getSelection();
      fe && (fe.removeAllRanges(), fe.addRange(de));
    }
  }
  return useEffect(() => {
    le && (ie != null && ie.current) && (ie.current.innerHTML = convertTextToHTML(
      le.text
    ).innerHTML), ue();
  }, [ie, le]), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: oe, children: [
    $ && ($ == null ? void 0 : $.length) > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "taggingBox",
        id: "scrollableTaggingContainer",
        style: returnCSSForTagging(oe),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InfiniteScroll,
          {
            loader: null,
            hasMore: re,
            next: te,
            dataLength: $.length,
            scrollableTarget: "scrollableTaggingContainer",
            children: $ == null ? void 0 : $.map((de) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "taggingTile",
                onClick: (fe) => {
                  fe.preventDefault();
                  const pe = window.getSelection();
                  if (!pe)
                    return;
                  const ye = pe.focusNode;
                  if (ye === null)
                    return;
                  const me = ye.parentElement, ve = me.childNodes;
                  if (ye === null || ve.length === 0)
                    return;
                  const ge = ye.textContent;
                  if (ge === null)
                    return;
                  const xe = findTag(ge);
                  if (xe === void 0)
                    return;
                  const { limitLeft: Ee, limitRight: Te } = xe, Se = ge.substring(
                    0,
                    Ee - 1
                  ), he = ge.substring(
                    Te + 1
                  ), Pe = document.createTextNode(Se), Ie = document.createElement("a");
                  Ie.id = de == null ? void 0 : de.id.toString(), Ie.href = "#", Ie.textContent = `@${de == null ? void 0 : de.name.trim()} `, Ie.contentEditable = "false";
                  const De = document.createTextNode(he), Ce = document.createElement("span");
                  me.replaceChild(De, ye), me.insertBefore(Ie, De), me.insertBefore(Ce, Ie), me.insertBefore(Pe, Ce), ee(), setCursorAtEnd(ie);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center"
                    },
                    children: [
                      setTagUserImage(de),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            padding: "0px 0.5rem",
                            textTransform: "capitalize",
                            overflowY: "hidden",
                            textOverflow: "ellipsis"
                          },
                          children: de == null ? void 0 : de.name
                        }
                      )
                    ]
                  }
                )
              },
              (de == null ? void 0 : de.id.toString()) + Math.random().toString()
            ))
          }
        )
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: ie,
        contentEditable: !0,
        suppressContentEditableWarning: !0,
        tabIndex: 0,
        autoFocus: !0,
        id: "editableDiv",
        "data-placeholder": "Write something here...",
        className: "lm-feed-create-post-text-area",
        onKeyDown: (de) => {
          var fe;
          if (de.key === "Enter") {
            de.preventDefault();
            const pe = window.getSelection(), ye = pe.getRangeAt(0).cloneRange(), me = document.createElement("p"), ve = document.createElement("br");
            me.appendChild(ve), (fe = ie == null ? void 0 : ie.current) == null || fe.appendChild(me), ye.setStart(me, 0), ye.setEnd(me, 0), pe.removeAllRanges(), pe.addRange(ye);
          }
        },
        onInput: (de) => {
          const fe = window.getSelection();
          if (se(de.currentTarget.textContent), fe === null)
            return;
          const pe = fe.focusNode;
          if (pe === null)
            return;
          const ye = pe.parentElement;
          if (ye === null)
            return;
          const me = ye.childNodes;
          if (pe === null || me.length === 0)
            return;
          const ve = pe.textContent, ge = findTag(ve);
          (ge == null ? void 0 : ge.tagString) !== null && (ge == null ? void 0 : ge.tagString) !== void 0 ? ne(ge == null ? void 0 : ge.tagString) : ne(null);
        }
      }
    )
  ] });
}, imgMedia = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.75%209.375C15.75%209.67337%2015.6315%209.95952%2015.4205%2010.1705C15.2095%2010.3815%2014.9234%2010.5%2014.625%2010.5C14.3266%2010.5%2014.0405%2010.3815%2013.8295%2010.1705C13.6185%209.95952%2013.5%209.67337%2013.5%209.375C13.5%209.07663%2013.6185%208.79048%2013.8295%208.5795C14.0405%208.36853%2014.3266%208.25%2014.625%208.25C14.9234%208.25%2015.2095%208.36853%2015.4205%208.5795C15.6315%208.79048%2015.75%209.07663%2015.75%209.375ZM21.75%205.25V17.25V18.75C21.75%2019.1478%2021.592%2019.5294%2021.3107%2019.8107C21.0294%2020.092%2020.6478%2020.25%2020.25%2020.25H3.75C3.35218%2020.25%202.97064%2020.092%202.68934%2019.8107C2.40804%2019.5294%202.25%2019.1478%202.25%2018.75V15.75V5.25C2.25%204.85218%202.40804%204.47064%202.68934%204.18934C2.97064%203.90804%203.35218%203.75%203.75%203.75H20.25C20.6478%203.75%2021.0294%203.90804%2021.3107%204.18934C21.592%204.47064%2021.75%204.85218%2021.75%205.25ZM20.25%2015.4406V5.25H3.75V13.9406L7.19062%2010.5C7.47302%2010.2217%207.85355%2010.0658%208.25%2010.0658C8.64645%2010.0658%209.02698%2010.2217%209.30938%2010.5L13.5%2014.6906L15.4406%2012.75C15.723%2012.4717%2016.1036%2012.3158%2016.5%2012.3158C16.8964%2012.3158%2017.277%2012.4717%2017.5594%2012.75L20.25%2015.4406Z'%20fill='%23ED8031'/%3e%3c/svg%3e", docMedia = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M18%2017.25C18%2016.8358%2017.6642%2016.5%2017.25%2016.5H6.5C4.29%2016.5%202.5%2014.71%202.5%2012.5C2.5%2010.29%204.29%208.5%206.5%208.5H19C20.38%208.5%2021.5%209.62%2021.5%2011C21.5%2012.38%2020.38%2013.5%2019%2013.5H10.5C9.95%2013.5%209.5%2013.05%209.5%2012.5C9.5%2011.95%209.95%2011.5%2010.5%2011.5H17.25C17.6642%2011.5%2018%2011.1642%2018%2010.75C18%2010.3358%2017.6642%2010%2017.25%2010H10.5C9.12%2010%208%2011.12%208%2012.5C8%2013.88%209.12%2015%2010.5%2015H19C21.21%2015%2023%2013.21%2023%2011C23%208.79%2021.21%207%2019%207H6.5C3.46%207%201%209.46%201%2012.5C1%2015.54%203.46%2018%206.5%2018H17.25C17.6642%2018%2018%2017.6642%2018%2017.25Z'%20fill='%23484F67'/%3e%3c/svg%3e", closeIcon = "data:image/svg+xml,%3csvg%20width='26'%20height='26'%20viewBox='0%200%2026%2026'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='13'%20cy='13'%20r='12'%20stroke='%23484F67'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M13.6857%2013L17.1141%209.5716L16.4284%208.88592L13%2012.3143L9.5716%208.88592L8.88592%209.5716L12.3143%2013L8.88592%2016.4284L9.5716%2017.1141L13%2013.6857L16.4284%2017.1141L17.1141%2016.4284L13.6857%2013Z'%20fill='%23484F67'/%3e%3cpath%20d='M17.1141%209.5716L17.4676%209.92515L17.8212%209.5716L17.4676%209.21804L17.1141%209.5716ZM13.6857%2013L13.3321%2012.6464L12.9786%2013L13.3321%2013.3535L13.6857%2013ZM16.4284%208.88592L16.782%208.53236L16.4284%208.17881L16.0748%208.53236L16.4284%208.88592ZM13%2012.3143L12.6464%2012.6679L13%2013.0214L13.3536%2012.6679L13%2012.3143ZM9.5716%208.88592L9.92516%208.53236L9.5716%208.17881L9.21805%208.53236L9.5716%208.88592ZM8.88592%209.5716L8.53237%209.21804L8.17882%209.5716L8.53237%209.92515L8.88592%209.5716ZM12.3143%2013L12.6679%2013.3535L13.0214%2013L12.6679%2012.6464L12.3143%2013ZM8.88592%2016.4284L8.53237%2016.0748L8.17882%2016.4284L8.53237%2016.7819L8.88592%2016.4284ZM9.5716%2017.1141L9.21805%2017.4676L9.5716%2017.8212L9.92516%2017.4676L9.5716%2017.1141ZM13%2013.6857L13.3536%2013.3321L13%2012.9786L12.6464%2013.3321L13%2013.6857ZM16.4284%2017.1141L16.0748%2017.4676L16.4284%2017.8212L16.7819%2017.4676L16.4284%2017.1141ZM17.1141%2016.4284L17.4676%2016.7819L17.8212%2016.4284L17.4676%2016.0748L17.1141%2016.4284ZM16.7605%209.21804L13.3321%2012.6464L14.0392%2013.3535L17.4676%209.92515L16.7605%209.21804ZM16.0748%209.23947L16.7605%209.92515L17.4676%209.21804L16.782%208.53236L16.0748%209.23947ZM13.3536%2012.6679L16.782%209.23947L16.0748%208.53236L12.6464%2011.9608L13.3536%2012.6679ZM9.21805%209.23947L12.6464%2012.6679L13.3536%2011.9608L9.92516%208.53236L9.21805%209.23947ZM9.23948%209.92515L9.92516%209.23947L9.21805%208.53236L8.53237%209.21804L9.23948%209.92515ZM12.6679%2012.6464L9.23948%209.21804L8.53237%209.92515L11.9608%2013.3535L12.6679%2012.6464ZM9.23948%2016.7819L12.6679%2013.3535L11.9608%2012.6464L8.53237%2016.0748L9.23948%2016.7819ZM9.92516%2016.7605L9.23948%2016.0748L8.53237%2016.7819L9.21805%2017.4676L9.92516%2016.7605ZM12.6464%2013.3321L9.21805%2016.7605L9.92516%2017.4676L13.3536%2014.0392L12.6464%2013.3321ZM16.7819%2016.7605L13.3536%2013.3321L12.6464%2014.0392L16.0748%2017.4676L16.7819%2016.7605ZM16.7605%2016.0748L16.0748%2016.7605L16.7819%2017.4676L17.4676%2016.7819L16.7605%2016.0748ZM13.3321%2013.3535L16.7605%2016.7819L17.4676%2016.0748L14.0392%2012.6464L13.3321%2013.3535Z'%20fill='%23484F67'/%3e%3c/svg%3e", LMFeedMediaUpload = () => {
  const { mediaUploadMode: $, changeMediaUploadMode: ee, addMediaItem: te } = useContext(
    LMFeedCreatePostContext
  );
  function ne() {
    switch ($) {
      case LMFeedCreatePostMediaUploadMode.DOCUMENT:
        return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: docMedia, alt: "attachment" });
      case LMFeedCreatePostMediaUploadMode.IMAGE:
      case LMFeedCreatePostMediaUploadMode.VIDEO:
        return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: imgMedia, alt: "attachment" });
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-feed-create-post-wrapper__media-upload", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: closeIcon,
        className: "close-icon",
        alt: "close-icon",
        onClick: (re) => {
          re.preventDefault(), ee(LMFeedCreatePostMediaUploadMode.NULL);
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "file-upload-icon", children: ne() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "file-upload-text", children: $ === LMFeedCreatePostMediaUploadMode.DOCUMENT ? "Add Files/Documents" : "Add Photos/Videos" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "file-upload-subtext", children: "or drag and drop" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        id: "file-upload",
        type: "file",
        multiple: !0,
        className: "file-upload-input",
        onChange: te,
        accept: $ === LMFeedCreatePostMediaUploadMode.DOCUMENT ? "application/pdf" : "image/png,image/jpg,image/jpeg,video/mp4"
      }
    )
  ] }) });
}, vidMedia = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.5%208.625V17.625C16.5%2018.0228%2016.342%2018.4044%2016.0607%2018.6857C15.7794%2018.967%2015.3978%2019.125%2015%2019.125H4.5C4.00754%2019.125%203.51991%2019.028%203.06494%2018.8395C2.60997%2018.6511%202.19657%2018.3749%201.84835%2018.0267C1.14509%2017.3234%200.75%2016.3696%200.75%2015.375V6.375C0.75%205.97718%200.908035%205.59564%201.18934%205.31434C1.47064%205.03304%201.85218%204.875%202.25%204.875H12.75C13.7446%204.875%2014.6984%205.27009%2015.4017%205.97335C16.1049%206.67661%2016.5%207.63044%2016.5%208.625ZM22.875%206.85312C22.762%206.78442%2022.6323%206.74808%2022.5%206.74808C22.3677%206.74808%2022.238%206.78442%2022.125%206.85312L18.375%208.99063C18.26%209.05702%2018.1647%209.15276%2018.0988%209.26806C18.0329%209.38336%2017.9988%209.51408%2018%209.64688V14.3531C17.9988%2014.4859%2018.0329%2014.6166%2018.0988%2014.7319C18.1647%2014.8472%2018.26%2014.943%2018.375%2015.0094L22.125%2017.1469C22.2393%2017.2124%2022.3683%2017.2479%2022.5%2017.25C22.6319%2017.2492%2022.7612%2017.2136%2022.875%2017.1469C22.9899%2017.0828%2023.0854%2016.9888%2023.1514%2016.875C23.2174%2016.7611%2023.2515%2016.6316%2023.25%2016.5V7.5C23.2515%207.36841%2023.2174%207.23886%2023.1514%207.12501C23.0854%207.01116%2022.9899%206.91723%2022.875%206.85312Z'%20fill='%237B61FF'/%3e%3c/svg%3e", LMFeedCreatePostAttachmentController = () => {
  const { changeMediaUploadMode: $ } = useContext(LMFeedCreatePostContext), { LMFeedCustomIcons: ee } = useContext(CustomAgentProviderContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "lm-feed-create-post-wrapper__attachments-controller",
      "lm-feed-component-id": "lm-feed-create-post-attachments-controller-zabcd",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            "lm-feed-component-id": "lm-feed-create-post-attachments-controller-efghi",
            children: "Add to your post"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "lm-create-dialog-image-icon-container",
            onClick: () => {
              $ && $(LMFeedCreatePostMediaUploadMode.IMAGE);
            },
            children: ee != null && ee.createPostDialogBoxImageIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ee.createPostDialogBoxImageIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: imgMedia,
                alt: "img-media",
                className: "img-media lm-cursor-pointer",
                "lm-feed-component-id": "lm-feed-create-post-attachments-controller-jklmn"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "lm-create-dialog-video-icon-container",
            onClick: () => {
              $ && $(LMFeedCreatePostMediaUploadMode.VIDEO);
            },
            children: ee != null && ee.createPostDialogBoxVideoIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ee.createPostDialogBoxVideoIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: vidMedia,
                alt: "vid-media",
                className: "vid-media lm-cursor-pointer",
                "lm-feed-component-id": "lm-feed-create-post-attachments-controller-opqrs"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "lm-create-dialog-document-icon-container",
            onClick: () => {
              $ && $(LMFeedCreatePostMediaUploadMode.DOCUMENT);
            },
            children: ee != null && ee.createPostDialogBoxDocumentIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(ee.createPostDialogBoxDocumentIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: docMedia,
                alt: "doc-media",
                className: "doc-media lm-cursor-pointer",
                "lm-feed-component-id": "lm-feed-create-post-attachments-controller-tuvwx"
              }
            )
          }
        )
      ]
    }
  );
}, LMFeedCreatePostSubmitButton = () => {
  const { postFeed: $, temporaryPost: ee, editPost: te } = useContext(
    LMFeedCreatePostContext
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "lm-cursor-pointer lm-feed-create-post-wrapper__submit-button lm-mt-4",
      onClick: ee ? te : $,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ee ? "SAVE" : "POST" })
    }
  );
}, cancelBtnIcon = "data:image/svg+xml,%3csvg%20width='26'%20height='26'%20viewBox='0%200%2026%2026'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='13'%20cy='13'%20r='12'%20fill='white'%20stroke='%23484F67'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M13.6857%2013L17.1141%209.5716L16.4284%208.88592L13%2012.3143L9.5716%208.88592L8.88592%209.5716L12.3143%2013L8.88592%2016.4284L9.5716%2017.1141L13%2013.6857L16.4284%2017.1141L17.1141%2016.4284L13.6857%2013Z'%20fill='%23484F67'/%3e%3cpath%20d='M17.1141%209.5716L17.4676%209.92515L17.8212%209.5716L17.4676%209.21804L17.1141%209.5716ZM13.6857%2013L13.3321%2012.6464L12.9786%2013L13.3321%2013.3535L13.6857%2013ZM16.4284%208.88592L16.782%208.53236L16.4284%208.17881L16.0748%208.53236L16.4284%208.88592ZM13%2012.3143L12.6464%2012.6679L13%2013.0214L13.3536%2012.6679L13%2012.3143ZM9.5716%208.88592L9.92516%208.53236L9.5716%208.17881L9.21805%208.53236L9.5716%208.88592ZM8.88592%209.5716L8.53237%209.21804L8.17882%209.5716L8.53237%209.92515L8.88592%209.5716ZM12.3143%2013L12.6679%2013.3535L13.0214%2013L12.6679%2012.6464L12.3143%2013ZM8.88592%2016.4284L8.53237%2016.0748L8.17882%2016.4284L8.53237%2016.7819L8.88592%2016.4284ZM9.5716%2017.1141L9.21805%2017.4676L9.5716%2017.8212L9.92516%2017.4676L9.5716%2017.1141ZM13%2013.6857L13.3536%2013.3321L13%2012.9786L12.6464%2013.3321L13%2013.6857ZM16.4284%2017.1141L16.0748%2017.4676L16.4284%2017.8212L16.7819%2017.4676L16.4284%2017.1141ZM17.1141%2016.4284L17.4676%2016.7819L17.8212%2016.4284L17.4676%2016.0748L17.1141%2016.4284ZM16.7605%209.21804L13.3321%2012.6464L14.0392%2013.3535L17.4676%209.92515L16.7605%209.21804ZM16.0748%209.23947L16.7605%209.92515L17.4676%209.21804L16.782%208.53236L16.0748%209.23947ZM13.3536%2012.6679L16.782%209.23947L16.0748%208.53236L12.6464%2011.9608L13.3536%2012.6679ZM9.21805%209.23947L12.6464%2012.6679L13.3536%2011.9608L9.92516%208.53236L9.21805%209.23947ZM9.23948%209.92515L9.92516%209.23947L9.21805%208.53236L8.53237%209.21804L9.23948%209.92515ZM12.6679%2012.6464L9.23948%209.21804L8.53237%209.92515L11.9608%2013.3535L12.6679%2012.6464ZM9.23948%2016.7819L12.6679%2013.3535L11.9608%2012.6464L8.53237%2016.0748L9.23948%2016.7819ZM9.92516%2016.7605L9.23948%2016.0748L8.53237%2016.7819L9.21805%2017.4676L9.92516%2016.7605ZM12.6464%2013.3321L9.21805%2016.7605L9.92516%2017.4676L13.3536%2014.0392L12.6464%2013.3321ZM16.7819%2016.7605L13.3536%2013.3321L12.6464%2014.0392L16.0748%2017.4676L16.7819%2016.7605ZM16.7605%2016.0748L16.0748%2016.7605L16.7819%2017.4676L17.4676%2016.7819L16.7605%2016.0748ZM13.3321%2013.3535L16.7605%2016.7819L17.4676%2016.0748L14.0392%2012.6464L13.3321%2013.3535Z'%20fill='%23484F67'/%3e%3c/svg%3e", addMoreIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M4%2012C4%2012.2205%204.07919%2012.41%204.23757%2012.5685C4.39595%2012.7201%204.58188%2012.7959%204.79535%2012.7959H11.2098V19.2145C11.2098%2019.4281%2011.2856%2019.6107%2011.4371%2019.7623C11.5954%2019.9208%2011.7848%2020%2012.0052%2020C12.2186%2020%2012.4011%2019.9208%2012.5526%2019.7623C12.7041%2019.6107%2012.7799%2019.4281%2012.7799%2019.2145V12.7959H19.215C19.4284%2012.7959%2019.6109%2012.7201%2019.7624%2012.5685C19.9208%2012.41%2020%2012.2205%2020%2012C20%2011.7864%2019.9208%2011.6038%2019.7624%2011.4522C19.6109%2011.2937%2019.4284%2011.2145%2019.215%2011.2145H12.7799V4.78553C12.7799%204.57881%2012.7041%204.39621%2012.5526%204.23773C12.4011%204.07924%2012.2186%204%2012.0052%204C11.7848%204%2011.5954%204.07924%2011.4371%204.23773C11.2856%204.39621%2011.2098%204.57881%2011.2098%204.78553V11.2145H4.79535C4.58188%2011.2145%204.39595%2011.2937%204.23757%2011.4522C4.07919%2011.6038%204%2011.7864%204%2012Z'%20fill='%235046E5'/%3e%3c/svg%3e", LMFeedCreateMediaPost = memo(({}) => {
  const {
    mediaList: $,
    addMediaItem: ee,
    removeMedia: te,
    mediaUploadMode: ne,
    temporaryPost: re
  } = useContext(LMFeedCreatePostContext), [se, ie] = useState(0), oe = {
    dots: !0,
    infinite: !1,
    speed: 500,
    slidesToShow: 1,
    slidesToScroll: 1
  };
  function le() {
    if (re) {
      const ue = re.attachments;
      switch (ue.length) {
        case 0:
          return null;
        case 1: {
          const de = ue[0];
          switch (de.attachmentType) {
            case 3:
              return /* @__PURE__ */ jsxRuntimeExports.jsx(DocumentMediaItem, { attachment: de });
            case 1:
              return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageMediaItem, { attachment: de });
            case 2:
              return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoMediaItem, { attachment: de });
            default:
              return null;
          }
        }
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Slider,
            {
              ...oe,
              beforeChange: (de, fe) => {
                ie(fe);
              },
              children: ue == null ? void 0 : ue.map((de) => {
                switch (de.attachmentType) {
                  case 3:
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(DocumentMediaItem, { attachment: de });
                  case 1:
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageMediaItem, { attachment: de });
                  case 2:
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoMediaItem, { attachment: de });
                  default:
                    return null;
                }
              })
            }
          );
      }
    } else
      switch ($ == null ? void 0 : $.length) {
        case 0:
          return null;
        case 1: {
          const ue = $[0];
          switch (ue.type) {
            case "application/pdf":
              return /* @__PURE__ */ jsxRuntimeExports.jsx(DocumentMediaItem, { file: ue });
            case "image/jpeg":
            case "image/png":
            case "image/jpg":
              return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageMediaItem, { file: ue });
            case "video/mp4":
              return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoMediaItem, { file: ue });
            default:
              return null;
          }
        }
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Slider,
            {
              ...oe,
              beforeChange: (ue, de) => {
                ie(de);
              },
              children: $ == null ? void 0 : $.map((ue) => {
                switch (ue.type) {
                  case "application/pdf":
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(DocumentMediaItem, { file: ue });
                  case "image/jpeg":
                  case "image/png":
                  case "image/jpg":
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageMediaItem, { file: ue });
                  case "video/mp4":
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoMediaItem, { file: ue });
                }
              })
            }
          );
      }
  }
  return !re && !($ != null && $.length) ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "postImgSlider", children: [
    !re && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "postImgSlider__header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "postImgSlider__header--addMore", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: addMoreIcon, alt: "icon" }),
        " Add More",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            "lm-feed-component-id": "lm-feed-create-media-vwxyz",
            onChange: ee,
            type: "file",
            accept: ne === LMFeedCreatePostMediaUploadMode.DOCUMENT ? "application/pdf" : "image/png, image/jpeg, image/jpg, video/mp4"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "postImgSlider__header--cancelBtn", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: cancelBtnIcon,
          alt: "video",
          onClick: () => {
            te && te(se || 0);
          },
          "lm-feed-component-id": "lm-feed-create-media-fghij"
        }
      ) })
    ] }),
    le()
  ] });
}), ImageMediaItem = ({ file: $, attachment: ee }) => $ ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  "img",
  {
    className: "lm-feed-create-post-media-item",
    "lm-feed-component-id": `lm-feed-create-media-vwxyz-${$.name}`,
    src: URL.createObjectURL($),
    alt: "image"
  }
) : ee ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  "img",
  {
    className: "lm-feed-create-post-media-item",
    "lm-feed-component-id": `lm-feed-edit-media-vwxyz-${ee.attachmentMeta.url}`,
    src: ee.attachmentMeta.url,
    alt: "image"
  }
) : null, VideoMediaItem = ({ file: $, attachment: ee }) => $ ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  "video",
  {
    className: "lm-feed-create-post-media-item",
    src: URL.createObjectURL($),
    controls: !0,
    "lm-feed-component-id": `lm-feed-create-media-fghij-${$.name}`
  }
) : ee ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  "video",
  {
    className: "lm-feed-create-post-media-item",
    src: ee.attachmentMeta.url,
    controls: !0,
    "lm-feed-component-id": `lm-feed-edit-media-fghij-${ee.attachmentMeta.url}`
  }
) : null, DocumentMediaItem = ({ attachment: $, file: ee }) => {
  if ($) {
    const { attachmentMeta: te } = $, { name: ne, url: re, size: se } = te;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "attachmentPdf",
        "lm-feed-component-id": `lm-feed-edit-media-klmno-${$.attachmentMeta.url}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Document$1, { file: te == null ? void 0 : te.url, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Page$1,
            {
              pageNumber: 1,
              className: "pdfPage",
              renderAnnotationLayer: !1,
              renderTextLayer: !1
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attachmentPdf__content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: pdfIcon,
                alt: "pdf",
                className: "attachmentOGTag__content--icon"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  className: "attachmentPdf__content--title",
                  target: "_blank",
                  href: re,
                  children: ne
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attachmentPdf__content--url", children: formatFileSize(se) })
            ] })
          ] })
        ]
      }
    );
  } else if (ee)
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "attachmentPdf",
        "lm-feed-component-id": `lm-feed-create-media-klmno-${ee.name}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Document$1, { file: URL.createObjectURL(ee), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Page$1,
            {
              pageNumber: 1,
              className: "pdfPage",
              renderAnnotationLayer: !1,
              renderTextLayer: !1
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attachmentPdf__content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: pdfIcon,
                alt: "pdf",
                className: "attachmentOGTag__content--icon"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  className: "attachmentPdf__content--title",
                  target: "_blank",
                  children: ee.name
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attachmentPdf__content--url", children: formatFileSize(ee.size) })
            ] })
          ] })
        ]
      }
    );
}, brokenLink = "data:image/svg+xml,%3csvg%20width='42'%20height='28'%20viewBox='0%200%2042%2028'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M33.1751%2028L9.76063%2027.9626C8.40056%2027.9626%207.14655%2027.7504%205.9986%2027.3262C4.85065%2026.8895%203.85243%2026.2906%203.00394%2025.5294C2.15546%2024.7683%201.4879%2023.8761%201.00127%2022.8529C0.527116%2021.8298%200.290039%2020.7193%200.290039%2019.5214C0.290039%2018.1738%200.552071%2016.9572%201.07614%2015.8717C1.61268%2014.7861%202.3551%2013.9189%203.30341%2013.2701C4.25171%2012.6212%205.33728%2012.2594%206.56009%2012.1845C6.54762%2011.0116%206.79093%209.95098%207.29004%209.00267C7.80163%208.05437%208.47542%207.27451%209.31143%206.6631C10.1599%206.05169%2011.0895%205.67736%2012.1002%205.54011C13.1234%205.39037%2014.1278%205.54011%2015.1136%205.9893C15.6875%204.90374%2016.4237%203.90553%2017.3221%202.99465C18.233%202.0713%2019.3061%201.34135%2020.5414%200.804813C21.7892%200.268271%2023.2178%200%2024.8275%200C26.4995%200%2028.0467%200.324421%2029.4692%200.973262C30.9041%201.60963%2032.1519%202.51426%2033.2125%203.68717C34.2731%204.86007%2035.0842%206.23262%2035.6457%207.80481C36.2072%209.36453%2036.4505%2011.074%2036.3756%2012.9332C37.561%2013.295%2038.5467%2013.8503%2039.3328%2014.5989C40.1314%2015.3476%2040.7241%2016.2273%2041.1109%2017.238C41.5102%2018.2487%2041.7098%2019.3217%2041.7098%2020.4572C41.7098%2021.5303%2041.4915%2022.5285%2041.0547%2023.4519C40.6305%2024.3627%2040.0316%2025.1613%2039.258%2025.8476C38.4843%2026.5214%2037.5735%2027.0517%2036.5253%2027.4385C35.4897%2027.8128%2034.3729%2028%2033.1751%2028ZM33.1564%2026.9893C34.5663%2026.9893%2035.8391%2026.7023%2036.9745%2026.1283C38.1225%2025.5544%2039.0271%2024.7807%2039.6884%2023.8075C40.3622%2022.8217%2040.6991%2021.705%2040.6991%2020.4572C40.6991%2018.8351%2040.2375%2017.4127%2039.3141%2016.1898C38.4032%2014.9545%2037.1555%2014.1123%2035.5708%2013.6631C35.4211%2013.6257%2035.3462%2013.5258%2035.3462%2013.3636C35.3462%2013.0267%2035.3524%2012.6961%2035.3649%2012.3717C35.3899%2012.0348%2035.3961%2011.7228%2035.3836%2011.4358C35.2214%209.46435%2034.6662%207.69251%2033.7178%206.12032C32.782%204.54813%2031.5467%203.3066%2030.012%202.39572C28.4772%201.47237%2026.749%201.0107%2024.8275%201.0107C23.2678%201.0107%2021.9077%201.28521%2020.7473%201.83422C19.5993%202.38324%2018.6136%203.10695%2017.79%204.00535C16.9665%204.90374%2016.2615%205.87077%2015.6751%206.90642C15.5877%207.06863%2015.4629%207.1123%2015.3007%207.03743C14.028%206.50089%2012.7927%206.40731%2011.5949%206.75668C10.397%207.09358%209.41125%207.79234%208.63763%208.85294C7.86401%209.90107%207.47721%2011.2237%207.47721%2012.8209C7.47721%2013.0205%207.38986%2013.1203%207.21517%2013.1203C5.97988%2013.1203%204.92551%2013.4011%204.05207%2013.9626C3.17863%2014.5241%202.50483%2015.2914%202.03068%2016.2647C1.56901%2017.2255%201.33817%2018.3111%201.33817%2019.5214C1.33817%2020.9064%201.70002%2022.1604%202.42373%2023.2834C3.15991%2024.4064%204.16437%2025.2986%205.4371%2025.9599C6.70983%2026.6087%208.14476%2026.9332%209.74191%2026.9332L33.1564%2026.9893ZM14.4585%2021.5989C13.585%2020.713%2013.1483%2019.7086%2013.1483%2018.5856C13.1483%2017.4501%2013.585%2016.4456%2014.4585%2015.5722L17.5467%2012.5027C17.3471%2012.877%2017.2161%2013.2201%2017.1537%2013.5321C17.1038%2013.844%2017.085%2014.1185%2017.0975%2014.3556L15.2259%2016.2086C14.5271%2016.8948%2014.1715%2017.6809%2014.159%2018.5668C14.1465%2019.4403%2014.4772%2020.2201%2015.151%2020.9064C15.8373%2021.5802%2016.6234%2021.9171%2017.5093%2021.9171C18.4077%2021.9046%2019.2%2021.5553%2019.8863%2020.869L23.1991%2017.5562C23.9104%2016.8324%2024.266%2016.0276%2024.266%2015.1417C24.266%2014.2558%2023.9353%2013.4822%2023.274%2012.8209C22.7998%2012.3592%2022.282%2012.0472%2021.7205%2011.885C21.1715%2011.7103%2020.7535%2011.6979%2020.4665%2011.8476C20.6287%2011.6729%2020.741%2011.5544%2020.8034%2011.492C20.8783%2011.4296%2020.9407%2011.3734%2020.9906%2011.3235L21.3649%2010.9305C21.6519%2010.918%2022.0449%2010.9991%2022.5441%2011.1738C23.0432%2011.336%2023.5173%2011.6542%2023.9665%2012.1283C24.815%2013.0143%2025.2455%2014.025%2025.258%2015.1604C25.2704%2016.2834%2024.84%2017.2816%2023.9665%2018.1551L20.4852%2021.5989C19.6243%2022.4724%2018.626%2022.9153%2017.4906%2022.9278C16.3551%2022.9278%2015.3444%2022.4848%2014.4585%2021.5989ZM28.5146%207.58021C29.3756%208.45365%2029.8061%209.45811%2029.8061%2010.5936C29.8186%2011.7291%2029.3881%2012.7335%2028.5146%2013.607L25.4451%2016.6765C25.6323%2016.3146%2025.7571%2015.9777%2025.8195%2015.6658C25.8818%2015.3414%2025.9006%2015.0606%2025.8756%2014.8235L27.7473%2012.9706C28.446%2012.2843%2028.7954%2011.5045%2028.7954%2010.631C28.8079%209.75758%2028.471%208.97148%2027.7847%208.27273C27.1234%207.59893%2026.356%207.26203%2025.4826%207.26203C24.6091%207.26203%2023.8105%207.62389%2023.0868%208.34759L19.774%2011.6604C19.0752%2012.3467%2018.7196%2013.1328%2018.7072%2014.0187C18.6947%2014.8922%2019.0316%2015.672%2019.7178%2016.3583C20.1546%2016.8075%2020.6537%2017.1194%2021.2152%2017.2941C21.7892%2017.4688%2022.2196%2017.4875%2022.5066%2017.3503C22.3444%2017.5%2022.2259%2017.6123%2022.151%2017.6872C22.0886%2017.7496%2022.0387%2017.8057%2022.0013%2017.8556L21.6269%2018.2299C21.34%2018.2424%2020.9469%2018.1676%2020.4478%2018.0053C19.9612%2017.8307%2019.4932%2017.5125%2019.0441%2017.0508C18.1581%2016.1774%2017.7089%2015.1729%2017.6965%2014.0374C17.6965%2012.902%2018.1394%2011.8975%2019.0253%2011.0241L22.4879%207.58021C23.3613%206.70677%2024.3658%206.26381%2025.5013%206.25134C26.6367%206.23886%2027.6412%206.68182%2028.5146%207.58021Z'%20fill='%2300897B'/%3e%3c/svg%3e", LMFeedOGTagMediaItem = () => {
  const { ogTag: $, closeOGTagContainer: ee, temporaryPost: te } = useContext(
    LMFeedCreatePostContext
  );
  if ($)
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "media-item-attachmentOGTag", children: [
      !te && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: closeIcon,
          className: "og-tag-close-icon lm-cursor-pointer",
          alt: "close-icon",
          onClick: (ne) => {
            ne.preventDefault(), ee && ee();
          }
        }
      ),
      $ != null && $.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: $.image,
          alt: "og tag image",
          className: "media-item-attachmentOGTag__attachmentOGTag__img"
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "media-item-attachmentOGTag__attachmentOGTag__noImg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: brokenLink,
            alt: "broken-link"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: $ == null ? void 0 : $.url })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "media-item-attachmentOGTag__attachmentOGTag__content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "link-url", href: $.url, target: "_blank", children: truncateString($ == null ? void 0 : $.title, 100) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "media-item-attachmentOGTag__attachmentOGTag__content--desc", children: truncateString($ == null ? void 0 : $.description, 300) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "media-item-attachmentOGTag__attachmentOGTag__content--url", children: $ == null ? void 0 : $.url })
      ] })
    ] });
}, LMFeedCreatePostDialog = ({}) => {
  const { currentUser: $ } = useContext(UserProviderContext), {
    mediaUploadMode: ee = "NULL",
    setSelectedTopicIds: te,
    selectedTopicIds: ne,
    preSelectedTopics: re,
    setPreSelectedTopics: se,
    mediaList: ie,
    temporaryPost: oe,
    showOGTagViewContainer: le,
    setOpenCreatePostDialog: ue,
    createPostComponentClickCustomCallback: de,
    ogTag: fe
  } = useContext(LMFeedCreatePostContext), { CustomComponents: pe = {} } = useContext(CustomAgentProviderContext), { CustomTopicDropDown: ye } = pe;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "lm-feed-create-post-wrapper",
      onClick: (me) => {
        de && de(me);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-feed-create-post-wrapper__dialog-heading", children: [
          oe ? EDIT_POST : CREATE_POST,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: cancelModelMcon,
              alt: "cancelModelMcon",
              onClick: () => {
                ue && ue(!1);
              },
              className: "cancelIcon"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-feed-create-post-wrapper__user-meta", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-avatar lm-mr-4", children: getAvatar({
            imageUrl: $ == null ? void 0 : $.imageUrl,
            name: $ == null ? void 0 : $.name
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: $ == null ? void 0 : $.name })
        ] }),
        ye || /* @__PURE__ */ jsxRuntimeExports.jsx(
          LMFeedViewTopicDropdown,
          {
            mode: oe ? LMTopicsDropdownMode.edit : LMTopicsDropdownMode.modify,
            setSelectedTopicsIds: te,
            selectedTopicIds: ne,
            preSelectedTopics: re,
            setPreSelectedTopics: se
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, { className: "lm-feed-create-post-topic-text-area-divider" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-textarea", children: pe.CustomCreatePostTextArea || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedTextArea, {}) }),
        le && fe && ee === LMFeedCreatePostMediaUploadMode.NULL && !(ie != null && ie.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedOGTagMediaItem, {}) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreateMediaPost, {}),
        ee !== LMFeedCreatePostMediaUploadMode.NULL && !oe && !(ie != null && ie.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedMediaUpload, {}) : null,
        !oe && /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreatePostAttachmentController, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreatePostSubmitButton, {})
      ]
    }
  );
}, createPostIcon = "data:image/svg+xml,%3csvg%20width='30'%20height='30'%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5.41357%2020.374C5.41357%2022.3892%206.47768%2023.4438%208.51172%2023.4438H18.3335C17.9851%2022.8788%2017.7402%2022.2385%2017.6272%2021.5699H8.5023C7.7207%2021.5699%207.28753%2021.165%207.28753%2020.3363V11.6728C7.28753%2010.8441%207.7207%2010.4392%208.5023%2010.4392H21.4881C22.2697%2010.4392%2022.7029%2010.8441%2022.7029%2011.6728V14.1965C23.0325%2014.14%2023.3433%2014.1117%2023.654%2014.1117C23.9648%2014.1117%2024.2755%2014.14%2024.5863%2014.1871V8.91364C24.5863%206.89844%2023.5222%205.84375%2021.4787%205.84375H8.51172C6.47768%205.84375%205.41357%206.88902%205.41357%208.91364V20.374ZM10.1126%2013.8198H19.8967C20.2357%2013.8198%2020.49%2013.5562%2020.49%2013.2077C20.49%2012.8781%2020.2357%2012.6239%2019.8967%2012.6239H10.1126C9.76416%2012.6239%209.5099%2012.8781%209.5099%2013.2077C9.5099%2013.5562%209.76416%2013.8198%2010.1126%2013.8198ZM10.1126%2016.5978H18.7102C19.0398%2016.1458%2019.4164%2015.7503%2019.859%2015.4019H10.1126C9.76416%2015.4019%209.5099%2015.6749%209.5099%2016.014C9.5099%2016.3435%209.76416%2016.5978%2010.1126%2016.5978ZM23.654%2025.1577C26.2907%2025.1577%2028.5131%2022.9542%2028.5131%2020.2986C28.5131%2017.6431%2026.319%2015.4489%2023.654%2015.4489C20.9985%2015.4489%2018.8043%2017.6431%2018.8043%2020.2986C18.8043%2022.9636%2020.9985%2025.1577%2023.654%2025.1577ZM20.5747%2020.2986C20.5747%2019.9125%2020.8384%2019.6583%2021.2245%2019.6583H23.0043V17.8785C23.0043%2017.4924%2023.2679%2017.2287%2023.654%2017.2287C24.0495%2017.2287%2024.3038%2017.4924%2024.3038%2017.8785V19.6583H26.0836C26.4697%2019.6583%2026.7333%2019.9125%2026.7333%2020.2986C26.7333%2020.6941%2026.4697%2020.9484%2026.0836%2020.9484H24.3038V22.7376C24.3038%2023.1237%2024.0495%2023.3779%2023.654%2023.3779C23.2679%2023.3779%2023.0043%2023.1237%2023.0043%2022.7376V20.9484H21.2245C20.8384%2020.9484%2020.5841%2020.6941%2020.5747%2020.2986ZM10.1126%2019.3758H16.29C16.629%2019.3758%2016.8833%2019.1215%2016.8833%2018.7919C16.8833%2018.4529%2016.629%2018.1892%2016.29%2018.1892H10.1126C9.76416%2018.1892%209.5099%2018.4529%209.5099%2018.7919C9.5099%2019.1215%209.76416%2019.3758%2010.1126%2019.3758Z'%20fill='white'/%3e%3c/svg%3e", LMFeedCreatePost = ({
  showStarterComponent: $
}) => {
  const { currentUser: ee } = useContext(UserProviderContext), { LMFeedCustomIcons: te, CustomComponents: ne = {} } = useContext(
    CustomAgentProviderContext
  ), { name: re, imageUrl: se } = ee, ie = getAvatar({
    imageUrl: se,
    name: re
  }), {
    postText: oe,
    setPostText: le,
    mediaList: ue,
    addMediaItem: de,
    removeMedia: fe,
    clearMedia: pe,
    mediaUploadMode: ye,
    changeMediaUploadMode: me,
    textFieldRef: ve,
    containerRef: ge,
    postFeed: xe,
    editPost: Ee,
    ogTag: Te,
    openCreatePostDialog: Se,
    setOpenCreatePostDialog: he,
    temporaryPost: Pe,
    selectedTopicIds: Ie,
    setSelectedTopicIds: De,
    preSelectedTopics: Ce,
    setPreSelectedTopics: Ne,
    showOGTagViewContainer: Me,
    closeOGTagContainer: Be,
    createPostComponentClickCustomCallback: We
  } = useCreatePost();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    LMFeedCreatePostContext.Provider,
    {
      value: {
        createPostComponentClickCustomCallback: We,
        postText: oe,
        setPostText: le,
        mediaList: ue,
        addMediaItem: de,
        removeMedia: fe,
        clearMedia: pe,
        mediaUploadMode: ye,
        changeMediaUploadMode: me,
        textFieldRef: ve,
        containerRef: ge,
        postFeed: xe,
        editPost: Ee,
        ogTag: Te,
        openCreatePostDialog: Se,
        setOpenCreatePostDialog: he,
        temporaryPost: Pe,
        selectedTopicIds: Ie,
        setSelectedTopicIds: De,
        preSelectedTopics: Ce,
        setPreSelectedTopics: Ne,
        showOGTagViewContainer: Me,
        closeOGTagContainer: Be
      },
      children: [
        $ ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "lm-create-post-btn",
              onClick: () => {
                he(!Se);
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: createPostIcon, alt: "createPostIcon" }),
                "New Post"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-createPost", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-createPost__media", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__media__imgBox lm-avatar", children: ie }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  onClick: () => {
                    he(!Se);
                  },
                  className: "lm-createPost__media--mediaText",
                  children: "Write something here..."
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-createPost__footer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-createPost__footer__left", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "lm-createPost__footer__left__media lm-cursor-pointer",
                    onClick: () => {
                      he(!Se), me(
                        LMFeedCreatePostMediaUploadMode.IMAGE
                      );
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--imgBox", children: te != null && te.createPostFooterImageIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(te.createPostFooterImageIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: photo, alt: "image icons" }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--texted lm-text-capitalize", children: PHOTO })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "lm-createPost__footer__left__media lm-cursor-pointer",
                    onClick: () => {
                      he(!Se), me(
                        LMFeedCreatePostMediaUploadMode.VIDEO
                      );
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--imgBox", children: te != null && te.createPostFooterVideoIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(te.createPostFooterVideoIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: video, alt: "video icon" }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--texted lm-text-capitalize", children: VIDEO })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "lm-createPost__footer__left__media lm-cursor-pointer",
                    onClick: () => {
                      he(!Se), me(
                        LMFeedCreatePostMediaUploadMode.DOCUMENT
                      );
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--imgBox", children: te != null && te.createPostFooterDocumentIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(te.createPostFooterDocumentIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: pdf, alt: "pdf" }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__left__media--texted lm-text-capitalize", children: PDF })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-createPost__footer__right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "lm-createPost__footer__right--btn-primary lm-text-capitalize",
                  onClick: () => {
                    he(!Se);
                  },
                  children: POST
                }
              ) })
            ] })
          ] })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog$1,
          {
            open: Se,
            onClose: () => {
              me(LMFeedCreatePostMediaUploadMode.NULL), he(!1);
            },
            children: ne.CustomCreatePostDialog || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreatePostDialog, {})
          }
        )
      ]
    }
  );
}, LMFeedAllMembers = () => {
  const { lmFeedclient: $, customEventClient: ee } = useContext(
    GlobalClientProviderContext
  ), { memberComponentClickCustomCallback: te } = useContext(
    CustomAgentProviderContext
  ), [ne, re] = useState([]), [se, ie] = useState(!0), [oe, le] = useState(1), [ue, de] = useState(0), fe = async (ye) => {
    try {
      const me = await ($ == null ? void 0 : $.getAllMembers(
        nt.builder().setpage(ye).build()
      ));
      me && me.data && me.data.members && (me.data.members.length > 0 && (re((ve) => [
        ...ve,
        ...me.data.members
      ]), le(ye), de(me.data.totalMembers)), (me.data.members.length === 0 || ne.length >= me.data.totalMembers) && ie(!1));
    } catch (me) {
      console.log(me), ie(!1);
    }
  };
  useEffect(() => {
    fe(1), fe(2);
  }, [$]);
  const pe = () => {
    fe(oe + 1);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-member-wrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-member-wrapper__header", children: [
      MEMBER_LIST,
      " (",
      ue,
      ")"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body", id: "member-scroll-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InfiniteScroll,
      {
        dataLength: ne ? ne.length : 0,
        hasMore: se,
        next: pe,
        loader: null,
        scrollableTarget: "member-scroll-container",
        children: ne ? ne.map((ye) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "lm-member-wrapper__body__media lm-hover-effect lm-cursor-pointer",
            "lm-feed-component-id": `lm-feed-member-wrapper-klmno-${ye == null ? void 0 : ye.uuid}`,
            onClick: (me) => {
              te && te(me);
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__imgBox lm-avatar", children: getAvatar({
                imageUrl: ye.imageUrl,
                name: ye == null ? void 0 : ye.name
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__content", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member-wrapper__body__media__content--name", children: ye.name }) })
            ]
          },
          ye.uuid
        )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading..." })
      }
    ) })
  ] });
}, LMFeedUniversalFeed = ($) => {
  const {
    topics: ee = {},
    selectedTopics: te,
    setSelectedTopics: ne,
    loadMoreFeeds: re = !0,
    feedList: se = [],
    feedUsersList: ie = {},
    getNextPage: oe = () => {
    },
    deletePost: le,
    pinPost: ue,
    likePost: de,
    clickNavigator: fe,
    postComponentClickCustomCallback: pe
  } = useContext(LMFeedDataContext), { lmfeedAnalyticsClient: ye } = useContext(
    GlobalClientProviderContext
  ), { CustomComponents: me } = useContext(CustomAgentProviderContext), ve = useRef(null);
  useEffect(() => {
    const xe = sessionStorage.getItem("scroll-pos");
    if (xe) {
      const Ee = document.getElementById(xe);
      Ee == null || Ee.scrollIntoView();
    }
    ye == null || ye.sendFeedOpenedEvent();
  }, [ve]);
  const ge = useCallback(() => se.map((xe) => {
    const Ee = xe.uuid, Se = Object.values(ie).find((he) => he.uuid === Ee);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FeedPostContext.Provider,
      {
        value: {
          post: xe,
          users: ie,
          topics: ee,
          deletePost: le,
          pinPost: ue,
          likePost: de,
          postComponentClickCustomCallback: pe,
          clickNavigator: fe
        },
        children: (me == null ? void 0 : me.CustomPostView) || /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedPost, { post: xe, user: Se })
      },
      xe.Id
    );
  }), [
    me == null ? void 0 : me.CustomPostView,
    fe,
    le,
    se,
    ie,
    de,
    ue,
    pe,
    ee
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: ve, className: "lm-feed-wrapper lm-d-flex", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-flex-grow", id: "feed-scroller", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreatePost, { showStarterComponent: !0 }),
      me != null && me.CustomTopicDropDown ? me.CustomTopicDropDown : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "lm-mb-4 lm-mt-4",
          "lm-feed-component-id": "lm-feed-topic-dropdown",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            LMFeedViewTopicDropdown,
            {
              mode: LMTopicsDropdownMode.view,
              selectedTopicIds: te,
              setSelectedTopicsIds: ne
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        InfiniteScroll,
        {
          dataLength: se.length,
          hasMore: re,
          next: oe,
          loader: null,
          scrollThreshold: 0.6,
          children: ge()
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lm-member", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedAllMembers, {}) })
  ] });
};
var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function equal($, ee) {
  if ($ === ee)
    return !0;
  if ($ && ee && typeof $ == "object" && typeof ee == "object") {
    if ($.constructor !== ee.constructor)
      return !1;
    var te, ne, re;
    if (Array.isArray($)) {
      if (te = $.length, te != ee.length)
        return !1;
      for (ne = te; ne-- !== 0; )
        if (!equal($[ne], ee[ne]))
          return !1;
      return !0;
    }
    var se;
    if (hasMap && $ instanceof Map && ee instanceof Map) {
      if ($.size !== ee.size)
        return !1;
      for (se = $.entries(); !(ne = se.next()).done; )
        if (!ee.has(ne.value[0]))
          return !1;
      for (se = $.entries(); !(ne = se.next()).done; )
        if (!equal(ne.value[1], ee.get(ne.value[0])))
          return !1;
      return !0;
    }
    if (hasSet && $ instanceof Set && ee instanceof Set) {
      if ($.size !== ee.size)
        return !1;
      for (se = $.entries(); !(ne = se.next()).done; )
        if (!ee.has(ne.value[0]))
          return !1;
      return !0;
    }
    if (hasArrayBuffer && ArrayBuffer.isView($) && ArrayBuffer.isView(ee)) {
      if (te = $.length, te != ee.length)
        return !1;
      for (ne = te; ne-- !== 0; )
        if ($[ne] !== ee[ne])
          return !1;
      return !0;
    }
    if ($.constructor === RegExp)
      return $.source === ee.source && $.flags === ee.flags;
    if ($.valueOf !== Object.prototype.valueOf && typeof $.valueOf == "function" && typeof ee.valueOf == "function")
      return $.valueOf() === ee.valueOf();
    if ($.toString !== Object.prototype.toString && typeof $.toString == "function" && typeof ee.toString == "function")
      return $.toString() === ee.toString();
    if (re = Object.keys($), te = re.length, te !== Object.keys(ee).length)
      return !1;
    for (ne = te; ne-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(ee, re[ne]))
        return !1;
    if (hasElementType && $ instanceof Element)
      return !1;
    for (ne = te; ne-- !== 0; )
      if (!((re[ne] === "_owner" || re[ne] === "__v" || re[ne] === "__o") && $.$$typeof) && !equal($[re[ne]], ee[re[ne]]))
        return !1;
    return !0;
  }
  return $ !== $ && ee !== ee;
}
var reactFastCompare = function $(ee, te) {
  try {
    return equal(ee, te);
  } catch (ne) {
    if ((ne.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw ne;
  }
};
const fastCompare = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
var invariant = function($, ee, te, ne, re, se, ie, oe) {
  if (process.env.NODE_ENV !== "production" && ee === void 0)
    throw new Error("invariant requires an error message argument");
  if (!$) {
    var le;
    if (ee === void 0)
      le = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var ue = [te, ne, re, se, ie, oe], de = 0;
      le = new Error(
        ee.replace(/%s/g, function() {
          return ue[de++];
        })
      ), le.name = "Invariant Violation";
    }
    throw le.framesToPop = 1, le;
  }
}, browser = invariant;
const invariant$1 = /* @__PURE__ */ getDefaultExportFromCjs(browser);
var shallowequal = function $(ee, te, ne, re) {
  var se = ne ? ne.call(re, ee, te) : void 0;
  if (se !== void 0)
    return !!se;
  if (ee === te)
    return !0;
  if (typeof ee != "object" || !ee || typeof te != "object" || !te)
    return !1;
  var ie = Object.keys(ee), oe = Object.keys(te);
  if (ie.length !== oe.length)
    return !1;
  for (var le = Object.prototype.hasOwnProperty.bind(te), ue = 0; ue < ie.length; ue++) {
    var de = ie[ue];
    if (!le(de))
      return !1;
    var fe = ee[de], pe = te[de];
    if (se = ne ? ne.call(re, fe, pe, de) : void 0, se === !1 || se === void 0 && fe !== pe)
      return !1;
  }
  return !0;
};
const shallowEqual = /* @__PURE__ */ getDefaultExportFromCjs(shallowequal);
var TAG_NAMES = /* @__PURE__ */ (($) => ($.BASE = "base", $.BODY = "body", $.HEAD = "head", $.HTML = "html", $.LINK = "link", $.META = "meta", $.NOSCRIPT = "noscript", $.SCRIPT = "script", $.STYLE = "style", $.TITLE = "title", $.FRAGMENT = "Symbol(react.fragment)", $))(TAG_NAMES || {}), SEO_PRIORITY_TAGS = {
  link: { rel: ["amphtml", "canonical", "alternate"] },
  script: { type: ["application/ld+json"] },
  meta: {
    charset: "",
    name: ["generator", "robots", "description"],
    property: [
      "og:type",
      "og:title",
      "og:url",
      "og:image",
      "og:image:alt",
      "og:description",
      "twitter:url",
      "twitter:title",
      "twitter:description",
      "twitter:image",
      "twitter:image:alt",
      "twitter:card",
      "twitter:site"
    ]
  }
}, VALID_TAG_NAMES = Object.values(TAG_NAMES), REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
}, HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce(
  ($, [ee, te]) => ($[te] = ee, $),
  {}
), HELMET_ATTRIBUTE = "data-rh", HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate",
  PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
}, getInnermostProperty = ($, ee) => {
  for (let te = $.length - 1; te >= 0; te -= 1) {
    const ne = $[te];
    if (Object.prototype.hasOwnProperty.call(ne, ee))
      return ne[ee];
  }
  return null;
}, getTitleFromPropsList = ($) => {
  let ee = getInnermostProperty(
    $,
    "title"
    /* TITLE */
  );
  const te = getInnermostProperty($, HELMET_PROPS.TITLE_TEMPLATE);
  if (Array.isArray(ee) && (ee = ee.join("")), te && ee)
    return te.replace(/%s/g, () => ee);
  const ne = getInnermostProperty($, HELMET_PROPS.DEFAULT_TITLE);
  return ee || ne || void 0;
}, getOnChangeClientState = ($) => getInnermostProperty($, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {
}), getAttributesFromPropsList = ($, ee) => ee.filter((te) => typeof te[$] < "u").map((te) => te[$]).reduce((te, ne) => ({ ...te, ...ne }), {}), getBaseTagFromPropsList = ($, ee) => ee.filter((te) => typeof te.base < "u").map((te) => te.base).reverse().reduce((te, ne) => {
  if (!te.length) {
    const re = Object.keys(ne);
    for (let se = 0; se < re.length; se += 1) {
      const oe = re[se].toLowerCase();
      if ($.indexOf(oe) !== -1 && ne[oe])
        return te.concat(ne);
    }
  }
  return te;
}, []), warn = ($) => console && typeof console.warn == "function" && console.warn($), getTagsFromPropsList = ($, ee, te) => {
  const ne = {};
  return te.filter((re) => Array.isArray(re[$]) ? !0 : (typeof re[$] < "u" && warn(
    `Helmet: ${$} should be of type "Array". Instead found type "${typeof re[$]}"`
  ), !1)).map((re) => re[$]).reverse().reduce((re, se) => {
    const ie = {};
    se.filter((le) => {
      let ue;
      const de = Object.keys(le);
      for (let pe = 0; pe < de.length; pe += 1) {
        const ye = de[pe], me = ye.toLowerCase();
        ee.indexOf(me) !== -1 && !(ue === "rel" && le[ue].toLowerCase() === "canonical") && !(me === "rel" && le[me].toLowerCase() === "stylesheet") && (ue = me), ee.indexOf(ye) !== -1 && (ye === "innerHTML" || ye === "cssText" || ye === "itemprop") && (ue = ye);
      }
      if (!ue || !le[ue])
        return !1;
      const fe = le[ue].toLowerCase();
      return ne[ue] || (ne[ue] = {}), ie[ue] || (ie[ue] = {}), ne[ue][fe] ? !1 : (ie[ue][fe] = !0, !0);
    }).reverse().forEach((le) => re.push(le));
    const oe = Object.keys(ie);
    for (let le = 0; le < oe.length; le += 1) {
      const ue = oe[le], de = {
        ...ne[ue],
        ...ie[ue]
      };
      ne[ue] = de;
    }
    return re;
  }, []).reverse();
}, getAnyTrueFromPropsList = ($, ee) => {
  if (Array.isArray($) && $.length) {
    for (let te = 0; te < $.length; te += 1)
      if ($[te][ee])
        return !0;
  }
  return !1;
}, reducePropsToState = ($) => ({
  baseTag: getBaseTagFromPropsList([
    "href"
    /* HREF */
  ], $),
  bodyAttributes: getAttributesFromPropsList("bodyAttributes", $),
  defer: getInnermostProperty($, HELMET_PROPS.DEFER),
  encode: getInnermostProperty($, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
  htmlAttributes: getAttributesFromPropsList("htmlAttributes", $),
  linkTags: getTagsFromPropsList(
    "link",
    [
      "rel",
      "href"
      /* HREF */
    ],
    $
  ),
  metaTags: getTagsFromPropsList(
    "meta",
    [
      "name",
      "charset",
      "http-equiv",
      "property",
      "itemprop"
      /* ITEM_PROP */
    ],
    $
  ),
  noscriptTags: getTagsFromPropsList("noscript", [
    "innerHTML"
    /* INNER_HTML */
  ], $),
  onChangeClientState: getOnChangeClientState($),
  scriptTags: getTagsFromPropsList(
    "script",
    [
      "src",
      "innerHTML"
      /* INNER_HTML */
    ],
    $
  ),
  styleTags: getTagsFromPropsList("style", [
    "cssText"
    /* CSS_TEXT */
  ], $),
  title: getTitleFromPropsList($),
  titleAttributes: getAttributesFromPropsList("titleAttributes", $),
  prioritizeSeoTags: getAnyTrueFromPropsList($, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
}), flattenArray = ($) => Array.isArray($) ? $.join("") : $, checkIfPropsMatch = ($, ee) => {
  const te = Object.keys($);
  for (let ne = 0; ne < te.length; ne += 1)
    if (ee[te[ne]] && ee[te[ne]].includes($[te[ne]]))
      return !0;
  return !1;
}, prioritizer = ($, ee) => Array.isArray($) ? $.reduce(
  (te, ne) => (checkIfPropsMatch(ne, ee) ? te.priority.push(ne) : te.default.push(ne), te),
  { priority: [], default: [] }
) : { default: $, priority: [] }, without = ($, ee) => ({
  ...$,
  [ee]: void 0
}), SELF_CLOSING_TAGS = [
  "noscript",
  "script",
  "style"
  /* STYLE */
], encodeSpecialCharacters = ($, ee = !0) => ee === !1 ? String($) : String($).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), generateElementAttributesAsString = ($) => Object.keys($).reduce((ee, te) => {
  const ne = typeof $[te] < "u" ? `${te}="${$[te]}"` : `${te}`;
  return ee ? `${ee} ${ne}` : ne;
}, ""), generateTitleAsString = ($, ee, te, ne) => {
  const re = generateElementAttributesAsString(te), se = flattenArray(ee);
  return re ? `<${$} ${HELMET_ATTRIBUTE}="true" ${re}>${encodeSpecialCharacters(
    se,
    ne
  )}</${$}>` : `<${$} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(
    se,
    ne
  )}</${$}>`;
}, generateTagsAsString = ($, ee, te = !0) => ee.reduce((ne, re) => {
  const se = re, ie = Object.keys(se).filter(
    (ue) => !(ue === "innerHTML" || ue === "cssText")
  ).reduce((ue, de) => {
    const fe = typeof se[de] > "u" ? de : `${de}="${encodeSpecialCharacters(se[de], te)}"`;
    return ue ? `${ue} ${fe}` : fe;
  }, ""), oe = se.innerHTML || se.cssText || "", le = SELF_CLOSING_TAGS.indexOf($) === -1;
  return `${ne}<${$} ${HELMET_ATTRIBUTE}="true" ${ie}${le ? "/>" : `>${oe}</${$}>`}`;
}, ""), convertElementAttributesToReactProps = ($, ee = {}) => Object.keys($).reduce((te, ne) => {
  const re = REACT_TAG_MAP[ne];
  return te[re || ne] = $[ne], te;
}, ee), generateTitleAsReactComponent = ($, ee, te) => {
  const ne = {
    key: ee,
    [HELMET_ATTRIBUTE]: !0
  }, re = convertElementAttributesToReactProps(te, ne);
  return [React__default.createElement("title", re, ee)];
}, generateTagsAsReactComponent = ($, ee) => ee.map((te, ne) => {
  const re = {
    key: ne,
    [HELMET_ATTRIBUTE]: !0
  };
  return Object.keys(te).forEach((se) => {
    const oe = REACT_TAG_MAP[se] || se;
    if (oe === "innerHTML" || oe === "cssText") {
      const le = te.innerHTML || te.cssText;
      re.dangerouslySetInnerHTML = { __html: le };
    } else
      re[oe] = te[se];
  }), React__default.createElement($, re);
}), getMethodsForTag = ($, ee, te = !0) => {
  switch ($) {
    case "title":
      return {
        toComponent: () => generateTitleAsReactComponent($, ee.title, ee.titleAttributes),
        toString: () => generateTitleAsString($, ee.title, ee.titleAttributes, te)
      };
    case "bodyAttributes":
    case "htmlAttributes":
      return {
        toComponent: () => convertElementAttributesToReactProps(ee),
        toString: () => generateElementAttributesAsString(ee)
      };
    default:
      return {
        toComponent: () => generateTagsAsReactComponent($, ee),
        toString: () => generateTagsAsString($, ee, te)
      };
  }
}, getPriorityMethods = ({ metaTags: $, linkTags: ee, scriptTags: te, encode: ne }) => {
  const re = prioritizer($, SEO_PRIORITY_TAGS.meta), se = prioritizer(ee, SEO_PRIORITY_TAGS.link), ie = prioritizer(te, SEO_PRIORITY_TAGS.script);
  return {
    priorityMethods: {
      toComponent: () => [
        ...generateTagsAsReactComponent("meta", re.priority),
        ...generateTagsAsReactComponent("link", se.priority),
        ...generateTagsAsReactComponent("script", ie.priority)
      ],
      toString: () => (
        // generate all the tags as strings and concatenate them
        `${getMethodsForTag("meta", re.priority, ne)} ${getMethodsForTag(
          "link",
          se.priority,
          ne
        )} ${getMethodsForTag("script", ie.priority, ne)}`
      )
    },
    metaTags: re.default,
    linkTags: se.default,
    scriptTags: ie.default
  };
}, mapStateOnServer = ($) => {
  const {
    baseTag: ee,
    bodyAttributes: te,
    encode: ne = !0,
    htmlAttributes: re,
    noscriptTags: se,
    styleTags: ie,
    title: oe = "",
    titleAttributes: le,
    prioritizeSeoTags: ue
  } = $;
  let { linkTags: de, metaTags: fe, scriptTags: pe } = $, ye = {
    toComponent: () => {
    },
    toString: () => ""
  };
  return ue && ({ priorityMethods: ye, linkTags: de, metaTags: fe, scriptTags: pe } = getPriorityMethods($)), {
    priority: ye,
    base: getMethodsForTag("base", ee, ne),
    bodyAttributes: getMethodsForTag("bodyAttributes", te, ne),
    htmlAttributes: getMethodsForTag("htmlAttributes", re, ne),
    link: getMethodsForTag("link", de, ne),
    meta: getMethodsForTag("meta", fe, ne),
    noscript: getMethodsForTag("noscript", se, ne),
    script: getMethodsForTag("script", pe, ne),
    style: getMethodsForTag("style", ie, ne),
    title: getMethodsForTag("title", { title: oe, titleAttributes: le }, ne)
  };
}, server_default = mapStateOnServer, instances = [], isDocument = !!(typeof window < "u" && window.document && window.document.createElement), HelmetData = class {
  constructor($, ee) {
    On(this, "instances", []);
    On(this, "canUseDOM", isDocument);
    On(this, "context");
    On(this, "value", {
      setHelmet: ($) => {
        this.context.helmet = $;
      },
      helmetInstances: {
        get: () => this.canUseDOM ? instances : this.instances,
        add: ($) => {
          (this.canUseDOM ? instances : this.instances).push($);
        },
        remove: ($) => {
          const ee = (this.canUseDOM ? instances : this.instances).indexOf($);
          (this.canUseDOM ? instances : this.instances).splice(ee, 1);
        }
      }
    });
    this.context = $, this.canUseDOM = ee || !1, ee || ($.helmet = server_default({
      baseTag: [],
      bodyAttributes: {},
      encodeSpecialCharacters: !0,
      htmlAttributes: {},
      linkTags: [],
      metaTags: [],
      noscriptTags: [],
      scriptTags: [],
      styleTags: [],
      title: "",
      titleAttributes: {}
    }));
  }
}, defaultValue = {}, Context = React__default.createContext(defaultValue), Kn, HelmetProvider = (Kn = class extends Component {
  constructor(te) {
    super(te);
    On(this, "helmetData");
    this.helmetData = new HelmetData(this.props.context || {}, Kn.canUseDOM);
  }
  render() {
    return /* @__PURE__ */ React__default.createElement(Context.Provider, { value: this.helmetData.value }, this.props.children);
  }
}, On(Kn, "canUseDOM", isDocument), Kn), updateTags = ($, ee) => {
  const te = document.head || document.querySelector(
    "head"
    /* HEAD */
  ), ne = te.querySelectorAll(`${$}[${HELMET_ATTRIBUTE}]`), re = [].slice.call(ne), se = [];
  let ie;
  return ee && ee.length && ee.forEach((oe) => {
    const le = document.createElement($);
    for (const ue in oe)
      if (Object.prototype.hasOwnProperty.call(oe, ue))
        if (ue === "innerHTML")
          le.innerHTML = oe.innerHTML;
        else if (ue === "cssText")
          le.styleSheet ? le.styleSheet.cssText = oe.cssText : le.appendChild(document.createTextNode(oe.cssText));
        else {
          const de = ue, fe = typeof oe[de] > "u" ? "" : oe[de];
          le.setAttribute(ue, fe);
        }
    le.setAttribute(HELMET_ATTRIBUTE, "true"), re.some((ue, de) => (ie = de, le.isEqualNode(ue))) ? re.splice(ie, 1) : se.push(le);
  }), re.forEach((oe) => {
    var le;
    return (le = oe.parentNode) == null ? void 0 : le.removeChild(oe);
  }), se.forEach((oe) => te.appendChild(oe)), {
    oldTags: re,
    newTags: se
  };
}, updateAttributes = ($, ee) => {
  const te = document.getElementsByTagName($)[0];
  if (!te)
    return;
  const ne = te.getAttribute(HELMET_ATTRIBUTE), re = ne ? ne.split(",") : [], se = [...re], ie = Object.keys(ee);
  for (const oe of ie) {
    const le = ee[oe] || "";
    te.getAttribute(oe) !== le && te.setAttribute(oe, le), re.indexOf(oe) === -1 && re.push(oe);
    const ue = se.indexOf(oe);
    ue !== -1 && se.splice(ue, 1);
  }
  for (let oe = se.length - 1; oe >= 0; oe -= 1)
    te.removeAttribute(se[oe]);
  re.length === se.length ? te.removeAttribute(HELMET_ATTRIBUTE) : te.getAttribute(HELMET_ATTRIBUTE) !== ie.join(",") && te.setAttribute(HELMET_ATTRIBUTE, ie.join(","));
}, updateTitle = ($, ee) => {
  typeof $ < "u" && document.title !== $ && (document.title = flattenArray($)), updateAttributes("title", ee);
}, commitTagChanges = ($, ee) => {
  const {
    baseTag: te,
    bodyAttributes: ne,
    htmlAttributes: re,
    linkTags: se,
    metaTags: ie,
    noscriptTags: oe,
    onChangeClientState: le,
    scriptTags: ue,
    styleTags: de,
    title: fe,
    titleAttributes: pe
  } = $;
  updateAttributes("body", ne), updateAttributes("html", re), updateTitle(fe, pe);
  const ye = {
    baseTag: updateTags("base", te),
    linkTags: updateTags("link", se),
    metaTags: updateTags("meta", ie),
    noscriptTags: updateTags("noscript", oe),
    scriptTags: updateTags("script", ue),
    styleTags: updateTags("style", de)
  }, me = {}, ve = {};
  Object.keys(ye).forEach((ge) => {
    const { newTags: xe, oldTags: Ee } = ye[ge];
    xe.length && (me[ge] = xe), Ee.length && (ve[ge] = ye[ge].oldTags);
  }), ee && ee(), le($, me, ve);
}, _helmetCallback = null, handleStateChangeOnClient = ($) => {
  _helmetCallback && cancelAnimationFrame(_helmetCallback), $.defer ? _helmetCallback = requestAnimationFrame(() => {
    commitTagChanges($, () => {
      _helmetCallback = null;
    });
  }) : (commitTagChanges($), _helmetCallback = null);
}, client_default = handleStateChangeOnClient, HelmetDispatcher = class extends Component {
  constructor() {
    super(...arguments);
    On(this, "rendered", !1);
  }
  shouldComponentUpdate(ee) {
    return !shallowEqual(ee, this.props);
  }
  componentDidUpdate() {
    this.emitChange();
  }
  componentWillUnmount() {
    const { helmetInstances: ee } = this.props.context;
    ee.remove(this), this.emitChange();
  }
  emitChange() {
    const { helmetInstances: ee, setHelmet: te } = this.props.context;
    let ne = null;
    const re = reducePropsToState(
      ee.get().map((se) => {
        const ie = { ...se.props };
        return delete ie.context, ie;
      })
    );
    HelmetProvider.canUseDOM ? client_default(re) : server_default && (ne = server_default(re)), te(ne);
  }
  // componentWillMount will be deprecated
  // for SSR, initialize on first render
  // constructor is also unsafe in StrictMode
  init() {
    if (this.rendered)
      return;
    this.rendered = !0;
    const { helmetInstances: ee } = this.props.context;
    ee.add(this), this.emitChange();
  }
  render() {
    return this.init(), null;
  }
}, _r, Helmet = (_r = class extends Component {
  shouldComponentUpdate($) {
    return !fastCompare(without(this.props, "helmetData"), without($, "helmetData"));
  }
  mapNestedChildrenToProps($, ee) {
    if (!ee)
      return null;
    switch ($.type) {
      case "script":
      case "noscript":
        return {
          innerHTML: ee
        };
      case "style":
        return {
          cssText: ee
        };
      default:
        throw new Error(
          `<${$.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`
        );
    }
  }
  flattenArrayTypeChildren($, ee, te, ne) {
    return {
      ...ee,
      [$.type]: [
        ...ee[$.type] || [],
        {
          ...te,
          ...this.mapNestedChildrenToProps($, ne)
        }
      ]
    };
  }
  mapObjectTypeChildren($, ee, te, ne) {
    switch ($.type) {
      case "title":
        return {
          ...ee,
          [$.type]: ne,
          titleAttributes: { ...te }
        };
      case "body":
        return {
          ...ee,
          bodyAttributes: { ...te }
        };
      case "html":
        return {
          ...ee,
          htmlAttributes: { ...te }
        };
      default:
        return {
          ...ee,
          [$.type]: { ...te }
        };
    }
  }
  mapArrayTypeChildrenToProps($, ee) {
    let te = { ...ee };
    return Object.keys($).forEach((ne) => {
      te = {
        ...te,
        [ne]: $[ne]
      };
    }), te;
  }
  warnOnInvalidChildren($, ee) {
    return invariant$1(
      VALID_TAG_NAMES.some((te) => $.type === te),
      typeof $.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${VALID_TAG_NAMES.join(
        ", "
      )} are allowed. Helmet does not support rendering <${$.type}> elements. Refer to our API for more information.`
    ), invariant$1(
      !ee || typeof ee == "string" || Array.isArray(ee) && !ee.some((te) => typeof te != "string"),
      `Helmet expects a string as a child of <${$.type}>. Did you forget to wrap your children in braces? ( <${$.type}>{\`\`}</${$.type}> ) Refer to our API for more information.`
    ), !0;
  }
  mapChildrenToProps($, ee) {
    let te = {};
    return React__default.Children.forEach($, (ne) => {
      if (!ne || !ne.props)
        return;
      const { children: re, ...se } = ne.props, ie = Object.keys(se).reduce((le, ue) => (le[HTML_TAG_MAP[ue] || ue] = se[ue], le), {});
      let { type: oe } = ne;
      switch (typeof oe == "symbol" ? oe = oe.toString() : this.warnOnInvalidChildren(ne, re), oe) {
        case "Symbol(react.fragment)":
          ee = this.mapChildrenToProps(re, ee);
          break;
        case "link":
        case "meta":
        case "noscript":
        case "script":
        case "style":
          te = this.flattenArrayTypeChildren(
            ne,
            te,
            ie,
            re
          );
          break;
        default:
          ee = this.mapObjectTypeChildren(ne, ee, ie, re);
          break;
      }
    }), this.mapArrayTypeChildrenToProps(te, ee);
  }
  render() {
    const { children: $, ...ee } = this.props;
    let te = { ...ee }, { helmetData: ne } = ee;
    if ($ && (te = this.mapChildrenToProps($, te)), ne && !(ne instanceof HelmetData)) {
      const re = ne;
      ne = new HelmetData(re.context, !0), delete te.helmetData;
    }
    return ne ? /* @__PURE__ */ React__default.createElement(HelmetDispatcher, { ...te, context: ne.value }) : /* @__PURE__ */ React__default.createElement(Context.Consumer, null, (re) => /* @__PURE__ */ React__default.createElement(HelmetDispatcher, { ...te, context: re }));
  }
}, On(_r, "defaultProps", {
  defer: !0,
  encodeSpecialCharacters: !0,
  prioritizeSeoTags: !1
}), _r);
const useFeedDetails = ($) => {
  const { routes: ee } = useContext(GeneralContext), { lmFeedclient: te, customEventClient: ne, lmfeedAnalyticsClient: re } = useContext(
    GlobalClientProviderContext
  ), { currentUser: se, currentCommunity: ie, logoutUser: oe } = useContext(
    UserProviderContext
  ), { displaySnackbarMessage: le, message: ue, showSnackbar: de, closeSnackbar: fe } = useContext(GeneralContext), {
    FeedPostDetailsCustomActions: pe = {},
    postComponentClickCustomCallback: ye
  } = useContext(CustomAgentProviderContext), {
    deletePostCustomAction: me,
    pinPostCustomAction: ve,
    likePostCustomAction: ge,
    clickNavigationCustomAction: xe,
    likeReplyCustomAction: Ee
  } = pe, Te = useNavigate(), [Se, he] = useState(null), [Pe, Ie] = useState({}), [De, Ce] = useState([]), [Ne, Me] = useState(!0), [Be, We] = useState({}), [Le, He] = useState(1), Ge = useCallback(async () => {
    var Fe;
    try {
      const $e = await (te == null ? void 0 : te.getPost(
        O$1.builder().setpage(1).setpageSize(20).setpostId($).build()
      ));
      $e.success ? (he({ ...$e.data.post }), Ce([...$e.data.post.replies || []]), Ie({ ...$e.data.users }), We({ ...$e.data.topics }), He((qe) => qe + 1), (Fe = $e.data.post.replies) != null && Fe.length || Me(!1)) : (le && (alert(LMDisplayMessages.ERROR_LOADING_POST), le(
        ($e == null ? void 0 : $e.errorMessage) || LMDisplayMessages.ERROR_LOADING_POST
      )), window.history.back());
    } catch ($e) {
      console.log($e);
    }
  }, [le, te, $]), Ze = useCallback(async () => {
    var Fe;
    try {
      const $e = await (te == null ? void 0 : te.getPost(
        O$1.builder().setpage(Le).setpageSize(20).setpostId($).build()
      ));
      $e.success && (Ce([
        ...De,
        ...$e.data.post.replies || []
      ]), Ie({ ...Pe, ...$e.data.users }), We({ ...Be, ...$e.data.topics }), He((qe) => qe + 1), (Fe = $e.data.post.replies) != null && Fe.length || Me(!1));
    } catch ($e) {
      console.log($e);
    }
  }, [te, Le, $, De, Be, Pe]), Ue = useCallback(
    (Fe) => {
      sessionStorage.setItem("scroll-pos", Fe.Id || "");
      let $e = "";
      ee ? $e = ee == null ? void 0 : ee.feedDetailsRoute.pathname : $e = LMAppRoutesConstant.POST_DETAILS_PATHNAME, Te(
        `/${$e}/${`${Fe.Id}-${Fe == null ? void 0 : Fe.heading}`.substring(0, 59)}`
      );
    },
    [Te, ee]
  ), Qe = useCallback(
    function(Fe) {
      const $e = [...De], qe = $e.find((Ye) => Ye.Id === Fe);
      qe && qe.commentsCount++, Ce($e);
    },
    [De]
  ), Je = useCallback(
    function(Fe, $e) {
      const qe = [Fe, ...De], Ye = { ...Pe, ...$e }, Ke = { ...Se };
      Ke && (Ke != null && Ke.commentsCount) && (Ke.commentsCount++, he(Ke)), Ce(qe), Ie(Ye), ne && ne.dispatchEvent(
        LMFeedCustomActionEvents.COMMENT_ADDED,
        {
          postId: Se == null ? void 0 : Se.Id
        }
      );
    },
    [ne, Se, De, Pe]
  ), Ot = useCallback(
    async function(Fe) {
      try {
        if ((await (te == null ? void 0 : te.deleteComment(
          lt.builder().setpostId((Se == null ? void 0 : Se.Id) || "").setcommentId(Fe).build()
        ))).success) {
          const qe = [...De].filter((Tt) => Tt.Id !== Fe), Ye = [...De].find((Tt) => Tt.Id === Fe);
          re == null || re.sendCommentDeletedEvent(
            Se,
            Ye,
            Be
          );
          const Ke = { ...Se };
          Ke && (Ke != null && Ke.commentsCount) && (Ke.commentsCount--, he(Ke), Ce(qe), le && le(LMDisplayMessages.COMMENT_DELETED_SUCCESS)), ne && ne.dispatchEvent(
            LMFeedCustomActionEvents.COMMENT_REMOVED,
            {
              postId: Se == null ? void 0 : Se.Id
            }
          );
        }
      } catch ($e) {
        console.log($e);
      }
    },
    [ne, le, te, Se, De]
  ), At = useCallback(
    function(Fe, $e) {
      const qe = [...De].map(
        (Tt) => Tt.Id === Fe.Id ? Fe : Tt
      ), Ye = { ...Pe, ...$e }, Ke = { ...Se };
      Ke && Ke.isEdited && (Ke.isEdited = !0, he(Ke)), Ce(qe), Ie(Ye);
    },
    [Se, De, Pe]
  ), ze = useCallback(
    async function(Fe) {
      try {
        if ((await (te == null ? void 0 : te.likeComment(
          ht.builder().setpostId($).setcommentId(Fe).build()
        ))).success) {
          const qe = [...De].map((Ye) => (Ye.Id === Fe && (Ye.isLiked ? (Ye.isLiked = !1, Ye.likesCount--) : (Ye.isLiked = !0, Ye.likesCount++)), Ye));
          Ce(qe);
        }
      } catch ($e) {
        console.log($e);
      }
    },
    [te, $, De]
  ), we = useCallback(
    async function(Fe) {
      try {
        if ((await (te == null ? void 0 : te.likePost(
          j$1.builder().setpostId(Fe).build()
        ))).success) {
          const qe = { ...Se };
          qe.isLiked ? (qe.isLiked = !1, qe.likesCount && qe.likesCount--) : (qe.isLiked = !0, qe.likesCount ? qe.likesCount++ : qe.likesCount = 1), he(qe), ne && ne.dispatchEvent(
            LMFeedCustomActionEvents.LIKE_POST_CALLED,
            {
              postId: Fe
            }
          );
        }
      } catch ($e) {
        console.log($e);
      }
    },
    [ne, te, Se]
  ), Ae = useCallback(
    async function(Fe) {
      ne == null || ne.dispatchEvent(
        LMFeedCustomActionEvents.DELETE_POST_ON_DETAILS,
        {
          postId: Fe
        }
      );
    },
    [ne]
  ), Re = useCallback(
    async function(Fe) {
      var $e, qe;
      try {
        if ((await (te == null ? void 0 : te.pinPost(
          K$1.builder().setpostId(Fe).build()
        ))).success) {
          const Ke = { ...Se };
          Ke.isPinned ? (Ke.isPinned = !1, re == null || re.sendPostUnPinnedEvent(Se, Be), Ke.menuItems = ($e = Ke.menuItems) == null ? void 0 : $e.map((Tt) => Tt.id.toString() === LMFeedPostMenuItems.UNPIN_POST ? {
            id: parseInt(LMFeedPostMenuItems.PIN_POST),
            title: "Pin Post"
          } : Tt)) : (Ke.isPinned = !0, re == null || re.sendPostPinnedEvent(Se, Be), Ke.menuItems = (qe = Ke.menuItems) == null ? void 0 : qe.map((Tt) => Tt.id.toString() === LMFeedPostMenuItems.PIN_POST ? {
            id: parseInt(LMFeedPostMenuItems.UNPIN_POST),
            title: "Unpin This Post"
          } : Tt)), he(Ke), ne && ne.dispatchEvent(
            LMFeedCustomActionEvents.PINNED_ON_DETAIL,
            {
              id: $
            }
          ), le && (Ke.isPinned ? le(LMDisplayMessages.PIN_REMOVED_SUCCESS) : le(LMDisplayMessages.POST_PINNED_SUCCESS));
        }
      } catch (Ye) {
        console.log(Ye);
      }
    },
    [ne, le, te, Se, $]
  );
  useEffect(() => (ne == null || ne.listen(
    LMFeedCustomActionEvents.REPLY_DELETED,
    (Fe) => {
      const $e = Fe.detail.replyId, qe = [...De], Ye = qe.find((Ke) => Ke.Id === $e);
      Ye && Ye.commentsCount--, Ce(qe), le && le(LMDisplayMessages.REPLY_DELETED_SUCCESS);
    }
  ), () => ne == null ? void 0 : ne.remove(LMFeedCustomActionEvents.REPLY_DELETED))), useEffect(() => (ne == null || ne.listen(
    LMFeedCustomActionEvents.POST_EDITED_TARGET_DETAILS,
    (Fe) => {
      const $e = Fe.detail, { post: qe, usersMap: Ye, topicsMap: Ke } = $e, Tt = { ...qe }, pt = { ...Pe, ...Ye }, Bt = { ...Be, ...Ke };
      he(Tt), We(Bt), Ie(pt), le && le(LMDisplayMessages.POST_EDIT_SUCCESS);
    }
  ), () => ne == null ? void 0 : ne.remove(
    LMFeedCustomActionEvents.POST_EDITED_TARGET_DETAILS
  )));
  const je = useMemo(() => ({
    feedPostDetailsStore: {
      post: Se,
      setPost: he,
      users: Pe,
      setUsers: Ie,
      replies: De,
      setReplies: Ce,
      loadNextPage: Ne,
      setLoadNextPage: Me,
      topics: Be,
      setTopics: We,
      pageCount: Le,
      setPageCount: He
    },
    applicationGeneralStore: {
      userDataStore: {
        lmFeedUser: se,
        lmFeedUserCurrentCommunity: ie,
        logOutUser: oe
      },
      generalDataStore: {
        displaySnackbarMessage: le,
        closeSnackbar: fe,
        showSnackbar: de,
        message: ue
      }
    },
    defaultActions: {
      addNewComment: Je,
      removeAComment: Ot,
      updateReply: At,
      updateReplyOnPostReply: Qe,
      likeReply: ze,
      clickNavigator: Ue,
      likePost: we,
      pinPost: Re,
      deletePost: Ae,
      getNextPage: Ze
    },
    navigate: Te
  }), [
    Je,
    Ue,
    fe,
    ie,
    se,
    Ae,
    le,
    Ze,
    we,
    ze,
    Ne,
    oe,
    ue,
    Te,
    Le,
    Re,
    Se,
    Ot,
    De,
    de,
    Be,
    At,
    Qe,
    Pe
  ]);
  return useEffect(() => {
    Ge();
  }, [Ge, $]), {
    post: Se,
    users: Pe,
    getNextPage: Ze,
    replies: De,
    loadNextPage: Ne,
    topics: Be,
    addNewComment: Je,
    removeAComment: Ot,
    updateReply: At,
    updateReplyOnPostReply: Qe,
    likeReply: (Ee == null ? void 0 : Ee.bind(null, je)) || ze,
    likePost: (ge == null ? void 0 : ge.bind(null, je)) || we,
    pinPost: (ve == null ? void 0 : ve.bind(null, je)) || Re,
    deletePost: (me == null ? void 0 : me.bind(null, je)) || Ae,
    clickNavigator: xe ? xe.bind(
      null,
      je
    ) : Ue,
    postComponentClickCustomCallback: ye ? ye == null ? void 0 : ye.bind(
      null,
      je
    ) : void 0
  };
}, lmBack = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M20%2011H7.8L13.4%205.4L12%204L4%2012L12%2020L13.4%2018.6L7.8%2013H20V11Z'%20fill='%23333333'/%3e%3c/svg%3e", LMFeedDetails = () => {
  const { id: $ = "" } = useParams(), { CustomComponents: ee = {} } = useContext(CustomAgentProviderContext), { CustomPostView: te } = ee, {
    post: ne,
    users: re,
    topics: se,
    replies: ie,
    getNextPage: oe,
    loadNextPage: le,
    addNewComment: ue,
    removeAComment: de,
    updateReply: fe,
    updateReplyOnPostReply: pe,
    likeReply: ye,
    likePost: me,
    pinPost: ve,
    deletePost: ge,
    clickNavigator: xe,
    postComponentClickCustomCallback: Ee
  } = useFeedDetails($.split("-")[0]);
  return !ne || !re ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-feed-wrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Helmet, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: ne.heading }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "description", content: ne == null ? void 0 : ne.text })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      FeedPostContext.Provider,
      {
        value: {
          post: ne,
          users: re,
          topics: se,
          replies: ie,
          getNextPage: oe,
          loadNextPage: le,
          addNewComment: ue,
          removeAComment: de,
          updateReply: fe,
          updateReplyOnPostReply: pe,
          likeReply: ye,
          likePost: me,
          pinPost: ve,
          deletePost: ge,
          clickNavigator: xe,
          postComponentClickCustomCallback: Ee
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedCreatePost, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-post-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                onClick: () => window.history.back(),
                src: lmBack,
                alt: "Back Icon",
                className: "lm-cursor-pointer"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Back to feed" })
          ] }),
          te || /* @__PURE__ */ jsxRuntimeExports.jsx(
            LMFeedPost,
            {
              post: ne,
              user: Object.values(re).find((Te) => Te.uuid === ne.uuid)
            }
          )
        ]
      }
    )
  ] });
}, LMFeedListDataContextProvider = () => {
  const {
    topics: $,
    selectedTopics: ee,
    setSelectedTopics: te,
    loadMoreFeeds: ne,
    feedList: re,
    feedUsersList: se,
    getNextPage: ie,
    deletePost: oe,
    pinPost: le,
    likePost: ue,
    postComponentClickCustomCallback: de,
    clickNavigator: fe
  } = useFetchFeeds(), { routes: pe } = useContext(GeneralContext);
  function ye() {
    return pe ? Object.keys(pe).map((ve) => {
      const { pathname: ge, params: xe, element: Ee } = pe[ve], Te = ge.concat(
        xe.reduce(
          (Se, he) => Se.concat(`/:${he}`)
        )
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: Te, element: Ee }, Te);
    }) : null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LMFeedDataContext.Provider,
    {
      value: {
        topics: $,
        selectedTopics: ee,
        setSelectedTopics: te,
        loadMoreFeeds: ne,
        clickNavigator: fe,
        feedList: re,
        feedUsersList: se,
        getNextPage: ie,
        deletePost: oe,
        pinPost: le,
        likePost: ue,
        postComponentClickCustomCallback: de
      },
      children: pe ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: ye() }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: ROUTES.ROOT_PATH,
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedUniversalFeed, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: ROUTES.POST_DETAIL,
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(HelmetProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedDetails, {}) })
          }
        )
      ] })
    }
  );
};
class LMFeedAnalytics {
  constructor(ee) {
    On(this, "callback");
    On(this, "LOG_TAG", "LMFeedAnalytics");
    // Event names
    On(this, "Events", {
      POST_CREATION_STARTED: "Post creation started",
      CLICKED_ON_ATTACHMENT: "Clicked on Attachment",
      USER_TAGGED_IN_POST: "User tagged in a post",
      LINK_ATTACHED_IN_POST: "link attached in the post",
      IMAGE_ATTACHED_TO_POST: "Image attached to post",
      VIDEO_ATTACHED_TO_POST: "Video attached to post",
      DOCUMENT_ATTACHED_TO_POST: "Document attached in post",
      POST_CREATION_COMPLETED: "Post creation completed",
      POST_CREATION_ERROR: "Post creation error",
      POST_PINNED: "Post pinned",
      POST_UNPINNED: "Post unpinned",
      POST_REPORTED: "Post reported",
      POST_DELETED: "Post deleted",
      FEED_OPENED: "Feed opened",
      LIKE_LIST_OPEN: "Like list open",
      COMMENT_LIST_OPEN: "Comment list open",
      COMMENT_DELETED: "Comment deleted",
      COMMENT_REPORTED: "Comment reported",
      COMMENT_POSTED: "Comment posted",
      REPLY_POSTED: "Reply posted",
      REPLY_DELETED: "Reply deleted",
      REPLY_REPORTED: "Reply reported",
      POST_EDITED: "Post edited",
      POST_SHARED: "Post shared",
      POST_LIKED: "Post Liked",
      POST_UNLIKED: "Post Unliked",
      POST_SAVED: "Post Saved",
      POST_UNSAVED: "Post Unsaved",
      COMMENT_LIKED: "Comment Liked",
      COMMENT_UNLIKED: "Comment Unliked",
      COMMENT_EDITED: "Comment edited",
      NOTIFICATION_RECEIVED: "Notification Received",
      NOTIFICATION_CLICKED: "Notification Clicked",
      NOTIFICATION_PAGE_OPENED: "Notification page opened"
    });
    // Event keys
    On(this, "Keys", {
      POST_ID: "post_id",
      UUID: "uuid",
      COMMENT_ID: "comment_id",
      COMMENT_REPLY_ID: "comment_reply_id",
      POST_TYPE_TEXT: "text",
      POST_TYPE_IMAGE: "image",
      POST_TYPE_VIDEO: "video",
      POST_TYPE_IMAGE_VIDEO: "image,video",
      POST_TYPE_DOCUMENT: "document",
      POST_TYPE_LINK: "link"
    });
    // Source keys
    On(this, "Source", {
      DEEP_LINK: "deep_link",
      NOTIFICATION: "notification",
      UNIVERSAL_FEED: "universal_feed",
      POST_DETAIL: "post_detail"
    });
    this.callback = ee;
  }
  track(ee, te = {}) {
    console.log(`
            eventName: ${ee}
            eventProperties: ${JSON.stringify(te)}
        `), this.callback(ee, te);
  }
  sendFeedOpenedEvent() {
    this.track(this.Events.FEED_OPENED, {
      feed_type: "universal_feed"
    });
  }
  sendPostCreationStartedEvent() {
    this.track(this.Events.POST_CREATION_STARTED);
  }
  sendClickedOnAttachmentEvent(ee, te) {
    const ne = {
      type: te
    };
    ee && (ne.post_id = ee), this.track(this.Events.CLICKED_ON_ATTACHMENT, ne);
  }
  sendPostLikedEvent(ee, te) {
    const ne = {};
    ne.post_id = ee.Id, ne.created_by_uuid = ee.uuid, ne.topics = Object.values(te).filter((re) => ee.topics.includes(re.Id)).toString(), this.track(this.Events.POST_LIKED, ne);
  }
  sendPostUnLikedEvent(ee, te) {
    const ne = {};
    ne.post_id = ee.Id, ne.created_by_uuid = ee.uuid, ne.topics = Object.values(te).filter((re) => ee.topics.includes(re.Id)).toString(), this.track(this.Events.POST_UNLIKED, ne);
  }
  sendPostSavedEvent(ee, te, ne) {
    const re = ne ? this.Events.POST_SAVED : this.Events.POST_UNSAVED;
    this.track(re, {
      [this.Keys.UUID]: ee,
      [this.Keys.POST_ID]: te
    });
  }
  sendPostPinnedEvent(ee, te) {
    const ne = {};
    ne.post_id = ee.Id, ne.post_created_by_uuid = ee.uuid, ne.post_topics = Object.values(te).toString(), this.track(this.Events.POST_PINNED, ne);
  }
  sendPostUnPinnedEvent(ee, te) {
    const ne = {};
    ne.post_id = ee.Id, ne.post_created_by_uuid = ee.uuid, ne.post_topics = Object.values(te).toString(), this.track(this.Events.POST_UNPINNED, ne);
  }
  sendCommentListOpenEvent() {
    this.track(this.Events.COMMENT_LIST_OPEN);
  }
  sendPostShared(ee) {
    const te = LMFeedViewUtils.getPostTypeFromViewType(ee.viewType), ne = ee.headerViewData.user.sdkClientInfoViewData.uuid;
    this.track(this.Events.POST_SHARED, {
      created_by_uuid: ne,
      [this.Keys.POST_ID]: ee.id,
      post_type: te
    });
  }
  sendPostCreatedEvent(ee) {
    const te = {
      created_by_uuid: ee.uuid,
      [this.Keys.POST_ID]: ee.Id
    };
    if (ee.attachments.some((ie) => ie.attachmentType === 4)) {
      const ie = ee.attachments.find(
        (oe) => oe.attachmentType === 4
      );
      ie && (te.link_attached = ie == null ? void 0 : ie.attachmentMeta.ogTags.url);
    }
    const ne = ee.attachments.filter(
      (ie) => ie.attachmentType === 1
    ).length, re = ee.attachments.filter(
      (ie) => ie.attachmentType === 2
    ).length, se = ee.attachments.filter(
      (ie) => ie.attachmentType === 3
    ).length;
    ne && (te.image_count = ne.toString()), re && (te.video_count = re.toString()), se && (te.document_count = se.toString()), ee.topics.length && (te.post_topics = ee.topics.toString()), this.track(this.Events.POST_CREATION_COMPLETED, te);
  }
  sendPostCreationErrorEvent(ee) {
    const te = {
      created_by_uuid: ee.uuid,
      [this.Keys.POST_ID]: ee.Id
    };
    if (ee.attachments.some((ie) => ie.attachmentType === 4)) {
      const ie = ee.attachments.find(
        (oe) => oe.attachmentType === 4
      );
      ie && (te.link_attached = ie == null ? void 0 : ie.attachmentMeta.ogTags.url);
    }
    const ne = ee.attachments.filter(
      (ie) => ie.attachmentType === 1
    ).length, re = ee.attachments.filter(
      (ie) => ie.attachmentType === 2
    ).length, se = ee.attachments.filter(
      (ie) => ie.attachmentType === 3
    ).length;
    ne && (te.image_count = ne.toString()), re && (te.video_count = re.toString()), se && (te.document_count = se.toString()), ee.topics.length && (te.post_topics = ee.topics.toString()), this.track(this.Events.POST_CREATION_ERROR, te);
  }
  sendPostEditedEvent(ee) {
    const te = {
      created_by_uuid: ee.uuid,
      [this.Keys.POST_ID]: ee.Id
    };
    if (ee.attachments.some((ie) => ie.attachmentType === 4)) {
      const ie = ee.attachments.find(
        (oe) => oe.attachmentType === 4
      );
      ie && (te.link_attached = ie == null ? void 0 : ie.attachmentMeta.ogTags.url);
    }
    const ne = ee.attachments.filter(
      (ie) => ie.attachmentType === 1
    ).length, re = ee.attachments.filter(
      (ie) => ie.attachmentType === 2
    ).length, se = ee.attachments.filter(
      (ie) => ie.attachmentType === 3
    ).length;
    ne && (te.image_count = ne.toString()), re && (te.video_count = re.toString()), se && (te.document_count = se.toString()), ee.topics.length && (te.post_topics = ee.topics.toString()), this.track(this.Events.POST_EDITED, te);
  }
  sendLinkAttachedEvent(ee, te) {
    te ? this.track(this.Events.LINK_ATTACHED_IN_POST, {
      link: ee,
      post_id: te
    }) : this.track(this.Events.LINK_ATTACHED_IN_POST, {
      link: ee
    });
  }
  sendPostDeletedEvent(ee, te, ne) {
    const re = {};
    re.user_state = ne, re.post_topics = Object.values(te).filter((se) => ee.topics.includes(se.Id)).toString(), re.post_created_by_uuid = ee.uuid, re.post_id = ee.Id, this.track(this.Events.POST_DELETED, re);
  }
  sendCommentDeletedEvent(ee, te, ne) {
    const re = {};
    re.post_id = ee.Id, re.comment_id = te.Id, re.post_topics = Object.values(ne).filter((se) => ee.topics.includes(se.Id)).toString(), re.post_created_by_uuid = ee.uuid, re.comment_created_by_uuid = te.uuid, this.track(this.Events.COMMENT_DELETED, re);
  }
  sendCommentReplyDeletedEvent(ee, te, ne) {
    ne ? this.track(this.Events.REPLY_DELETED, {
      [this.Keys.POST_ID]: ee,
      [this.Keys.COMMENT_ID]: ne,
      [this.Keys.COMMENT_REPLY_ID]: te
    }) : this.track(this.Events.COMMENT_DELETED, {
      [this.Keys.POST_ID]: ee,
      [this.Keys.COMMENT_ID]: te
    });
  }
  sendReplyPostedEvent(ee, te, ne, re) {
    this.track(this.Events.REPLY_POSTED, {
      [this.Keys.UUID]: ee,
      [this.Keys.POST_ID]: te,
      [this.Keys.COMMENT_ID]: ne,
      [this.Keys.COMMENT_REPLY_ID]: re
    });
  }
  sendCommentPostedEvent(ee, te) {
    this.track(this.Events.COMMENT_POSTED, {
      [this.Keys.POST_ID]: ee,
      [this.Keys.COMMENT_ID]: te
    });
  }
  sendCommentLikedEvent(ee, te, ne, re) {
    const se = ne ? this.Events.COMMENT_LIKED : this.Events.COMMENT_UNLIKED;
    this.track(se, {
      [this.Keys.UUID]: re,
      [this.Keys.POST_ID]: ee,
      [this.Keys.COMMENT_ID]: te
    });
  }
  sendCommentEditedEvent(ee) {
    this.track(this.Events.COMMENT_EDITED, {
      created_by_uuid: ee.user.sdkClientInfoViewData.uuid,
      [this.Keys.COMMENT_ID]: ee.id,
      level: ee.level.toString()
    });
  }
  sendPostReportedEvent(ee, te, ne, re) {
    this.track(this.Events.POST_REPORTED, {
      created_by_uuid: te,
      [this.Keys.POST_ID]: ee,
      report_reason: re,
      post_type: ne
    });
  }
  sendCommentReportedEvent(ee, te, ne, re) {
    this.track(this.Events.COMMENT_REPORTED, {
      [this.Keys.POST_ID]: ee,
      [this.Keys.UUID]: te,
      [this.Keys.COMMENT_ID]: ne,
      reason: re
    });
  }
  sendReplyReportedEvent(ee, te, ne, re, se) {
    const ie = ne ?? "";
    this.track(this.Events.REPLY_REPORTED, {
      [this.Keys.POST_ID]: ee,
      [this.Keys.COMMENT_ID]: ie,
      [this.Keys.COMMENT_REPLY_ID]: re,
      [this.Keys.UUID]: te,
      reason: se
    });
  }
  sendLikeListOpenEvent(ee, te) {
    const ne = {};
    ne[this.Keys.POST_ID] = ee, te && (ne[this.Keys.COMMENT_ID] = te), this.track(this.Events.LIKE_LIST_OPEN, ne);
  }
  sendNotificationPageOpenedEvent() {
    this.track(this.Events.NOTIFICATION_PAGE_OPENED);
  }
  sendUserTagEvent(ee, te) {
    this.track(this.Events.USER_TAGGED_IN_POST, {
      tagged_user_uuid: ee,
      tagged_user_count: te.toString()
    });
  }
}
const LMFeedViewUtils = {
  getPostTypeFromViewType: ($) => $
  // Simplified for this example
};
class LMCoreCallbacks {
  constructor(ee, te) {
    On(this, "onAccessTokenExpiredAndRefreshed");
    On(this, "onRefreshTokenExpired");
    this.onAccessTokenExpiredAndRefreshed = ee, this.onRefreshTokenExpired = te;
  }
}
class LMSDKCallbacksImplementations extends Ct {
  constructor(te, ne, re) {
    super();
    On(this, "lmCoreCallbacks");
    On(this, "client");
    On(this, "customEventsClient");
    this.lmCoreCallbacks = te, this.client = ne, this.customEventsClient = re;
  }
  onAccessTokenExpiredAndRefreshed(te, ne) {
    this.lmCoreCallbacks.onAccessTokenExpiredAndRefreshed(
      te,
      ne
    );
  }
  onRefreshTokenExpired() {
    console.log("inside refresh token expired");
    const te = this.client.getApiKeyFromLocalStorage();
    return te && te.length ? (console.log("a"), this.customEventsClient.dispatchEvent(
      LMFeedCustomActionEvents.TRIGGER_SET_USER
    ), null) : (console.log("here"), this.lmCoreCallbacks.onRefreshTokenExpired());
  }
}
function LMFeed({
  useParentRouter: $ = !1,
  LMFeedCoreCallbacks: ee,
  userDetails: te,
  client: ne,
  routes: re,
  customEventClient: se,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  analyticsCallback: ie = (Se, he) => {
  },
  LMPostHeaderStyles: oe,
  LMFeedCustomIcons: le,
  CustomComponents: ue,
  FeedListCustomActions: de,
  FeedPostDetailsCustomActions: fe,
  GeneralCustomCallbacks: pe,
  TopicsCustomCallbacks: ye,
  RepliesCustomCallbacks: me,
  PostCreationCustomCallbacks: ve,
  postComponentClickCustomCallback: ge,
  createPostComponentClickCustomCallback: xe,
  topicComponentClickCustomCallback: Ee,
  memberComponentClickCustomCallback: Te
}) {
  const { lmFeedUser: Se, logoutUser: he, lmFeedUserCurrentCommunity: Pe } = useUserProvider(ne, se, te), { showSnackbar: Ie, message: De, closeSnackbar: Ce, displaySnackbarMessage: Ne } = useLMFeedGeneralContextProvider();
  return useEffect(() => {
    const Me = `//cdn.jsdelivr.net/npm/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.js`;
    pdfjs.GlobalWorkerOptions.workerSrc = Me;
  }, []), useEffect(() => {
    ne.setLMSDKCallbacks(
      new LMSDKCallbacksImplementations(
        ee,
        ne,
        se
      )
    ), console.log(ne);
  }, [ee, ne, se]), Se ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    GlobalClientProviderContext.Provider,
    {
      value: {
        lmFeedclient: ne,
        customEventClient: se,
        lmfeedAnalyticsClient: new LMFeedAnalytics(ie)
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomAgentProviderContext.Provider,
          {
            value: {
              LMPostHeaderStyles: oe,
              LMFeedCustomIcons: le,
              CustomComponents: ue,
              FeedListCustomActions: de,
              FeedPostDetailsCustomActions: fe,
              GeneralCustomCallbacks: pe,
              postComponentClickCustomCallback: ge,
              topicComponentClickCustomCallback: Ee,
              createPostComponentClickCustomCallback: xe,
              memberComponentClickCustomCallback: Te,
              TopicsCustomCallbacks: ye,
              RepliesCustomCallbacks: me,
              PostCreationCustomCallbacks: ve
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              GeneralContext.Provider,
              {
                value: {
                  message: De,
                  showSnackbar: Ie,
                  closeSnackbar: Ce,
                  displaySnackbarMessage: Ne,
                  useParentRouter: $,
                  routes: re
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  UserProviderContext.Provider,
                  {
                    value: {
                      currentUser: Se,
                      currentCommunity: Pe,
                      logoutUser: he
                    },
                    children: $ ? /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedListDataContextProvider, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedListDataContextProvider, {}) })
                  }
                )
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Snackbar$1,
          {
            open: Ie,
            message: De,
            onClose: Ce,
            autoHideDuration: 3e3
          }
        )
      ]
    }
  ) : null;
}
const LMFeedLoaderContextProvider = React__default.createContext({
  loader: !1,
  setLoader: null
});
function useLMFeedNotification($, ee = {}) {
  const [te, ne] = useState([]), [re, se] = useState({}), [ie, oe] = useState(!0), [le, ue] = useState(0), [de, fe] = useState(1), [pe, ye] = useState(null), [, me] = useState(null), { handleNotificationCustomAction: ve } = ee, ge = useCallback(
    async function() {
      try {
        const he = await (pe == null ? void 0 : pe.getUnreadNotificationCount());
        he.success && ue(he.data.count);
      } catch (he) {
        console.log(he);
      }
    },
    [pe]
  );
  async function xe(he) {
    try {
      await (pe == null ? void 0 : pe.markReadNotification(
        gt.builder().setactivityId(he).build()
      ));
    } catch (Pe) {
      console.log(Pe);
    }
  }
  const Ee = useCallback(
    async function() {
      try {
        const he = await (pe == null ? void 0 : pe.getNotificationFeed(
          mt.builder().setpage(de).setpageSize(DEFAULT_PAGE_SIZE).build()
        ));
        if (he.success) {
          const Pe = [...te, ...he.data.activities], Ie = { ...re, ...he.data.users };
          se(Ie), ne(Pe), fe((De) => De + 1), he.data.activities.length || oe(!1);
        }
      } catch (he) {
        console.log(he);
      }
    },
    [pe, de, te, re]
  ), Te = useCallback(
    (he) => {
      const Pe = [...te], Ie = Pe.findIndex(
        (Ce) => Ce.Id === he
      ), De = Pe[Ie];
      De.isRead || (De.isRead = !0), xe(he), window.location.href = `/community/post/${De.activityEntityData.Id}`, ne(Pe);
    },
    [xe, te]
  );
  useEffect(() => {
    pe && ge();
  }, [pe]), useEffect(() => ($.listen(
    LMFeedCustomActionEvents.USER_INITIATED,
    (he) => {
      const Pe = he.detail, { lmFeedClient: Ie, user: De } = Pe;
      ye(Ie), me(De);
    }
  ), () => $.remove(LMFeedCustomActionEvents.USER_INITIATED)), [$]), useEffect(() => {
    pe && Ee();
  }, [pe]);
  const Se = useMemo(() => ({
    notificationsDataStore: {
      notifications: te,
      setNotifications: ne,
      users: re,
      setUsers: se,
      shouldLoadMoreNotifications: ie,
      setShouldLoadMoreNotifications: oe,
      notificationCount: le,
      setNotificationCount: ue,
      notificationPage: de,
      setNotificationPage: fe
    },
    defaultActions: {
      getNotifications: Ee,
      handleNotification: Te
    }
  }), [
    Ee,
    Te,
    le,
    de,
    te,
    ie,
    re
  ]);
  return {
    notifications: te,
    shouldLoadMoreNotifications: ie,
    getNotifications: Ee,
    notificationCount: le,
    users: re,
    handleNotification: ve ? ve.bind(
      null,
      Se
    ) : Te
  };
}
const LMFeedError = () => {
  const $ = useRouteError();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "error-page", className: "lmError", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lmErrorBox", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "404" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lmErrorTitle", children: "Sorry, an unexpected error has occurred." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "lmErrorMsg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: ($ == null ? void 0 : $.message) || ($ == null ? void 0 : $.statusText) }) })
  ] }) });
}, LMFeedLoader = ({ show: $ }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: $ && /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: "100vh"
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, { color: "primary" })
  }
) }), notificationBell = "data:image/svg+xml,%3csvg%20width='36'%20height='36'%20viewBox='0%200%2036%2036'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.5'%20y='0.5'%20width='35'%20height='35'%20rx='17.5'%20stroke='%23484F67'/%3e%3cpath%20d='M25.7588%2021.3838L24.3571%2019.9823C23.8884%2019.5134%2023.625%2018.8775%2023.625%2018.2145V15.0676C23.625%2012.3677%2021.7863%209.98273%2019.2354%209.3948C19.2409%209.34676%2019.25%209.29961%2019.25%209.25C19.25%208.5609%2018.6891%208%2018%208C17.3109%208%2016.75%208.5609%2016.75%209.25C16.75%209.29883%2016.7589%209.34508%2016.7643%209.39238C14.2534%209.95617%2012.375%2012.1937%2012.375%2014.875V18.2145C12.375%2018.8775%2012.1116%2019.5134%2011.6429%2019.9823L10.2412%2021.3838C10.0068%2021.6183%209.875%2021.9362%209.875%2022.2677V23.625H26.125V22.2677C26.125%2021.9362%2025.9932%2021.6183%2025.7588%2021.3838Z'%20fill='%23333333'/%3e%3cpath%20d='M15.5%2025.5C15.5%2026.8806%2016.6194%2028%2018%2028C19.3806%2028%2020.5%2026.8806%2020.5%2025.5V24.875H15.5V25.5Z'%20fill='%23333333'/%3e%3c/svg%3e", noNotifications = "data:image/svg+xml,%3csvg%20width='100'%20height='100'%20viewBox='0%200%20100%20100'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cpath%20d='M50%20100C77.6142%20100%20100%2077.6142%20100%2050C100%2022.3858%2077.6142%200%2050%200C22.3858%200%200%2022.3858%200%2050C0%2077.6142%2022.3858%20100%2050%20100Z'%20fill='url(%23pattern0_6852_36118)'/%3e%3cdefs%3e%3cpattern%20id='pattern0_6852_36118'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6852_36118'%20transform='translate(-0.125%20-0.125)%20scale(0.005)'/%3e%3c/pattern%3e%3cimage%20id='image0_6852_36118'%20width='250'%20height='250'%20xlink:href='data:image/png;base64,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'/%3e%3c/defs%3e%3c/svg%3e", LMFeedNotification = ({
  customEventClient: $,
  NotificationBellCustomIcon: ee,
  NotificationsCustomCallbacks: te
}) => {
  const {
    notificationCount: ne,
    notifications: re,
    getNotifications: se,
    shouldLoadMoreNotifications: ie,
    users: oe,
    handleNotification: le
  } = useLMFeedNotification($, te), [ue, de] = useState(null);
  function fe() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Menu$1,
      {
        open: !!ue,
        anchorEl: ue,
        onClose: () => de(null),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "lm-feed-activity-wrapper",
            id: "scroller",
            "lm-feed-component-id": "lm-feed-notifications-wrapper-yzabc",
            children: re.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "lm-feed-activity-wrapper__title",
                  "lm-feed-component-id": "lm-feed-notifications-wrapper-defgh",
                  children: "Notification"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "notificationBody",
                  "lm-feed-component-id": "lm-feed-notifications-wrapper-ijklm",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InfiniteScroll,
                    {
                      dataLength: re.length + 1,
                      hasMore: ie,
                      next: se,
                      loader: null,
                      scrollableTarget: "scroller",
                      children: re.map((pe) => {
                        var ge;
                        const { imageUrl: ye, name: me } = oe[pe == null ? void 0 : pe.actionBy[0]], ve = getAvatar({ imageUrl: ye, name: me });
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            className: `lm-feed-activity-wrapper__activity-item lm-cursor-pointer ${pe.isRead ? "" : "non-interacted-activity"} lm-hover-effect`,
                            onClick: () => le(pe.Id),
                            "lm-feed-component-id": `lm-feed-notifications-wrapper-nopqr-${pe.Id}`,
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  className: "user-image",
                                  "lm-feed-component-id": `lm-feed-notifications-wrapper-stuvw-${pe.Id}`,
                                  children: ve
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "div",
                                {
                                  className: "notification-content",
                                  "lm-feed-component-id": `lm-feed-notifications-wrapper-xyzab-${pe.Id}`,
                                  children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "div",
                                      {
                                        className: "notification-text",
                                        dangerouslySetInnerHTML: {
                                          __html: (ge = convertTextToHTML(pe == null ? void 0 : pe.activityText)) == null ? void 0 : ge.innerHTML
                                        },
                                        "lm-feed-component-id": `lm-feed-notifications-wrapper-cdefg-${pe.Id}`
                                      }
                                    ),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "div",
                                      {
                                        className: "notification-time-before",
                                        "lm-feed-component-id": `lm-feed-notifications-wrapper-hijkl-${pe.Id}`,
                                        children: dayjs(pe == null ? void 0 : pe.updatedAt).fromNow()
                                      }
                                    )
                                  ]
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  "lm-feed-component-id": `lm-feed-notifications-wrapper-mnopq-${pe.Id}`
                                }
                              )
                            ]
                          },
                          pe == null ? void 0 : pe.Id
                        );
                      })
                    }
                  )
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "lmNoNotification noNotifications lm-d-flex",
                "lm-feed-component-id": "lm-feed-no-notifications-wrapper-rstuw",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      "lm-feed-component-id": "lm-feed-no-notifications-wrapper-vwxyz",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          src: noNotifications,
                          alt: "default image",
                          "lm-feed-component-id": "lm-feed-no-notifications-wrapper-abcde"
                        }
                      )
                    }
                  ),
                  "Oops! You do not have any no notifications yet."
                ]
              }
            )
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "lm-feed-notification-badge", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, { badgeContent: ne.toString(), color: "error", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        onClick: (pe) => {
          de(pe.currentTarget);
        },
        children: ee ? /* @__PURE__ */ jsxRuntimeExports.jsx(ee, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: notificationBell,
            alt: "notification",
            className: "lm-cursor-pointer"
          }
        )
      }
    ) }),
    fe()
  ] });
}, LMFeedNotificationHeader = ({
  customEventClient: $
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lm-header-notification", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "LMFeed" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LMFeedNotification, { customEventClient: $ }) })
] }), LMFeedPDFViewer = ({ pdfUrl: $ }) => {
  const [ee, te] = useState(null);
  function ne({ numPages: re }) {
    te(re);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Document$1, { file: $, onLoadSuccess: ne, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Page$1, { pageNumber: 1 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
      "Number of Pages: ",
      ee
    ] })
  ] });
};
var LikeActionType = /* @__PURE__ */ (($) => ($[$.reply = 0] = "reply", $[$.post = 1] = "post", $))(LikeActionType || {});
class LMFeedCustomEvents {
  constructor() {
    On(this, "events");
    On(this, "eventListenerMap");
    On(this, "feedListActionsAndDataStore", null);
    On(this, "feedPostDetilsActionsAndDataStore", null);
    On(this, "topicsActionsAndDataStore", null);
    On(this, "repliesActionsAndDataStore", null);
    On(this, "postCreationActionAndDataStore", null);
    On(this, "notificationsActionsAndDataStore", null);
    this.events = {}, this.eventListenerMap = {};
  }
  updateFeedListActionsAndDataStore(ee) {
    this.feedListActionsAndDataStore = ee;
  }
  updateFeedPostDetilsActionsAndDataStore(ee) {
    this.feedPostDetilsActionsAndDataStore = ee;
  }
  updateTopicsActionsAndDataStore(ee) {
    this.topicsActionsAndDataStore = ee;
  }
  updateRepliesActionsAndDataStore(ee) {
    this.repliesActionsAndDataStore = ee;
  }
  updatePostCreationActionAndDataStore(ee) {
    this.postCreationActionAndDataStore = ee;
  }
  updateNotificationsActionsAndDataStore(ee) {
    this.notificationsActionsAndDataStore = ee;
  }
  createEventListener(ee) {
    const te = {
      handleEvent: ee,
      feedListActionsAndDataStore: this.feedListActionsAndDataStore,
      feedPostDetilsActionsAndDataStore: this.feedPostDetilsActionsAndDataStore,
      topicsActionsAndDataStore: this.topicsActionsAndDataStore,
      repliesActionsAndDataStore: this.repliesActionsAndDataStore,
      postCreationActionAndDataStore: this.postCreationActionAndDataStore,
      notificationsActionsAndDataStore: this.notificationsActionsAndDataStore
    };
    return ee.bind(te);
  }
  registerEvent(ee) {
    this.events[ee] = ee;
  }
  dispatchEvent(ee, te) {
    this.registerEvent(ee);
    const ne = new CustomEvent(ee, {
      detail: te
    });
    dispatchEvent(ne);
  }
  listen(ee, te) {
    this.eventListenerMap[ee] = te, addEventListener(ee, te);
  }
  remove(ee) {
    removeEventListener(ee, this.eventListenerMap[ee]);
  }
}
export {
  parseEpochTimestamp as $,
  resolveHttpHandlerRuntimeConfig as A,
  getAwsRegionExtensionConfiguration as B,
  Client as C,
  DEFAULT_MAX_ATTEMPTS as D,
  resolveRegionConfig as E,
  FetchHttpHandler as F,
  resolveEndpointConfig as G,
  HttpResponse as H,
  resolveRetryConfig as I,
  resolveUserAgentConfig as J,
  getRetryPlugin as K,
  getContentLengthPlugin as L,
  getHostHeaderPlugin as M,
  NoOpLogger as N,
  getLoggerPlugin as O,
  getRecursionDetectionPlugin as P,
  getUserAgentPlugin as Q,
  getHttpAuthSchemeEndpointRuleSetPlugin as R,
  SignatureV4 as S,
  getHttpSigningPlugin as T,
  resolveHostHeaderConfig as U,
  ServiceException as V,
  decorateServiceException as W,
  withBaseException as X,
  take as Y,
  expectString as Z,
  expectNonNull as _,
  HttpRequest as a,
  LMFeedPostMenuItems as a$,
  expectNumber as a0,
  Command as a1,
  getSerdePlugin as a2,
  getEndpointPlugin as a3,
  LMFeed as a4,
  LMFeedError as a5,
  LMFeedLoader as a6,
  LMFeedPost as a7,
  LMFeedPostHeader as a8,
  LMFeedViewTopicDropdown as a9,
  FeedPostContext as aA,
  ReplyContext as aB,
  UserProviderContext as aC,
  useCreatePost as aD,
  useFeedDetails as aE,
  useLMFeedGeneralContextProvider as aF,
  useLMFeedNotification as aG,
  useFetchFeeds as aH,
  useLMPostReply as aI,
  useReply as aJ,
  useTopicDropdown as aK,
  useUserProvider as aL,
  useTagging as aM,
  LMFeedAttachments as aN,
  LMFeedCreatePostAttachmentController as aO,
  LMFeedCreatePostSubmitButton as aP,
  LMFeedNotification as aQ,
  LMFeedNotificationHeader as aR,
  LMFeedPDFViewer as aS,
  LMFeedReplyEditTextArea as aT,
  LMFeedReplyTextArea as aU,
  LMFeedTextArea as aV,
  LMFeedAnalytics as aW,
  LMCoreCallbacks as aX,
  LMDisplayMessages as aY,
  LMFeedEntityType as aZ,
  LMFeedCustomActionEvents as a_,
  LMFeedUniversalFeed as aa,
  LMFeedCommentsScroller as ab,
  LMFeedRepliesScroller as ac,
  LMFeedReply as ad,
  LMFeedLoaderContextProvider as ae,
  LMFeedTopicSelectedBlock as af,
  LMFeedTopicSelectionTile as ag,
  LMFeedTopicsTile as ah,
  LMFeedDeleteDialogBox as ai,
  LMFeedAllMembers as aj,
  LMFeedCreateMediaPost as ak,
  LMFeedCreatePost as al,
  LMFeedListDataContextProvider as am,
  LMFeedDetails as an,
  LMFeedLikedMembers as ao,
  LMFeedMediaUpload as ap,
  LMFeedOGTagMediaItem as aq,
  LMFeedPostBody as ar,
  LMFeedPostFooter as as,
  LMFeedPostTopicsWrapper as at,
  LMFeedReportPostDialog as au,
  LMFeedCreatePostContext as av,
  CustomAgentProviderContext as aw,
  LMFeedDataContext as ax,
  GeneralContext as ay,
  GlobalClientProviderContext as az,
  customEndpointFunctions as b,
  LMFeedReplyMenuItems as b0,
  LMFeedReplyMode as b1,
  LMAppRoutesConstant as b2,
  LMFeedDeletePostModes as b3,
  LMFeedCreatePostMediaUploadMode as b4,
  LikeActionType as b5,
  LMTopicsDropdownMode as b6,
  LMFeedCustomEvents as b7,
  collectBodyString as c,
  awsEndpointFunctions as d,
  fromUtf8$3 as e,
  fromBase64 as f,
  getSmithyContext as g,
  toUtf8$3 as h,
  calculateBodyLength as i,
  defaultUserAgent as j,
  invalidProvider as k,
  DEFAULT_RETRY_MODE as l,
  build$3 as m,
  normalizeProvider as n,
  DEFAULT_USE_DUALSTACK_ENDPOINT as o,
  parseUrl as p,
  DEFAULT_USE_FIPS_ENDPOINT as q,
  resolveEndpoint as r,
  streamCollector as s,
  toBase64 as t,
  resolveDefaultsModeConfig as u,
  loadConfigsForDefaultMode as v,
  getDefaultExtensionConfiguration as w,
  getHttpHandlerExtensionConfiguration as x,
  resolveAwsRegionExtensionConfiguration as y,
  resolveDefaultRuntimeConfig as z
};
